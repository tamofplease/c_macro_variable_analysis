<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/deps/lua/src/lgc.c"><comment type="block">/*
** $Id: lgc.c,v 2.38.1.2 2011/03/18 18:05:38 roberto Exp $
** Garbage Collector
** See Copyright Notice in lua.h
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lgc_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lua.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ldebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ldo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lfunc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lgc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lstate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lstring.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ltable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ltm.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCSTEPSIZE</name></cpp:macro>	<cpp:value>1024u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCSWEEPMAX</name></cpp:macro>	<cpp:value>40</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCSWEEPCOST</name></cpp:macro>	<cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCFINALIZECOST</name></cpp:macro>	<cpp:value>100</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>maskmarks</name></cpp:macro>	<cpp:value>cast_byte(~(bitmask(BLACKBIT)|WHITEBITS))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>makewhite</name><parameter_list>(<parameter><type><name>g</name></type></parameter>,<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	\
   <cpp:value>((x)-&gt;gch.marked = cast_byte(((x)-&gt;gch.marked &amp; maskmarks) | luaC_white(g)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>white2gray</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>reset2bits((x)-&gt;gch.marked, WHITE0BIT, WHITE1BIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>black2gray</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>resetbit((x)-&gt;gch.marked, BLACKBIT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>stringmark</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>reset2bits((s)-&gt;tsv.marked, WHITE0BIT, WHITE1BIT)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isfinalized</name><parameter_list>(<parameter><type><name>u</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>testbit((u)-&gt;marked, FINALIZEDBIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>markfinalized</name><parameter_list>(<parameter><type><name>u</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>l_setbit((u)-&gt;marked, FINALIZEDBIT)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KEYWEAK</name></cpp:macro>         <cpp:value>bitmask(KEYWEAKBIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VALUEWEAK</name></cpp:macro>       <cpp:value>bitmask(VALUEWEAKBIT)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>markvalue</name><parameter_list>(<parameter><type><name>g</name></type></parameter>,<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ checkconsistency(o); \
  if (iscollectable(o) &amp;&amp; iswhite(gcvalue(o))) reallymarkobject(g,gcvalue(o)); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>markobject</name><parameter_list>(<parameter><type><name>g</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ if (iswhite(obj2gco(t))) \
		reallymarkobject(g, obj2gco(t)); }</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setthreshold</name><parameter_list>(<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(g-&gt;GCthreshold = (g-&gt;estimate/100) * g-&gt;gcpause)</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>void</name></type> <name>removeentry</name> <parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ttisnil</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>iscollectable</name><argument_list>(<argument><expr><call><name>gkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>setttype</name><argument_list>(<argument><expr><call><name>gkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LUA_TDEADKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* dead key; remove it */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>reallymarkobject</name> <parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>iswhite</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isdead</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>white2gray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>tt</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LUA_TSTRING</name></expr>:</case> <block>{<block_content>
      <return>return;</return>
    </block_content>}</block>
    <case>case <expr><name>LUA_TUSERDATA</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><call><name>gco2u</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>gray2black</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* udata are never gray */</comment>
      <if_stmt><if>if <condition>(<expr><name>mt</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>mt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>gco2u</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
    <case>case <expr><name>LUA_TUPVAL</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>UpVal</name> <modifier>*</modifier></type><name>uv</name> <init>= <expr><call><name>gco2uv</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>uv</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>uv</name><operator>-&gt;</operator><name>v</name></name> <operator>==</operator> <operator>&amp;</operator><name><name>uv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>value</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* closed? */</comment>
        <expr_stmt><expr><call><name>gray2black</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* open upvalues are never black */</comment>
      <return>return;</return>
    </block_content>}</block>
    <case>case <expr><name>LUA_TFUNCTION</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>gco2cl</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>c</name><operator>.</operator><name>gclist</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>gray</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>LUA_TTABLE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>gco2h</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>gclist</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>gray</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>LUA_TTHREAD</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>gco2th</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>gclist</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>gray</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>LUA_TPROTO</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>gco2p</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>gclist</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>gray</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></switch>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>marktmu</name> <parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>u</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>u</name></expr>)</condition> <block>{<block_content>
    <do>do <block>{<block_content>
      <expr_stmt><expr><name>u</name> <operator>=</operator> <name><name>u</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* may be marked, if left from previous GC */</comment>
      <expr_stmt><expr><call><name>reallymarkobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><name>u</name> <operator>!=</operator> <name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name></expr>)</condition>;</do>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* move `dead' udata that need finalization to list `tmudata' */</comment>
<function><type><name>size_t</name></type> <name>luaC_separateudata</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>all</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>deadmem</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>mainthread</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>curr</name></decl>;</decl_stmt>
  <while>while <condition>(<expr><operator>(</operator><name>curr</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>iswhite</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>all</name><operator>)</operator> <operator>||</operator> <call><name>isfinalized</name><argument_list>(<argument><expr><call><name>gco2u</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* don't bother with them */</comment>
    <if type="elseif">else if <condition>(<expr><call><name>fasttm</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>gco2u</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>, <argument><expr><name>TM_GC</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>markfinalized</name><argument_list>(<argument><expr><call><name>gco2u</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* don't need finalization */</comment>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>  <comment type="block">/* must call its gc method */</comment>
      <expr_stmt><expr><name>deadmem</name> <operator>+=</operator> <call><name>sizeudata</name><argument_list>(<argument><expr><call><name>gco2u</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>markfinalized</name><argument_list>(<argument><expr><call><name>gco2u</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
      <comment type="block">/* link `curr' at the end of `tmudata' list */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* list is empty? */</comment>
        <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name> <operator>=</operator> <name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* creates a circular list */</comment>
      <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>tmudata</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>deadmem</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>traversetable</name> <parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>weakkey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>weakvalue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>mode</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>metatable</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>metatable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>mode</name> <operator>=</operator> <call><name>gfasttm</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>metatable</name></name></expr></argument>, <argument><expr><name>TM_MODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>mode</name> <operator>&amp;&amp;</operator> <call><name>ttisstring</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* is there a weak mode? */</comment>
    <expr_stmt><expr><name>weakkey</name> <operator>=</operator> <operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><call><name>svalue</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'k'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>weakvalue</name> <operator>=</operator> <operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><call><name>svalue</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'v'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>weakkey</name> <operator>||</operator> <name>weakvalue</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* is really weak? */</comment>
      <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>marked</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>KEYWEAK</name> <operator>|</operator> <name>VALUEWEAK</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* clear bits */</comment>
      <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>marked</name></name> <operator>|=</operator> <call><name>cast_byte</name><argument_list>(<argument><expr><operator>(</operator><name>weakkey</name> <operator>&lt;&lt;</operator> <name>KEYWEAKBIT</name><operator>)</operator> <operator>|</operator>
                             <operator>(</operator><name>weakvalue</name> <operator>&lt;&lt;</operator> <name>VALUEWEAKBIT</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>gclist</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>weak</name></name></expr>;</expr_stmt>  <comment type="block">/* must be cleared after GC, ... */</comment>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>weak</name></name> <operator>=</operator> <call><name>obj2gco</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* ... so put in the appropriate list */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>weakkey</name> <operator>&amp;&amp;</operator> <name>weakvalue</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>weakvalue</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>sizearray</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>i</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>sizenode</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>i</name><operator>--</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>gnode</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ttype</name><argument_list>(<argument><expr><call><name>gkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>LUA_TDEADKEY</name> <operator>||</operator> <call><name>ttisnil</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ttisnil</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>removeentry</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* remove empty entries */</comment>
    <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ttisnil</name><argument_list>(<argument><expr><call><name>gkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>weakkey</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>gkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>weakvalue</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>weakkey</name> <operator>||</operator> <name>weakvalue</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** All marks are conditional because a GC may happen while the
** prototype is still being created
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>traverseproto</name> <parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>Proto</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>source</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>stringmark</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>source</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>f</name><operator>-&gt;</operator><name>sizek</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* mark literals */</comment>
    <expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>k</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>f</name><operator>-&gt;</operator><name>sizeupvalues</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>  <comment type="block">/* mark upvalue names */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>stringmark</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>f</name><operator>-&gt;</operator><name>sizep</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>  <comment type="block">/* mark nested protos */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>f</name><operator>-&gt;</operator><name>sizelocvars</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>  <comment type="block">/* mark local-variable names */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>locvars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>varname</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>stringmark</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>locvars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type> <name>traverseclosure</name> <parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>Closure</name> <modifier>*</modifier></type><name>cl</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>env</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>isC</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>nupvalues</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* mark its upvalues */</comment>
      <expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>upvalue</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>nupvalues</name></name> <operator>==</operator> <name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>nups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>nupvalues</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* mark its upvalues */</comment>
      <expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>upvals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>checkstacksizes</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>max</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ci_used</name> <init>= <expr><call><name>cast_int</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* number of `ci' in use */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>s_used</name> <init>= <expr><call><name>cast_int</name><argument_list>(<argument><expr><name>max</name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* part of stack in use */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name> <operator>&gt;</operator> <name>LUAI_MAXCALLS</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* handling overflow? */</comment>
    <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* do not touch the stacks */</comment>
  <if_stmt><if>if <condition>(<expr><literal type="number">4</literal><operator>*</operator><name>ci_used</name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name> <operator>&amp;&amp;</operator> <literal type="number">2</literal><operator>*</operator><name>BASIC_CI_SIZE</name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaD_reallocCI</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* still big enough... */</comment>
  <expr_stmt><expr><call><name>condhardstacktests</name><argument_list>(<argument><expr><call><name>luaD_reallocCI</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ci_used</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><literal type="number">4</literal><operator>*</operator><name>s_used</name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name> <operator>&amp;&amp;</operator>
      <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>BASIC_STACK_SIZE</name><operator>+</operator><name>EXTRA_STACK</name><operator>)</operator> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaD_reallocstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* still big enough... */</comment>
  <expr_stmt><expr><call><name>condhardstacktests</name><argument_list>(<argument><expr><call><name>luaD_reallocstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>s_used</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>traversestack</name> <parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>StkId</name></type> <name>o</name></decl>, <decl><type ref="prev"/><name>lim</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>gt</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>lim</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>ci</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>base_ci</name></name></expr>;</init> <condition><expr><name>ci</name> <operator>&lt;=</operator> <name><name>l</name><operator>-&gt;</operator><name>ci</name></name></expr>;</condition> <incr><expr><name>ci</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>&lt;=</operator> <name><name>l</name><operator>-&gt;</operator><name>stack_last</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>lim</name> <operator>&lt;</operator> <name><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lim</name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <for>for <control>(<init><expr><name>o</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>stack</name></name></expr>;</init> <condition><expr><name>o</name> <operator>&lt;</operator> <name><name>l</name><operator>-&gt;</operator><name>top</name></name></expr>;</condition> <incr><expr><name>o</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <for>for <control>(<init>;</init> <condition><expr><name>o</name> <operator>&lt;=</operator> <name>lim</name></expr>;</condition> <incr><expr><name>o</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>checkstacksizes</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>lim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** traverse one gray object, turning it to black.
** Returns `quantity' traversed.
*/</comment>
<function><type><specifier>static</specifier> <name>l_mem</name></type> <name>propagatemark</name> <parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>isgray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>gray2black</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>tt</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LUA_TTABLE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><call><name>gco2h</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>gclist</name></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>traversetable</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* table is weak? */</comment>
        <expr_stmt><expr><call><name>black2gray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* keep it gray */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>push</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name><name>:</name> <name>4334</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>Table</name></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof><operator>*</operator> <name><name>h</name><operator>-&gt;</operator><name>sizearray</name></name> <operator>+</operator>
                             <sizeof>sizeof<argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>sizenode</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>pop</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block>
    <case>case <expr><name>LUA_TFUNCTION</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Closure</name> <modifier>*</modifier></type><name>cl</name> <init>= <expr><call><name>gco2cl</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>gclist</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>traverseclosure</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><ternary><condition><expr><operator>(</operator><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>isC</name></name><operator>)</operator></expr> ?</condition><then> <expr><call><name>sizeCclosure</name><argument_list>(<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>nupvalues</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
                           <expr><call><name>sizeLclosure</name><argument_list>(<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>nupvalues</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>LUA_TTHREAD</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><call><name>gco2th</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name><name>th</name><operator>-&gt;</operator><name>gclist</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>gclist</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>black2gray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>traversestack</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>lua_State</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>th</name><operator>-&gt;</operator><name>stacksize</name></name> <operator>+</operator>
                                 <sizeof>sizeof<argument_list>(<argument><expr><name>CallInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>th</name><operator>-&gt;</operator><name>size_ci</name></name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>LUA_TPROTO</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>gco2p</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>gclist</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>traverseproto</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>Proto</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Instruction</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>sizecode</name></name> <operator>+</operator>
                             <sizeof>sizeof<argument_list>(<argument><expr><name>Proto</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>sizep</name></name> <operator>+</operator>
                             <sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>sizek</name></name> <operator>+</operator> 
                             <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>sizelineinfo</name></name> <operator>+</operator>
                             <sizeof>sizeof<argument_list>(<argument><expr><name>LocVar</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>sizelocvars</name></name> <operator>+</operator>
                             <sizeof>sizeof<argument_list>(<argument><expr><name>TString</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>sizeupvalues</name></name></expr>;</return>
    </block_content>}</block>
    <default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>size_t</name></type> <name>propagateall</name> <parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>m</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>m</name> <operator>+=</operator> <call><name>propagatemark</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  <return>return <expr><name>m</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** The next function tells whether a key or value can be cleared from
** a weak table. Non-collectable objects are never removed from weak
** tables. Strings behave as `values', so are never removed too. for
** other objects: if really collected, cannot keep them; for userdata
** being finalized, keep them in keys, but not in values
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>iscleared</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iskey</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>iscollectable</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ttisstring</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>stringmark</name><argument_list>(<argument><expr><call><name>rawtsvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* strings are `values', so are never weak */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>iswhite</name><argument_list>(<argument><expr><call><name>gcvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
    <operator>(</operator><call><name>ttisuserdata</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>iskey</name> <operator>&amp;&amp;</operator> <call><name>isfinalized</name><argument_list>(<argument><expr><call><name>uvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** clear collected entries from weaktables
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cleartable</name> <parameter_list>(<parameter><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <while>while <condition>(<expr><name>l</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><call><name>gco2h</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>sizearray</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>testbit</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>marked</name></name></expr></argument>, <argument><expr><name>VALUEWEAKBIT</name></expr></argument>)</argument_list></call> <operator>||</operator>
               <call><name>testbit</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>marked</name></name></expr></argument>, <argument><expr><name>KEYWEAKBIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>testbit</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>marked</name></name></expr></argument>, <argument><expr><name>VALUEWEAKBIT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <while>while <condition>(<expr><name>i</name><operator>--</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>iscleared</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* value was collected? */</comment>
          <expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* remove value */</comment>
      </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>sizenode</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>i</name><operator>--</operator></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>gnode</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ttisnil</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>  <comment type="block">/* non-empty entry? */</comment>
          <operator>(</operator><call><name>iscleared</name><argument_list>(<argument><expr><call><name>key2tval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>iscleared</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remove value ... */</comment>
        <expr_stmt><expr><call><name>removeentry</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remove entry from table */</comment>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>l</name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>gclist</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>freeobj</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>tt</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LUA_TPROTO</name></expr>:</case> <expr_stmt><expr><call><name>luaF_freeproto</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>gco2p</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>LUA_TFUNCTION</name></expr>:</case> <expr_stmt><expr><call><name>luaF_freeclosure</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>gco2cl</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>LUA_TUPVAL</name></expr>:</case> <expr_stmt><expr><call><name>luaF_freeupval</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>gco2uv</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>LUA_TTABLE</name></expr>:</case> <expr_stmt><expr><call><name>luaH_free</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>gco2h</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>LUA_TTHREAD</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>gco2th</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>L</name> <operator>&amp;&amp;</operator> <call><name>gco2th</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>mainthread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>luaE_freethread</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>gco2th</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>LUA_TSTRING</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>strt</name><operator>.</operator><name>nuse</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>luaM_freemem</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><call><name>sizestring</name><argument_list>(<argument><expr><call><name>gco2ts</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>LUA_TUSERDATA</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>luaM_freemem</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><call><name>sizeudata</name><argument_list>(<argument><expr><call><name>gco2u</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></switch>
</block_content>}</block></function>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sweepwholelist</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>sweeplist(L,p,MAX_LUMEM)</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>GCObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>sweeplist</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>lu_mem</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>curr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>deadmask</name> <init>= <expr><call><name>otherwhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><operator>(</operator><name>curr</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>count</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>tt</name></name> <operator>==</operator> <name>LUA_TTHREAD</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* sweep open upvalues of each thread */</comment>
      <expr_stmt><expr><call><name>sweepwholelist</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>gco2th</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>openupval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>marked</name></name> <operator>^</operator> <name>WHITEBITS</name><operator>)</operator> <operator>&amp;</operator> <name>deadmask</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* not dead? */</comment>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isdead</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>testbit</name><argument_list>(<argument><expr><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>marked</name></name></expr></argument>, <argument><expr><name>FIXEDBIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* make it white (for next cycle) */</comment>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>  <comment type="block">/* must erase `curr' */</comment>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>isdead</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>deadmask</name> <operator>==</operator> <call><name>bitmask</name><argument_list>(<argument><expr><name>SFIXEDBIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>curr</name> <operator>==</operator> <name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* is the first element of the list? */</comment>
        <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name> <operator>=</operator> <name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* adjust first */</comment>
      <expr_stmt><expr><call><name>freeobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>checkSizes</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="block">/* check size of string hash */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>nuse</name></name> <operator>&lt;</operator> <call><name>cast</name><argument_list>(<argument><expr><name>lu_int32</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>size</name></name><operator>/</operator><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
      <name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <name>MINSTRTABSIZE</name><operator>*</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaS_resize</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>size</name></name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* table is too big */</comment>
  <comment type="block">/* check size of buffer */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>luaZ_sizebuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>LUA_MINBUFFER</name><operator>*</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* buffer too big? */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>newsize</name> <init>= <expr><call><name>luaZ_sizebuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>luaZ_resizebuffer</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>GCTM</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* get first element */</comment>
  <decl_stmt><decl><type><name>Udata</name> <modifier>*</modifier></type><name>udata</name> <init>= <expr><call><name>rawgco2u</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>tm</name></decl>;</decl_stmt>
  <comment type="block">/* remove udata from `tmudata' */</comment>
  <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* last element? */</comment>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>udata</name><operator>-&gt;</operator><name>uv</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><name><name>udata</name><operator>-&gt;</operator><name>uv</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>mainthread</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>  <comment type="block">/* return it to `root' list */</comment>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>mainthread</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>fasttm</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>udata</name><operator>-&gt;</operator><name>uv</name><operator>.</operator><name>metatable</name></name></expr></argument>, <argument><expr><name>TM_GC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>tm</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>lu_byte</name></type> <name>oldah</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>lu_mem</name></type> <name>oldt</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>GCthreshold</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* stop debug hooks during GC tag method */</comment>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>GCthreshold</name></name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr>;</expr_stmt>  <comment type="block">/* avoid GC steps */</comment>
    <expr_stmt><expr><call><name>setobj2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setuvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>udata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaD_call</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name> <operator>=</operator> <name>oldah</name></expr>;</expr_stmt>  <comment type="block">/* restore hooks */</comment>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>GCthreshold</name></name> <operator>=</operator> <name>oldt</name></expr>;</expr_stmt>  <comment type="block">/* restore threshold */</comment>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Call all GC tag methods
*/</comment>
<function><type><name>void</name></type> <name>luaC_callGCTM</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <while>while <condition>(<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>tmudata</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>GCTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>luaC_freeall</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>currentwhite</name></name> <operator>=</operator> <name>WHITEBITS</name> <operator>|</operator> <call><name>bitmask</name><argument_list>(<argument><expr><name>SFIXEDBIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* mask to collect all elements */</comment>
  <expr_stmt><expr><call><name>sweepwholelist</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* free all string lists */</comment>
    <expr_stmt><expr><call><name>sweepwholelist</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>hash</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>markmt</name> <parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>NUM_TAGS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>mt</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>mt</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>


<comment type="block">/* mark root set */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>markroot</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>weak</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>mainthread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* make global table be traversed before main stack */</comment>
  <expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>gt</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>mainthread</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>registry</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>markmt</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>=</operator> <name>GCSpropagate</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>remarkupvals</name> <parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>UpVal</name> <modifier>*</modifier></type><name>uv</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>uv</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>uvhead</name><operator>.</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>next</name></name></expr>;</init> <condition><expr><name>uv</name> <operator>!=</operator> <operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>uvhead</name></name></expr>;</condition> <incr><expr><name>uv</name> <operator>=</operator> <name><name>uv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>uv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>next</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>prev</name></name> <operator>==</operator> <name>uv</name> <operator>&amp;&amp;</operator> <name><name>uv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>prev</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>next</name></name> <operator>==</operator> <name>uv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>isgray</name><argument_list>(<argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>uv</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>atomic</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>udsize</name></decl>;</decl_stmt>  <comment type="block">/* total size of userdata to be finalized */</comment>
  <comment type="block">/* remark occasional upvalues of (maybe) dead threads */</comment>
  <expr_stmt><expr><call><name>remarkupvals</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* traverse objects cautch by write barrier and by 'remarkupvals' */</comment>
  <expr_stmt><expr><call><name>propagateall</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* remark weak tables */</comment>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>weak</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>weak</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>iswhite</name><argument_list>(<argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>mainthread</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* mark running thread */</comment>
  <expr_stmt><expr><call><name>markmt</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* mark basic metatables (again) */</comment>
  <expr_stmt><expr><call><name>propagateall</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* remark gray again */</comment>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>propagateall</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>udsize</name> <operator>=</operator> <call><name>luaC_separateudata</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* separate userdata to be finalized */</comment>
  <expr_stmt><expr><call><name>marktmu</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* mark `preserved' userdata */</comment>
  <expr_stmt><expr><name>udsize</name> <operator>+=</operator> <call><name>propagateall</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remark, to propagate `preserveness' */</comment>
  <expr_stmt><expr><call><name>cleartable</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>weak</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remove collected objects from weak tables */</comment>
  <comment type="block">/* flip current white */</comment>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>currentwhite</name></name> <operator>=</operator> <call><name>cast_byte</name><argument_list>(<argument><expr><call><name>otherwhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>sweepstrgc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>sweepgc</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>=</operator> <name>GCSsweepstring</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>estimate</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name> <operator>-</operator> <name>udsize</name></expr>;</expr_stmt>  <comment type="block">/* first estimate */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>l_mem</name></type> <name>singlestep</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="block">/*lua_checkmemory(L);*/</comment>
  <switch>switch <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>GCSpause</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>markroot</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* start a new collection */</comment>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>GCSpropagate</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>propagatemark</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
      <else>else <block>{<block_content>  <comment type="block">/* no more `gray' objects */</comment>
        <expr_stmt><expr><call><name>atomic</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* finish mark phase */</comment>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <case>case <expr><name>GCSsweepstring</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>lu_mem</name></type> <name>old</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sweepwholelist</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>hash</name><index>[<expr><name><name>g</name><operator>-&gt;</operator><name>sweepstrgc</name></name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>sweepstrgc</name></name> <operator>&gt;=</operator> <name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* nothing more to sweep? */</comment>
        <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>=</operator> <name>GCSsweep</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* end sweep-string phase */</comment>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>old</name> <operator>&gt;=</operator> <name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>estimate</name></name> <operator>-=</operator> <name>old</name> <operator>-</operator> <name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr>;</expr_stmt>
      <return>return <expr><name>GCSWEEPCOST</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>GCSsweep</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>lu_mem</name></type> <name>old</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>sweepgc</name></name> <operator>=</operator> <call><name>sweeplist</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>sweepgc</name></name></expr></argument>, <argument><expr><name>GCSWEEPMAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>g</name><operator>-&gt;</operator><name>sweepgc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* nothing more to sweep? */</comment>
        <expr_stmt><expr><call><name>checkSizes</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>=</operator> <name>GCSfinalize</name></expr>;</expr_stmt>  <comment type="block">/* end sweep phase */</comment>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>old</name> <operator>&gt;=</operator> <name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>estimate</name></name> <operator>-=</operator> <name>old</name> <operator>-</operator> <name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr>;</expr_stmt>
      <return>return <expr><name>GCSWEEPMAX</name><operator>*</operator><name>GCSWEEPCOST</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>GCSfinalize</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>GCTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>estimate</name></name> <operator>&gt;</operator> <name>GCFINALIZECOST</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>estimate</name></name> <operator>-=</operator> <name>GCFINALIZECOST</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>GCFINALIZECOST</name></expr>;</return>
      </block_content>}</block></if>
      <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>=</operator> <name>GCSpause</name></expr>;</expr_stmt>  <comment type="block">/* end collection */</comment>
        <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcdept</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>luaC_step</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>l_mem</name></type> <name>lim</name> <init>= <expr><operator>(</operator><name>GCSTEPSIZE</name><operator>/</operator><literal type="number">100</literal><operator>)</operator> <operator>*</operator> <name><name>g</name><operator>-&gt;</operator><name>gcstepmul</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>lim</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>lim</name> <operator>=</operator> <operator>(</operator><name>MAX_LUMEM</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* no limit */</comment>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcdept</name></name> <operator>+=</operator> <name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name> <operator>-</operator> <name><name>g</name><operator>-&gt;</operator><name>GCthreshold</name></name></expr>;</expr_stmt>
  <do>do <block>{<block_content>
    <expr_stmt><expr><name>lim</name> <operator>-=</operator> <call><name>singlestep</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>==</operator> <name>GCSpause</name></expr>)</condition><block type="pseudo"><block_content>
      <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block> while <condition>(<expr><name>lim</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
  <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSpause</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcdept</name></name> <operator>&lt;</operator> <name>GCSTEPSIZE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>GCthreshold</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name> <operator>+</operator> <name>GCSTEPSIZE</name></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* - lim/g-&gt;gcstepmul;*/</comment>
    <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcdept</name></name> <operator>-=</operator> <name>GCSTEPSIZE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>GCthreshold</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>setthreshold</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>luaC_fullgc</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>&lt;=</operator> <name>GCSpropagate</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* reset sweep marks to sweep all elements (returning them to white) */</comment>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>sweepstrgc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>sweepgc</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name></expr>;</expr_stmt>
    <comment type="block">/* reset other collector lists */</comment>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>weak</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>=</operator> <name>GCSsweepstring</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSpause</name> <operator>&amp;&amp;</operator> <name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSpropagate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* finish any pending sweep phase */</comment>
  <while>while <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSfinalize</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>==</operator> <name>GCSsweepstring</name> <operator>||</operator> <name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>==</operator> <name>GCSsweep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>singlestep</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>markroot</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSpause</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>singlestep</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>setthreshold</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>luaC_barrierf</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>isblack</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>iswhite</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isdead</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isdead</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSfinalize</name> <operator>&amp;&amp;</operator> <name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSpause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ttype</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>gch</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>LUA_TTABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* must keep invariant? */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>==</operator> <name>GCSpropagate</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>reallymarkobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* restore invariant */</comment>
  <else>else<block type="pseudo"><block_content>  <comment type="block">/* don't mind */</comment>
    <expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* mark as white just to avoid other barriers */</comment>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>luaC_barrierback</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>isblack</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isdead</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSfinalize</name> <operator>&amp;&amp;</operator> <name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSpause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>black2gray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* make table gray (again) */</comment>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>gclist</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>luaC_link</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>lu_byte</name></type> <name>tt</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>marked</name></name> <operator>=</operator> <call><name>luaC_white</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>tt</name></name> <operator>=</operator> <name>tt</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>luaC_linkupval</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>UpVal</name> <modifier>*</modifier></type><name>uv</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name></expr>;</expr_stmt>  <comment type="block">/* link upvalue into `rootgc' list */</comment>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>isgray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
    <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>==</operator> <name>GCSpropagate</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>gray2black</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* closed upvalues need barrier */</comment>
      <expr_stmt><expr><call><name>luaC_barrier</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>uv</name></expr></argument>, <argument><expr><name><name>uv</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>  <comment type="block">/* sweep phase: sweep it (turning it into white) */</comment>
      <expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSfinalize</name> <operator>&amp;&amp;</operator> <name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSpause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

</unit>
