<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/deps/hiredis/async.c"><comment type="block">/*
 * Copyright (c) 2009-2011, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * Copyright (c) 2010-2011, Pieter Noordhuis &lt;pcnoordhuis at gmail dot com&gt;
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"win32_hiredis.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../src/Win32_Interop/win32_wsiocp2.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmacros.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<macro><name>POSIX_ONLY</name><argument_list>(<argument>#include &lt;strings.h&gt;</argument>)</argument_list></macro>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"net.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dict.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sds.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_EL_ADD_READ</name><parameter_list>(<parameter><type><name>ctx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
        if ((ctx)-&gt;ev.addRead) (ctx)-&gt;ev.addRead((ctx)-&gt;ev.data); \
    } while(0)</cpp:value></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_EL_FORCE_ADD_READ</name><parameter_list>(<parameter><type><name>ctx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
        if ((ctx)-&gt;ev.forceAddRead) (ctx)-&gt;ev.forceAddRead((ctx)-&gt;ev.data); \
    } while (0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_EL_DEL_READ</name><parameter_list>(<parameter><type><name>ctx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
        if ((ctx)-&gt;ev.delRead) (ctx)-&gt;ev.delRead((ctx)-&gt;ev.data); \
    } while(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_EL_ADD_WRITE</name><parameter_list>(<parameter><type><name>ctx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
        if ((ctx)-&gt;ev.addWrite) (ctx)-&gt;ev.addWrite((ctx)-&gt;ev.data); \
    } while(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_EL_DEL_WRITE</name><parameter_list>(<parameter><type><name>ctx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
        if ((ctx)-&gt;ev.delWrite) (ctx)-&gt;ev.delWrite((ctx)-&gt;ev.data); \
    } while(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_EL_CLEANUP</name><parameter_list>(<parameter><type><name>ctx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
        if ((ctx)-&gt;ev.cleanup) (ctx)-&gt;ev.cleanup((ctx)-&gt;ev.data); \
    } while(0);</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strcasecmp</name></cpp:macro> <cpp:value>_stricmp</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strncasecmp</name></cpp:macro> <cpp:value>_strnicmp</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Forward declaration of function in hiredis.c */</comment>
<function_decl><type><name>int</name></type> <name>__redisAppendCommand</name><parameter_list>(<parameter><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Functions managing dictionary of callbacks for pub/sub. */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>callbackHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>dictGenHashFunction</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>key</name></expr></argument>,
		<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>sdslen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>sds</name><operator>)</operator><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>callbackValDup</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>redisCallback</name> <modifier>*</modifier></type><name>dup</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>dup</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name><operator>)</operator><name>privdata</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dup</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>dup</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>dup</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>callbackKeyCompare</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>l1</name></decl>, <decl><type ref="prev"/><name>l2</name></decl>;</decl_stmt>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name><operator>)</operator><name>privdata</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>l1</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>sds</name><operator>)</operator><name>key1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>l2</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>sds</name><operator>)</operator><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>l1</name> <operator>!=</operator> <name>l2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>callbackKeyDestructor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name><operator>)</operator><name>privdata</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><operator>(</operator><name>sds</name><operator>)</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>callbackValDestructor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name><operator>)</operator><name>privdata</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>dictType</name></type> <name>callbackDict</name> <init>= <expr><block>{
	<expr><name>callbackHash</name></expr>,
	<expr><name>NULL</name></expr>,
	<expr><name>callbackValDup</name></expr>,
	<expr><name>callbackKeyCompare</name></expr>,
	<expr><name>callbackKeyDestructor</name></expr>,
	<expr><name>callbackValDestructor</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>redisAsyncContext</name> <modifier>*</modifier></type><name>redisAsyncInitialize</name><parameter_list>(<parameter><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ac</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>redisAsyncContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ac</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>ac</name><operator>-&gt;</operator><name>c</name></name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* The regular connect functions will always set the flag REDIS_CONNECTED.
	 * For the async API, we want to wait until the first write event is
	 * received up before setting this flag, so reset it here. */</comment>
	<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>REDIS_CONNECTED</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>errstr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>ev</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>ev</name><operator>.</operator><name>addRead</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
	<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>ev</name><operator>.</operator><name>forceAddRead</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>ev</name><operator>.</operator><name>delRead</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>ev</name><operator>.</operator><name>addWrite</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>ev</name><operator>.</operator><name>delWrite</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>ev</name><operator>.</operator><name>cleanup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>onConnect</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>onDisconnect</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>replies</name><operator>.</operator><name>head</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>replies</name><operator>.</operator><name>tail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>sub</name><operator>.</operator><name>invalid</name><operator>.</operator><name>head</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>sub</name><operator>.</operator><name>invalid</name><operator>.</operator><name>tail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>sub</name><operator>.</operator><name>channels</name></name> <operator>=</operator> <call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>callbackDict</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>sub</name><operator>.</operator><name>patterns</name></name> <operator>=</operator> <call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>callbackDict</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ac</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* We want the error field to be accessible directly instead of requiring
 * an indirection to the redisContext struct. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>__redisAsyncCopyError</name><parameter_list>(<parameter><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ac</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>ac</name><operator>-&gt;</operator><name>c</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>err</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>errstr</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>errstr</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<function><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>redisAsyncConnect</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SOCKADDR_STORAGE</name></type> <name>ss</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>redisPreConnectNonBlock</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ss</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name> <init>= <expr><call><name>redisAsyncInitialize</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>WSIOCP_SocketConnect</name><argument_list>(<argument><expr><name><name>ac</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ss</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>err</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strerror_r</name><argument_list>(<argument><expr><name>errno</name></expr></argument>, <argument><expr><name><name>ac</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>errstr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ac</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>errstr</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>__redisAsyncCopyError</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ac</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>redisAsyncConnectBind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source_addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SOCKADDR_STORAGE</name></type> <name>ss</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>redisPreConnectNonBlock</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ss</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name> <init>= <expr><call><name>redisAsyncInitialize</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>WSIOCP_SocketConnectBind</name><argument_list>(<argument><expr><name><name>ac</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ss</name></expr></argument>, <argument><expr><name>source_addr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>err</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strerror_r</name><argument_list>(<argument><expr><name>errno</name></expr></argument>, <argument><expr><name><name>ac</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>errstr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ac</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>errstr</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>__redisAsyncCopyError</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ac</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>redisAsyncConnect</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>redisConnectNonBlock</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ac</name> <operator>=</operator> <call><name>redisAsyncInitialize</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ac</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>redisFree</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>__redisAsyncCopyError</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ac</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>redisAsyncConnectBind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source_addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>redisConnectBindNonBlock</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>source_addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name> <init>= <expr><call><name>redisAsyncInitialize</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>__redisAsyncCopyError</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ac</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>redisAsyncConnectBindWithReuse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source_addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>redisConnectBindNonBlockWithReuse</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>source_addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name> <init>= <expr><call><name>redisAsyncInitialize</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>__redisAsyncCopyError</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ac</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>redisAsyncConnectUnix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>redisConnectUnixNonBlock</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ac</name> <operator>=</operator> <call><name>redisAsyncInitialize</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ac</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>redisFree</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>__redisAsyncCopyError</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ac</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>redisAsyncSetConnectCallback</name><parameter_list>(<parameter><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>, <parameter><decl><type><name>redisConnectCallback</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>ac</name><operator>-&gt;</operator><name>onConnect</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>onConnect</name></name> <operator>=</operator> <name>fn</name></expr>;</expr_stmt>

		<comment type="block">/* The common way to detect an established connection is to wait for
		 * the first write event to be fired. This assumes the related event
		 * library functions are already set. */</comment>
		<expr_stmt><expr><call><name>_EL_ADD_WRITE</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>REDIS_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>REDIS_ERR</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>redisAsyncSetDisconnectCallback</name><parameter_list>(<parameter><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>, <parameter><decl><type><name>redisDisconnectCallback</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>ac</name><operator>-&gt;</operator><name>onDisconnect</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>onDisconnect</name></name> <operator>=</operator> <name>fn</name></expr>;</expr_stmt>
		<return>return <expr><name>REDIS_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>REDIS_ERR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Helper functions to push/shift callbacks */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>__redisPushCallback</name><parameter_list>(<parameter><decl><type><name>redisCallbackList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>redisCallback</name> <modifier>*</modifier></type><name>source</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>redisCallback</name> <modifier>*</modifier></type><name>cb</name></decl>;</decl_stmt>

	<comment type="block">/* Copy callback from stack to heap */</comment>
	<expr_stmt><expr><name>cb</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cb</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>REDIS_ERR_OOM</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>source</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cb</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Store callback in list */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>cb</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>tail</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>cb</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>cb</name></expr>;</expr_stmt>
	<return>return <expr><name>REDIS_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>__redisShiftCallback</name><parameter_list>(<parameter><decl><type><name>redisCallbackList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>redisCallback</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>redisCallback</name> <modifier>*</modifier></type><name>cb</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>cb</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name><name>cb</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cb</name> <operator>==</operator> <name><name>list</name><operator>-&gt;</operator><name>tail</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Copy callback from heap to stack */</comment>
		<if_stmt><if>if <condition>(<expr><name>target</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>REDIS_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>REDIS_ERR</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>__redisRunCallback</name><parameter_list>(<parameter><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>, <parameter><decl><type><name>redisCallback</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>, <parameter><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>ac</name><operator>-&gt;</operator><name>c</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>fn</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>REDIS_IN_CALLBACK</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>cb</name><operator>-&gt;</operator><name>fn</name></name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>reply</name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>privdata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>REDIS_IN_CALLBACK</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Helper function to free the context. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>__redisAsyncFree</name><parameter_list>(<parameter><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>ac</name><operator>-&gt;</operator><name>c</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>redisCallback</name></type> <name>cb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

	<comment type="block">/* Execute pending callbacks with NULL reply. */</comment>
	<while>while <condition>(<expr><call><name>__redisShiftCallback</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ac</name><operator>-&gt;</operator><name>replies</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>__redisRunCallback</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* Execute callbacks for invalid commands */</comment>
	<while>while <condition>(<expr><call><name>__redisShiftCallback</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ac</name><operator>-&gt;</operator><name>sub</name><operator>.</operator><name>invalid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>__redisRunCallback</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* Run subscription callbacks callbacks with NULL reply */</comment>
	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>dictGetIterator</name><argument_list>(<argument><expr><name><name>ac</name><operator>-&gt;</operator><name>sub</name><operator>.</operator><name>channels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>__redisRunCallback</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><call><name>dictGetEntryVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dictRelease</name><argument_list>(<argument><expr><name><name>ac</name><operator>-&gt;</operator><name>sub</name><operator>.</operator><name>channels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>dictGetIterator</name><argument_list>(<argument><expr><name><name>ac</name><operator>-&gt;</operator><name>sub</name><operator>.</operator><name>patterns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>__redisRunCallback</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><call><name>dictGetEntryVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dictRelease</name><argument_list>(<argument><expr><name><name>ac</name><operator>-&gt;</operator><name>sub</name><operator>.</operator><name>patterns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Signal event lib to clean up */</comment>
	<expr_stmt><expr><call><name>_EL_CLEANUP</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Execute disconnect callback. When redisAsyncFree() initiated destroying
	 * this context, the status will always be REDIS_OK. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ac</name><operator>-&gt;</operator><name>onDisconnect</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDIS_CONNECTED</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDIS_FREEING</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name><name>ac</name><operator>-&gt;</operator><name>onDisconnect</name></name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>REDIS_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else <block>{<block_content>
			<expr_stmt><expr><call><name><name>ac</name><operator>-&gt;</operator><name>onDisconnect</name></name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>ac</name><operator>-&gt;</operator><name>err</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>REDIS_OK</name></expr> </then><else>: <expr><name>REDIS_ERR</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Cleanup self */</comment>
	<expr_stmt><expr><call><name>redisFree</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Free the async context. When this function is called from a callback,
 * control needs to be returned to redisProcessCallbacks() before actual
 * free'ing. To do so, a flag is set on the context which is picked up by
 * redisProcessCallbacks(). Otherwise, the context is immediately free'd. */</comment>
<function><type><name>void</name></type> <name>redisAsyncFree</name><parameter_list>(<parameter><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>ac</name><operator>-&gt;</operator><name>c</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>REDIS_FREEING</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDIS_IN_CALLBACK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>__redisAsyncFree</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Helper function to make the disconnect happen and clean up. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>__redisAsyncDisconnect</name><parameter_list>(<parameter><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>ac</name><operator>-&gt;</operator><name>c</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Make sure error is accessible if there is any */</comment>
	<expr_stmt><expr><call><name>__redisAsyncCopyError</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ac</name><operator>-&gt;</operator><name>err</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/* For clean disconnects, there should be no pending callbacks. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>__redisShiftCallback</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ac</name><operator>-&gt;</operator><name>replies</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else <block>{<block_content>
		<comment type="block">/* Disconnection is caused by an error, make sure that pending
		 * callbacks cannot call new commands. */</comment>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>REDIS_DISCONNECTING</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* For non-clean disconnects, __redisAsyncFree() will execute pending
	 * callbacks with a NULL-reply. */</comment>
	<expr_stmt><expr><call><name>__redisAsyncFree</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Tries to do a clean disconnect from Redis, meaning it stops new commands
 * from being issued, but tries to flush the output buffer and execute
 * callbacks for all remaining replies. When this function is called from a
 * callback, there might be more replies and we can safely defer disconnecting
 * to redisProcessCallbacks(). Otherwise, we can only disconnect immediately
 * when there are no pending callbacks. */</comment>
<function><type><name>void</name></type> <name>redisAsyncDisconnect</name><parameter_list>(<parameter><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>ac</name><operator>-&gt;</operator><name>c</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>REDIS_DISCONNECTING</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDIS_IN_CALLBACK</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>ac</name><operator>-&gt;</operator><name>replies</name><operator>.</operator><name>head</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>__redisAsyncDisconnect</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>__redisGetSubscribeCallback</name><parameter_list>(<parameter><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>, <parameter><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>, <parameter><decl><type><name>redisCallback</name> <modifier>*</modifier></type><name>dstcb</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>ac</name><operator>-&gt;</operator><name>c</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>callbacks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>pvariant</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>stype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sds</name></type> <name>sname</name></decl>;</decl_stmt>

	<comment type="block">/* Custom reply functions are not supported for pub/sub. This will fail
	 * very hard when they are used... */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ARRAY</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>elements</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>type</name> <operator>==</operator> <name>REDIS_REPLY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>stype</name> <operator>=</operator> <name><name>reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pvariant</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>tolower</name><argument_list>(<argument><expr><name><name>stype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'p'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>pvariant</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>callbacks</name> <operator>=</operator> <name><name>ac</name><operator>-&gt;</operator><name>sub</name><operator>.</operator><name>patterns</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>callbacks</name> <operator>=</operator> <name><name>ac</name><operator>-&gt;</operator><name>sub</name><operator>.</operator><name>channels</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Locate the right callback */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>type</name> <operator>==</operator> <name>REDIS_REPLY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sname</name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>dictFind</name><argument_list>(<argument><expr><name>callbacks</name></expr></argument>, <argument><expr><name>sname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>de</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dstcb</name></expr></argument>, <argument><expr><call><name>dictGetEntryVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>dstcb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* If this is an unsubscribe message, remove it. */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>stype</name> <operator>+</operator> <name>pvariant</name></expr></argument>, <argument><expr><literal type="string">"unsubscribe"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name>callbacks</name></expr></argument>, <argument><expr><name>sname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* If this was the last unsubscribe message, revert to
				 * non-subscribe mode. */</comment>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>type</name> <operator>==</operator> <name>REDIS_REPLY_INTEGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>integer</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>REDIS_SUBSCRIBED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>sname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else <block>{<block_content>
		<comment type="block">/* Shift callback for invalid commands. */</comment>
		<expr_stmt><expr><call><name>__redisShiftCallback</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ac</name><operator>-&gt;</operator><name>sub</name><operator>.</operator><name>invalid</name></name></expr></argument>, <argument><expr><name>dstcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>REDIS_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>redisProcessCallbacks</name><parameter_list>(<parameter><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>ac</name><operator>-&gt;</operator><name>c</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>redisCallback</name></type> <name>cb</name> <init>= <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>status</name> <operator>=</operator> <call><name>redisGetReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reply</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>REDIS_OK</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>reply</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* When the connection is being disconnected and there are
			 * no more replies, this is the cue to really disconnect. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDIS_DISCONNECTING</name> <operator>&amp;&amp;</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
				<operator>&amp;&amp;</operator> <name><name>ac</name><operator>-&gt;</operator><name>replies</name><operator>.</operator><name>head</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>__redisAsyncDisconnect</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* If monitor mode, repush callback */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDIS_MONITORING</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>__redisPushCallback</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ac</name><operator>-&gt;</operator><name>replies</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* When the connection is not being disconnected, simply stop
			 * trying to get replies and wait for the next loop tick. */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Even if the context is subscribed, pending regular callbacks will
		 * get a reply before pub/sub messages arrive. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>__redisShiftCallback</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ac</name><operator>-&gt;</operator><name>replies</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>REDIS_OK</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/*
			 * A spontaneous reply in a not-subscribed context can be the error
			 * reply that is sent when a new connection exceeds the maximum
			 * number of allowed connections on the server side.
			 *
			 * This is seen as an error instead of a regular reply because the
			 * server closes the connection after sending it.
			 *
			 * To prevent the error from being overwritten by an EOF error the
			 * connection is closed here. See issue #43.
			 *
			 * Another possibility is that the server is loading its dataset.
			 * In this case we also want to close the connection, and have the
			 * user wait until the server is ready to take our request.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>redisReply</name><operator>*</operator><operator>)</operator><name>reply</name><operator>)</operator><operator>-&gt;</operator><name>type</name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <name>REDIS_ERR_OTHER</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>errstr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>errstr</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>redisReply</name><operator>*</operator><operator>)</operator><name>reply</name><operator>)</operator><operator>-&gt;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name><name>c</name><operator>-&gt;</operator><name>reader</name><operator>-&gt;</operator><name>fn</name><operator>-&gt;</operator><name>freeObject</name></name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>__redisAsyncDisconnect</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* No more regular callbacks and no errors, the context *must* be subscribed or monitoring. */</comment>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDIS_SUBSCRIBED</name> <operator>||</operator> <name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDIS_MONITORING</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDIS_SUBSCRIBED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>__redisGetSubscribeCallback</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>reply</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>.</operator><name>fn</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>__redisRunCallback</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>, <argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name><name>c</name><operator>-&gt;</operator><name>reader</name><operator>-&gt;</operator><name>fn</name><operator>-&gt;</operator><name>freeObject</name></name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Proceed with free'ing when redisAsyncFree() was called. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDIS_FREEING</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>__redisAsyncFree</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else <block>{<block_content>
			<comment type="block">/* No callback for this reply. This can either be a NULL callback,
			 * or there were no callbacks to begin with. Either way, don't
			 * abort with an error, but simply ignore it because the client
			 * doesn't know what the server will spit out over the wire. */</comment>
			<expr_stmt><expr><call><name><name>c</name><operator>-&gt;</operator><name>reader</name><operator>-&gt;</operator><name>fn</name><operator>-&gt;</operator><name>freeObject</name></name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Disconnect when there was an error reading the reply */</comment>
	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REDIS_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>__redisAsyncDisconnect</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Internal helper function to detect socket status the first time a read or
 * write event fires. When connecting was not successful, the connect callback
 * is called with a REDIS_ERR status and the context is free'd. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>__redisAsyncHandleConnect</name><parameter_list>(<parameter><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>ac</name><operator>-&gt;</operator><name>c</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>redisCheckSocketError</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_ERR</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Try again later when connect(2) is still in progress. */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINPROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>REDIS_OK</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ac</name><operator>-&gt;</operator><name>onConnect</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>ac</name><operator>-&gt;</operator><name>onConnect</name></name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>REDIS_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>__redisAsyncDisconnect</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>REDIS_ERR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Mark context as connected. */</comment>
	<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>REDIS_CONNECTED</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ac</name><operator>-&gt;</operator><name>onConnect</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>ac</name><operator>-&gt;</operator><name>onConnect</name></name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>REDIS_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>REDIS_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function should be called when the socket is readable.
 * It processes all replies that can be read and executes their callbacks.
 */</comment>
<function><type><name>void</name></type> <name>redisAsyncHandleRead</name><parameter_list>(<parameter><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>ac</name><operator>-&gt;</operator><name>c</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDIS_CONNECTED</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Abort connect was not successful. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>__redisAsyncHandleConnect</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>REDIS_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Try again later when the context is still not connected. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDIS_CONNECTED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>redisBufferRead</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_ERR</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>__redisAsyncDisconnect</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else <block>{<block_content>
		<comment type="block">/* Always re-schedule reads */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
		<comment type="line">// There appears to be a bug in the Linux version of _EL_ADD_READ which will not reschedule</comment>
		<comment type="line">// the read if already reading. This is a problem if there is a large number of async GET</comment>
		<comment type="line">// operations. If the receive buffer is exhausted with the data returned, the read would</comment>
		<comment type="line">// not be rescheduled, and the async operations would cease. This forces the read to recur.</comment>
		<expr_stmt><expr><call><name>_EL_FORCE_ADD_READ</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>_EL_ADD_READ</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>redisProcessCallbacks</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>redisAsyncHandleWrite</name><parameter_list>(<parameter><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>ac</name><operator>-&gt;</operator><name>c</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDIS_CONNECTED</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Abort connect was not successful. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>__redisAsyncHandleConnect</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>REDIS_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Try again later when the context is still not connected. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDIS_CONNECTED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>redisBufferWrite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>done</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_ERR</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>__redisAsyncDisconnect</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else <block>{<block_content>
		<comment type="block">/* Continue writing when not done, stop writing otherwise */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_EL_ADD_WRITE</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_EL_DEL_WRITE</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Always schedule reads after writes */</comment>
		<expr_stmt><expr><call><name>_EL_ADD_READ</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<comment type="block">/* The redisAsyncHandleWrite is split into a Prep and Complete routines
   To allow using a write routine suitable for async behavior.
   For Windows this will use IOCP on write. */</comment>
<function><type><name>int</name></type> <name>redisAsyncHandleWritePrep</name><parameter_list>(<parameter><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>ac</name><operator>-&gt;</operator><name>c</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDIS_CONNECTED</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Abort connect was not successful. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>__redisAsyncHandleConnect</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>REDIS_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>REDIS_ERR</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Try again later when the context is still not connected. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDIS_CONNECTED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>REDIS_ERR</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>REDIS_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>redisAsyncHandleWriteComplete</name><parameter_list>(<parameter><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>written</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>ac</name><operator>-&gt;</operator><name>c</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>redisBufferWriteDone</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>written</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>REDIS_ERR</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>__redisAsyncDisconnect</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else <block>{<block_content>
		<comment type="block">/* Continue writing when not done, stop writing otherwise */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_EL_ADD_WRITE</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_EL_DEL_WRITE</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Always schedule reads after writes */</comment>
		<expr_stmt><expr><call><name>_EL_ADD_READ</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>REDIS_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Sets a pointer to the first argument and its length starting at p. Returns
 * the number of bytes to skip to get to the following argument. */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nextArgument</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strtol</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'\r'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<return>return <expr><name>p</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>len</name><operator>)</operator> <operator>+</operator> <literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Helper function for the redisAsyncCommand* family of functions. Writes a
 * formatted command to the output buffer and registers the provided callback
 * function with the context. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>__redisAsyncCommand</name><parameter_list>(<parameter><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>, <parameter><decl><type><name>redisCallbackFn</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>ac</name><operator>-&gt;</operator><name>c</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>redisCallback</name></type> <name>cb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>pvariant</name></decl>, <decl><type ref="prev"/><name>hasnext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cstr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>astr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>clen</name></decl>, <decl><type ref="prev"/><name>alen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sds</name></type> <name>sname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

	<comment type="block">/* Don't accept new commands when the connection is about to be closed. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>REDIS_DISCONNECTING</name> <operator>|</operator> <name>REDIS_FREEING</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDIS_ERR</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Setup callback */</comment>
	<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>fn</name></name> <operator>=</operator> <name>fn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>privdata</name></name> <operator>=</operator> <name>privdata</name></expr>;</expr_stmt>

	<comment type="block">/* Find out which command will be appended. */</comment>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>nextArgument</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hasnext</name> <operator>=</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'$'</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>pvariant</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>tolower</name><argument_list>(<argument><expr><name><name>cstr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'p'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>cstr</name> <operator>+=</operator> <name>pvariant</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>clen</name> <operator>-=</operator> <name>pvariant</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hasnext</name> <operator>&amp;&amp;</operator> <call><name>strncasecmp</name><argument_list>(<argument><expr><name>cstr</name></expr></argument>, <argument><expr><literal type="string">"subscribe\r\n"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>REDIS_SUBSCRIBED</name></expr>;</expr_stmt>

		<comment type="block">/* Add every channel/pattern to the list of subscription callbacks. */</comment>
		<while>while <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>nextArgument</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>astr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>alen</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>sname</name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name>astr</name></expr></argument>, <argument><expr><name>alen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pvariant</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dictReplace</name><argument_list>(<argument><expr><name><name>ac</name><operator>-&gt;</operator><name>sub</name><operator>.</operator><name>patterns</name></name></expr></argument>, <argument><expr><name>sname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dictReplace</name><argument_list>(<argument><expr><name><name>ac</name><operator>-&gt;</operator><name>sub</name><operator>.</operator><name>channels</name></name></expr></argument>, <argument><expr><name>sname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>sname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name>cstr</name></expr></argument>, <argument><expr><literal type="string">"unsubscribe\r\n"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/* It is only useful to call (P)UNSUBSCRIBE when the context is
		 * subscribed to one or more channels or patterns. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDIS_SUBSCRIBED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDIS_ERR</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* (P)UNSUBSCRIBE does not have its own response: every channel or
		 * pattern that is unsubscribed will receive a message. This means we
		 * should not append a callback function for this command. */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name>cstr</name></expr></argument>, <argument><expr><literal type="string">"monitor\r\n"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Set monitor flag and push callback */</comment>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>REDIS_MONITORING</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>__redisPushCallback</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ac</name><operator>-&gt;</operator><name>replies</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDIS_SUBSCRIBED</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* This will likely result in an error reply, but it needs to be
			 * received and passed to the callback. */</comment>
			<expr_stmt><expr><call><name>__redisPushCallback</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ac</name><operator>-&gt;</operator><name>sub</name><operator>.</operator><name>invalid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>__redisPushCallback</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ac</name><operator>-&gt;</operator><name>replies</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>__redisAppendCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Always schedule a write when the write buffer is non-empty */</comment>
	<expr_stmt><expr><call><name>_EL_ADD_WRITE</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>REDIS_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>redisvAsyncCommand</name><parameter_list>(<parameter><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>, <parameter><decl><type><name>redisCallbackFn</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>redisvFormatCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We don't want to pass -1 or -2 to future functions as a length. */</comment>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>REDIS_ERR</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>__redisAsyncCommand</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>privdata</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>redisAsyncCommand</name><parameter_list>(<parameter><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>, <parameter><decl><type><name>redisCallbackFn</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>redisvAsyncCommand</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>privdata</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>redisAsyncCommandArgv</name><parameter_list>(<parameter><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>, <parameter><decl><type><name>redisCallbackFn</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>argvlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>sds</name></type> <name>cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>redisFormatSdsCommandArgv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>argvlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>__redisAsyncCommand</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>privdata</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>redisAsyncFormattedCommand</name><parameter_list>(<parameter><decl><type><name>redisAsyncContext</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>, <parameter><decl><type><name>redisCallbackFn</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><call><name>__redisAsyncCommand</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>privdata</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function></unit>
