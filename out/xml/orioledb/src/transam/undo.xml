<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/transam/undo.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * undo.c
 *		Implementation of OrioleDB undo log.
 *
 * Copyright (c) 2021-2022, Oriole DB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/transam/undo.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"checkpoint/checkpoint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"recovery/recovery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"recovery/wal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tableam/descr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tableam/handler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transam/oxid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transam/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/o_buffers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/page_pool.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/stopevent.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_UNDO_REC</name><parameter_list>(<parameter><type><name>loc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(o_undo_buffers + (loc) % undo_circular_buffer_size)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNDO_FILE_SIZE</name></cpp:macro> <cpp:value>(0x4000000)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>undoLocCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pairingheap_node</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>pairingheap_node</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>pairingheap</name></type> <name>retainUndoLocHeap</name> <init>= <expr><block>{<expr><operator>&amp;</operator><name>undoLocCmp</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>UndoCallback</name>) <parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>UndoStackItem</name> <modifier>*</modifier></type><name>item</name></decl></parameter>,
							  <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>abort</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>changeCountsValid</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>o_stub_item_callback</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>UndoStackItem</name> <modifier>*</modifier></type><name>baseItem</name></decl></parameter>,
								 <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>abort</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>changeCountsValid</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Descriptor of undo item type.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>UndoItemType</name></type> <name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>callOnCommit</name></decl>;</decl_stmt>	<comment type="block">/* call the callback on commit */</comment>
	<decl_stmt><decl><type><name>UndoCallback</name></type> <name>callback</name></decl>;</decl_stmt>		<comment type="block">/* callback to be called on transaction finish */</comment>
}</block></struct></type> <name>UndoItemTypeDescr</name>;</typedef>

<decl_stmt><decl><type><name>UndoItemTypeDescr</name></type> <name><name>undoItemTypeDescrs</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>ModifyUndoItemType</name></expr>,
		<expr><operator>.</operator><name>callback</name> <operator>=</operator> <name>modify_undo_callback</name></expr>,
		<expr><operator>.</operator><name>callOnCommit</name> <operator>=</operator> <name>false</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>RowLockUndoItemType</name></expr>,
		<expr><operator>.</operator><name>callback</name> <operator>=</operator> <name>lock_undo_callback</name></expr>,
		<expr><operator>.</operator><name>callOnCommit</name> <operator>=</operator> <name>false</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>RelnodeUndoItemType</name></expr>,
		<expr><operator>.</operator><name>callback</name> <operator>=</operator> <name>btree_relnode_undo_callback</name></expr>,
		<expr><operator>.</operator><name>callOnCommit</name> <operator>=</operator> <name>true</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>SysTreesLockUndoItemType</name></expr>,
		<expr><operator>.</operator><name>callback</name> <operator>=</operator> <name>systrees_lock_callback</name></expr>,
		<expr><operator>.</operator><name>callOnCommit</name> <operator>=</operator> <name>false</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>InvalidateUndoItemType</name></expr>,
		<expr><operator>.</operator><name>callback</name> <operator>=</operator> <name>o_invalidate_undo_item_callback</name></expr>,
		<expr><operator>.</operator><name>callOnCommit</name> <operator>=</operator> <name>true</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>BranchUndoItemType</name></expr>,
		<expr><operator>.</operator><name>callback</name> <operator>=</operator> <name>o_stub_item_callback</name></expr>,
		<expr><operator>.</operator><name>callOnCommit</name> <operator>=</operator> <name>false</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>SubXactUndoItemType</name></expr>,
		<expr><operator>.</operator><name>callback</name> <operator>=</operator> <name>o_stub_item_callback</name></expr>,
		<expr><operator>.</operator><name>callOnCommit</name> <operator>=</operator> <name>false</name></expr>
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>orioledb_has_retained_undo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>UndoMeta</name>   <modifier>*</modifier></type><name>undo_meta</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>UndoLocation</name></type> <name>curRetainUndoLocation</name> <init>= <expr><name>InvalidUndoLocation</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>oxid_needs_wal_flush</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Size</name></type> <name>reserved_undo_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>OBuffersDesc</name></type> <name>buffersDesc</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>singleFileSize</name> <operator>=</operator> <name>UNDO_FILE_SIZE</name></expr>,
	<expr><operator>.</operator><name>filenameTemplate</name> <operator>=</operator> <name>ORIOLEDB_UNDO_DIR</name> <literal type="string">"/%02X%08X"</literal></expr>,
	<expr><operator>.</operator><name>groupCtlTrancheName</name> <operator>=</operator> <literal type="string">"undoBuffersGroupCtlTranche"</literal></expr>,
	<expr><operator>.</operator><name>bufferCtlTrancheName</name> <operator>=</operator> <literal type="string">"undoBuffersCtlTranche"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>wait_for_reserved_location</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>undoLocationToWait</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>Size</name></type>
<name>undo_shmem_needs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>buffersDesc</name><operator>.</operator><name>buffersCount</name></name> <operator>=</operator> <name>undo_buffers_count</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UndoMeta</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>undo_circular_buffer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>o_buffers_shmem_needs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffersDesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>undo_shmem_init</name><parameter_list>(<parameter><decl><type><name>Pointer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>found</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>ptr</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>undo_meta</name> <operator>=</operator> <operator>(</operator><name>UndoMeta</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UndoMeta</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>o_undo_buffers</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>undo_circular_buffer_size</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>o_buffers_shmem_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffersDesc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minUndoLocationsMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>undo_meta</name><operator>-&gt;</operator><name>minUndoLocationsChangeCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>undo_meta</name><operator>-&gt;</operator><name>undoWriteTrancheId</name></name> <operator>=</operator> <call><name>LWLockNewTrancheId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>undo_meta</name><operator>-&gt;</operator><name>undoStackLocationsFlushLockTrancheId</name></name> <operator>=</operator> <call><name>LWLockNewTrancheId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>undoWriteLock</name></name></expr></argument>,
						 <argument><expr><name><name>undo_meta</name><operator>-&gt;</operator><name>undoWriteTrancheId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Undo locations are initialized in checkpoint_shmem_init() */</comment>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name><name>undo_meta</name><operator>-&gt;</operator><name>undoWriteTrancheId</name></name></expr></argument>,
						  <argument><expr><literal type="string">"OUndoWriteTranche"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name><name>undo_meta</name><operator>-&gt;</operator><name>undoStackLocationsFlushLockTrancheId</name></name></expr></argument>,
						  <argument><expr><literal type="string">"UndoStackPosFlushTranche"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>UndoItemTypeDescr</name> <modifier>*</modifier></type>
<name>item_type_get_descr</name><parameter_list>(<parameter><decl><type><name>UndoItemType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoItemTypeDescr</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>type</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>type</name> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>undoItemTypeDescrs</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>undoItemTypeDescrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>&amp;</operator><name><name>undoItemTypeDescrs</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <name>type</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>update_min_undo_locations</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>have_lock</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>do_cleanup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>minReservedLocation</name></decl>,
				<decl><type ref="prev"/><name>minRetainLocation</name></decl>,
				<decl><type ref="prev"/><name>minTransactionRetainLocation</name></decl>,
				<decl><type ref="prev"/><name>lastUsedLocation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>oldCleanedLocation</name></decl>,
				<decl><type ref="prev"/><name>oldCheckpointStartLocation</name></decl>,
				<decl><type ref="prev"/><name>oldCheckpointEndLocation</name></decl>,
				<decl><type ref="prev"/><name>newCheckpointStartLocation</name></decl>,
				<decl><type ref="prev"/><name>newCheckpointEndLocation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>have_lock</name> <operator>||</operator> <operator>!</operator><name>do_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_lock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minUndoLocationsMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minUndoLocationsChangeCount</name></name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>undo_meta</name><operator>-&gt;</operator><name>minUndoLocationsChangeCount</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lastUsedLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>lastUsedLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>minTransactionRetainLocation</name> <operator>=</operator> <name>minRetainLocation</name> <operator>=</operator> <name>minReservedLocation</name> <operator>=</operator> <name>lastUsedLocation</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_procs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>UndoLocation</name></type> <name>tmp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oProcData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reservedUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>minReservedLocation</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>minReservedLocation</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oProcData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>transactionUndoRetainLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>minRetainLocation</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>minRetainLocation</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>minTransactionRetainLocation</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>minTransactionRetainLocation</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oProcData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>snapshotRetainUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>minRetainLocation</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>minRetainLocation</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Make sure none of calculated variables goes backwards.
	 */</comment>
	<expr_stmt><expr><name>minReservedLocation</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcReservedLocation</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>minReservedLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>minRetainLocation</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcRetainLocation</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>minRetainLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>minTransactionRetainLocation</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcTransactionRetainLocation</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>minTransactionRetainLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcReservedLocation</name></name></expr></argument>, <argument><expr><name>minReservedLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcRetainLocation</name></name></expr></argument>, <argument><expr><name>minRetainLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcTransactionRetainLocation</name></name></expr></argument>, <argument><expr><name>minTransactionRetainLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>lastUsedUndoLocationWhenUpdatedMinLocation</name></name></expr></argument>, <argument><expr><name>lastUsedLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>undo_meta</name><operator>-&gt;</operator><name>minUndoLocationsChangeCount</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minUndoLocationsChangeCount</name></name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_lock</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>UndoLocation</name></type> <name>writeInProgressLocation</name></decl>,
					<decl><type ref="prev"/><name>writtenLocation</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>writeInProgressLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writeInProgressLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>writtenLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writtenLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>writtenLocation</name> <operator>==</operator> <name>writeInProgressLocation</name> <operator>&amp;&amp;</operator> <name>writtenLocation</name> <operator>&lt;</operator> <name>minRetainLocation</name> <operator>&amp;&amp;</operator>
			<call><name>LWLockConditionalAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>undoWriteLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>minRetainLocation</name> <operator>&gt;=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writeInProgressLocation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>minRetainLocation</name> <operator>&gt;=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writtenLocation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writeInProgressLocation</name></name></expr></argument>, <argument><expr><name>minRetainLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writtenLocation</name></name></expr></argument>, <argument><expr><name>minRetainLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>undoWriteLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>do_cleanup</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>oldCleanedLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>cleanedLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldCheckpointStartLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>cleanedCheckpointStartLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldCheckpointEndLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>cleanedCheckpointEndLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newCheckpointStartLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>checkpointRetainStartLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newCheckpointEndLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>checkpointRetainEndLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>oldCleanedLocation</name> <operator>!=</operator> <name>minRetainLocation</name> <operator>||</operator>
			<name>oldCheckpointStartLocation</name> <operator>!=</operator> <name>newCheckpointStartLocation</name> <operator>||</operator>
			<name>oldCheckpointEndLocation</name> <operator>!=</operator> <name>newCheckpointEndLocation</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>cleanedCheckpointStartLocation</name></name></expr></argument>, <argument><expr><name>newCheckpointStartLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>cleanedCheckpointEndLocation</name></name></expr></argument>, <argument><expr><name>newCheckpointEndLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>cleanedLocation</name></name></expr></argument>, <argument><expr><name>minRetainLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>do_cleanup</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_lock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minUndoLocationsMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>do_cleanup</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type>		<name>oldCleanedNum</name> <init>= <expr><name>oldCleanedLocation</name> <operator>/</operator> <name>UNDO_FILE_SIZE</name></expr></init></decl>,
					<decl><type ref="prev"/><name>newCleanedNum</name> <init>= <expr><name>minRetainLocation</name> <operator>/</operator> <name>UNDO_FILE_SIZE</name></expr></init></decl>,
					<decl><type ref="prev"/><name>oldCheckpointStartNum</name> <init>= <expr><name>oldCheckpointStartLocation</name> <operator>/</operator> <name>UNDO_FILE_SIZE</name></expr></init></decl>,
					<decl><type ref="prev"/><name>oldCheckpointEndNum</name> <init>= <expr><name>oldCheckpointEndLocation</name> <operator>/</operator> <name>UNDO_FILE_SIZE</name></expr></init></decl>,
					<decl><type ref="prev"/><name>newCheckpointStartNum</name> <init>= <expr><name>newCheckpointStartLocation</name> <operator>/</operator> <name>UNDO_FILE_SIZE</name></expr></init></decl>,
					<decl><type ref="prev"/><name>newCheckpointEndNum</name> <init>= <expr><name>newCheckpointEndLocation</name> <operator>/</operator> <name>UNDO_FILE_SIZE</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>oldCheckpointEndLocation</name> <operator>%</operator> <name>UNDO_FILE_SIZE</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>oldCheckpointEndNum</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>newCheckpointEndLocation</name> <operator>%</operator> <name>UNDO_FILE_SIZE</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newCheckpointEndNum</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>o_buffers_unlink_files_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffersDesc</name></expr></argument>,
									 <argument><expr><name>oldCheckpointStartNum</name></expr></argument>,
									 <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>oldCheckpointEndNum</name></expr></argument>,
										 <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>newCheckpointStartNum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
											 <argument><expr><name>newCleanedNum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>o_buffers_unlink_files_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffersDesc</name></expr></argument>,
									 <argument><expr><call><name>Max</name><argument_list>(<argument><expr><name>oldCheckpointStartNum</name></expr></argument>,
										 <argument><expr><name>newCheckpointEndNum</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>oldCheckpointEndNum</name></expr></argument>,
										 <argument><expr><name>newCleanedNum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>o_buffers_unlink_files_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffersDesc</name></expr></argument>,
									 <argument><expr><name>oldCleanedNum</name></expr></argument>,
									 <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>newCheckpointStartNum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
										 <argument><expr><name>newCleanedNum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>o_buffers_unlink_files_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffersDesc</name></expr></argument>,
									 <argument><expr><call><name>Max</name><argument_list>(<argument><expr><name>oldCleanedNum</name></expr></argument>,
										 <argument><expr><name>newCheckpointEndNum</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>newCleanedNum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Guarantees that concurrent update_min_undo_locations() finishes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>wait_for_even_changecount</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpinDelayStatus</name></type> <name>status</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_local_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name><name>undo_meta</name><operator>-&gt;</operator><name>minUndoLocationsChangeCount</name></name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>perform_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>finish_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_my_reserved_location</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ODBProcData</name> <modifier>*</modifier></type><name>curProcData</name> <init>= <expr><call><name>GET_CUR_PROCDATA</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>lastUsedLocation</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>lastUsedLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>lastUsedLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>reservedUndoLocation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>reservedUndoLocation</name></name></expr></argument>, <argument><expr><name>lastUsedLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>transactionUndoRetainLocation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>transactionUndoRetainLocation</name></name></expr></argument>, <argument><expr><name>lastUsedLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>wait_for_even_changecount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Retry if minimal positions run higher due to concurrent
		 * update_min_undo_locations().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcReservedLocation</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>lastUsedLocation</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcTransactionRetainLocation</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>lastUsedLocation</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<break>break;</break>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>curRetainUndoLocation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>curRetainUndoLocation</name> <operator>=</operator> <name>lastUsedLocation</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>UndoLocation</name></type>
<name>set_my_retain_location</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ODBProcData</name> <modifier>*</modifier></type><name>curProcData</name> <init>= <expr><call><name>GET_CUR_PROCDATA</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>curSnapshotRetainUndoLocation</name></decl>,
				<decl><type ref="prev"/><name>retainUndoLocation</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>retainUndoLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcTransactionRetainLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>curSnapshotRetainUndoLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>snapshotRetainUndoLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>curSnapshotRetainUndoLocation</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<name>retainUndoLocation</name> <operator>&lt;</operator> <name>curSnapshotRetainUndoLocation</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>snapshotRetainUndoLocation</name></name></expr></argument>, <argument><expr><name>retainUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>wait_for_even_changecount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Retry if minimal positions run higher due to concurrent
		 * update_min_undo_locations().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcRetainLocation</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>retainUndoLocation</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<break>break;</break>
	</block_content>}</block></while>
	<return>return <expr><name>retainUndoLocation</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>wait_for_reserved_location</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>undoLocationToWait</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpinDelayStatus</name></type> <name>delay</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ODBProcData</name> <modifier>*</modifier></type><name>curProcData</name> <init>= <expr><call><name>GET_CUR_PROCDATA</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>delay_inited</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>undoLocationToWait</name> <operator>&gt;</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>reservedUndoLocation</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>undo_circular_buffer_size</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_procs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>delay_inited</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>undoLocationToWait</name> <operator>&gt;</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oProcData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reservedUndoLocation</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>undo_circular_buffer_size</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>delay_inited</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>init_local_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>delay_inited</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>perform_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></while>

		<if_stmt><if>if <condition>(<expr><name>delay_inited</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>finish_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNDO_ITEM_BUF_SIZE</name></cpp:macro>	<cpp:value>2048</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name><name>staticData</name><index>[<expr><name>UNDO_ITEM_BUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>length</name></decl>;</decl_stmt>
}</block></struct></type> <name>UndoItemBuf</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_undo_item_buf</name><parameter_list>(<parameter><decl><type><name>UndoItemBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>staticData</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <name>UNDO_ITEM_BUF_SIZE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>UndoStackItem</name> <modifier>*</modifier></type>
<name>undo_item_buf_read_item</name><parameter_list>(<parameter><decl><type><name>UndoItemBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>itemSize</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>undo_read</name><argument_list>(<argument><expr><name>location</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UndoStackItem</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>itemSize</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>UndoStackItem</name> <operator>*</operator><operator>)</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator><operator>-&gt;</operator><name>itemSize</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>itemSize</name> <operator>&gt;</operator> <name><name>buf</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>length</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name> <operator>==</operator> <name><name>buf</name><operator>-&gt;</operator><name>staticData</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>staticData</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UndoStackItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemSize</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UndoStackItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>undo_read</name><argument_list>(<argument><expr><name>location</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UndoStackItem</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr><name>itemSize</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UndoStackItem</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UndoStackItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>UndoStackItem</name> <operator>*</operator><operator>)</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_undo_item_buf</name><parameter_list>(<parameter><decl><type><name>UndoItemBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name> <operator>!=</operator> <name><name>buf</name><operator>-&gt;</operator><name>staticData</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>UndoLocation</name></type>
<name>o_add_branch_undo_item</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>newLocation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>location</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoStackSharedLocations</name> <modifier>*</modifier></type><name>sharedLocations</name> <init>= <expr><call><name>GET_CUR_UNDO_STACK_LOCATIONS</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BranchUndoStackItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BranchUndoStackItem</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>BranchUndoStackItem</name> <operator>*</operator><operator>)</operator> <call><name>get_undo_record_unreserved</name><argument_list>(<argument><expr><name>UndoReserveTxn</name></expr></argument>,
															  <argument><expr><operator>&amp;</operator><name>location</name></expr></argument>,
															  <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>longPathLocation</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sharedLocations</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>prevBranchLocation</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sharedLocations</name><operator>-&gt;</operator><name>branchLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>BranchUndoItemType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>indexType</name></name> <operator>=</operator> <name>oIndexPrimary</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>itemSize</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <name>newLocation</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>release_undo_size</name><argument_list>(<argument><expr><name>UndoReserveTxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>location</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Walk through the undo stack calling the callbacks for each item.
 */</comment>
<function><type><specifier>static</specifier> <name>UndoLocation</name></type>
<name>walk_undo_range</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name></type> <name>toLoc</name></decl></parameter>, <parameter><decl><type><name>UndoItemBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
				<parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>abort</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name> <modifier>*</modifier></type><name>onCommitLocation</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>changeCountsValid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoStackItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoItemTypeDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>location</name> <operator>&gt;</operator> <name>toLoc</name> <operator>||</operator> <operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>toLoc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>undo_item_buf_read_item</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>item_type_get_descr</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>descr</name><operator>-&gt;</operator><name>callback</name></name><argument_list>(<argument><expr><name>location</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>abort</name></expr></argument>, <argument><expr><name>changeCountsValid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update location of the last item, which needs an action on commit,
		 * if needed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>onCommitLocation</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>onCommitLocation</name> <operator>==</operator> <name>location</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OnCommitUndoStackItem</name> <modifier>*</modifier></type><name>fItem</name> <init>= <expr><operator>(</operator><name>OnCommitUndoStackItem</name> <operator>*</operator><operator>)</operator> <name>item</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><operator>*</operator><name>onCommitLocation</name> <operator>=</operator> <name><name>fItem</name><operator>-&gt;</operator><name>onCommitLocation</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * On commit, we only walk through the specific items. On abort, we
		 * walk through all the items.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>abort</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OnCommitUndoStackItem</name> <modifier>*</modifier></type><name>fItem</name> <init>= <expr><operator>(</operator><name>OnCommitUndoStackItem</name> <operator>*</operator><operator>)</operator> <name>item</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>location</name> <operator>=</operator> <name><name>fItem</name><operator>-&gt;</operator><name>onCommitLocation</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>location</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>location</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Apply undo branches: parts of transaction undo chain, which should be already
 * aborted.  This is used during recovery: despite some parts of chain are
 * already aborted, checkpointed items could still reference them.
 */</comment>
<function><type><name>void</name></type>
<name>apply_undo_branches</name><parameter_list>(<parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoItemBuf</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoStackSharedLocations</name> <modifier>*</modifier></type><name>sharedLocations</name> <init>= <expr><call><name>GET_CUR_UNDO_STACK_LOCATIONS</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BranchUndoStackItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>location</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_undo_item_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sharedLocations</name><operator>-&gt;</operator><name>branchLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>BranchUndoStackItem</name> <operator>*</operator><operator>)</operator> <call><name>undo_item_buf_read_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>location</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>prevBranchLocation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>walk_undo_range</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>longPathLocation</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>prev</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						<argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>free_undo_item_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Walk transaction undo stack chain during (sub)transaction abort or
 * transaction commit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>walk_undo_stack</name><parameter_list>(<parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>UndoStackLocations</name> <modifier>*</modifier></type><name>toLocation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>abortTrx</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>changeCountsValid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoItemBuf</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>location</name></decl>,
				<decl><type ref="prev"/><name>newOnCommitLocation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ODBProcData</name> <modifier>*</modifier></type><name>curProcData</name> <init>= <expr><call><name>GET_CUR_PROCDATA</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoStackSharedLocations</name> <modifier>*</modifier></type><name>sharedLocations</name> <init>= <expr><call><name>GET_CUR_UNDO_STACK_LOCATIONS</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>STOPEVENTS_ENABLED</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>params</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>WJB_BEGIN_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jsonb_push_bool_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"commit"</literal></expr></argument>, <argument><expr><operator>!</operator><name>abortTrx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>WJB_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>STOPEVENT</name><argument_list>(<argument><expr><name>STOPEVENT_BEFORE_APPLY_UNDO</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>init_undo_item_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>abortTrx</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * One could only do the "on commit" action for the whole transaction
		 * chain.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>toLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sharedLocations</name><operator>-&gt;</operator><name>onCommitLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>walk_undo_range</name><argument_list>(<argument><expr><name>location</name></expr></argument>, <argument><expr><name>InvalidUndoLocation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								   <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>changeCountsValid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newOnCommitLocation</name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Abort can relate to part of transactio chain.  "On commit" location
		 * needs to be updated accordingly.
		 */</comment>
		<expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sharedLocations</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newOnCommitLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sharedLocations</name><operator>-&gt;</operator><name>onCommitLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>walk_undo_range</name><argument_list>(<argument><expr><name>location</name></expr></argument>,
								   <argument><expr><ternary><condition><expr><name>toLocation</name></expr> ?</condition><then> <expr><name><name>toLocation</name><operator>-&gt;</operator><name>location</name></name></expr> </then><else>: <expr><name>InvalidUndoLocation</name></expr></else></ternary></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newOnCommitLocation</name></expr></argument>,
								   <argument><expr><name>changeCountsValid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Create special branch item, which allows finding aborted items.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>toLocation</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>o_add_branch_undo_item</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>undoStackLocationsFlushLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>toLocation</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sharedLocations</name><operator>-&gt;</operator><name>branchLocation</name></name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Flush undo location to checkpoint if concurrent checkpointing requires
	 * that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>toLocation</name> <operator>&amp;&amp;</operator> <name><name>curProcData</name><operator>-&gt;</operator><name>flushUndoLocations</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XidFileRec</name></type>	<name>rec</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>rec</name><operator>.</operator><name>oxid</name></name> <operator>=</operator> <name>oxid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>read_shared_undo_locations</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rec</name><operator>.</operator><name>undoLocation</name></name></expr></argument>, <argument><expr><name>sharedLocations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_to_xids_queue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sharedLocations</name><operator>-&gt;</operator><name>location</name></name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sharedLocations</name><operator>-&gt;</operator><name>onCommitLocation</name></name></expr></argument>, <argument><expr><name>newOnCommitLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>undoStackLocationsFlushLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_undo_item_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>apply_undo_stack</name><parameter_list>(<parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>UndoStackLocations</name> <modifier>*</modifier></type><name>toLocation</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>changeCountsValid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>walk_undo_stack</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>toLocation</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>changeCountsValid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>on_commit_undo_stack</name><parameter_list>(<parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>changeCountsValid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>walk_undo_stack</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>changeCountsValid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>have_retained_undo_location</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ODBProcData</name> <modifier>*</modifier></type><name>curProcData</name> <init>= <expr><call><name>GET_CUR_PROCDATA</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>transactionUndoRetainLocation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>UndoLocation</name></type>
<name>get_snapshot_retained_undo_location</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ODBProcData</name> <modifier>*</modifier></type><name>curProcData</name> <init>= <expr><call><name>GET_CUR_PROCDATA</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>snapshotRetainUndoLocation</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>free_retained_undo_location</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ODBProcData</name> <modifier>*</modifier></type><name>curProcData</name> <init>= <expr><call><name>GET_CUR_PROCDATA</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>reserved_undo_size</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>reservedUndoLocation</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>transactionUndoRetainLocation</name></name></expr></argument>, <argument><expr><name>InvalidUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>curRetainUndoLocation</name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>

</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_reserved_undo_location</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>,
							 <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>minProcReservedLocation</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>waitForUndoLocation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>minProcReservedLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcReservedLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>location</name> <operator>&gt;</operator> <operator>*</operator><name>minProcReservedLocation</name> <operator>+</operator> <name>undo_circular_buffer_size</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>failed</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>waitForUndoLocation</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>failed</name> <operator>=</operator> <operator>!</operator><call><name>wait_for_reserved_location</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>failed</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>minProcReservedLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcReservedLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>location</name> <operator>&lt;=</operator> <operator>*</operator><name>minProcReservedLocation</name> <operator>+</operator> <name>undo_circular_buffer_size</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>update_min_undo_locations</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>waitForUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>minProcReservedLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcReservedLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_undo_range</name><parameter_list>(<parameter><decl><type><name>Pointer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name></type> <name>minLoc</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name></type> <name>maxLoc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>maxLoc</name> <operator>&gt;</operator> <name>minLoc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>o_buffers_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffersDesc</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>minLoc</name></expr></argument>, <argument><expr><name>maxLoc</name> <operator>-</operator> <name>minLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>read_undo_range</name><parameter_list>(<parameter><decl><type><name>Pointer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name></type> <name>minLoc</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name></type> <name>maxLoc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>maxLoc</name> <operator>&gt;</operator> <name>minLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>o_buffers_read</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffersDesc</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>minLoc</name></expr></argument>, <argument><expr><name>maxLoc</name> <operator>-</operator> <name>minLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>write_undo</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>targetUndoLocation</name></decl></parameter>,
		   <parameter><decl><type><name>UndoLocation</name></type> <name>minProcReservedLocation</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>attempt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>retainUndoLocation</name></decl>,
				<decl><type ref="prev"/><name>writtenLocation</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>targetUndoLocation</name> <operator>&lt;=</operator> <name>minProcReservedLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>attempt</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LWLockConditionalAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>undoWriteLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>undoWriteLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minUndoLocationsMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>update_min_undo_locations</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>retainUndoLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcRetainLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>targetUndoLocation</name> <operator>&lt;=</operator> <name>retainUndoLocation</name> <operator>||</operator>
		<name>targetUndoLocation</name> <operator>&lt;=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writtenLocation</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We don't have to really write undo. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writeInProgressLocation</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>retainUndoLocation</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writeInProgressLocation</name></name></expr></argument>, <argument><expr><name>retainUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writtenLocation</name></name></expr></argument>, <argument><expr><name>retainUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minUndoLocationsMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>undoWriteLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Try to write 5% of the whole undo size if possible */</comment>
	<expr_stmt><expr><name>writtenLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writtenLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>retainUndoLocation</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>retainUndoLocation</name></expr></argument>, <argument><expr><name>writtenLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>targetUndoLocation</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>targetUndoLocation</name></expr></argument>, <argument><expr><name>writtenLocation</name> <operator>+</operator> <name>undo_circular_buffer_size</name> <operator>/</operator> <literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>targetUndoLocation</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>targetUndoLocation</name></expr></argument>, <argument><expr><name>minProcReservedLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>targetUndoLocation</name> <operator>&gt;=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writeInProgressLocation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writeInProgressLocation</name></name></expr></argument>, <argument><expr><name>targetUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minUndoLocationsMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>minProcReservedLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcReservedLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>minProcReservedLocation</name> <operator>&lt;</operator> <name>targetUndoLocation</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>wait_for_reserved_location</name><argument_list>(<argument><expr><name>targetUndoLocation</name> <operator>+</operator> <name>undo_circular_buffer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<if_stmt><if>if <condition>(<expr><name>retainUndoLocation</name> <operator>%</operator> <name>undo_circular_buffer_size</name> <operator>&lt;</operator>
		<name>targetUndoLocation</name> <operator>%</operator> <name>undo_circular_buffer_size</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_undo_range</name><argument_list>(<argument><expr><name>o_undo_buffers</name> <operator>+</operator> <name>retainUndoLocation</name> <operator>%</operator> <name>undo_circular_buffer_size</name></expr></argument>,
						 <argument><expr><name>retainUndoLocation</name></expr></argument>, <argument><expr><name>targetUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>UndoLocation</name></type> <name>breakUndoLocation</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>breakUndoLocation</name> <operator>=</operator> <name>retainUndoLocation</name> <operator>+</operator> <operator>(</operator><name>undo_circular_buffer_size</name> <operator>-</operator>
												  <operator>(</operator><name>retainUndoLocation</name> <operator>%</operator> <name>undo_circular_buffer_size</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_undo_range</name><argument_list>(<argument><expr><name>o_undo_buffers</name> <operator>+</operator> <name>retainUndoLocation</name> <operator>%</operator> <name>undo_circular_buffer_size</name></expr></argument>,
						 <argument><expr><name>retainUndoLocation</name></expr></argument>, <argument><expr><name>breakUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_undo_range</name><argument_list>(<argument><expr><name>o_undo_buffers</name></expr></argument>, <argument><expr><name>breakUndoLocation</name></expr></argument>, <argument><expr><name>targetUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minUndoLocationsMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>targetUndoLocation</name> <operator>&gt;=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writtenLocation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writtenLocation</name></name></expr></argument>, <argument><expr><name>targetUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minUndoLocationsMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>undoWriteLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>reserve_undo_size_extended</name><parameter_list>(<parameter><decl><type><name>UndoReserveType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>waitForUndoLocation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>reportError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>location</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>minProcReservedLocation</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>waitForUndoLocation</name> <operator>||</operator> <operator>!</operator><call><name>have_locked_pages</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>type</name> <operator>==</operator> <name>UndoReserveTxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>reserved_undo_size</name> <operator>&gt;=</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>size</name> <operator>-=</operator> <name>reserved_undo_size</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>advanceReservedLocation</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>reserved_undo_size</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>location</name> <operator>+</operator> <name>size</name> <operator>&lt;=</operator>
		<call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writtenLocation</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>undo_circular_buffer_size</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>update_min_undo_locations</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>waitForUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_reserved_undo_location</name><argument_list>(<argument><expr><name>location</name> <operator>+</operator> <name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minProcReservedLocation</name></expr></argument>,
									  <argument><expr><name>waitForUndoLocation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * we add size to reserver_undo_size and
		 * undo_meta-&gt;advanceReservedLocation and must revert this action
		 */</comment>
		<expr_stmt><expr><call><name>pg_atomic_fetch_sub_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>advanceReservedLocation</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>reserved_undo_size</name> <operator>-=</operator> <name>size</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>reportError</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>report_undo_overflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Recheck if the required location was already written */</comment>
	<if_stmt><if>if <condition>(<expr><name>location</name> <operator>+</operator> <name>size</name> <operator>&lt;=</operator>
		<call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writtenLocation</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>undo_circular_buffer_size</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>waitForUndoLocation</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * No more chances to succeed without waiting.
		 */</comment>
		<expr_stmt><expr><call><name>pg_atomic_fetch_sub_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>advanceReservedLocation</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>reserved_undo_size</name> <operator>-=</operator> <name>size</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>reportError</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>report_undo_overflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>location</name> <operator>+</operator> <name>size</name> <operator>&lt;=</operator>
		<call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writeInProgressLocation</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>undo_circular_buffer_size</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Current in-progress undo write should cover our required location.
		 * It should be enough to just wait for current in-progress write to
		 * be finished.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>undoWriteLock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>undoWriteLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minUndoLocationsMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>location</name> <operator>+</operator> <name>size</name> <operator>&lt;=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writtenLocation</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>undo_circular_buffer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minUndoLocationsMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>write_undo</name><argument_list>(<argument><expr><name>location</name> <operator>+</operator> <name>size</name> <operator>-</operator> <name>undo_circular_buffer_size</name></expr></argument>, <argument><expr><name>minProcReservedLocation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>location</name> <operator>+</operator> <name>size</name> <operator>&lt;=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writtenLocation</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>undo_circular_buffer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>fsync_undo_range</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>fromLoc</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name></type> <name>toLoc</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>wait_event_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>minProcReservedLocation</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>check_reserved_undo_location</name><argument_list>(<argument><expr><name>toLoc</name> <operator>+</operator> <name>undo_circular_buffer_size</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>minProcReservedLocation</name></expr></argument>,
										<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>toLoc</name> <operator>&lt;=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writeInProgressLocation</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Current in-progress undo write should cover our required location.
		 * It should be enough to just wait for current in-progress write to
		 * be finished.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>undoWriteLock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>undoWriteLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minUndoLocationsMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>toLoc</name> <operator>&lt;=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writtenLocation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minUndoLocationsMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_undo</name><argument_list>(<argument><expr><name>toLoc</name></expr></argument>, <argument><expr><name>minProcReservedLocation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>o_buffers_sync</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffersDesc</name></expr></argument>, <argument><expr><name>fromLoc</name></expr></argument>, <argument><expr><name>toLoc</name></expr></argument>, <argument><expr><name>wait_event_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Pointer</name></type>
<name>get_undo_record</name><parameter_list>(<parameter><decl><type><name>UndoReserveType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name> <modifier>*</modifier></type><name>undoLocation</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>size</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>type</name> <operator>==</operator> <name>UndoReserveTxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_my_reserved_location</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>UndoLocation</name></type> <name>location</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>reserved_undo_size</name> <operator>&gt;=</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>lastUsedLocation</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>reserved_undo_size</name> <operator>-=</operator> <name>size</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We might hit the boundary of circular buffer.  If so then just
		 * retry. Thankfully we've reserved twice more space than required.
		 *
		 * This situation shouldn't happen twice, since we've reserved undo
		 * location.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>location</name> <operator>+</operator> <name>size</name><operator>)</operator> <operator>%</operator> <name>undo_circular_buffer_size</name> <operator>&gt;</operator>
			<name>location</name> <operator>%</operator> <name>undo_circular_buffer_size</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>undoLocation</name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
			<return>return <expr><call><name>GET_UNDO_REC</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>Pointer</name></type>
<name>get_undo_record_unreserved</name><parameter_list>(<parameter><decl><type><name>UndoReserveType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name> <modifier>*</modifier></type><name>undoLocation</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>size</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>reserved_undo_size</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>reserve_undo_size</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>get_undo_record</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>undoLocation</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>release_undo_size</name><parameter_list>(<parameter><decl><type><name>UndoReserveType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ODBProcData</name> <modifier>*</modifier></type><name>curProcData</name> <init>= <expr><call><name>GET_CUR_PROCDATA</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>type</name> <operator>==</operator> <name>UndoReserveTxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>reserved_undo_size</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_atomic_fetch_sub_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>advanceReservedLocation</name></name></expr></argument>, <argument><expr><name>reserved_undo_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>reserved_undo_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>reservedUndoLocation</name></name></expr></argument>, <argument><expr><name>InvalidUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Size</name></type>
<name>get_reserved_undo_size</name><parameter_list>(<parameter><decl><type><name>UndoReserveType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>type</name> <operator>==</operator> <name>UndoReserveTxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>reserved_undo_size</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>add_new_undo_stack_item</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoStackItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>(</operator><name>UndoStackItem</name> <operator>*</operator><operator>)</operator> <call><name>GET_UNDO_REC</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoStackSharedLocations</name> <modifier>*</modifier></type><name>sharedLocations</name> <init>= <expr><call><name>GET_CUR_UNDO_STACK_LOCATIONS</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoItemTypeDescr</name> <modifier>*</modifier></type><name>descr</name> <init>= <expr><call><name>item_type_get_descr</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sharedLocations</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sharedLocations</name><operator>-&gt;</operator><name>location</name></name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>descr</name><operator>-&gt;</operator><name>callOnCommit</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OnCommitUndoStackItem</name> <modifier>*</modifier></type><name>fItem</name> <init>= <expr><operator>(</operator><name>OnCommitUndoStackItem</name> <operator>*</operator><operator>)</operator> <name>item</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>fItem</name><operator>-&gt;</operator><name>onCommitLocation</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sharedLocations</name><operator>-&gt;</operator><name>onCommitLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sharedLocations</name><operator>-&gt;</operator><name>onCommitLocation</name></name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>UndoLocation</name></type>
<name>get_subxact_undo_location</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoStackSharedLocations</name> <modifier>*</modifier></type><name>sharedLocations</name> <init>= <expr><call><name>GET_CUR_UNDO_STACK_LOCATIONS</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sharedLocations</name><operator>-&gt;</operator><name>subxactLocation</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>read_shared_undo_locations</name><parameter_list>(<parameter><decl><type><name>UndoStackLocations</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>UndoStackSharedLocations</name> <modifier>*</modifier></type><name>from</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>from</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>branchLocation</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>from</name><operator>-&gt;</operator><name>branchLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>subxactLocation</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>from</name><operator>-&gt;</operator><name>subxactLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>onCommitLocation</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>from</name><operator>-&gt;</operator><name>onCommitLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>write_shared_undo_locations</name><parameter_list>(<parameter><decl><type><name>UndoStackSharedLocations</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>UndoStackLocations</name> <modifier>*</modifier></type><name>from</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>location</name></name></expr></argument>, <argument><expr><name><name>from</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>branchLocation</name></name></expr></argument>, <argument><expr><name><name>from</name><operator>-&gt;</operator><name>branchLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>subxactLocation</name></name></expr></argument>, <argument><expr><name><name>from</name><operator>-&gt;</operator><name>subxactLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>onCommitLocation</name></name></expr></argument>, <argument><expr><name><name>from</name><operator>-&gt;</operator><name>onCommitLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>UndoStackLocations</name></type>
<name>get_cur_undo_locations</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoStackLocations</name></type> <name>location</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoStackSharedLocations</name> <modifier>*</modifier></type><name>sharedLocations</name> <init>= <expr><call><name>GET_CUR_UNDO_STACK_LOCATIONS</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>read_shared_undo_locations</name><argument_list>(<argument><expr><operator>&amp;</operator><name>location</name></expr></argument>, <argument><expr><name>sharedLocations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>location</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>set_cur_undo_locations</name><parameter_list>(<parameter><decl><type><name>UndoStackLocations</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoStackSharedLocations</name> <modifier>*</modifier></type><name>sharedLocations</name> <init>= <expr><call><name>GET_CUR_UNDO_STACK_LOCATIONS</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>write_shared_undo_locations</name><argument_list>(<argument><expr><name>sharedLocations</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>reset_cur_undo_locations</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoStackLocations</name></type> <name>location</name> <init>= <expr><block>{<expr><name>InvalidUndoLocation</name></expr>, <expr><name>InvalidUndoLocation</name></expr>, <expr><name>InvalidUndoLocation</name></expr>, <expr><name>InvalidUndoLocation</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>set_cur_undo_locations</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>orioledb_reset_xmin_hook</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ODBProcData</name> <modifier>*</modifier></type><name>curProcData</name> <init>= <expr><call><name>GET_CUR_PROCDATA</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RetainUndoLocationPHNode</name> <modifier>*</modifier></type><name>location</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pairingheap_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retainUndoLocHeap</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>snapshotRetainUndoLocation</name></name></expr></argument>, <argument><expr><name>InvalidUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><name>InvalidOXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>pairingheap_container</name><argument_list>(<argument><expr><name>RetainUndoLocationPHNode</name></expr></argument>, <argument><expr><name>ph_node</name></expr></argument>,
										 <argument><expr><call><name>pairingheap_first</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retainUndoLocHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>location</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>&gt;</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>snapshotRetainUndoLocation</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>snapshotRetainUndoLocation</name></name></expr></argument>, <argument><expr><name><name>location</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><name><name>location</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>undo_xact_callback</name><parameter_list>(<parameter><decl><type><name>XactEvent</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name> <init>= <expr><call><name>get_current_oxid_if_any</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ODBProcData</name> <modifier>*</modifier></type><name>curProcData</name> <init>= <expr><call><name>GET_CUR_PROCDATA</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Cleanup EXPLAY ANALYZE counters pointer to handle case when execution
	 * of node was interrupted by exception.
	 */</comment>
	<expr_stmt><expr><name>ea_counters</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OXidIsValid</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>event</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>XACT_EVENT_COMMIT</name></expr>:</case>
			<case>case <expr><name>XACT_EVENT_ABORT</name></expr>:</case>
				<expr_stmt><expr><call><name>reset_cur_undo_locations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>orioledb_reset_xmin_hook</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>oxid_needs_wal_flush</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>event</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>XACT_EVENT_PRE_COMMIT</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>wal_joint_commit</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>XACT_EVENT_COMMIT</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>wal_commit</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>current_oxid_precommit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>csn</name> <operator>=</operator> <call><name>GetCurrentCSN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>csn</name> <operator>==</operator> <name>COMMITSEQNO_INPROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>csn</name> <operator>=</operator> <call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextCommitSeqNo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>current_oxid_commit</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>on_commit_undo_stack</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>wal_after_commit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>reset_cur_undo_locations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>oxid_needs_wal_flush</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>XACT_EVENT_ABORT</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>wal_rollback</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>apply_undo_stack</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>reset_cur_undo_locations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>current_oxid_abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>oxid_needs_wal_flush</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Remove registered snapshot one-by-one, so that we can evade
				 * double removing in undo_snapshot_deregister_hook().
				 */</comment>
				<while>while <condition>(<expr><operator>!</operator><call><name>pairingheap_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retainUndoLocHeap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pairingheap_remove_first</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retainUndoLocHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

				<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>snapshotRetainUndoLocation</name></name></expr></argument>, <argument><expr><name>InvalidUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>event</name> <operator>==</operator> <name>XACT_EVENT_COMMIT</name> <operator>||</operator> <name>event</name> <operator>==</operator> <name>XACT_EVENT_ABORT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>release_undo_size</name><argument_list>(<argument><expr><name>UndoReserveTxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>OPagePoolTypesCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OPagePool</name>  <modifier>*</modifier></type><name>pool</name> <init>= <expr><call><name>get_ppool</name><argument_list>(<argument><expr><operator>(</operator><name>OPagePoolType</name><operator>)</operator> <name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ppool_release_reserved</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>PPOOL_RESERVE_MASK_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>free_retained_undo_location</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>add_subxact_undo_item</name><parameter_list>(<parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SubXactUndoStackItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoStackSharedLocations</name> <modifier>*</modifier></type><name>sharedLocations</name> <init>= <expr><call><name>GET_CUR_UNDO_STACK_LOCATIONS</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>location</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SubXactUndoStackItem</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>SubXactUndoStackItem</name> <operator>*</operator><operator>)</operator> <call><name>get_undo_record_unreserved</name><argument_list>(<argument><expr><name>UndoReserveTxn</name></expr></argument>,
															   <argument><expr><operator>&amp;</operator><name>location</name></expr></argument>,
															   <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>prevSubLocation</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sharedLocations</name><operator>-&gt;</operator><name>subxactLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>parentSubid</name></name> <operator>=</operator> <name>parentSubid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>SubXactUndoItemType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>indexType</name></name> <operator>=</operator> <name>oIndexPrimary</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>itemSize</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_new_undo_stack_item</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>release_undo_size</name><argument_list>(<argument><expr><name>UndoReserveTxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sharedLocations</name><operator>-&gt;</operator><name>subxactLocation</name></name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>search_for_undo_sub_location</name><parameter_list>(<parameter><decl><type><name>UndoStackKind</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>,
							 <parameter><decl><type><name>UndoItemBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>,
							 <parameter><decl><type><name>UndoLocation</name> <modifier>*</modifier></type><name>toLoc</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name> <modifier>*</modifier></type><name>toSubLoc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SubXactUndoStackItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>UndoStackFull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"subxact goes out of order"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>kind</name> <operator>==</operator> <name>UndoStackTail</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>toLoc</name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>toSubLoc</name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>SubXactUndoStackItem</name> <operator>*</operator><operator>)</operator> <call><name>undo_item_buf_read_item</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>parentSubid</name></name> <operator>!=</operator> <name>parentSubid</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>UndoStackFull</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"subxact goes out of order"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>kind</name> <operator>==</operator> <name>UndoStackTail</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>toLoc</name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>toSubLoc</name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>kind</name> <operator>==</operator> <name>UndoStackHead</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>parentSubid</name></name> <operator>&gt;</operator> <name>parentSubid</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>location</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>prevSubLocation</name></name></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>toLoc</name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>toSubLoc</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>prevSubLocation</name></name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_subxact_undo_location</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>subxactLocation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ODBProcData</name> <modifier>*</modifier></type><name>curProcData</name> <init>= <expr><call><name>GET_CUR_PROCDATA</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoStackSharedLocations</name> <modifier>*</modifier></type><name>sharedLocations</name> <init>= <expr><call><name>GET_CUR_UNDO_STACK_LOCATIONS</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>undoStackLocationsFlushLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sharedLocations</name><operator>-&gt;</operator><name>subxactLocation</name></name></expr></argument>, <argument><expr><name>subxactLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>undoStackLocationsFlushLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rollback_to_savepoint</name><parameter_list>(<parameter><decl><type><name>UndoStackKind</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>changeCountsValid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoStackLocations</name></type> <name>toLoc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>location</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoStackSharedLocations</name> <modifier>*</modifier></type><name>sharedLocations</name> <init>= <expr><call><name>GET_CUR_UNDO_STACK_LOCATIONS</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoItemBuf</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>applyResult</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_undo_item_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sharedLocations</name><operator>-&gt;</operator><name>subxactLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>applyResult</name> <operator>=</operator> <call><name>search_for_undo_sub_location</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>parentSubid</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>toLoc</name><operator>.</operator><name>location</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>toLoc</name><operator>.</operator><name>subxactLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_undo_item_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>applyResult</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oxid</name> <operator>=</operator> <call><name>get_current_oxid_if_any</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OXidIsValid</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>walk_undo_stack</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>toLoc</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>changeCountsValid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>update_subxact_undo_location</name><argument_list>(<argument><expr><name><name>toLoc</name><operator>.</operator><name>subxactLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_subxact_undo_location_on_commit</name><parameter_list>(<parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoStackLocations</name></type> <name>toLoc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>location</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoStackSharedLocations</name> <modifier>*</modifier></type><name>sharedLocations</name> <init>= <expr><call><name>GET_CUR_UNDO_STACK_LOCATIONS</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoItemBuf</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_undo_item_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sharedLocations</name><operator>-&gt;</operator><name>subxactLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>search_for_undo_sub_location</name><argument_list>(<argument><expr><name>UndoStackFull</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>parentSubid</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>toLoc</name><operator>.</operator><name>location</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>toLoc</name><operator>.</operator><name>subxactLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_undo_item_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>update_subxact_undo_location</name><argument_list>(<argument><expr><name><name>toLoc</name><operator>.</operator><name>subxactLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>undo_subxact_callback</name><parameter_list>(<parameter><decl><type><name>SubXactEvent</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl></parameter>,
					  <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Cleanup EXPLAY ANALYZE counters pointer to handle case when execution
	 * of node was interrupted by exception.
	 */</comment>
	<expr_stmt><expr><name>ea_counters</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>event</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SUBXACT_EVENT_START_SUB</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_current_oxid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>add_subxact_undo_item</name><argument_list>(<argument><expr><name>parentSubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>add_savepoint_wal_record</name><argument_list>(<argument><expr><name>parentSubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SUBXACT_EVENT_COMMIT_SUB</name></expr>:</case>
			<expr_stmt><expr><call><name>update_subxact_undo_location_on_commit</name><argument_list>(<argument><expr><name>parentSubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SUBXACT_EVENT_ABORT_SUB</name></expr>:</case>
			<expr_stmt><expr><call><name>rollback_to_savepoint</name><argument_list>(<argument><expr><name>UndoStackFull</name></expr></argument>, <argument><expr><name>parentSubid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>add_rollback_to_savepoint_wal_record</name><argument_list>(<argument><expr><name>parentSubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>have_current_undo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoStackLocations</name></type> <name>location</name> <init>= <expr><call><name>get_cur_undo_locations</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name><name>location</name><operator>.</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>report_undo_overflow</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SNAPSHOT_TOO_OLD</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to add an undo record: undo size is exceeded"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>orioledb_has_retained_undo</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>location</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_procs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oProcData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>transactionUndoRetainLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>start_autonomous_transaction</name><parameter_list>(<parameter><decl><type><name>OAutonomousTxState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>is_recovery_process</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>needs_wal_flush</name></name> <operator>=</operator> <name>oxid_needs_wal_flush</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>oxid</name></name> <operator>=</operator> <call><name>get_current_oxid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>has_retained_undo_location</name></name> <operator>=</operator> <call><name>have_retained_undo_location</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>local_wal_is_empty</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>flush_local_wal</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oxid_needs_wal_flush</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>reset_current_oxid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>abort_autonomous_transaction</name><parameter_list>(<parameter><decl><type><name>OAutonomousTxState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name> <init>= <expr><call><name>get_current_oxid_if_any</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OXidIsValid</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>wal_rollback</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>current_oxid_abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>apply_undo_stack</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>release_undo_size</name><argument_list>(<argument><expr><name>UndoReserveTxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>has_retained_undo_location</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free_retained_undo_location</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>oxid_needs_wal_flush</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>needs_wal_flush</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_current_oxid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>oxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>finish_autonomous_transaction</name><parameter_list>(<parameter><decl><type><name>OAutonomousTxState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name> <init>= <expr><call><name>get_current_oxid_if_any</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OXidIsValid</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>wal_commit</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>current_oxid_precommit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>csn</name> <operator>=</operator> <call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextCommitSeqNo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>current_oxid_commit</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>on_commit_undo_stack</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>wal_after_commit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>release_undo_size</name><argument_list>(<argument><expr><name>UndoReserveTxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>has_retained_undo_location</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free_retained_undo_location</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>oxid_needs_wal_flush</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>needs_wal_flush</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_current_oxid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>oxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>undo_read</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>writtenLocation</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>writtenLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writtenLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>location</name> <operator>+</operator> <name>size</name> <operator>&gt;</operator> <name>writtenLocation</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>UndoLocation</name></type> <name>maxLoc</name></decl>,
					<decl><type ref="prev"/><name>minLoc</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>maxLoc</name> <operator>=</operator> <name>location</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>minLoc</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>writtenLocation</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <operator>(</operator><name>minLoc</name> <operator>-</operator> <name>location</name><operator>)</operator></expr></argument>, <argument><expr><call><name>GET_UNDO_REC</name><argument_list>(<argument><expr><name>minLoc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>maxLoc</name> <operator>-</operator> <name>minLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>writtenLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writtenLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>writtenLocation</name> <operator>&gt;</operator> <name>location</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>read_undo_range</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>location</name> <operator>+</operator> <name>size</name></expr></argument>, <argument><expr><name>writtenLocation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>read_undo_range</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><name>location</name> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write buffer to the given undo location.
 */</comment>
<function><type><name>void</name></type>
<name>undo_write</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>writeInProgressLocation</name></decl>,
				<decl><type ref="prev"/><name>prevReservedUndoLocation</name></decl>,
				<decl><type ref="prev"/><name>memoryUndoLocation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>undoLocationIsReserved</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ODBProcData</name> <modifier>*</modifier></type><name>curProcData</name> <init>= <expr><call><name>GET_CUR_PROCDATA</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>writeInProgressLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writeInProgressLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>writeInProgressLocation</name> <operator>&gt;=</operator> <name>location</name> <operator>+</operator> <name>size</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Nothing we can write to the memory */</comment>
			<expr_stmt><expr><name>memoryUndoLocation</name> <operator>=</operator> <name>location</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Reserve the location we're going to write into */</comment>
		<expr_stmt><expr><name>memoryUndoLocation</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>location</name></expr></argument>, <argument><expr><name>writeInProgressLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prevReservedUndoLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>reservedUndoLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>prevReservedUndoLocation</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>prevReservedUndoLocation</name> <operator>&gt;</operator> <name>memoryUndoLocation</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>reservedUndoLocation</name></name></expr></argument>, <argument><expr><name>memoryUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>undoLocationIsReserved</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Recheck is writeInProgressLocation was advanced concurrently */</comment>
		<expr_stmt><expr><name>writeInProgressLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writeInProgressLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>writeInProgressLocation</name> <operator>&gt;</operator> <name>memoryUndoLocation</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>undoLocationIsReserved</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>reservedUndoLocation</name></name></expr></argument>, <argument><expr><name>prevReservedUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>undoLocationIsReserved</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * At this point we should either detect concurrent writing of undo
		 * log. Or concurrent writing of undo log should wait for our reserved
		 * location. So, it should be safe to write to the memory.
		 */</comment>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>GET_UNDO_REC</name><argument_list>(<argument><expr><name>memoryUndoLocation</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>buf</name> <operator>+</operator> <operator>(</operator><name>memoryUndoLocation</name> <operator>-</operator> <name>location</name><operator>)</operator></expr></argument>,
			   <argument><expr><name>size</name> <operator>-</operator> <operator>(</operator><name>memoryUndoLocation</name> <operator>-</operator> <name>location</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>undoLocationIsReserved</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>reservedUndoLocation</name></name></expr></argument>, <argument><expr><name>prevReservedUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>undoLocationIsReserved</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>memoryUndoLocation</name> <operator>==</operator> <name>location</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Everything is written to the in-memory buffer */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Wait for in-progress write if needed */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writtenLocation</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>memoryUndoLocation</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>undoWriteLock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>undoWriteLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writtenLocation</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>memoryUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Finally perform writing to the file */</comment>
	<expr_stmt><expr><call><name>write_undo_range</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><name>memoryUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Comparison function for retainUndoLocHeap.  Smallest undo location at the
 * top.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>undoLocCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pairingheap_node</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>pairingheap_node</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>RetainUndoLocationPHNode</name> <modifier>*</modifier></type><name>aloc</name> <init>= <expr><call><name>pairingheap_const_container</name><argument_list>(<argument><expr><name>RetainUndoLocationPHNode</name></expr></argument>, <argument><expr><name>ph_node</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>RetainUndoLocationPHNode</name> <modifier>*</modifier></type><name>bloc</name> <init>= <expr><call><name>pairingheap_const_container</name><argument_list>(<argument><expr><name>RetainUndoLocationPHNode</name></expr></argument>, <argument><expr><name>ph_node</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aloc</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>&lt;</operator> <name><name>bloc</name><operator>-&gt;</operator><name>undoLocation</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>aloc</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>&gt;</operator> <name><name>bloc</name><operator>-&gt;</operator><name>undoLocation</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>undo_snapshot_register_hook</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pairingheap_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retainUndoLocHeap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>snapshot</name><operator>-&gt;</operator><name>undoLocationPhNode</name><operator>.</operator><name>ph_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>undo_snapshot_deregister_hook</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Skip if it was already removed during transaction abort.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>undoLocationPhNode</name><operator>.</operator><name>ph_node</name><operator>.</operator><name>prev_or_parent</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<operator>&amp;</operator><name><name>snapshot</name><operator>-&gt;</operator><name>undoLocationPhNode</name><operator>.</operator><name>ph_node</name></name> <operator>!=</operator> <name><name>retainUndoLocHeap</name><operator>.</operator><name>ph_root</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pairingheap_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retainUndoLocHeap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>snapshot</name><operator>-&gt;</operator><name>undoLocationPhNode</name><operator>.</operator><name>ph_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>orioledb_snapshot_hook</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>lastUsedLocation</name></decl>,
				<decl><type ref="prev"/><name>lastUsedUndoLocationWhenUpdatedMinLocation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OXid</name></type>		<name>curXmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ODBProcData</name> <modifier>*</modifier></type><name>curProcData</name> <init>= <expr><call><name>GET_CUR_PROCDATA</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>lastUsedLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>lastUsedLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lastUsedUndoLocationWhenUpdatedMinLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>lastUsedUndoLocationWhenUpdatedMinLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>lastUsedLocation</name> <operator>-</operator> <name>lastUsedUndoLocationWhenUpdatedMinLocation</name> <operator>&gt;</operator> <name>undo_circular_buffer_size</name> <operator>/</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>update_min_undo_locations</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>undoLocationPhNode</name><operator>.</operator><name>undoLocation</name></name> <operator>=</operator> <call><name>set_my_retain_location</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>undoLocationPhNode</name><operator>.</operator><name>xmin</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>runXmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>curXmin</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OXidIsValid</name><argument_list>(<argument><expr><name>curXmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>undoLocationPhNode</name><operator>.</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Snapshot CSN could be newer than retained location, not older.  Enforce
	 * this with barrier.
	 */</comment>
	<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>snapshotcsn</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextCommitSeqNo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>o_stub_item_callback</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>UndoStackItem</name> <modifier>*</modifier></type><name>baseItem</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>abort</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>changeCountsValid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>abort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
</block_content>}</block></function>
</unit>
