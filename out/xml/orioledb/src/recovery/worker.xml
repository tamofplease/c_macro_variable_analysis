<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/recovery/worker.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * worker.c
 *		Recovery worker process implementation for orioledb engine.
 *
 * Copyright (c) 2021-2022, Oriole DB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/recovery/worker.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/modify.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/o_tables.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"recovery/recovery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"recovery/internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tableam/descr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tableam/operations.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tableam/tree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transam/oxid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tuple/slot.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgworker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shm_mq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinvaladt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timeout.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_READ_USLEEP_BASE</name></cpp:macro>		<cpp:value>(10)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_READ_USLEEP_MULTIPLER</name></cpp:macro>	<cpp:value>(2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_READ_USLEEP_MAX</name></cpp:macro>		<cpp:value>(1024 * QUEUE_READ_USLEEP_BASE)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>detached</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>CommitSeqNo</name></type> <name>my_ptr</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>recovery_queue_process</name><parameter_list>(<parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>queue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>Pointer</name></type> <name>recovery_queue_read</name><parameter_list>(<parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>queue</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>data_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>apply_tbl_modify_record</name><parameter_list>(<parameter><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>type</name></decl></parameter>,
									<parameter><decl><type><name>OTuple</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>,
									<parameter><decl><type><name>bool</name></type> <name>must_modify</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>apply_tbl_insert</name><parameter_list>(<parameter><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>,
							 <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>must_modify</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>apply_tbl_delete</name><parameter_list>(<parameter><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>key</name></decl></parameter>,
							 <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>must_modify</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>apply_tbl_update</name><parameter_list>(<parameter><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>,
							 <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>must_modify</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl>;</decl_stmt>
}</block></struct></type> <name>CallbackTupleCopy</name>;</typedef>

<comment type="block">/*
 * Callback examples which stores modified tuple as arg.
 */</comment>
<function><type><specifier>static</specifier> <name>OBTreeModifyCallbackAction</name></type>
<name>o_delete_copy_callback</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>,
					   <parameter><decl><type><name>OTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>OTuple</name> <modifier>*</modifier></type><name>newtup</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>,
					   <parameter><decl><type><name>OTupleXactInfo</name></type> <name>xactInfo</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>,
					   <parameter><decl><type><name>RowLockMode</name> <modifier>*</modifier></type><name>lock_mode</name></decl></parameter>, <parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CallbackTupleCopy</name> <modifier>*</modifier></type><name>copyArg</name> <init>= <expr><operator>(</operator><name>CallbackTupleCopy</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>descr</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>oIndexPrimary</name> <operator>||</operator> <name><name>descr</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>oIndexToast</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_OXID_EQ</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>o_tuple_get_version</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>o_tuple_get_version</name><argument_list>(<argument><expr><name><name>copyArg</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>OBTreeCallbackActionUndo</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>descr</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>oIndexPrimary</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>id</name> <init>= <expr><operator>(</operator><name>OIndexDescr</name> <operator>*</operator><operator>)</operator> <name><name>descr</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>sz</name> <init>= <expr><call><name>o_tuple_size</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>leafSpec</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>copyArg</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>copyArg</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>tup</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>copyArg</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>tup</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>copyArg</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <name>COMMITSEQNO_MAX_NORMAL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>copyArg</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <name>COMMITSEQNO_INPROGRESS</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>OBTreeCallbackActionDelete</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OBTreeModifyCallbackAction</name></type>
<name>o_update_copy_callback</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>,
					   <parameter><decl><type><name>OTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>OTuple</name> <modifier>*</modifier></type><name>newtup</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>,
					   <parameter><decl><type><name>OTupleXactInfo</name></type> <name>xactInfo</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>,
					   <parameter><decl><type><name>RowLockMode</name> <modifier>*</modifier></type><name>lock_mode</name></decl></parameter>, <parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CallbackTupleCopy</name> <modifier>*</modifier></type><name>copyArg</name> <init>= <expr><operator>(</operator><name>CallbackTupleCopy</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>descr</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>oIndexPrimary</name> <operator>||</operator> <name><name>descr</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>oIndexToast</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_OXID_EQ</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>o_tuple_get_version</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>o_tuple_get_version</name><argument_list>(<argument><expr><operator>*</operator><name>newtup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>OBTreeCallbackActionUndo</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>descr</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>oIndexPrimary</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>id</name> <init>= <expr><operator>(</operator><name>OIndexDescr</name> <operator>*</operator><operator>)</operator> <name><name>descr</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>sz</name> <init>= <expr><call><name>o_tuple_size</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>leafSpec</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>copyArg</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>copyArg</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>tup</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>copyArg</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>tup</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>copyArg</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <name>COMMITSEQNO_MAX_NORMAL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>copyArg</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <name>COMMITSEQNO_INPROGRESS</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>OBTreeCallbackActionUpdate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Registers a new recovery worker. Returns NULL typically if no background
 * workers slots available.
 */</comment>
<function><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type>
<name>recovery_worker_register</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>worker_name</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundWorker</name></type> <name>worker</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>worker_name</name></expr></argument>, <argument><expr><literal type="string">"orioledb recovery worker %d"</literal></expr></argument>, <argument><expr><name>worker_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Set up background worker parameters */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>worker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_flags</name></name> <operator>=</operator> <name>BGWORKER_SHMEM_ACCESS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_start_time</name></name> <operator>=</operator> <name>BgWorkerStart_PostmasterStart</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_restart_time</name></name> <operator>=</operator> <name>BGW_NEVER_RESTART</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_main_arg</name></name> <operator>=</operator> <name>worker_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>, <argument><expr><literal type="string">"orioledb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_function_name</name></name></expr></argument>, <argument><expr><literal type="string">"recovery_worker_main"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_name</name></name></expr></argument>, <argument><expr><name>worker_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_type</name></name></expr></argument>, <argument><expr><literal type="string">"orioledb recovery worker"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>MyProcPid</name> <operator>==</operator> <name>PostmasterPid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RegisterBackgroundWorker</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RegisterDynamicBackgroundWorker</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>handle</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>handle_sigterm</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>detached</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Recovery worker main function.
 */</comment>
<function><type><name>void</name></type>
<name>recovery_worker_main</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>main_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>recovery_worker_queue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>id</name> <init>= <expr><name>main_arg</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"orioledb recovery worker %d started."</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* enable timeout for relation lock */</comment>
		<expr_stmt><expr><call><name>RegisterTimeout</name><argument_list>(<argument><expr><name>DEADLOCK_TIMEOUT</name></expr></argument>, <argument><expr><name>CheckDeadLockAlert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* enable relation cache invalidation (remove old table descriptors) */</comment>
		<expr_stmt><expr><call><name>RelationCacheInitialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SharedInvalBackendInit</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>NormalProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>handle_sigterm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BackgroundWorkerUnblockSignals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>before_shmem_exit</name><argument_list>(<argument><expr><name>recovery_on_proc_exit</name></expr></argument>, <argument><expr><name>main_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recovery_init</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>shm_mq_set_receiver</name><argument_list>(<argument><expr><call><name>GET_WORKER_QUEUE</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>recovery_worker_queue</name> <operator>=</operator> <call><name>shm_mq_attach</name><argument_list>(<argument><expr><call><name>GET_WORKER_QUEUE</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>my_ptr</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>worker_ptrs</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>commitPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recovery_queue_process</name><argument_list>(<argument><expr><name>recovery_worker_queue</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>detached</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"orioledb recovery worker %d finished: unexpected detach from recovery messages queue."</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>shm_mq_detach</name><argument_list>(<argument><expr><name>recovery_worker_queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>recovery_worker_queue</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>recovery_finish</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockReleaseSession</name><argument_list>(<argument><expr><name>DEFAULT_LOCKMETHOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pg_atomic_fetch_add_u32</name><argument_list>(<argument><expr><name>worker_finish_count</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"orioledb recovery worker %d finished."</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>recovery_worker_queue</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* detach from queue if attached */</comment>
			<expr_stmt><expr><call><name>shm_mq_detach</name><argument_list>(<argument><expr><name>recovery_worker_queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Don't call recovery_finish().  We haven't receive the finish
		 * message from main recovery process.  So, we aren't promoted.
		 * Information about running transactions might be needed by
		 * checkpoint.
		 */</comment>
		<expr_stmt><expr><call><name>LockReleaseSession</name><argument_list>(<argument><expr><name>DEFAULT_LOCKMETHOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>update_worker_ptr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><name>worker_ptrs_changes</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>worker_ptrs</name><index>[<expr><name>worker_id</name></expr>]</index></name><operator>.</operator><name>commitPtr</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><name>worker_ptrs_changes</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>my_ptr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reads messages from recovery queue and applies modify records to BTrees.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>recovery_queue_process</name><parameter_list>(<parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>queue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecoveryMsgOXidPtr</name> <modifier>*</modifier></type><name>oxid_csn_record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RecoveryMsgPtr</name> <modifier>*</modifier></type><name>csn_record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RecoveryMsgHeader</name> <modifier>*</modifier></type><name>recovery_header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>indexDescr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexType</name></type>	<name>ix_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ORelOids</name></type>	<name>oids</name> <init>= <expr><block>{<expr><name>InvalidOid</name></expr>, <expr><name>InvalidOid</name></expr>, <expr><name>InvalidOid</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tuple_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>data_size</name></decl>,
				<decl><type ref="prev"/><name>data_pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>finished</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>!</operator><name>finished</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>recovery_queue_read</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data_size</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>detached</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>data_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>data_pos</name> <operator>&lt;</operator> <name>data_size</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>recovery_header</name> <operator>=</operator> <operator>(</operator><name>RecoveryMsgHeader</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>data</name> <operator>+</operator> <name>data_pos</name><operator>)</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>recovery_header</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>RECOVERY_MODIFY</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>data_pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RecoveryMsgHeader</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>recovery_header</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>RECOVERY_MODIFY_OXID</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oxid</name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name>data_pos</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OXid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>data_pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OXid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>recovery_switch_to_oxid</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>recovery_header</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>RECOVERY_MODIFY_OIDS</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oids</name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name>data_pos</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ORelOids</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>data_pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ORelOids</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
					<expr_stmt><expr><name>ix_type</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>data</name> <operator>+</operator> <name>data_pos</name><operator>)</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>data_pos</name><operator>++</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>descr</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>table_descr_dec_refcnt</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>descr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>ix_type</name> <operator>==</operator> <name>oIndexInvalid</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>o_fetch_table_descr</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>table_descr_inc_refcnt</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>indexDescr</name> <operator>=</operator> <call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>indexDescr</name> <operator>=</operator> <call><name>o_fetch_index_descr</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name>ix_type</name></expr></argument>,
														 <argument><expr><name>false</name></expr></argument>,
														 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuple_len</name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name>data_pos</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data_pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>.</operator><name>formatFlags</name></name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name>data_pos</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data_pos</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>data_pos</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>data_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>indexDescr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ORelOidsIsValid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>data</name> <operator>+</operator> <name>data_pos</name></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>apply_modify_record</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>indexDescr</name></expr></argument>,
										<argument><expr><operator>(</operator><name><name>recovery_header</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>RECOVERY_MODIFY</name><operator>)</operator></expr></argument>,
										<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>data_pos</name> <operator>+=</operator> <name>tuple_len</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>recovery_header</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>RECOVERY_COMMIT</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>oxid_csn_record</name> <operator>=</operator> <operator>(</operator><name>RecoveryMsgOXidPtr</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>data</name> <operator>+</operator> <name>data_pos</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>recovery_switch_to_oxid</name><argument_list>(<argument><expr><name><name>oxid_csn_record</name><operator>-&gt;</operator><name>oxid</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>recovery_finish_current_oxid</name><argument_list>(<argument><expr><name>COMMITSEQNO_MAX_NORMAL</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
											 <argument><expr><name><name>oxid_csn_record</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,
											 <argument><expr><name>id</name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>update_worker_ptr</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name><name>oxid_csn_record</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data_pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RecoveryMsgOXidPtr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>recovery_header</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>RECOVERY_ROLLBACK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>oxid_csn_record</name> <operator>=</operator> <operator>(</operator><name>RecoveryMsgOXidPtr</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>data</name> <operator>+</operator> <name>data_pos</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>recovery_switch_to_oxid</name><argument_list>(<argument><expr><name><name>oxid_csn_record</name><operator>-&gt;</operator><name>oxid</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>recovery_finish_current_oxid</name><argument_list>(<argument><expr><name>COMMITSEQNO_ABORTED</name></expr></argument>,
											 <argument><expr><name><name>oxid_csn_record</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,
											 <argument><expr><name>id</name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>update_worker_ptr</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name><name>oxid_csn_record</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data_pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RecoveryMsgOXidPtr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>recovery_header</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>RECOVERY_SYNCHRONIZE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>csn_record</name> <operator>=</operator> <operator>(</operator><name>RecoveryMsgPtr</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>data</name> <operator>+</operator> <name>data_pos</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>update_worker_ptr</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name><name>csn_record</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data_pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RecoveryMsgPtr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>recovery_header</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>RECOVERY_FINISHED</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>finished</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>recovery_header</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>RECOVERY_TOAST_CONSISTENT</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>toast_consistent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>data_pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RecoveryMsgEmpty</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>recovery_header</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>RECOVERY_SAVEPOINT</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RecoveryMsgSavepoint</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>msg</name> <operator>=</operator> <operator>(</operator><name>RecoveryMsgSavepoint</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>data</name> <operator>+</operator> <name>data_pos</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>recovery_switch_to_oxid</name><argument_list>(<argument><expr><name><name>msg</name><operator>-&gt;</operator><name>oxid</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>recovery_savepoint</name><argument_list>(<argument><expr><name><name>msg</name><operator>-&gt;</operator><name>parentSubId</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data_pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RecoveryMsgSavepoint</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>recovery_header</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>RECOVERY_ROLLBACK_TO_SAVEPOINT</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RecoveryMsgRollbackToSavepoint</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>msg</name> <operator>=</operator> <operator>(</operator><name>RecoveryMsgRollbackToSavepoint</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>data</name> <operator>+</operator> <name>data_pos</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>recovery_switch_to_oxid</name><argument_list>(<argument><expr><name><name>msg</name><operator>-&gt;</operator><name>oxid</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>recovery_rollback_to_savepoint</name><argument_list>(<argument><expr><name><name>msg</name><operator>-&gt;</operator><name>parentSubId</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>update_worker_ptr</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name><name>msg</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data_pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RecoveryMsgRollbackToSavepoint</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>data_pos</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>data_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>update_recovery_undo_loc_flush</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name>descr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>table_descr_dec_refcnt</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Apply the modify WAL or XIP record.
 */</comment>
<function><type><name>void</name></type>
<name>apply_modify_record</name><parameter_list>(<parameter><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>type</name></decl></parameter>,
					<parameter><decl><type><name>OTuple</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>must_modify</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>success</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>oxid</name> <operator>=</operator> <call><name>get_current_oxid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>csn</name> <operator>=</operator> <name>COMMITSEQNO_INPROGRESS</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Don't apply changes to secondary indices before TOAST is consisntent.
	 * Otherwise, values of secondary indices on TOASTed fields can be
	 * invalid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>descr</name> <operator>&amp;&amp;</operator> <name>toast_consistent</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Modify table */</comment>
		<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>apply_tbl_modify_record</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>must_modify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>apply_btree_modify_record</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* For now only XIP records must be always applied */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name> <operator>&amp;&amp;</operator> <name>must_modify</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Wrong recovery result for modify type %d"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reads a message from the queue.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>Pointer</name></type>
<name>recovery_queue_read</name><parameter_list>(<parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>queue</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>data_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>shm_mq_result</name></type> <name>read_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>prev_rec_ptr</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>,
				<decl><type ref="prev"/><name>cur_rec_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>usleep_time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>usleep_time</name> <operator>=</operator> <name>QUEUE_READ_USLEEP_BASE</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>read_result</name> <operator>=</operator> <call><name>shm_mq_receive</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>data_size</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>read_result</name> <operator>==</operator> <name>SHM_MQ_SUCCESS</name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>read_result</name> <operator>==</operator> <name>SHM_MQ_DETACHED</name> <operator>||</operator> <name>detached</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>detached</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>data</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * else the queue is empty
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>read_result</name> <operator>==</operator> <name>SHM_MQ_WOULD_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we can try to update our ptr if queue is empty */</comment>
		<expr_stmt><expr><name>cur_rec_ptr</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><name>recovery_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cur_rec_ptr</name> <operator>&gt;</operator> <name>my_ptr</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>prev_rec_ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>update_worker_ptr</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>prev_rec_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * if cur_skiped is a new value than we need to recheck is queue
			 * still empty before apply it
			 */</comment>
			<expr_stmt><expr><name>prev_rec_ptr</name> <operator>=</operator> <ternary><condition><expr><name>cur_rec_ptr</name> <operator>!=</operator> <name>prev_rec_ptr</name></expr> ?</condition><then> <expr><name>cur_rec_ptr</name></expr> </then><else>: <expr><name>InvalidXLogRecPtr</name></expr></else></ternary></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>prev_rec_ptr</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>usleep_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>update_proc_retain_undo_location</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>update_recovery_undo_loc_flush</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PostmasterIsAlive</name><argument_list>()</argument_list></call> <operator>||</operator> <name>detached</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>detached</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>data</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>usleep_time</name> <operator>!=</operator> <name>QUEUE_READ_USLEEP_MAX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>usleep_time</name> <operator>*=</operator> <name>QUEUE_READ_USLEEP_MULTIPLER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Applies table modify records. We skip unique indices because recovery master
 * distributes it separately.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>apply_tbl_modify_record</name><parameter_list>(<parameter><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>type</name></decl></parameter>,
						<parameter><decl><type><name>OTuple</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>must_modify</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RECOVERY_INSERT</name></expr>:</case>
			<return>return <expr><call><name>apply_tbl_insert</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>must_modify</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>RECOVERY_DELETE</name></expr>:</case>
			<return>return <expr><call><name>apply_tbl_delete</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>must_modify</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>RECOVERY_UPDATE</name></expr>:</case>
			<return>return <expr><call><name>apply_tbl_update</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>must_modify</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Wrong primary index modify record type %d"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>apply_tbl_insert</name><parameter_list>(<parameter><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>,
				 <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>must_modify</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OBTreeModifyResult</name></type> <name>modify_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeKeyBound</name></type> <name>keyBound</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>stuple</name></decl>,
				<decl><type ref="prev"/><name>cur_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>true</name></expr></init></decl>,
				<decl><type ref="prev"/><name>primary</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>descr</name><operator>-&gt;</operator><name>newTuple</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeModifyCallbackInfo</name></type> <name>callbackInfo</name> <init>= <expr><name>nullCallbackInfo</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>stuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tts_orioledb_store_tuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>,
							 <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>PrimaryIndexNumber</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>primaryIsCtid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>btree_ctid_update_if_needed</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>desc</name></expr></argument>,
									<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>descr</name><operator>-&gt;</operator><name>nIndices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>primary</name> <operator>=</operator> <name>i</name> <operator>==</operator> <name>PrimaryIndexNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>id</name> <operator>=</operator> <name><name>descr</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>primary</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>stuple</name> <operator>=</operator> <call><name>tts_orioledb_make_secondary_tuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>descr</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>primary</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>o_is_index_predicate_satisfied</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>id</name><operator>-&gt;</operator><name>econtext</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>cur_tuple</name> <operator>=</operator> <ternary><condition><expr><name>primary</name></expr> ?</condition><then> <expr><name>tuple</name></expr> </then><else>: <expr><name>stuple</name></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>primary</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>callbackInfo</name><operator>.</operator><name>modifyCallback</name></name> <operator>=</operator> <name>recovery_insert_primary_callback</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>callbackInfo</name><operator>.</operator><name>modifyDeletedCallback</name></name> <operator>=</operator> <name>recovery_insert_primary_callback</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>callbackInfo</name><operator>.</operator><name>modifyCallback</name></name> <operator>=</operator> <name>recovery_insert_overwrite_callback</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>callbackInfo</name><operator>.</operator><name>modifyDeletedCallback</name></name> <operator>=</operator> <name>recovery_insert_overwrite_callback</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>tts_orioledb_fill_key_bound</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keyBound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>modify_result</name> <operator>=</operator> <call><name>o_btree_modify</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>BTreeOperationInsert</name></expr></argument>,
									   <argument><expr><name>cur_tuple</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>,
									   <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>keyBound</name></expr></argument>, <argument><expr><name>BTreeKeyBound</name></expr></argument>,
									   <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>RowLockUpdate</name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>callbackInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>modify_result</name> <operator>==</operator> <name>OBTreeModifyResultInserted</name> <operator>||</operator> <name>modify_result</name> <operator>==</operator> <name>OBTreeModifyResultUpdated</name><operator>)</operator>
			<operator>&amp;&amp;</operator> <name>must_modify</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>primary</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>stuple</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>stuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>stuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>stuple</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>apply_tbl_delete</name><parameter_list>(<parameter><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>key</name></decl></parameter>,
				 <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>must_modify</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OBTreeModifyResult</name></type> <name>modify_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeKeyBound</name></type> <name>keyBound</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CallbackTupleCopy</name></type> <name>tupCopy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>primary</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>descr</name><operator>-&gt;</operator><name>newTuple</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>nullTup</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>nullTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>descr</name><operator>-&gt;</operator><name>nIndices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>primary</name> <operator>=</operator> <name>i</name> <operator>==</operator> <name>PrimaryIndexNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>id</name> <operator>=</operator> <name><name>descr</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>primary</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreeModifyCallbackInfo</name></type> <name>callbackInfo</name> <init>= <expr><block>{
				<expr><operator>.</operator><name>waitCallback</name> <operator>=</operator> <name>NULL</name></expr>,
				<expr><operator>.</operator><name>modifyCallback</name> <operator>=</operator> <name>o_delete_copy_callback</name></expr>,
				<expr><operator>.</operator><name>modifyDeletedCallback</name> <operator>=</operator> <name>NULL</name></expr>,
				<expr><operator>.</operator><name>needsUndoForSelfCreated</name> <operator>=</operator> <name>false</name></expr>,
				<expr><operator>.</operator><name>arg</name> <operator>=</operator> <operator>&amp;</operator><name>tupCopy</name></expr>
			}</block></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>o_fill_key_bound</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keyBound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name><name>tupCopy</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tupCopy</name><operator>.</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>modify_result</name> <operator>=</operator> <call><name>o_btree_modify</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>BTreeOperationDelete</name></expr></argument>,
										   <argument><expr><name>nullTup</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>keyBound</name></expr></argument>, <argument><expr><name>BTreeKeyBound</name></expr></argument>,
										   <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>RowLockUpdate</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>callbackInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>modify_result</name> <operator>!=</operator> <name>OBTreeModifyResultDeleted</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>descr</name><operator>-&gt;</operator><name>nIndices</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>tupCopy</name><operator>.</operator><name>tuple</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>tts_orioledb_store_tuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>tupCopy</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>descr</name></expr></argument>,
									 <argument><expr><name><name>tupCopy</name><operator>.</operator><name>csn</name></name></expr></argument>, <argument><expr><name>PrimaryIndexNumber</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreeModifyCallbackInfo</name></type> <name>callbackInfo</name> <init>= <expr><block>{
				<expr><operator>.</operator><name>waitCallback</name> <operator>=</operator> <name>NULL</name></expr>,
				<expr><operator>.</operator><name>modifyCallback</name> <operator>=</operator> <name>recovery_delete_overwrite_callback</name></expr>,
				<expr><operator>.</operator><name>modifyDeletedCallback</name> <operator>=</operator> <name>NULL</name></expr>,
				<expr><operator>.</operator><name>needsUndoForSelfCreated</name> <operator>=</operator> <name>false</name></expr>,
				<expr><operator>.</operator><name>arg</name> <operator>=</operator> <name>NULL</name></expr>
			}</block></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_EMPTY</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>o_is_index_predicate_satisfied</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>id</name><operator>-&gt;</operator><name>econtext</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>tts_orioledb_fill_key_bound</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keyBound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>o_btree_modify</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>BTreeOperationDelete</name></expr></argument>,
						   <argument><expr><name>nullTup</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>,
						   <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>keyBound</name></expr></argument>, <argument><expr><name>BTreeKeyBound</name></expr></argument>,
						   <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>RowLockUpdate</name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>callbackInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>apply_tbl_update</name><parameter_list>(<parameter><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>,
				 <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>must_modify</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OBTreeModifyResult</name></type> <name>modify_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeKeyBound</name></type> <name>old_key</name></decl>,
				<decl><type ref="prev"/><name>new_key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>new_stup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CallbackTupleCopy</name></type> <name>tupCopy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>tree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>true</name></expr></init></decl>,
				<decl><type ref="prev"/><name>primary</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>new_slot</name> <init>= <expr><name><name>descr</name><operator>-&gt;</operator><name>newTuple</name></name></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>old_slot</name> <init>= <expr><name><name>descr</name><operator>-&gt;</operator><name>oldTuple</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>descr</name><operator>-&gt;</operator><name>nIndices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>primary</name> <operator>=</operator> <name>i</name> <operator>==</operator> <name>PrimaryIndexNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tree</name> <operator>=</operator> <name><name>descr</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tree</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>primary</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreeModifyCallbackInfo</name></type> <name>callbackInfo</name> <init>= <expr><block>{
				<expr><operator>.</operator><name>waitCallback</name> <operator>=</operator> <name>NULL</name></expr>,
				<expr><operator>.</operator><name>modifyCallback</name> <operator>=</operator> <name>o_update_copy_callback</name></expr>,
				<expr><operator>.</operator><name>modifyDeletedCallback</name> <operator>=</operator> <name>NULL</name></expr>,
				<expr><operator>.</operator><name>needsUndoForSelfCreated</name> <operator>=</operator> <name>false</name></expr>,
				<expr><operator>.</operator><name>arg</name> <operator>=</operator> <operator>&amp;</operator><name>tupCopy</name></expr>
			}</block></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name><name>tupCopy</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>modify_result</name> <operator>=</operator> <call><name>o_btree_modify</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tree</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>BTreeOperationUpdate</name></expr></argument>,
										   <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>,
										   <argument><expr><name>RowLockNoKeyUpdate</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>callbackInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>modify_result</name> <operator>!=</operator> <name>OBTreeModifyResultUpdated</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>descr</name><operator>-&gt;</operator><name>nIndices</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>tupCopy</name><operator>.</operator><name>tuple</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>tts_orioledb_store_tuple</name><argument_list>(<argument><expr><name>new_slot</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>,
									 <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>PrimaryIndexNumber</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>tts_orioledb_store_tuple</name><argument_list>(<argument><expr><name>old_slot</name></expr></argument>, <argument><expr><name><name>tupCopy</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>descr</name></expr></argument>,
									 <argument><expr><name><name>tupCopy</name><operator>.</operator><name>csn</name></name></expr></argument>, <argument><expr><name>PrimaryIndexNumber</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>tts_orioledb_fill_key_bound</name><argument_list>(<argument><expr><name>new_slot</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>tts_orioledb_fill_key_bound</name><argument_list>(<argument><expr><name>old_slot</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tree</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>,
							  <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>new_key</name></expr></argument>, <argument><expr><name>BTreeKeyBound</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>old_key</name></expr></argument>, <argument><expr><name>BTreeKeyBound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OTuple</name></type>		<name>nullTup</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>BTreeModifyCallbackInfo</name></type> <name>callbackInfo</name> <init>= <expr><name>nullCallbackInfo</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>nullTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>o_is_index_predicate_satisfied</name><argument_list>(<argument><expr><name>tree</name></expr></argument>,
												   <argument><expr><name>old_slot</name></expr></argument>,
												   <argument><expr><name><name>tree</name><operator>-&gt;</operator><name>econtext</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>callbackInfo</name><operator>.</operator><name>modifyCallback</name></name> <operator>=</operator> <name>recovery_delete_overwrite_callback</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>o_btree_modify</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tree</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>BTreeOperationDelete</name></expr></argument>,
										  <argument><expr><name>nullTup</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>old_key</name></expr></argument>, <argument><expr><name>BTreeKeyBound</name></expr></argument>,
										  <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>RowLockUpdate</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>callbackInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>o_is_index_predicate_satisfied</name><argument_list>(<argument><expr><name>tree</name></expr></argument>,
												   <argument><expr><name>new_slot</name></expr></argument>,
												   <argument><expr><name><name>tree</name><operator>-&gt;</operator><name>econtext</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>callbackInfo</name><operator>.</operator><name>modifyDeletedCallback</name></name> <operator>=</operator> <name>recovery_insert_overwrite_callback</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>callbackInfo</name><operator>.</operator><name>modifyCallback</name></name> <operator>=</operator> <name>recovery_insert_overwrite_callback</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>new_stup</name> <operator>=</operator> <call><name>tts_orioledb_make_secondary_tuple</name><argument_list>(<argument><expr><name>new_slot</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>o_btree_modify</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tree</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>BTreeOperationInsert</name></expr></argument>,
										  <argument><expr><name>new_stup</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>new_key</name></expr></argument>, <argument><expr><name>BTreeKeyBound</name></expr></argument>,
										  <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>RowLockUpdate</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>callbackInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>new_stup</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>new_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>old_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
