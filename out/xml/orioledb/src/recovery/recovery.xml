<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/recovery/recovery.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * recovery.c
 *		General routines for orioledb recovery.
 *
 * Copyright (c) 2021-2022, Oriole DB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/recovery/recovery.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/btree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/modify.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/free_extents.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indices.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/o_sys_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"recovery/recovery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"recovery/internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"recovery/wal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tableam/descr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transam/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/stopevent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">150000</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogrecovery.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/ilist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/pairingheap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/startup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/message.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shm_mq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/standby.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Recovery transaction state.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name></decl>;</decl_stmt>			<comment type="block">/* hash table key */</comment>

	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>			<comment type="block">/* builtin transaction identifier for joint
								 * commit */</comment>

	<decl_stmt><decl><type><name>bool</name></type>		<name>needs_wal_flush</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>retain_loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoStackLocations</name></type> <name>undo_stack</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_head</name></type>	<name>checkpoint_undo_stacks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>ptr</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>in_finished_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>in_retain_heap</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>dlist_node</name></type>	<name>joint_commit_list_node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_node</name></type>	<name>finished_list_node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pairingheap_node</name></type> <name>retain_ph_node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pairingheap_node</name></type> <name>xmin_ph_node</name></decl>;</decl_stmt>

	<comment type="block">/* is relnode created on the xactInfo */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>systree_modified</name></decl>;</decl_stmt>
	<comment type="block">/* is provided by checkpoint xids file */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>checkpoint_xid</name></decl>;</decl_stmt>
	<comment type="block">/* is started from wal stream */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>wal_xid</name></decl>;</decl_stmt>
	<comment type="block">/* usage map */</comment>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>used_by</name></decl>;</decl_stmt>
}</block></struct></type> <name>RecoveryXidState</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>UndoStackLocations</name></type> <name>undo_stack</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_node</name></type>	<name>node</name></decl>;</decl_stmt>
}</block></struct></type> <name>CheckpointUndoStack</name>;</typedef>

<comment type="block">/*
 * Recovery worker state in pool.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<comment type="block">/* Pointer to the worker queue */</comment>
	<decl_stmt><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>queue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>queue_buf</name><index>[<expr><name>RECOVERY_QUEUE_BUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>queue_buf_len</name></decl>;</decl_stmt>
	<comment type="block">/* Current oids */</comment>
	<decl_stmt><decl><type><name>ORelOids</name></type>	<name>oids</name></decl>;</decl_stmt>
	<comment type="block">/* Current oxid */</comment>
	<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name></decl>;</decl_stmt>
	<comment type="block">/* Current index type */</comment>
	<decl_stmt><decl><type><name>OIndexType</name></type>	<name>type</name></decl>;</decl_stmt>
	<comment type="block">/* Handle for the worker */</comment>
	<decl_stmt><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl>;</decl_stmt>
}</block></struct></type> <name>RecoveryWorkerState</name>;</typedef>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>orioledb_recovery_synchronized</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Comparator for retain min-heap.
 *
 * See pairingheap.c/pairingheap_comparator description.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>retain_pairingheap_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pairingheap_node</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>pairingheap_node</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
					   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>RecoveryXidState</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>pairingheap_const_container</name><argument_list>(<argument><expr><name>RecoveryXidState</name></expr></argument>, <argument><expr><name>retain_ph_node</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>RecoveryXidState</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>pairingheap_const_container</name><argument_list>(<argument><expr><name>RecoveryXidState</name></expr></argument>, <argument><expr><name>retain_ph_node</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>l</name><operator>-&gt;</operator><name>retain_loc</name></name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>retain_loc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>l</name><operator>-&gt;</operator><name>retain_loc</name></name> <operator>&gt;</operator> <name><name>r</name><operator>-&gt;</operator><name>retain_loc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Comparator for xmin min-heap.
 *
 * See pairingheap.c/pairingheap_comparator description.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>xmin_pairingheap_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pairingheap_node</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>pairingheap_node</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
					 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>RecoveryXidState</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>pairingheap_const_container</name><argument_list>(<argument><expr><name>RecoveryXidState</name></expr></argument>, <argument><expr><name>xmin_ph_node</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>RecoveryXidState</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>pairingheap_const_container</name><argument_list>(<argument><expr><name>RecoveryXidState</name></expr></argument>, <argument><expr><name>xmin_ph_node</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>l</name><operator>-&gt;</operator><name>oxid</name></name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>oxid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>l</name><operator>-&gt;</operator><name>oxid</name></name> <operator>&gt;</operator> <name><name>r</name><operator>-&gt;</operator><name>oxid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Current recovery transaction state. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>RecoveryXidState</name> <modifier>*</modifier></type><name>cur_state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Recovery transaction hash for the current process. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>recovery_xid_state_hash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Queue of undo retain locations */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>pairingheap</name> <modifier>*</modifier></type><name>retain_queue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Queue of xmin's */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>pairingheap</name> <modifier>*</modifier></type><name>xmin_queue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * List of locally finished transaction, which aren't yet knows as finished
 * for every recovery process.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>dlist_head</name></type> <name>finished_list</name></decl>;</decl_stmt>

<comment type="block">/*
 * List of transactions waiting for joint commit with builtin transaction.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>dlist_head</name></type> <name>joint_commit_list</name></decl>;</decl_stmt>

<comment type="block">/* Pool of recovery workers and oxid hash for it */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>RecoveryWorkerState</name> <modifier>*</modifier></type><name>workers_pool</name></decl>;</decl_stmt>

<comment type="block">/* orioledb checkpoint number from which we start recovery */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>startup_chkp_num</name></decl>;</decl_stmt>

<comment type="block">/* is recovery main process has error */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>unexpected_worker_detach</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * True if current process is a recovery process (worker or master).
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>iam_recovery</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Current orioledb transaction recovery id
 */</comment>
<decl_stmt><decl><type><name>OXid</name></type>		<name>recovery_oxid</name> <init>= <expr><name>InvalidOXid</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Full size of a recovery queue.
 */</comment>
<decl_stmt><decl><type><name>uint64</name></type>		<name>recovery_queue_data_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * The pointer to a first recovery queue.
 */</comment>
<decl_stmt><decl><type><name>Pointer</name></type>		<name>recovery_first_queue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * GUC value, number of recovery workers.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>recovery_pool_size_guc</name></decl>;</decl_stmt>

<comment type="block">/*
 * GUC value, size of a single recovery queue.
 */</comment>
<decl_stmt><decl><type><name>Size</name></type>		<name>recovery_queue_size_guc</name></decl>;</decl_stmt>

<comment type="block">/*
 * Are TOAST trees consistent with primary indices.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>toast_consistent</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Checkpoint requests for flushing undo positions and their completion.
 */</comment>
<decl_stmt><decl><type><name>RecoveryUndoLocFlush</name> <modifier>*</modifier></type><name>recovery_undo_loc_flush</name></decl>;</decl_stmt>

<comment type="block">/*
 * The last xmin we received from primary.
 */</comment>
<decl_stmt><decl><type><name>OXid</name></type>		<name>recovery_xmin</name> <init>= <expr><name>InvalidOXid</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Number of successfully finished recovery workers.
 */</comment>
<decl_stmt><decl><type><name>pg_atomic_uint32</name> <modifier>*</modifier></type><name>worker_finish_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pg_atomic_uint32</name> <modifier>*</modifier></type><name>worker_ptrs_changes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RecoveryWorkerPtrs</name> <modifier>*</modifier></type><name>worker_ptrs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pg_atomic_uint64</name> <modifier>*</modifier></type><name>recovery_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pg_atomic_uint64</name> <modifier>*</modifier></type><name>recovery_main_retain_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pg_atomic_uint64</name> <modifier>*</modifier></type><name>recovery_finished_list_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>recovery_single_process</name></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>update_run_xmin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>free_run_xmin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>need_flush_undo_pos</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>flush_current_undo_stack</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>o_handle_startup_proc_interrupts_hook</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>abort_recovery</name><parameter_list>(<parameter><decl><type><name>RecoveryWorkerState</name> <modifier>*</modifier></type><name>workers_pool</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_workers</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>worker_wait_shutdown</name><parameter_list>(<parameter><decl><type><name>RecoveryWorkerState</name> <modifier>*</modifier></type><name>worker</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>replay_container</name><parameter_list>(<parameter><decl><type><name>Pointer</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>endPtr</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>single</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>xlogRecPtr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>worker_send_msg</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>msg</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>msg_size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>worker_send_modify</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>, <parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>recType</name></decl></parameter>,
							   <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tuple_len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>workers_send_finish</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>workers_send_oxid_finish</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>commit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>workers_send_savepoint</name><parameter_list>(<parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>workers_send_rollback_to_savepoint</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>,
											   <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>workers_synchronize</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>csn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>send_synchronize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>workers_notify_toast_consistent</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>worker_queue_flush</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>apply_sys_tree_modify_record</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sys_tree_num</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>type</name></decl></parameter>,
												<parameter><decl><type><name>OTuple</name></type> <name>tup</name></decl></parameter>,
												<parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>spread_idx_modify</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>recType</name></decl></parameter>,
									 <parameter><decl><type><name>OTuple</name></type> <name>rec</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wal</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint16</name></type> <name>recovery_msg_from_wal_record</name><parameter_list>(<parameter><decl><type><name>uint8</name></type> <name>wal_record</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Returns full size of the shared memory needed to recovery.
 */</comment>
<function><type><name>Size</name></type>
<name>recovery_shmem_needs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><name>recovery_queue_size_guc</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>recovery_pool_size_guc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pg_atomic_uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pg_atomic_uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RecoveryUndoLocFlush</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RecoveryWorkerPtrs</name></expr></argument>)</argument_list></sizeof></expr></argument>,
												  <argument><expr><name>recovery_pool_size_guc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pg_atomic_uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initializes recovery shared memory.
 *
 * Must be called after checkpoint_shmem_init() because it initializes
 * startupCommitSeqNo.
 */</comment>
<function><type><name>void</name></type>
<name>recovery_shmem_init</name><parameter_list>(<parameter><decl><type><name>Pointer</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>found</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>recovery_first_queue</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><name>recovery_queue_size_guc</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>recovery_pool_size_guc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>recovery_single_process</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>worker_finish_count</name> <operator>=</operator> <operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pg_atomic_uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>worker_ptrs_changes</name> <operator>=</operator> <operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pg_atomic_uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>recovery_undo_loc_flush</name> <operator>=</operator> <operator>(</operator><name>RecoveryUndoLocFlush</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RecoveryUndoLocFlush</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>worker_ptrs</name> <operator>=</operator> <operator>(</operator><name>RecoveryWorkerPtrs</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RecoveryWorkerPtrs</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>recovery_pool_size_guc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>recovery_ptr</name> <operator>=</operator> <operator>(</operator><name>pg_atomic_uint64</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>recovery_main_retain_ptr</name> <operator>=</operator> <name>recovery_ptr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>recovery_finished_list_ptr</name> <operator>=</operator> <name>recovery_ptr</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pg_atomic_uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>recovery_queue_data_size</name> <operator>=</operator> <name>recovery_queue_size_guc</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>finishRequestCheckpointNumber</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>immediateRequestCheckpointNumber</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>completedCheckpointNumber</name></name> <operator>=</operator> <name>UINT32_MAX</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>recoveryMainCompletedCheckpointNumber</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>exitLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><name>worker_finish_count</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><name>worker_ptrs_changes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>recovery_pool_size_guc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>shm_mq_create</name><argument_list>(<argument><expr><call><name>GET_WORKER_QUEUE</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recovery_queue_size_guc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>worker_ptrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>commitPtr</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>worker_ptrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>retainPtr</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>worker_ptrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flushedUndoLocCompletedCheckpointNumber</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><name>recovery_ptr</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><name>recovery_main_retain_ptr</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><name>recovery_finished_list_ptr</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>undo_stack_locations_set_invalid</name><parameter_list>(<parameter><decl><type><name>UndoStackLocations</name> <modifier>*</modifier></type><name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>location</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>location</name><operator>-&gt;</operator><name>subxactLocation</name></name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>location</name><operator>-&gt;</operator><name>branchLocation</name></name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>location</name><operator>-&gt;</operator><name>onCommitLocation</name></name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read information about undo locations of in-progress transactions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>read_xids</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>checkpointnum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recovery_single</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>xidFilename</name> <init>= <expr><call><name>psprintf</name><argument_list>(<argument><expr><name>XID_FILENAME_FORMAT</name></expr></argument>, <argument><expr><name>checkpointnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>xidFile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xidFile</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>xidFilename</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xidFile</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open xid file %s"</literal></expr></argument>, <argument><expr><name>xidFilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OFileRead</name><argument_list>(<argument><expr><name>xidFile</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>count</name></expr></argument>,
				  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
				  <argument><expr><name>WAIT_EVENT_SLRU_READ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read xid record from file %s"</literal></expr></argument>, <argument><expr><name>xidFilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RecoveryXidState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XidFileRec</name></type>	<name>xidRec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OFileRead</name><argument_list>(<argument><expr><name>xidFile</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>xidRec</name></expr></argument>,
					  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xidRec</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
					  <argument><expr><name>WAIT_EVENT_SLRU_READ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>xidRec</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read xid record from file %s"</literal></expr></argument>, <argument><expr><name>xidFilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>advance_oxids</name><argument_list>(<argument><expr><name><name>xidRec</name><operator>.</operator><name>oxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>RecoveryXidState</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>recovery_xid_state_hash</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name><name>xidRec</name><operator>.</operator><name>oxid</name></name></expr></argument>,
												 <argument><expr><name>HASH_ENTER</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>needs_wal_flush</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>retain_loc</name></name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>	<comment type="block">/* undo locations are
														 * held by checkpoint */</comment>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <name>COMMITSEQNO_INPROGRESS</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>in_finished_list</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>in_retain_heap</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>undo_stack_locations_set_invalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>undo_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>checkpoint_undo_stacks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pairingheap_add</name><argument_list>(<argument><expr><name>xmin_queue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>xmin_ph_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>systree_modified</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>checkpoint_xid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>wal_xid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recovery_single</name> <operator>&amp;&amp;</operator> <name>worker_id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>used_by</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>recovery_pool_size_guc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>used_by</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CheckpointUndoStack</name> <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>stack</name> <operator>=</operator> <operator>(</operator><name>CheckpointUndoStack</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
															   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CheckpointUndoStack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>undo_stack</name></name> <operator>=</operator> <name><name>xidRec</name><operator>.</operator><name>undoLocation</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>checkpoint_undo_stacks</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>set_oxid_csn</name><argument_list>(<argument><expr><name><name>xidRec</name><operator>.</operator><name>oxid</name></name></expr></argument>, <argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>xidRec</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>update_run_xmin</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>xidFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>xidFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Apply undo records "hidden" in undo branches.
 *
 * These records are intended to be already aborted.  But checkpointer could
 * "see" tuples which still reference those records.  This routine is du
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>apply_xids_branches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>recovery_xid_state_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>cur_state</name> <operator>=</operator> <operator>(</operator><name>RecoveryXidState</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oxid_needs_wal_flush</name> <operator>=</operator> <name><name>cur_state</name><operator>-&gt;</operator><name>needs_wal_flush</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recovery_oxid</name> <operator>=</operator> <name><name>cur_state</name><operator>-&gt;</operator><name>oxid</name></name></expr>;</expr_stmt>

		<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;cur_state-&gt;checkpoint_undo_stacks</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CheckpointUndoStack</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>CheckpointUndoStack</name></expr></argument>,
														 <argument><expr><name>node</name></expr></argument>,
														 <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>set_cur_undo_locations</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>undo_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>apply_undo_branches</name><argument_list>(<argument><expr><name>recovery_oxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></while>

	<expr_stmt><expr><name>oxid_needs_wal_flush</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>recovery_oxid</name> <operator>=</operator> <name>InvalidOXid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>reset_cur_undo_locations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cur_state</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>o_recovery_start_hook</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecoveryWorkerState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>num_workers</name> <init>= <expr><name>recovery_pool_size_guc</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>recovery_single</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>before_shmem_exit</name><argument_list>(<argument><expr><name>recovery_on_proc_exit</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recovery_single</name> <operator>=</operator> <operator>*</operator><name>recovery_single_process</name> <operator>=</operator> <call><name>IsFatalError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>recovery_single</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"orioledb recovery after fatal error started.  Unable to make multiprocess recovery."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"orioledb recovery started."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>startup_chkp_num</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>recovery_cleanup_old_files</name><argument_list>(<argument><expr><name>startup_chkp_num</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recovery_single</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>workers_pool</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RecoveryWorkerState</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_workers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>&amp;</operator><name><name>workers_pool</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>shm_mq_set_sender</name><argument_list>(<argument><expr><call><name>GET_WORKER_QUEUE</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>oIndexInvalid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>reloid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>oxid</name></name> <operator>=</operator> <name>InvalidOXid</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>workers_pool</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>handle</name> <operator>=</operator> <call><name>recovery_worker_register</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>workers_pool</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>handle</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Not enough slots for background workers.
				 */</comment>
				<expr_stmt><expr><call><name>abort_recovery</name><argument_list>(<argument><expr><name>workers_pool</name></expr></argument>, <argument><expr><name>recovery_pool_size_guc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIGURATION_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to start recovery workers"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"You must increase max_worker_processes value or decrease orioledb.recovery_workers_number value."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>queue</name></name> <operator>=</operator> <call><name>shm_mq_attach</name><argument_list>(<argument><expr><call><name>GET_WORKER_QUEUE</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>workers_pool</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></for>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_workers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>shm_mq_wait_for_attach</name><argument_list>(<argument><expr><name><name>workers_pool</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>queue</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SHM_MQ_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unable to attach recovery workers to shm queue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

<comment type="block">/*	if (enable_stopevents)
	{
		wait_for_stopevent_enabled(STOPEVENT_RECOVERY_START);
		STOPEVENT(STOPEVENT_RECOVERY_START, NULL);
	}*/</comment>

	<expr_stmt><expr><name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>completedCheckpointNumber</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recovery_init</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>apply_xids_branches</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>o_recovery_logicalmsg_redo_hook</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rec</name> <init>= <expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_LOGICAL_MESSAGE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_logical_message</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_logical_message</name> <operator>*</operator><operator>)</operator> <name>rec</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>prefix_size</name></name> <operator>==</operator> <operator>(</operator><name>ORIOLEDB_WAL_PREFIX_SIZE</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator>
			<operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>message</name></name></expr></argument>, <argument><expr><name>ORIOLEDB_WAL_PREFIX</name></expr></argument>, <argument><expr><name>ORIOLEDB_WAL_PREFIX_SIZE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Pointer</name></type>		<name>msg_start</name> <init>= <expr><name><name>xlrec</name><operator>-&gt;</operator><name>message</name></name> <operator>+</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>prefix_size</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>recovery_single</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>recovery_single</name> <operator>=</operator> <operator>*</operator><name>recovery_single_process</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>controlToastConsistentPtr</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>toast_consistent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recovery_single</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>workers_notify_toast_consistent</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>controlReplayStartPtr</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>replay_container</name><argument_list>(<argument><expr><name>msg_start</name></expr></argument>, <argument><expr><name>msg_start</name> <operator>+</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>message_size</name></name></expr></argument>,
								 <argument><expr><name>recovery_single</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>unexpected_worker_detach</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>abort_recovery</name><argument_list>(<argument><expr><name>workers_pool</name></expr></argument>, <argument><expr><name>recovery_pool_size_guc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"orioledb recovery worker detached unexpectedly."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>o_recovery_finish_hook</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>cleanup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecoveryWorkerState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>num_workers</name> <init>= <expr><name>recovery_pool_size_guc</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>recovery_single</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>recovery_single</name> <operator>=</operator> <operator>*</operator><name>recovery_single_process</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recovery_single</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>workers_send_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_workers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>worker_wait_shutdown</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>workers_pool</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>recovery_finish</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recovery_single</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_workers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>&amp;</operator><name><name>workers_pool</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>shm_mq_detach</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>workers_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Release all the locks.  All of them are acquired at statement-level. */</comment>
	<expr_stmt><expr><call><name>LockReleaseCurrentOwner</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * No sense to check recovery_internal_error state, because shm_mq_sendv()
	 * can return SHM_MQ_DETACHED even if finish message was successfully
	 * sent.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recovery_single</name> <operator>&amp;&amp;</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><name>worker_finish_count</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>num_workers</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"orioledb recovery worker died."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>cleanup</name> <operator>&amp;&amp;</operator> <name>remove_old_checkpoint_files</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>recovery_cleanup_old_files</name><argument_list>(<argument><expr><name>startup_chkp_num</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"orioledb recovery finished."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>completedCheckpointNumber</name></name> <operator>=</operator> <name>UINT32_MAX</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns minimum ptr which is already reached by all recovery workers.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>recovery_get_current_ptr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>CommitSeqNo</name></type> <name>prev_ptr</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>uint64</name></type> <name>prev_changes</name> <init>= <expr><name>UINT64_MAX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>old_changes</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fast check - single process recovery */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>recovery_single_process</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>prev_ptr</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><name>recovery_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>prev_ptr</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* fast check - nothing changed */</comment>
	<expr_stmt><expr><name>old_changes</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><name>worker_ptrs_changes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>old_changes</name> <operator>==</operator> <name>prev_changes</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>prev_ptr</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we need to find a new ptr */</comment>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>min_ptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>new_changes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>min_ptr</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>worker_ptrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>commitPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>recovery_pool_size_guc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name>min_ptr</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>min_ptr</name></expr></argument>, <argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>worker_ptrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>commitPtr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<expr_stmt><expr><name>new_changes</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><name>worker_ptrs_changes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>old_changes</name> <operator>!=</operator> <name>new_changes</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>old_changes</name> <operator>=</operator> <name>new_changes</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>prev_changes</name> <operator>=</operator> <name>new_changes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev_ptr</name> <operator>=</operator> <name>min_ptr</name></expr>;</expr_stmt>
		<return>return <expr><name>prev_ptr</name></expr>;</return>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>recovery_get_retain_ptr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* fast check - single process recovery */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>recovery_single_process</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><name>recovery_ptr</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we need to find a new ptr */</comment>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><name>recovery_main_retain_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>recovery_pool_size_guc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>worker_ptrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>retainPtr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if current process is recovery process.
 */</comment>
<function><type><name>bool</name></type>
<name>is_recovery_process</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>iam_recovery</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>CommitSeqNo</name></type>
<name>recovery_map_oxid_csn</name><parameter_list>(<parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecoveryXidState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>recovery_xid_state_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oxid</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>wal_xid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>COMMITSEQNO_ABORTED</name></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>csn</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Initializes a new recovery process, recovery transaction support.
 */</comment>
<function><type><name>void</name></type>
<name>recovery_init</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OXid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RecoveryXidState</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>TopMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>recovery_xid_state_hash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"orioledb recovery xid state hash"</literal></expr></argument>,
										  <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
										  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>iam_recovery</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>retain_queue</name> <operator>=</operator> <call><name>pairingheap_allocate</name><argument_list>(<argument><expr><name>retain_pairingheap_cmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xmin_queue</name> <operator>=</operator> <call><name>pairingheap_allocate</name><argument_list>(<argument><expr><name>xmin_pairingheap_cmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>finished_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>joint_commit_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurTransactionContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
												  <argument><expr><literal type="string">"orioledb recovery current transaction context"</literal></expr></argument>,
												  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>TopTransactionContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
												  <argument><expr><literal type="string">"orioledb recovery top transaction context"</literal></expr></argument>,
												  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RelationCacheInitialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* needed for OTableDescr invalidation */</comment>
	<expr_stmt><expr><call><name>InitCatalogCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>o_set_syscache_hooks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>read_xids</name><argument_list>(<argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name></expr></argument>,
				  <argument><expr><operator>*</operator><name>recovery_single_process</name></expr></argument>,
				  <argument><expr><name>worker_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>recovery_xmin</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>runXmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>HandleStartupProcInterrupts_hook</name> <operator>=</operator> <name>o_handle_startup_proc_interrupts_hook</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>walk_checkpoint_stacks</name><parameter_list>(<parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>,
					   <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>flushUndoPos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>miter</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oxid_needs_wal_flush</name> <operator>=</operator> <name><name>cur_state</name><operator>-&gt;</operator><name>needs_wal_flush</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>recovery_oxid</name> <operator>=</operator> <name><name>cur_state</name><operator>-&gt;</operator><name>oxid</name></name></expr>;</expr_stmt>

	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>miter</argument>, <argument>&amp;cur_state-&gt;checkpoint_undo_stacks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CheckpointUndoStack</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>CheckpointUndoStack</name></expr></argument>,
													 <argument><expr><name>node</name></expr></argument>,
													 <argument><expr><name><name>miter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>set_cur_undo_locations</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>undo_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>flushUndoPos</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>flush_current_undo_stack</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>COMMITSEQNO_IS_ABORTED</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>parentSubid</name> <operator>==</operator> <name>InvalidSubTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>apply_undo_stack</name><argument_list>(<argument><expr><name>recovery_oxid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>rollback_to_savepoint</name><argument_list>(<argument><expr><name>UndoStackHead</name></expr></argument>, <argument><expr><name>parentSubid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>on_commit_undo_stack</name><argument_list>(<argument><expr><name>recovery_oxid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><name><name>miter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Finishes a recovery process, close all recovery transactions.
 */</comment>
<function><type><name>void</name></type>
<name>recovery_finish</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>flush_undo_pos</name> <init>= <expr><call><name>need_flush_undo_pos</name><argument_list>(<argument><expr><name>worker_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>cur_state</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>needs_wal_flush</name></name> <operator>=</operator> <name>oxid_needs_wal_flush</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>undo_stack</name></name> <operator>=</operator> <call><name>get_cur_undo_locations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>retain_loc</name></name> <operator>=</operator> <name>curRetainUndoLocation</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>recovery_xid_state_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>cur_state</name> <operator>=</operator> <operator>(</operator><name>RecoveryXidState</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>COMMITSEQNO_IS_INPROGRESS</name><argument_list>(<argument><expr><name><name>cur_state</name><operator>-&gt;</operator><name>csn</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>oxid_needs_wal_flush</name> <operator>=</operator> <name><name>cur_state</name><operator>-&gt;</operator><name>needs_wal_flush</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>recovery_oxid</name> <operator>=</operator> <name><name>cur_state</name><operator>-&gt;</operator><name>oxid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>set_cur_undo_locations</name><argument_list>(<argument><expr><name><name>cur_state</name><operator>-&gt;</operator><name>undo_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>flush_undo_pos</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>flush_current_undo_stack</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>apply_undo_stack</name><argument_list>(<argument><expr><name>recovery_oxid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>walk_checkpoint_stacks</name><argument_list>(<argument><expr><name>COMMITSEQNO_ABORTED</name></expr></argument>,
								   <argument><expr><name>InvalidSubTransactionId</name></expr></argument>,
								   <argument><expr><name>flush_undo_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cur_state</name><operator>-&gt;</operator><name>in_finished_list</name></name> <operator>&amp;&amp;</operator> <name>worker_id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>set_oxid_csn</name><argument_list>(<argument><expr><name><name>cur_state</name><operator>-&gt;</operator><name>oxid</name></name></expr></argument>, <argument><expr><name>COMMITSEQNO_COMMITTING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextCommitSeqNo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>set_oxid_csn</name><argument_list>(<argument><expr><name><name>cur_state</name><operator>-&gt;</operator><name>oxid</name></name></expr></argument>, <argument><expr><name><name>cur_state</name><operator>-&gt;</operator><name>csn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cur_state</name><operator>-&gt;</operator><name>used_by</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cur_state</name><operator>-&gt;</operator><name>used_by</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name>HandleStartupProcInterrupts_hook</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>recovery_xid_state_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recovery_xid_state_hash</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>release_undo_size</name><argument_list>(<argument><expr><name>UndoReserveTxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_retained_undo_location</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pairingheap_free</name><argument_list>(<argument><expr><name>retain_queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pairingheap_free</name><argument_list>(<argument><expr><name>xmin_queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free_run_xmin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>worker_ptrs</name><index>[<expr><name>worker_id</name></expr>]</index></name><operator>.</operator><name>retainPtr</name></expr></argument>,
							<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>worker_ptrs</name><index>[<expr><name>worker_id</name></expr>]</index></name><operator>.</operator><name>commitPtr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><name>recovery_main_retain_ptr</name></expr></argument>,
							<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><name>recovery_ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>oxid_needs_wal_flush</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>recovery_oxid</name> <operator>=</operator> <name>InvalidOXid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>reset_cur_undo_locations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>CurTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>TopTransactionContext</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurTransactionContext</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>iam_recovery</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>o_reset_syscache_hooks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Switches recovery process to other orioledb transaction.
 */</comment>
<function><type><name>void</name></type>
<name>recovery_switch_to_oxid</name><parameter_list>(<parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>recovery_oxid</name> <operator>!=</operator> <name>oxid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>cur_state</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>needs_wal_flush</name></name> <operator>=</operator> <name>oxid_needs_wal_flush</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>undo_stack</name></name> <operator>=</operator> <call><name>get_cur_undo_locations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name><name>cur_state</name><operator>-&gt;</operator><name>retain_loc</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>curRetainUndoLocation</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>retain_loc</name></name> <operator>=</operator> <name>curRetainUndoLocation</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>in_retain_heap</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pairingheap_add</name><argument_list>(<argument><expr><name>retain_queue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cur_state</name><operator>-&gt;</operator><name>retain_ph_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>recovery_oxid</name> <operator>=</operator> <name>oxid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cur_state</name> <operator>=</operator> <operator>(</operator><name>RecoveryXidState</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>recovery_xid_state_hash</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>oxid</name></expr></argument>,
													 <argument><expr><name>HASH_ENTER</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>wal_xid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>oxid_needs_wal_flush</name> <operator>=</operator> <name><name>cur_state</name><operator>-&gt;</operator><name>needs_wal_flush</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>set_cur_undo_locations</name><argument_list>(<argument><expr><name><name>cur_state</name><operator>-&gt;</operator><name>undo_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>curRetainUndoLocation</name> <operator>=</operator> <name><name>cur_state</name><operator>-&gt;</operator><name>retain_loc</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>retain_loc</name></name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <name>COMMITSEQNO_INPROGRESS</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>in_finished_list</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>in_retain_heap</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cur_state</name><operator>-&gt;</operator><name>checkpoint_undo_stacks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>oxid_needs_wal_flush</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>reset_cur_undo_locations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>curRetainUndoLocation</name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pairingheap_add</name><argument_list>(<argument><expr><name>xmin_queue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cur_state</name><operator>-&gt;</operator><name>xmin_ph_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>systree_modified</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>checkpoint_xid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>recovery_single_process</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>used_by</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>recovery_pool_size_guc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>used_by</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>update_proc_retain_undo_location</name><argument_list>(<argument><expr><name>worker_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Delete recovery xid item if it's already deleted from both retain undo
 * location heap and finished list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_delete_xid_state</name><parameter_list>(<parameter><decl><type><name>RecoveryXidState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>in_retain_heap</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>in_finished_list</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>oxid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>used_by</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>used_by</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pairingheap_remove</name><argument_list>(<argument><expr><name>xmin_queue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>xmin_ph_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>update_run_xmin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>recovery_xid_state_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oxid</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>need_flush_undo_pos</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>recoveryMainCompletedCheckpointNumber</name></name> <operator>&lt;</operator>
			<name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>finishRequestCheckpointNumber</name></name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name><name>worker_ptrs</name><index>[<expr><name>worker_id</name></expr>]</index></name><operator>.</operator><name>flushedUndoLocCompletedCheckpointNumber</name> <operator>&lt;</operator>
			<name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>finishRequestCheckpointNumber</name></name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>flush_current_undo_stack</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XidFileRec</name></type>	<name>rec</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>rec</name><operator>.</operator><name>oxid</name></name> <operator>=</operator> <name>recovery_oxid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rec</name><operator>.</operator><name>undoLocation</name></name> <operator>=</operator> <call><name>get_cur_undo_locations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>write_to_xids_queue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Finishes the current recovery transaction for the current recovery process.
 */</comment>
<function><type><name>void</name></type>
<name>recovery_finish_current_oxid</name><parameter_list>(<parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name> <init>= <expr><name>recovery_oxid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>flush_undo_pos</name> <init>= <expr><call><name>need_flush_undo_pos</name><argument_list>(<argument><expr><name>worker_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>COMMITSEQNO_IS_ABORTED</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>sync</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>worker_id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_oxid_csn</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>COMMITSEQNO_COMMITTING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>flush_undo_pos</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>flush_current_undo_stack</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>on_commit_undo_stack</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>walk_checkpoint_stacks</name><argument_list>(<argument><expr><name>csn</name></expr></argument>, <argument><expr><name>InvalidSubTransactionId</name></expr></argument>, <argument><expr><name>flush_undo_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>csn</name> <operator>=</operator> <call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextCommitSeqNo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_oxid_csn</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>COMMITSEQNO_IS_ABORTED</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>sync</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>flush_undo_pos</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>flush_current_undo_stack</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>on_commit_undo_stack</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>walk_checkpoint_stacks</name><argument_list>(<argument><expr><name>csn</name></expr></argument>, <argument><expr><name>InvalidSubTransactionId</name></expr></argument>, <argument><expr><name>flush_undo_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>in_finished_list</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name>finished_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cur_state</name><operator>-&gt;</operator><name>finished_list_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>flush_undo_pos</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>flush_current_undo_stack</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>apply_undo_stack</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>walk_checkpoint_stacks</name><argument_list>(<argument><expr><name>csn</name></expr></argument>, <argument><expr><name>InvalidSubTransactionId</name></expr></argument>, <argument><expr><name>flush_undo_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>sync</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>set_oxid_csn</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>COMMITSEQNO_ABORTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Postpone transaction abort until it will be aborted by all
				 * the workers.  Otherwise, workers can consider it as
				 * committed due to runXmin.
				 */</comment>
				<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>in_finished_list</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name>finished_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cur_state</name><operator>-&gt;</operator><name>finished_list_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <name>csn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>oxid_needs_wal_flush</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>reset_cur_undo_locations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recovery_oxid</name> <operator>=</operator> <name>InvalidOXid</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name><name>cur_state</name><operator>-&gt;</operator><name>retain_loc</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>curRetainUndoLocation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>retain_loc</name></name> <operator>=</operator> <name>curRetainUndoLocation</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pairingheap_add</name><argument_list>(<argument><expr><name>retain_queue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cur_state</name><operator>-&gt;</operator><name>retain_ph_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>in_retain_heap</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>curRetainUndoLocation</name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>release_undo_size</name><argument_list>(<argument><expr><name>UndoReserveTxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_delete_xid_state</name><argument_list>(<argument><expr><name>cur_state</name></expr></argument>, <argument><expr><name>worker_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cur_state</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>update_proc_retain_undo_location</name><argument_list>(<argument><expr><name>worker_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkpoint_rollback_to_savepoint</name><parameter_list>(<parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>undo_stack</name></name> <operator>=</operator> <call><name>get_cur_undo_locations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>walk_checkpoint_stacks</name><argument_list>(<argument><expr><name>COMMITSEQNO_ABORTED</name></expr></argument>, <argument><expr><name>parentSubid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_cur_undo_locations</name><argument_list>(<argument><expr><name><name>cur_state</name><operator>-&gt;</operator><name>undo_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>recovery_savepoint</name><parameter_list>(<parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>checkpoint_rollback_to_savepoint</name><argument_list>(<argument><expr><name>parentSubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>add_subxact_undo_item</name><argument_list>(<argument><expr><name>parentSubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>recovery_rollback_to_savepoint</name><parameter_list>(<parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>rollback_to_savepoint</name><argument_list>(<argument><expr><name>UndoStackTail</name></expr></argument>, <argument><expr><name>parentSubid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>checkpoint_rollback_to_savepoint</name><argument_list>(<argument><expr><name>parentSubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>OBTreeModifyCallbackAction</name></type>
<name>recovery_insert_primary_callback</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>,
								 <parameter><decl><type><name>OTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>OTuple</name> <modifier>*</modifier></type><name>newtup</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>,
								 <parameter><decl><type><name>OTupleXactInfo</name></type> <name>xactInfo</name></decl></parameter>,
								 <parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>RowLockMode</name> <modifier>*</modifier></type><name>lock_mode</name></decl></parameter>,
								 <parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_OXID_EQ</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>o_tuple_get_version</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>o_tuple_get_version</name><argument_list>(<argument><expr><operator>*</operator><name>newtup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>OBTreeCallbackActionUndo</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>OBTreeCallbackActionUpdate</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>OBTreeModifyCallbackAction</name></type>
<name>recovery_delete_primary_callback</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>,
								 <parameter><decl><type><name>OTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>OTuple</name> <modifier>*</modifier></type><name>newtup</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>,
								 <parameter><decl><type><name>OTupleXactInfo</name></type> <name>xactInfo</name></decl></parameter>,
								 <parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>,
								 <parameter><decl><type><name>RowLockMode</name> <modifier>*</modifier></type><name>lock_mode</name></decl></parameter>,
								 <parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTuple</name>	   <modifier>*</modifier></type><name>key</name> <init>= <expr><operator>(</operator><name>OTuple</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_OXID_EQ</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>o_tuple_get_version</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>o_tuple_get_version</name><argument_list>(<argument><expr><operator>*</operator><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>OBTreeCallbackActionUndo</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>OBTreeCallbackActionDelete</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>OBTreeModifyCallbackAction</name></type>
<name>recovery_insert_overwrite_callback</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>,
								   <parameter><decl><type><name>OTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>OTuple</name> <modifier>*</modifier></type><name>newtup</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>,
								   <parameter><decl><type><name>OTupleXactInfo</name></type> <name>xactInfo</name></decl></parameter>,
								   <parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>,
								   <parameter><decl><type><name>RowLockMode</name> <modifier>*</modifier></type><name>lock_mode</name></decl></parameter>,
								   <parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_OXID_EQ</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>OBTreeCallbackActionUndo</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>OBTreeCallbackActionUpdate</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>OBTreeModifyCallbackAction</name></type>
<name>recovery_delete_overwrite_callback</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>,
								   <parameter><decl><type><name>OTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>OTuple</name> <modifier>*</modifier></type><name>newtup</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>,
								   <parameter><decl><type><name>OTupleXactInfo</name></type> <name>xactInfo</name></decl></parameter>,
								   <parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>,
								   <parameter><decl><type><name>RowLockMode</name> <modifier>*</modifier></type><name>lock_mode</name></decl></parameter>,
								   <parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_OXID_EQ</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>OBTreeCallbackActionUndo</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>OBTreeCallbackActionDelete</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OBTreeModifyCallbackAction</name></type>
<name>recovery_insert_systree_callback</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>,
								 <parameter><decl><type><name>OTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>OTuple</name> <modifier>*</modifier></type><name>newtup</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>,
								 <parameter><decl><type><name>OTupleXactInfo</name></type> <name>xactInfo</name></decl></parameter>,
								 <parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>RowLockMode</name> <modifier>*</modifier></type><name>lock_mode</name></decl></parameter>,
								 <parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>OBTreeCallbackActionUpdate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Applies modify recovery record to the BTree.
 */</comment>
<function><type><name>bool</name></type>
<name>apply_btree_modify_record</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>ptr</name></decl></parameter>,
						  <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OBTreeModifyResult</name></type> <name>modifyResult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeModifyCallbackInfo</name></type> <name>callbackInfo</name> <init>= <expr><name>nullCallbackInfo</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>callbackInfo</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>&amp;</operator><name>ptr</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IS_SYS_TREE_OIDS</name><argument_list>(<argument><expr><name><name>tree</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>RECOVERY_INSERT</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>RECOVERY_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>callbackInfo</name><operator>.</operator><name>modifyCallback</name></name> <operator>=</operator> <name><name>callbackInfo</name><operator>.</operator><name>modifyDeletedCallback</name></name> <operator>=</operator> <name>recovery_insert_systree_callback</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tree</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>oIndexPrimary</name> <operator>||</operator> <name><name>tree</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>oIndexToast</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>RECOVERY_INSERT</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>RECOVERY_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>callbackInfo</name><operator>.</operator><name>modifyCallback</name></name> <operator>=</operator> <name><name>callbackInfo</name><operator>.</operator><name>modifyDeletedCallback</name></name> <operator>=</operator> <name>recovery_insert_primary_callback</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>RECOVERY_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>callbackInfo</name><operator>.</operator><name>modifyCallback</name></name> <operator>=</operator> <name><name>callbackInfo</name><operator>.</operator><name>modifyDeletedCallback</name></name> <operator>=</operator> <name>recovery_delete_primary_callback</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>RECOVERY_INSERT</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>RECOVERY_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>callbackInfo</name><operator>.</operator><name>modifyCallback</name></name> <operator>=</operator> <name><name>callbackInfo</name><operator>.</operator><name>modifyDeletedCallback</name></name> <operator>=</operator> <name>recovery_insert_overwrite_callback</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>RECOVERY_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>callbackInfo</name><operator>.</operator><name>modifyCallback</name></name> <operator>=</operator> <name><name>callbackInfo</name><operator>.</operator><name>modifyDeletedCallback</name></name> <operator>=</operator> <name>recovery_delete_overwrite_callback</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RECOVERY_INSERT</name></expr>:</case>
			<expr_stmt><expr><name>modifyResult</name> <operator>=</operator> <call><name>o_btree_modify</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>BTreeOperationInsert</name></expr></argument>,
										  <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>,
										  <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>RowLockUpdate</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>callbackInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>modifyResult</name> <operator>==</operator> <name>OBTreeModifyResultInserted</name> <operator>||</operator> <name>modifyResult</name> <operator>==</operator> <name>OBTreeModifyResultUpdated</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RECOVERY_UPDATE</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>o_btree_modify</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>BTreeOperationInsert</name></expr></argument>,
									<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>,
									<argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>RowLockNoKeyUpdate</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>callbackInfo</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OBTreeModifyResultUpdated</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RECOVERY_DELETE</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>o_btree_modify</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>BTreeOperationDelete</name></expr></argument>,
									<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>RowLockUpdate</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>callbackInfo</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OBTreeModifyResultDeleted</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Wrong recovery record type %d"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>OTuple</name></type>
<name>recovery_rec_insert</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>allocated</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>allocated</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>OTupleLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>OTuple</name></type>
<name>recovery_rec_update</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>allocated</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>allocated</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>OTupleLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>OTuple</name></type>
<name>recovery_rec_delete</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>allocated</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>key</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>o_btree_tuple_make_key</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>allocated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>OKeyLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>key</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>OTuple</name></type>
<name>recovery_rec_delete_key</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>allocated</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>allocated</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>OKeyLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>key</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Debug method checks is recovery main process and recovery workers
 * transactions is synchronized.
 */</comment>
<function><type><name>Datum</name></type>
<name>orioledb_recovery_synchronized</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>ptr</name> <init>= <expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><name>recovery_ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <call><name>recovery_get_current_ptr</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <call><name>recovery_get_retain_ptr</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><name>recovery_finished_list_ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_run_xmin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OXid</name></type>		<name>xmin</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pairingheap_is_empty</name><argument_list>(<argument><expr><name>xmin_queue</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RecoveryXidState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>pairingheap_container</name><argument_list>(<argument><expr><name>RecoveryXidState</name></expr></argument>, <argument><expr><name>xmin_ph_node</name></expr></argument>,
									  <argument><expr><call><name>pairingheap_first</name><argument_list>(<argument><expr><name>xmin_queue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>xmin</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>oxid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>xmin</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>xmin</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>, <argument><expr><name>recovery_xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>runXmin</name></name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xmin</name> <operator>&lt;</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>globalXmin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>globalXmin</name></name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_run_xmin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OXid</name></type>		<name>xmin</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xmin</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>runXmin</name></name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xmin</name> <operator>&lt;</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>globalXmin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>globalXmin</name></name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Updates advanceReservedLocation for a recovery process. Searches min
 * transactionUndoRetainLocation for active transactions.
 */</comment>
<function><type><name>void</name></type>
<name>update_proc_retain_undo_location</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ODBProcData</name> <modifier>*</modifier></type><name>curProcData</name> <init>= <expr><call><name>GET_CUR_PROCDATA</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RecoveryXidState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recoveryPtr</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>,
				<decl><type ref="prev"/><name>listPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>miter</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>cur_state</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name><name>cur_state</name><operator>-&gt;</operator><name>retain_loc</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>curRetainUndoLocation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>retain_loc</name></name> <operator>=</operator> <name>curRetainUndoLocation</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>in_retain_heap</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pairingheap_add</name><argument_list>(<argument><expr><name>retain_queue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cur_state</name><operator>-&gt;</operator><name>retain_ph_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>listPtr</name> <operator>=</operator> <name>recoveryPtr</name> <operator>=</operator> <call><name>recovery_get_current_ptr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>listPtr</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><name>recovery_finished_list_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>miter</argument>, <argument>&amp;finished_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>RecoveryXidState</name></expr></argument>, <argument><expr><name>finished_list_node</name></expr></argument>, <argument><expr><name><name>miter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>ptr</name></name> <operator>&gt;</operator> <name>listPtr</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>COMMITSEQNO_IS_ABORTED</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>csn</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>set_oxid_csn</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>oxid</name></name></expr></argument>, <argument><expr><name>COMMITSEQNO_COMMITTING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextCommitSeqNo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>set_oxid_csn</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>oxid</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>csn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>set_oxid_csn</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>oxid</name></name></expr></argument>, <argument><expr><name>COMMITSEQNO_ABORTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><name><name>miter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>in_finished_list</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>check_delete_xid_state</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>worker_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><name>recovery_finished_list_ptr</name></expr></argument>, <argument><expr><name>recoveryPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Remove transactions, visible for all, from the retain queue.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pairingheap_is_empty</name><argument_list>(<argument><expr><name>retain_queue</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free_retained_undo_location</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>worker_ptrs</name><index>[<expr><name>worker_id</name></expr>]</index></name><operator>.</operator><name>retainPtr</name></expr></argument>,
								<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>worker_ptrs</name><index>[<expr><name>worker_id</name></expr>]</index></name><operator>.</operator><name>commitPtr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><name>recovery_main_retain_ptr</name></expr></argument>,
								<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><name>recovery_ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>recoveryPtr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>recoveryPtr</name> <operator>=</operator> <call><name>recovery_get_current_ptr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pairingheap_is_empty</name><argument_list>(<argument><expr><name>retain_queue</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>free_retained_undo_location</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>worker_ptrs</name><index>[<expr><name>worker_id</name></expr>]</index></name><operator>.</operator><name>retainPtr</name></expr></argument>,
									<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>worker_ptrs</name><index>[<expr><name>worker_id</name></expr>]</index></name><operator>.</operator><name>commitPtr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><name>recovery_main_retain_ptr</name></expr></argument>,
									<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><name>recovery_ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>pairingheap_container</name><argument_list>(<argument><expr><name>RecoveryXidState</name></expr></argument>, <argument><expr><name>retain_ph_node</name></expr></argument>,
									  <argument><expr><call><name>pairingheap_first</name><argument_list>(<argument><expr><name>retain_queue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>retain_loc</name></name> <operator>&gt;</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>transactionUndoRetainLocation</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curProcData</name><operator>-&gt;</operator><name>transactionUndoRetainLocation</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>retain_loc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>csn</name></name> <operator>==</operator> <name>COMMITSEQNO_ABORTED</name> <operator>||</operator>
			<operator>(</operator><call><name>COMMITSEQNO_IS_NORMAL</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>csn</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>in_finished_list</name></name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>ptr</name></name> <operator>&lt;=</operator> <name>recoveryPtr</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pairingheap_remove</name><argument_list>(<argument><expr><name>retain_queue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>retain_ph_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>in_retain_heap</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>check_delete_xid_state</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>worker_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>worker_ptrs</name><index>[<expr><name>worker_id</name></expr>]</index></name><operator>.</operator><name>retainPtr</name></expr></argument>, <argument><expr><name>recoveryPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><name>recovery_main_retain_ptr</name></expr></argument>, <argument><expr><name>recoveryPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>recovery_write_to_xids_queue</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>requestNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RecoveryXidState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>cur_state</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>undo_stack</name></name> <operator>=</operator> <call><name>get_cur_undo_locations</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>recovery_xid_state_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>state</name> <operator>=</operator> <operator>(</operator><name>RecoveryXidState</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XidFileRec</name></type>	<name>rec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>COMMITSEQNO_IS_INPROGRESS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>csn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>rec</name><operator>.</operator><name>oxid</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>oxid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rec</name><operator>.</operator><name>undoLocation</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>undo_stack</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_to_xids_queue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;state-&gt;checkpoint_undo_stacks</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CheckpointUndoStack</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>CheckpointUndoStack</name></expr></argument>,
														 <argument><expr><name>node</name></expr></argument>,
														 <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>rec</name><operator>.</operator><name>undoLocation</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>undo_stack</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>write_to_xids_queue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>recoveryMainCompletedCheckpointNumber</name></name> <operator>=</operator> <name>requestNumber</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>worker_ptrs</name><index>[<expr><name>worker_id</name></expr>]</index></name><operator>.</operator><name>flushedUndoLocCompletedCheckpointNumber</name> <operator>=</operator> <name>requestNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_undo_loc_flush_completed_number</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>single</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>completedNumber</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>completedNumber</name> <operator>=</operator> <name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>recoveryMainCompletedCheckpointNumber</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>single</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>recovery_pool_size_guc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name>completedNumber</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>completedNumber</name></expr></argument>, <argument><expr><name><name>worker_ptrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flushedUndoLocCompletedCheckpointNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>completedCheckpointNumber</name></name> <operator>=</operator> <name>completedNumber</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handles immediate undo positions flush request from checkpointer.
 */</comment>
<function><type><name>void</name></type>
<name>update_recovery_undo_loc_flush</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>single</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>myCompletedNumber</name></decl>,
				<decl><type ref="prev"/><name>requestNumber</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>requestNumber</name> <operator>=</operator> <name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>immediateRequestCheckpointNumber</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>completedCheckpointNumber</name></name> <operator>&gt;=</operator> <name>requestNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>myCompletedNumber</name> <operator>=</operator> <name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>recoveryMainCompletedCheckpointNumber</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>myCompletedNumber</name> <operator>=</operator> <name><name>worker_ptrs</name><index>[<expr><name>worker_id</name></expr>]</index></name><operator>.</operator><name>flushedUndoLocCompletedCheckpointNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Process immediate request if any.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>myCompletedNumber</name> <operator>&lt;</operator> <name>requestNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>recovery_write_to_xids_queue</name><argument_list>(<argument><expr><name>worker_id</name></expr></argument>, <argument><expr><name>requestNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>update_undo_loc_flush_completed_number</name><argument_list>(<argument><expr><name>single</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>recovery_on_proc_exit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>worker_id</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>myCompletedNumber</name></decl>,
				<decl><type ref="prev"/><name>requestNumber</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>single</name> <init>= <expr><operator>*</operator><name>recovery_single_process</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recovery_xid_state_hash</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"recovery on exit: %d"</literal></expr></argument>, <argument><expr><name>worker_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>requestNumber</name> <operator>=</operator> <name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>finishRequestCheckpointNumber</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>worker_id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>myCompletedNumber</name> <operator>=</operator> <name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>recoveryMainCompletedCheckpointNumber</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>myCompletedNumber</name> <operator>=</operator> <name><name>worker_ptrs</name><index>[<expr><name>worker_id</name></expr>]</index></name><operator>.</operator><name>flushedUndoLocCompletedCheckpointNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>completedCheckpointNumber</name></name> <operator>&gt;=</operator> <name>requestNumber</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>requestNumber</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>before_writing_xids_file</name><argument_list>(<argument><expr><name>requestNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Process immediate request if any.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>myCompletedNumber</name> <operator>&lt;</operator> <name>requestNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>recovery_write_to_xids_queue</name><argument_list>(<argument><expr><name>worker_id</name></expr></argument>, <argument><expr><name>requestNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>exitLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>update_undo_loc_flush_completed_number</name><argument_list>(<argument><expr><name>single</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>exitLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also write our xids to the last checkpoint caused by fast shutdown.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oXidQueueLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>requestNumber</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>before_writing_xids_file</name><argument_list>(<argument><expr><name>requestNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oXidQueueLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recovery_write_to_xids_queue</name><argument_list>(<argument><expr><name>worker_id</name></expr></argument>, <argument><expr><name>requestNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>exitLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>update_undo_loc_flush_completed_number</name><argument_list>(<argument><expr><name>single</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>exitLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>o_handle_startup_proc_interrupts_hook</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>is_recovery_in_progress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>update_proc_retain_undo_location</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>update_recovery_undo_loc_flush</name><argument_list>(<argument><expr><operator>*</operator><name>recovery_single_process</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>abort_recovery</name><parameter_list>(<parameter><decl><type><name>RecoveryWorkerState</name> <modifier>*</modifier></type><name>workers_pool</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_workers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_workers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>workers_pool</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>queue</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>shm_mq_detach</name><argument_list>(<argument><expr><name><name>workers_pool</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>workers_pool</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>handle</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>TerminateBackgroundWorker</name><argument_list>(<argument><expr><name><name>workers_pool</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>worker_wait_shutdown</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>workers_pool</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"orioledb recovery finished: abort recovery."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * WaitForBackgroundWorkerShutdown() does not work in this context. We need
 * an analog.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>worker_wait_shutdown</name><parameter_list>(<parameter><decl><type><name>RecoveryWorkerState</name> <modifier>*</modifier></type><name>worker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BgwHandleStatus</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>not_used</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>worker</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>handle</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>GetBackgroundWorkerPid</name><argument_list>(<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>not_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>BGWH_POSTMASTER_DIED</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>status</name> <operator>==</operator> <name>BGWH_STOPPED</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">200</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>recovery_cleanup_old_files</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>chkp_num</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>before_recovery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>ext</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>before_recovery</name> <operator>&amp;&amp;</operator> <name>chkp_num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name>ORIOLEDB_DATA_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><operator>(</operator><name>file</name> <operator>=</operator> <call><name>readdir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>file_datoid</name></decl>,
					<decl><type ref="prev"/><name>file_reloid</name></decl>,
					<decl><type ref="prev"/><name>file_chkp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>cleanup</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"%10u_%10u-%10u.%4s"</literal></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>file_datoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_reloid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_chkp</name></expr></argument>, <argument><expr><name>ext</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">4</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>before_recovery</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Before recovery We should cleanup: 1. All *.evt files. 2.
				 * *.map and *.tmp files which were not created by
				 * checkpointer. 3. All free extents tree files.
				 *
				 * Otherwise: 1. BTree will be loaded from evicted state, not
				 * from checkpoint state. 2. In some cases wrong *.map files
				 * will be created. (if size of old *.map or *.tmp file is
				 * more than will be created by checkpointer).
				 */</comment>
				<expr_stmt><expr><name>cleanup</name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><name>ORIOLEDB_EVT_EXTENSION</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cleanup</name> <operator>&amp;&amp;</operator> <name>file_chkp</name> <operator>&gt;</operator> <name>chkp_num</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>cleanup</name> <operator>=</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"tmp"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"map"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cleanup</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ORelOids</name></type>	<name>oids</name> <init>= <expr><block>{<expr><name>file_datoid</name></expr>, <expr><name>file_reloid</name></expr>, <expr><name>file_reloid</name></expr>}</block></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>cleanup</name> <operator>=</operator> <call><name>IS_SYS_TREE_OIDS</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>sys_tree_get_storage_type</name><argument_list>(<argument><expr><name><name>oids</name><operator>.</operator><name>relnode</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BTreeStorageTemporary</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * After recovery we should cleanup old *.tmp and *.map files.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>file_chkp</name> <operator>&lt;</operator> <name>chkp_num</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>cleanup</name> <operator>=</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"tmp"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"map"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>file_chkp</name> <operator>==</operator> <name>chkp_num</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>cleanup</name> <operator>=</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"tmp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>before_recovery</name> <operator>&amp;&amp;</operator>
				 <call><name>sscanf</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"%10u_%10u"</literal></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>file_datoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_reloid</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Removes free extents tree data files.
			 */</comment>
			<decl_stmt><decl><type><name>ORelOids</name></type>	<name>oids</name> <init>= <expr><block>{<expr><name>file_datoid</name></expr>, <expr><name>file_reloid</name></expr>, <expr><name>file_reloid</name></expr>}</block></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>cleanup</name> <operator>=</operator> <call><name>IS_SYS_TREE_OIDS</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>sys_tree_get_storage_type</name><argument_list>(<argument><expr><name><name>oids</name><operator>.</operator><name>relnode</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BTreeStorageTemporary</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>cleanup</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><name>ORIOLEDB_DATA_DIR</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>durable_unlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to clean up temporary files"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ORelOids</name> <modifier>*</modifier></type>
<name>o_indices_get_oids</name><parameter_list>(<parameter><decl><type><name>Pointer</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>ORelOids</name> <modifier>*</modifier></type><name>tableOids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexChunk</name></type> <name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ORelOids</name>   <modifier>*</modifier></type><name>treeOids</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunk</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>OIndexChunk</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>.</operator><name>key</name><operator>.</operator><name>offset</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunk</name><operator>.</operator><name>dataLength</name></name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tableOids</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tableOids</name></expr></argument>, <argument><expr><name>tuple</name> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>OIndexChunk</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tableOids</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>treeOids</name> <operator>=</operator> <operator>(</operator><name>ORelOids</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>CurTransactionContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ORelOids</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>treeOids</name> <operator>=</operator> <name><name>chunk</name><operator>.</operator><name>key</name><operator>.</operator><name>oids</name></name></expr>;</expr_stmt>

	<return>return <expr><name>treeOids</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Replays a single orioledb WAL container.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>replay_container</name><parameter_list>(<parameter><decl><type><name>Pointer</name></type> <name>startPtr</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>endPtr</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>single</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>xlogRecPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>indexDescr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name> <init>= <expr><name>InvalidOXid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ORelOids</name></type>	<name>cur_oids</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>,
				<decl><type ref="prev"/><name>tmp_oids</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>treeOids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>length</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>success</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>rec_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sys_tree_num</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>ptr</name> <init>= <expr><name>startPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>xlogPtr</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>endPtr</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>xlogPtr</name> <operator>=</operator> <name>xlogRecPtr</name> <operator>+</operator> <operator>(</operator><name>ptr</name> <operator>-</operator> <name>startPtr</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>rec_type</name> <operator>=</operator> <operator>*</operator><name>ptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rec_type</name> <operator>==</operator> <name>WAL_REC_XID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oxid</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>oxid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>oxid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>advance_oxids</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>recovery_switch_to_oxid</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>rec_type</name> <operator>==</operator> <name>WAL_REC_COMMIT</name> <operator>||</operator> <name>rec_type</name> <operator>==</operator> <name>WAL_REC_ROLLBACK</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>commit</name></decl>,
						<decl><type ref="prev"/><name>sync</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OXid</name></type>		<name>xmin</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xmin</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

			<expr_stmt><expr><name>recovery_xmin</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>recovery_xmin</name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sys_tree_num</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>sys_tree_supports_transactions</name><argument_list>(<argument><expr><name>sys_tree_num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>commit</name> <operator>=</operator> <operator>(</operator><name>rec_type</name> <operator>==</operator> <name>WAL_REC_COMMIT</name><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oxid</name> <operator>!=</operator> <name>InvalidOXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>single</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cur_state</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>workers_send_oxid_finish</name><argument_list>(<argument><expr><name>xlogPtr</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>cur_state</name><operator>-&gt;</operator><name>systree_modified</name></name> <operator>||</operator> <name><name>cur_state</name><operator>-&gt;</operator><name>checkpoint_xid</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>sync</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>workers_synchronize</name><argument_list>(<argument><expr><name>xlogPtr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>sync</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><name>recovery_ptr</name></expr></argument>, <argument><expr><name>xlogPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>recovery_finish_current_oxid</name><argument_list>(<argument><expr><ternary><condition><expr><name>commit</name></expr> ?</condition><then> <expr><name>COMMITSEQNO_MAX_NORMAL</name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>COMMITSEQNO_ABORTED</name></expr></else></ternary></expr></argument>,
										 <argument><expr><name>xlogPtr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>oxid</name> <operator>=</operator> <name>InvalidOXid</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>rec_type</name> <operator>==</operator> <name>WAL_REC_JOINT_COMMIT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OXid</name></type>		<name>xmin</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xid</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xmin</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>recovery_xmin</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>recovery_xmin</name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name>joint_commit_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cur_state</name><operator>-&gt;</operator><name>joint_commit_list_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>rec_type</name> <operator>==</operator> <name>WAL_REC_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OIndexType</name></type>	<name>ix_type</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ix_type</name> <operator>=</operator> <operator>*</operator><name>ptr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cur_oids</name><operator>.</operator><name>datoid</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cur_oids</name><operator>.</operator><name>reloid</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cur_oids</name><operator>.</operator><name>relnode</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IS_SYS_TREE_OIDS</name><argument_list>(<argument><expr><name>cur_oids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sys_tree_num</name> <operator>=</operator> <name><name>cur_oids</name><operator>.</operator><name>relnode</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>sys_tree_num</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>sys_tree_num</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>descr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>indexDescr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>sys_tree_get_storage_type</name><argument_list>(<argument><expr><name>sys_tree_num</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BTreeStoragePersistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>ix_type</name> <operator>==</operator> <name>oIndexInvalid</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>o_fetch_table_descr</name><argument_list>(<argument><expr><name>cur_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>indexDescr</name> <operator>=</operator> <ternary><condition><expr><name>descr</name></expr> ?</condition><then> <expr><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>descr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>indexDescr</name> <operator>=</operator> <call><name>o_fetch_index_descr</name><argument_list>(<argument><expr><name>cur_oids</name></expr></argument>, <argument><expr><name>ix_type</name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>rec_type</name> <operator>==</operator> <name>WAL_REC_INVALIDATE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ORelOids</name></type>	<name>oids</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>old_relnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oids</name><operator>.</operator><name>datoid</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oids</name><operator>.</operator><name>reloid</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_relnode</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oids</name><operator>.</operator><name>relnode</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>recreate_table_descr_by_oids</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>sys_tree_num</name> <operator>==</operator> <name>SYS_TREES_O_TABLES</name> <operator>&amp;&amp;</operator> <name>reachedConsistency</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OTable</name>	   <modifier>*</modifier></type><name>new_o_table</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>OTable</name>	   <modifier>*</modifier></type><name>old_o_table</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>old_descr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>OIndexNumber</name></type> <name>ix_num</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>uint16</name></type>		<name>nindices</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>new_o_table</name> <operator>=</operator> <call><name>o_tables_get</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_o_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>oids</name><operator>.</operator><name>relnode</name></name> <operator>==</operator> <name>old_relnode</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>uint32</name></type>		<name>version</name> <init>= <expr><name><name>new_o_table</name><operator>-&gt;</operator><name>version</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>old_o_table</name> <operator>=</operator> <call><name>o_tables_get_by_oids_and_version</name><argument_list>(<argument><expr><name>oids</name></expr></argument>,
																   <argument><expr><operator>&amp;</operator><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>ORelOids</name></type>	<name>old_oids</name> <init>= <expr><name>oids</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>old_oids</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name>old_relnode</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>old_o_table</name> <operator>=</operator> <call><name>o_tables_get</name><argument_list>(<argument><expr><name>old_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>old_o_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>nindices</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>old_o_table</name><operator>-&gt;</operator><name>nindices</name></name></expr></argument>, <argument><expr><name><name>new_o_table</name><operator>-&gt;</operator><name>nindices</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>ix_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ix_num</name> <operator>&lt;</operator> <name>nindices</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>ix_num</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ORelOidsIsEqual</name><argument_list>(<argument><expr><name><name>old_o_table</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>ix_num</name></expr>]</index></name><operator>.</operator><name>oids</name></expr></argument>,
										 <argument><expr><name><name>new_o_table</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>ix_num</name></expr>]</index></name><operator>.</operator><name>oids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block></for>

				<if_stmt><if>if <condition>(<expr><name><name>new_o_table</name><operator>-&gt;</operator><name>nindices</name></name> <operator>&gt;</operator> <name><name>old_o_table</name><operator>-&gt;</operator><name>nindices</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>OTableDescr</name></type> <name>tmp_descr</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>o_fill_tmp_table_descr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_descr</name></expr></argument>, <argument><expr><name>new_o_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>new_o_table</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>ix_num</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>oIndexPrimary</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>tbl_data_exists</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>old_o_table</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>old_descr</name> <operator>=</operator> <call><name>o_fetch_table_descr</name><argument_list>(<argument><expr><name><name>old_o_table</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>rebuild_indices</name><argument_list>(<argument><expr><name>old_o_table</name></expr></argument>, <argument><expr><name>old_descr</name></expr></argument>,
											<argument><expr><name>new_o_table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>build_secondary_index</name><argument_list>(<argument><expr><name>new_o_table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_descr</name></expr></argument>, <argument><expr><name>ix_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<expr_stmt><expr><call><name>o_free_tmp_table_descr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>new_o_table</name><operator>-&gt;</operator><name>nindices</name></name> <operator>&lt;</operator> <name><name>old_o_table</name><operator>-&gt;</operator><name>nindices</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>old_o_table</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>ix_num</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>oIndexPrimary</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>OTableDescr</name></type> <name>tmp_descr</name></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>o_fill_tmp_table_descr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_descr</name></expr></argument>, <argument><expr><name>new_o_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>old_descr</name> <operator>=</operator> <call><name>o_fetch_table_descr</name><argument_list>(<argument><expr><name><name>old_o_table</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>rebuild_indices</name><argument_list>(<argument><expr><name>old_o_table</name></expr></argument>, <argument><expr><name>old_descr</name></expr></argument>,
										<argument><expr><name>new_o_table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>o_free_tmp_table_descr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>old_o_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_o_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>rec_type</name> <operator>==</operator> <name>WAL_REC_SAVEPOINT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parentSubid</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SubTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SubTransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>recovery_savepoint</name><argument_list>(<argument><expr><name>parentSubid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>single</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>workers_send_savepoint</name><argument_list>(<argument><expr><name>parentSubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>rec_type</name> <operator>==</operator> <name>WAL_REC_ROLLBACK_TO_SAVEPOINT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parentSubid</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SubTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SubTransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>single</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>workers_send_rollback_to_savepoint</name><argument_list>(<argument><expr><name>xlogPtr</name></expr></argument>, <argument><expr><name>parentSubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>workers_synchronize</name><argument_list>(<argument><expr><name>xlogPtr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>recovery_rollback_to_savepoint</name><argument_list>(<argument><expr><name>parentSubid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>OFixedTuple</name></type> <name>tuple</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rec_type</name> <operator>==</operator> <name>WAL_REC_INSERT</name> <operator>||</operator> <name>rec_type</name> <operator>==</operator> <name>WAL_REC_UPDATE</name> <operator>||</operator> <name>rec_type</name> <operator>==</operator> <name>WAL_REC_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>tuple</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <operator>*</operator><name>ptr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>tuple</name><operator>.</operator><name>fixedData</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>tuple</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name><name>tuple</name><operator>.</operator><name>fixedData</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>recovery_msg_from_wal_record</name><argument_list>(<argument><expr><name>rec_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oxid</name> <operator>!=</operator> <name>InvalidOXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>sys_tree_num</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>sys_tree_supports_transactions</name><argument_list>(<argument><expr><name>sys_tree_num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>recovery_switch_to_oxid</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>systree_modified</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>single</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>workers_synchronize</name><argument_list>(<argument><expr><name>xlogPtr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>apply_sys_tree_modify_record</name><argument_list>(<argument><expr><name>sys_tree_num</name></expr></argument>, <argument><expr><name>type</name></expr></argument>,
													   <argument><expr><name><name>tuple</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>,
													   <argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>sys_tree_num</name> <operator>==</operator> <name>SYS_TREES_O_INDICES</name> <operator>&amp;&amp;</operator> <name>success</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>RECOVERY_DELETE</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>treeOids</name> <operator>=</operator> <call><name>o_indices_get_oids</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>treeOids</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>add_undo_drop_relnode</name><argument_list>(<argument><expr><name>tmp_oids</name></expr></argument>, <argument><expr><name>treeOids</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>RECOVERY_INSERT</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>treeOids</name> <operator>=</operator> <call><name>o_indices_get_oids</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>treeOids</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>add_undo_create_relnode</name><argument_list>(<argument><expr><name>tmp_oids</name></expr></argument>, <argument><expr><name>treeOids</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>RECOVERY_UPDATE</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>treeOids</name> <operator>=</operator> <call><name>o_indices_get_oids</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>treeOids</name> <operator>&amp;&amp;</operator> <call><name>ORelOidsIsEqual</name><argument_list>(<argument><expr><operator>*</operator><name>treeOids</name></expr></argument>, <argument><expr><name>tmp_oids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>recreate_table_descr_by_oids</name><argument_list>(<argument><expr><operator>*</operator><name>treeOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>sys_tree_num</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>indexDescr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* nothing to do here */</comment>
				<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>single</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>recovery_switch_to_oxid</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>apply_modify_record</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>indexDescr</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>spread_idx_modify</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>indexDescr</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>update_recovery_undo_loc_flush</name><argument_list>(<argument><expr><name>single</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Hook for replaying builtin commit record.  Performs joint commit.
 */</comment>
<function><type><name>void</name></type>
<name>o_xact_redo_hook</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>miter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>single</name> <init>= <expr><operator>*</operator><name>recovery_single_process</name></expr></init></decl>;</decl_stmt>

	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>miter</argument>, <argument>&amp;joint_commit_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RecoveryXidState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>sync</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>RecoveryXidState</name></expr></argument>, <argument><expr><name>joint_commit_list_node</name></expr></argument>, <argument><expr><name><name>miter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>xid</name></name> <operator>!=</operator> <name>xid</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>recovery_switch_to_oxid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>oxid</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>single</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cur_state</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>workers_send_oxid_finish</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>cur_state</name><operator>-&gt;</operator><name>systree_modified</name></name> <operator>||</operator> <name><name>cur_state</name><operator>-&gt;</operator><name>checkpoint_xid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>sync</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>workers_synchronize</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>sync</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><name>recovery_ptr</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><name><name>miter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recovery_finish_current_oxid</name><argument_list>(<argument><expr><name>COMMITSEQNO_MAX_NORMAL</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
									 <argument><expr><name>lsn</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Sends the message to a worker.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>worker_send_msg</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>msg</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>msg_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecoveryWorkerState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>&amp;</operator><name><name>workers_pool</name><index>[<expr><name>worker_id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>RECOVERY_QUEUE_BUF_SIZE</name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name><operator>)</operator> <operator>&lt;</operator> <name>msg_size</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>worker_queue_flush</name><argument_list>(<argument><expr><name>worker_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>queue_buf</name></name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>msg_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name> <operator>+=</operator> <name>msg_size</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Sends modify message to a worker.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>worker_send_modify</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>, <parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>recType</name></decl></parameter>,
				   <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tuple_len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecoveryMsgHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RecoveryWorkerState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>&amp;</operator><name><name>workers_pool</name><index>[<expr><name>worker_id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_msg_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ORelOids</name></type>	<name>oids</name> <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexType</name></type>	<name>type</name> <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>type</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>wal</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_SYS_TREE_OIDS</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>oIndexPrimary</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>id</name> <init>= <expr><operator>(</operator><name>OIndexDescr</name> <operator>*</operator><operator>)</operator> <name><name>desc</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>oids</name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>tableOids</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <name>oIndexInvalid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>max_msg_size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RecoveryMsgHeader</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OXid</name></expr></argument>)</argument_list></sizeof>
							<operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ORelOids</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal>
							<operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>tuple_len</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>recType</name> <operator>&amp;</operator> <name>RECOVERY_MODIFY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>RECOVERY_QUEUE_BUF_SIZE</name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name> <operator>&lt;</operator> <name>max_msg_size</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>worker_queue_flush</name><argument_list>(<argument><expr><name>worker_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>queue_buf</name></name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>RecoveryMsgHeader</name> <operator>*</operator><operator>)</operator> <name>data</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>recType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RecoveryMsgHeader</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RecoveryMsgHeader</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>oxid</name></name> <operator>!=</operator> <name><name>cur_state</name><operator>-&gt;</operator><name>oxid</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cur_state</name><operator>-&gt;</operator><name>oxid</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OXid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OXid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OXid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>type</name></name> <operator>|=</operator> <name>RECOVERY_MODIFY_OXID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>oxid</name></name> <operator>=</operator> <name><name>cur_state</name><operator>-&gt;</operator><name>oxid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cur_state</name><operator>-&gt;</operator><name>used_by</name><index>[<expr><name>worker_id</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ORelOidsIsEqual</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>, <argument><expr><name>oids</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>type</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oids</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ORelOids</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ORelOids</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>data</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ORelOids</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>type</name></name> <operator>|=</operator> <name>RECOVERY_MODIFY_OIDS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>oids</name></name> <operator>=</operator> <name>oids</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>.</operator><name>formatFlags</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>queue_buf</name></name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>tuple_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name> <operator>+=</operator> <name>tuple_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Sends recovery finish message to all workers in the pool.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>workers_send_finish</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecoveryMsgEmpty</name></type> <name>finish_msg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RecoveryWorkerState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>recovery_pool_size_guc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>&amp;</operator><name><name>workers_pool</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>finish_msg</name><operator>.</operator><name>header</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>RECOVERY_FINISHED</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>RECOVERY_QUEUE_BUF_SIZE</name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RecoveryMsgEmpty</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>worker_queue_flush</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>queue_buf</name></name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>finish_msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RecoveryMsgEmpty</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RecoveryMsgEmpty</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>worker_queue_flush</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Sends savepoint message to workers with active the oxid in the pool.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>workers_send_savepoint</name><parameter_list>(<parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecoveryWorkerState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RecoveryMsgSavepoint</name></type> <name>msg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cur_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>header</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>RECOVERY_SAVEPOINT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>oxid</name></name> <operator>=</operator> <name><name>cur_state</name><operator>-&gt;</operator><name>oxid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>parentSubId</name></name> <operator>=</operator> <name>parentSubId</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>recovery_pool_size_guc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>cur_state</name><operator>-&gt;</operator><name>used_by</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>&amp;</operator><name><name>workers_pool</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>oxid</name></name> <operator>==</operator> <name><name>cur_state</name><operator>-&gt;</operator><name>oxid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>oxid</name></name> <operator>=</operator> <name>InvalidOXid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>worker_send_msg</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>EnableHotStandby</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* we need to apply recovery records as fast as we can */</comment>
				<expr_stmt><expr><call><name>worker_queue_flush</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Sends rollback to savepoint message to workers with active the oxid in the pool.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>workers_send_rollback_to_savepoint</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>,
								   <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecoveryWorkerState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RecoveryMsgRollbackToSavepoint</name></type> <name>msg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cur_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>header</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>RECOVERY_ROLLBACK_TO_SAVEPOINT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>oxid</name></name> <operator>=</operator> <name><name>cur_state</name><operator>-&gt;</operator><name>oxid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>parentSubId</name></name> <operator>=</operator> <name>parentSubId</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>recovery_pool_size_guc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>cur_state</name><operator>-&gt;</operator><name>used_by</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>&amp;</operator><name><name>workers_pool</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>oxid</name></name> <operator>==</operator> <name><name>cur_state</name><operator>-&gt;</operator><name>oxid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>oxid</name></name> <operator>=</operator> <name>InvalidOXid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>worker_send_msg</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>EnableHotStandby</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* we need to apply recovery records as fast as we can */</comment>
				<expr_stmt><expr><call><name>worker_queue_flush</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><name>recovery_ptr</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Sends commit or rollback message to workers with active the oxid in the pool.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>workers_send_oxid_finish</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>commit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecoveryWorkerState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RecoveryMsgOXidPtr</name></type> <name>oxid_ptr_record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>oxid_ptr_record</name><operator>.</operator><name>header</name><operator>.</operator><name>type</name></name> <operator>=</operator> <ternary><condition><expr><name>commit</name></expr> ?</condition><then> <expr><name>RECOVERY_COMMIT</name></expr> </then><else>: <expr><name>RECOVERY_ROLLBACK</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oxid_ptr_record</name><operator>.</operator><name>oxid</name></name> <operator>=</operator> <name><name>cur_state</name><operator>-&gt;</operator><name>oxid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oxid_ptr_record</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>recovery_pool_size_guc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>cur_state</name><operator>-&gt;</operator><name>used_by</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>&amp;</operator><name><name>workers_pool</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>oxid</name></name> <operator>==</operator> <name><name>cur_state</name><operator>-&gt;</operator><name>oxid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>oxid</name></name> <operator>=</operator> <name>InvalidOXid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>worker_send_msg</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>oxid_ptr_record</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>oxid_ptr_record</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>EnableHotStandby</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* we need to apply recovery records as fast as we can */</comment>
				<expr_stmt><expr><call><name>worker_queue_flush</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><name>recovery_ptr</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Synchronize execution with workers.
 *
 * Actually used only before delete a relnode. We can hold a list of relnodes
 * used by workers and synchronize only with needed workers. But we assume that
 * it does not happen too often and we can use this simple solution.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>workers_synchronize</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>send_synchronize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>send_synchronize</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RecoveryMsgPtr</name></type> <name>sync_msg</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>sync_msg</name><operator>.</operator><name>header</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>RECOVERY_SYNCHRONIZE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sync_msg</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>recovery_pool_size_guc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>worker_send_msg</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>sync_msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sync_msg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>worker_queue_flush</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><name>recovery_ptr</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>recovery_pool_size_guc</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>unexpected_worker_detach</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<while>while <condition>(<expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>worker_ptrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>commitPtr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>ptr</name> <operator>&amp;&amp;</operator>
			   <name><name>workers_pool</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>queue</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BgwHandleStatus</name></type> <name>status</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>pid_t</name></type>		<name>pid</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>%</operator> <literal type="number">100</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>GetBackgroundWorkerPid</name><argument_list>(<argument><expr><name><name>workers_pool</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>BGWH_STARTED</name> <operator>&amp;&amp;</operator> <name>status</name> <operator>!=</operator> <name>BGWH_NOT_YET_STARTED</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>unexpected_worker_detach</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * Notify workers that toast reached consistent state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>workers_notify_toast_consistent</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecoveryMsgEmpty</name></type> <name>msg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>header</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>RECOVERY_TOAST_CONSISTENT</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>recovery_pool_size_guc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>worker_send_msg</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>worker_queue_flush</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Flushes a queue buffer to the queue.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>worker_queue_flush</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecoveryWorkerState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>&amp;</operator><name><name>workers_pool</name><index>[<expr><name>worker_id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shm_mq_result</name></type> <name>result</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">150000</literal></expr></cpp:if>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>shm_mq_send</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>queue_buf</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>shm_mq_send</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>queue_buf</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>queue_buf_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result</name> <operator>!=</operator> <name>SHM_MQ_WOULD_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>SHM_MQ_DETACHED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>unexpected_worker_detach</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result</name> <operator>==</operator> <name>SHM_MQ_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Applies recovery record to o_tables.
 *
 * We do it by master process to avoid concurrent issues such as:
 *
 * Worker can not fetch table description because another worker does not
 * commit transaction yet.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>apply_sys_tree_modify_record</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sys_tree_num</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tup</name></decl></parameter>,
							 <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>apply_btree_modify_record</name><argument_list>(<argument><expr><call><name>get_sys_tree</name><argument_list>(<argument><expr><name>sys_tree_num</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>type</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Spreads the index modify recovery record to the recovery workers pool.
 *
 * Tuples with a same key will be processed by a same worker. This approach
 * helps to apply recovery records for tuples in the right order.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>spread_idx_modify</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>recType</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>rec</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTuple</name>		<name>key</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>key_len</name></decl>,
				<decl><type ref="prev"/><name>tup_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>		<name>key_pfree</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>recType</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RECOVERY_INSERT</name></expr>:</case>
		<case>case <expr><name>RECOVERY_UPDATE</name></expr>:</case>
			<expr_stmt><expr><name>tup_len</name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>OTupleLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>o_btree_hash</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
			<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>o_btree_tuple_make_key</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key_pfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>hash</name> <operator>==</operator> <call><name>o_btree_hash</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>key_pfree</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>worker_send_modify</name><argument_list>(<argument><expr><call><name>GET_WORKER_ID</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>desc</name></expr></argument>,
							   <argument><expr><name>recType</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>tup_len</name></expr></argument>, <argument><expr><name>wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RECOVERY_DELETE</name></expr>:</case>
			<expr_stmt><expr><name>key_len</name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>OKeyLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>o_btree_hash</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>worker_send_modify</name><argument_list>(<argument><expr><call><name>GET_WORKER_ID</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>recType</name></expr></argument>,
							   <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>, <argument><expr><name>wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Converts wal record type to recovery message type.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint16</name></type>
<name>recovery_msg_from_wal_record</name><parameter_list>(<parameter><decl><type><name>uint8</name></type> <name>wal_record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>wal_record</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>WAL_REC_INSERT</name></expr>:</case>
			<return>return <expr><name>RECOVERY_INSERT</name></expr>;</return>
		<case>case <expr><name>WAL_REC_DELETE</name></expr>:</case>
			<return>return <expr><name>RECOVERY_DELETE</name></expr>;</return>
		<case>case <expr><name>WAL_REC_UPDATE</name></expr>:</case>
			<return>return <expr><name>RECOVERY_UPDATE</name></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Wrong WAL record modify type %d"</literal></expr></argument>, <argument><expr><name>wal_record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<return>return <expr><operator>(</operator><name>uint16</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>			<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>
</unit>
