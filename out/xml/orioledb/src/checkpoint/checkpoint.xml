<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/checkpoint/checkpoint.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * checkpoint.c
 *		Routines for making checkpoints.
 *
 * Copyright (c) 2021-2022, Oriole DB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/checkpoint/checkpoint.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/insert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/merge.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/page_chunks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/free_extents.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/o_indices.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/o_tables.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/o_sys_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/sys_trees.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"checkpoint/checkpoint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"recovery/internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"recovery/recovery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tableam/toast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transam/oxid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transam/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/page_pool.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/seq_buf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/stopevent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ucm.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONTROL_FILENAME</name></cpp:macro> <cpp:value>ORIOLEDB_DATA_DIR"/control"</cpp:value></cpp:define>

<comment type="block">/*
 * Single action in B-tree checkpoint loop.
 */</comment>
<typedef>typedef <type><enum>enum <name>WalkAction</name>
<block>{
	<decl><name>WalkUpwards</name></decl>,
	<decl><name>WalkDownwards</name></decl>,
	<decl><name>WalkContinue</name></decl>
}</block></enum></type> <name>WalkAction</name>;</typedef>

<typedef>typedef <type><struct>struct <name>WalkMessage</name>
<block>{
	<comment type="block">/* current action */</comment>
	<decl_stmt><decl><type><name>WalkAction</name></type>	<name>action</name></decl>;</decl_stmt>
	<union>union
	<block>{
		<struct>struct
		<block>{
			<comment type="block">/* is we must mark upward page as dirty */</comment>
			<decl_stmt><decl><type><name>bool</name></type>		<name>parentDirty</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * disk downlink to a written page, InvalidODiskDownlink if page
			 * was not written to disk
			 */</comment>
			<decl_stmt><decl><type><name>uint64</name></type>		<name>diskDownlink</name></decl>;</decl_stmt>
			<comment type="block">/* will be copied to upward level if needed */</comment>
			<decl_stmt><decl><type><name>NextKeyType</name></type> <name>nextkeyType</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OFixedKey</name></type>	<name>nextkey</name></decl>;</decl_stmt>
			<comment type="block">/* is current internal tuple must be saved on image */</comment>
			<decl_stmt><decl><type><name>bool</name></type>		<name>saveTuple</name></decl>;</decl_stmt>
		}</block>			<decl><name>upwards</name></decl>;</struct>
		<struct>struct
		<block>{
			<comment type="block">/* page to process */</comment>
			<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>pageChangeCount</name></decl>;</decl_stmt>
			<comment type="block">/* lokey of downwards page */</comment>
			<decl_stmt><decl><type><name>OFixedKey</name></type>	<name>lokey</name></decl>;</decl_stmt>
		}</block>			<decl><name>downwards</name></decl>;</struct>
	}</block>			<decl><name>content</name></decl>;</union>
}</block></struct></type> <name>WalkMessage</name>;</typedef>

<typedef>typedef <type><struct>struct <name>CheckpointWriteBack</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>isCompressed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>extentsNumber</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>extentsAllocated</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>checkpointFlags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>extents</name></decl>;</decl_stmt>
}</block></struct></type> <name>CheckpointWriteBack</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>ORelOids</name></type>	<name>oids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexType</name></type>	<name>type</name></decl>;</decl_stmt>
}</block></struct></type> <name>IndexIdItem</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cleanupMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>freeExtents</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>
}</block></struct></type> <name>CheckpointTablesArg</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>extents</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>allocated</name></decl>;</decl_stmt>
}</block></struct></type> <name>FileExtentsArray</name>;</typedef>

<comment type="block">/*
 * For a checkpoint image we can add only hikey
 * or downlink to the end of the image.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>StackImageAddHikey</name></decl>,
	<decl><name>StackImageAddDownlink</name></decl>
}</block></enum></type> <name>StackImageAddType</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>UndoStackItem</name></type> <name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>lock</name></decl>;</decl_stmt>			<comment type="block">/* true for lock, false for unlock */</comment>
}</block></struct></type> <name>SysTreesLockUndoStackItem</name>;</typedef>

<decl_stmt><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>checkpoint_state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>chkp_mem_context</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>xidFilename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>xidFileCheckpointnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>File</name></type> <name>xidFile</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_writeback</name><parameter_list>(<parameter><decl><type><name>CheckpointWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isCompressed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>writeback_put_extent</name><parameter_list>(<parameter><decl><type><name>CheckpointWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>, <parameter><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>perform_writeback</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>CheckpointWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>free_writeback</name><parameter_list>(<parameter><decl><type><name>CheckpointWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>write_checkpoint_control</name><parameter_list>(<parameter><decl><type><name>CheckpointControl</name> <modifier>*</modifier></type><name>control</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>append_file_contents</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>target</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>source_filename</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>finalize_chkp_map</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>chkp_file</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>len</name></decl></parameter>,
								<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>input_filename</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>input_offset</name></decl></parameter>,
								<parameter><decl><type><name>uint32</name></type> <name>input_num</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>uint32_offsets_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>file_extents_len_off_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>file_extents_off_len_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>file_extents_writeback_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sort_checkpoint_map_file</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cur_chkp_index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sort_checkpoint_tmp_file</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cur_chkp_index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>checkpoint_ix_init_state</name><parameter_list>(<parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkpoint_temporary_tree</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>checkpoint_ix</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>checkpoint_btree</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier><modifier>*</modifier></type><name>descrPtr</name></decl></parameter>, <parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
							   <parameter><decl><type><name>CheckpointWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Jsonb</name> <modifier>*</modifier></type><name>prepare_checkpoint_step_params</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>,
											 <parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>chkpState</name></decl></parameter>,
											 <parameter><decl><type><name>WalkMessage</name> <modifier>*</modifier></type><name>message</name></decl></parameter>,
											 <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>checkpoint_btree_loop</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier><modifier>*</modifier></type><name>descrPtr</name></decl></parameter>, <parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
									<parameter><decl><type><name>CheckpointWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>,
									<parameter><decl><type><name>MemoryContext</name></type> <name>tmp_context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkpoint_internal_pass</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
									 <parameter><decl><type><name>CheckpointWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>WalkMessage</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prepare_leaf_page</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkpoint_lock_page</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
								 <parameter><decl><type><name>OInMemoryBlkno</name> <modifier>*</modifier></type><name>blkno</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>page_chage_count</name></decl></parameter>,
								 <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkpoint_tables_callback</name><parameter_list>(<parameter><decl><type><name>OIndexType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>ORelOids</name></type> <name>treeOids</name></decl></parameter>,
									   <parameter><decl><type><name>ORelOids</name></type> <name>tableOids</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>init_seq_buf_pages</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>SeqBufDescShared</name> <modifier>*</modifier></type><name>shared</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>free_seq_buf_pages</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>SeqBufDescShared</name> <modifier>*</modifier></type><name>shared</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>FileExtentsArray</name> <modifier>*</modifier></type><name>file_extents_array_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>file_extents_array_free</name><parameter_list>(<parameter><decl><type><name>FileExtentsArray</name> <modifier>*</modifier></type><name>array</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>file_extents_array_append</name><parameter_list>(<parameter><decl><type><name>FileExtentsArray</name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>foreach_extent_append</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>FileExtent</name></type> <name>extent</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>checkpoint_reset_stack</name><parameter_list>(<parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>chkp_inc_changecount_before</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ORIOLEDB_MAX_DEPTH</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>blkno</name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hikeyBlkno</name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>leftmost</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bound</name> <operator>=</operator> <name>CheckpointBoundNone</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>autonomousTupleExist</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>autonomous</name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>image</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>==</operator> <name>NextKeyNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>autonomousLevel</name></name></expr></argument>, <argument><expr><name>ORIOLEDB_MAX_DEPTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>chkp_inc_changecount_after</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Size</name></type>
<name>checkpoint_shmem_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>CheckpointState</name></expr></argument>, <argument><expr><name>xidRecQueue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XidFileRec</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>XID_RECS_QUEUE_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>checkpoint_shmem_init</name><parameter_list>(<parameter><decl><type><name>Pointer</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>found</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>checkpoint_state</name> <operator>=</operator> <operator>(</operator><name>CheckpointState</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>controlFile</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CheckpointControl</name></type> <name>control</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pg_crc32c</name></type>	<name>crc</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>checkpoint_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>curKeyType</name></name> <operator>=</operator> <name>CurKeyFinished</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name>InvalidPid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>mmapDataLength</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>autonomousLevel</name></name></expr></argument>, <argument><expr><name>ORIOLEDB_MAX_DEPTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>lastUsedLocation</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>advanceReservedLocation</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writeInProgressLocation</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writtenLocation</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>lastUsedUndoLocationWhenUpdatedMinLocation</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcRetainLocation</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcTransactionRetainLocation</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcReservedLocation</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>cleanedLocation</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>checkpointRetainStartLocation</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>checkpointRetainEndLocation</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>cleanedCheckpointStartLocation</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>cleanedCheckpointEndLocation</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>, <argument><expr><name>FirstNormalTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>runXmin</name></name></expr></argument>, <argument><expr><name>FirstNormalTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>globalXmin</name></name></expr></argument>, <argument><expr><name>FirstNormalTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>lastXidWhenUpdatedGlobalXmin</name></name></expr></argument>, <argument><expr><name>FirstNormalTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>writtenXmin</name></name></expr></argument>, <argument><expr><name>FirstNormalTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>writeInProgressXmin</name></name></expr></argument>, <argument><expr><name>FirstNormalTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>checkpointRetainXmin</name></name></expr></argument>, <argument><expr><name>FirstNormalTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>checkpointRetainXmax</name></name></expr></argument>, <argument><expr><name>FirstNormalTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>cleanedXmin</name></name></expr></argument>, <argument><expr><name>FirstNormalTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>cleanedCheckpointXmin</name></name></expr></argument>, <argument><expr><name>FirstNormalTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>cleanedCheckpointXmax</name></name></expr></argument>, <argument><expr><name>FirstNormalTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>checkpoint_reset_stack</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oTablesAddTrancheId</name></name> <operator>=</operator> <call><name>LWLockNewTrancheId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oSysTreesTrancheId</name></name> <operator>=</operator> <call><name>LWLockNewTrancheId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oSharedRootInfoInsertTrancheId</name></name> <operator>=</operator> <call><name>LWLockNewTrancheId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oXidQueueTrancheId</name></name> <operator>=</operator> <call><name>LWLockNewTrancheId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oXidQueueFlushTrancheId</name></name> <operator>=</operator> <call><name>LWLockNewTrancheId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>copyBlknoTrancheId</name></name> <operator>=</operator> <call><name>LWLockNewTrancheId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oMetaTrancheId</name></name> <operator>=</operator> <call><name>LWLockNewTrancheId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oTablesAddLock</name></name></expr></argument>,
						 <argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oTablesAddTrancheId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oSysTreesLock</name></name></expr></argument>,
						 <argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oSysTreesTrancheId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SHARED_ROOT_INFO_INSERT_NUM_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oSharedRootInfoInsertLocks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							 <argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oSharedRootInfoInsertTrancheId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oXidQueueLock</name></name></expr></argument>,
						 <argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oXidQueueTrancheId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oXidQueueFlushLock</name></name></expr></argument>,
						 <argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oXidQueueFlushTrancheId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecLastPos</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecFlushPos</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecQueue</name></name></expr></argument>,
			   <argument><expr><literal type="number">0</literal></expr></argument>,
			   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XidFileRec</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>XID_RECS_QUEUE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>XID_RECS_QUEUE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecQueue</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>oxid</name> <operator>=</operator> <name>InvalidOXid</name></expr>;</expr_stmt></block_content></block></for>

		<expr_stmt><expr><name>controlFile</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>CONTROL_FILENAME</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>controlFile</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>controlFile</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>control</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>control</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>control</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read data from control file %s"</literal></expr></argument>, <argument><expr><name>CONTROL_FILENAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>controlFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>control</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>CheckpointControl</name></expr></argument>, <argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>crc</name> <operator>!=</operator> <name><name>control</name><operator>.</operator><name>crc</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Wrong CRC in control file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>control</name><operator>.</operator><name>binaryVersion</name></name> <operator>!=</operator> <name>ORIOLEDB_BINARY_VERSION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database files are incompatible with server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"OrioleDB was initialized with binary version %d,"</literal>
							   <literal type="string">" but the extension was compiled with binary version %d."</literal></expr></argument>,
							   <argument><expr><name><name>control</name><operator>.</operator><name>binaryVersion</name></name></expr></argument>, <argument><expr><name>ORIOLEDB_BINARY_VERSION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"It looks like you need to initdb."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>=</operator> <name><name>control</name><operator>.</operator><name>lastCheckpointNumber</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>controlToastConsistentPtr</name></name> <operator>=</operator> <name><name>control</name><operator>.</operator><name>toastConsistentPtr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>controlReplayStartPtr</name></name> <operator>=</operator> <name><name>control</name><operator>.</operator><name>replayStartPtr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>mmapDataLength</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>mmapDataLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>lastUsedLocation</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>lastUndoLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>advanceReservedLocation</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>lastUndoLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writeInProgressLocation</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>lastUndoLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>writtenLocation</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>lastUndoLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>lastUsedUndoLocationWhenUpdatedMinLocation</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>lastUndoLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcRetainLocation</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>lastUndoLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcTransactionRetainLocation</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>lastUndoLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcReservedLocation</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>lastUndoLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>cleanedLocation</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>lastUndoLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>checkpointRetainStartLocation</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>checkpointRetainStartLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>checkpointRetainEndLocation</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>checkpointRetainEndLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>cleanedCheckpointStartLocation</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>checkpointRetainStartLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>cleanedCheckpointEndLocation</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>checkpointRetainEndLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>lastXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>runXmin</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>lastXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>globalXmin</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>lastXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>lastXidWhenUpdatedGlobalXmin</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>lastXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>writtenXmin</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>lastXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>writeInProgressXmin</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>lastXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>checkpointRetainXmin</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>checkpointRetainXmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>checkpointRetainXmax</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>checkpointRetainXmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>cleanedXmin</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>lastXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>cleanedCheckpointXmin</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>checkpointRetainXmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>cleanedCheckpointXmax</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>.</operator><name>checkpointRetainXmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>startupCommitSeqNo</name> <operator>=</operator> <name><name>control</name><operator>.</operator><name>lastCSN</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oTablesAddTrancheId</name></name></expr></argument>,
						  <argument><expr><literal type="string">"OTablesAddTranche"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oSysTreesTrancheId</name></name></expr></argument>,
						  <argument><expr><literal type="string">"OSysTreesTranche"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>copyBlknoTrancheId</name></name></expr></argument>,
						  <argument><expr><literal type="string">"CopyBlknoTranche"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oMetaTrancheId</name></name></expr></argument>,
						  <argument><expr><literal type="string">"orioledb_meta"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_writeback</name><parameter_list>(<parameter><decl><type><name>CheckpointWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isCompressed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>writeback</name><operator>-&gt;</operator><name>isCompressed</name></name> <operator>=</operator> <name>isCompressed</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>writeback</name><operator>-&gt;</operator><name>checkpointFlags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>writeback</name><operator>-&gt;</operator><name>extentsNumber</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>writeback</name><operator>-&gt;</operator><name>extentsAllocated</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>writeback</name><operator>-&gt;</operator><name>extents</name></name> <operator>=</operator> <operator>(</operator><name>FileExtent</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FileExtent</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
											   <name><name>writeback</name><operator>-&gt;</operator><name>extentsAllocated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>writeback_put_extent</name><parameter_list>(<parameter><decl><type><name>CheckpointWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>, <parameter><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>extent</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>writeback</name><operator>-&gt;</operator><name>extentsNumber</name></name> <operator>&gt;=</operator> <name><name>writeback</name><operator>-&gt;</operator><name>extentsAllocated</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>writeback</name><operator>-&gt;</operator><name>extentsAllocated</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>writeback</name><operator>-&gt;</operator><name>extents</name></name> <operator>=</operator> <operator>(</operator><name>FileExtent</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>writeback</name><operator>-&gt;</operator><name>extents</name></name></expr></argument>,
													 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FileExtent</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>writeback</name><operator>-&gt;</operator><name>extentsAllocated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>writeback</name><operator>-&gt;</operator><name>extents</name><index>[<expr><name><name>writeback</name><operator>-&gt;</operator><name>extentsNumber</name></name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>extent</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>writeback</name><operator>-&gt;</operator><name>isCompressed</name></name> <operator>&amp;&amp;</operator> <name>use_device</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>writeback</name><operator>-&gt;</operator><name>extents</name><index>[<expr><name><name>writeback</name><operator>-&gt;</operator><name>extentsNumber</name></name></expr>]</index></name><operator>.</operator><name>len</name> <operator>*=</operator> <name>ORIOLEDB_BLCKSZ</name> <operator>/</operator> <name>ORIOLEDB_COMP_BLCKSZ</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>writeback</name><operator>-&gt;</operator><name>extentsNumber</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>perform_writeback</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>CheckpointWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>offset</name> <init>= <expr><name>InvalidFileExtentOff</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>progress</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type>		<name>blcksz</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>writeback</name><operator>-&gt;</operator><name>isCompressed</name></name> <operator>||</operator> <name>use_mmap</name><operator>)</operator></expr> ?</condition><then> <expr><name>ORIOLEDB_COMP_BLCKSZ</name></expr> </then><else>: <expr><name>ORIOLEDB_BLCKSZ</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>use_device</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>use_mmap</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>writeback</name><operator>-&gt;</operator><name>extentsNumber</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pg_qsort</name><argument_list>(<argument><expr><name><name>writeback</name><operator>-&gt;</operator><name>extents</name></name></expr></argument>, <argument><expr><name><name>writeback</name><operator>-&gt;</operator><name>extentsNumber</name></name></expr></argument>,
			 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FileExtent</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>file_extents_writeback_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>writeback</name><operator>-&gt;</operator><name>extentsNumber</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>writeback</name><operator>-&gt;</operator><name>extents</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>off</name> <operator>==</operator> <name><name>writeback</name><operator>-&gt;</operator><name>extents</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>off</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* duplicate offset */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>writeback</name><operator>-&gt;</operator><name>extents</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>off</name> <operator>==</operator> <name>offset</name> <operator>+</operator> <name>len</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>&lt;</operator> <literal type="number">1024</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>len</name> <operator>+=</operator> <name><name>writeback</name><operator>-&gt;</operator><name>extents</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>btree_smgr_writeback</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>offset</name> <operator>*</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>blcksz</name></expr></argument>,
									 <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>len</name> <operator>*</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>blcksz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>writeback</name><operator>-&gt;</operator><name>extents</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>off</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>writeback</name><operator>-&gt;</operator><name>extents</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>progress</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>progress</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>pagesWritten</name></name> <operator>+</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>i</name><operator>)</operator>
				<operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>dirtyPagesEstimate</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>progress</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>progress</name> <operator>*=</operator> <name>o_checkpoint_completion_ratio</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CheckpointWriteDelay</name><argument_list>(<argument><expr><name><name>writeback</name><operator>-&gt;</operator><name>checkpointFlags</name></name></expr></argument>, <argument><expr><name>progress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>btree_smgr_writeback</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>offset</name> <operator>*</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>blcksz</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>len</name> <operator>*</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>blcksz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>pagesWritten</name></name> <operator>+=</operator> <name><name>writeback</name><operator>-&gt;</operator><name>extentsNumber</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>writeback</name><operator>-&gt;</operator><name>extentsNumber</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BTreeDescr</name> <modifier>*</modifier></type>
<name>perform_writeback_and_relock</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>,
							 <parameter><decl><type><name>CheckpointWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>,
							 <parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
							 <parameter><decl><type><name>WalkMessage</name> <modifier>*</modifier></type><name>message</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ORelOids</name></type>	<name>treeOids</name> <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexType</name></type>	<name>type</name> <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>type</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>indexDescr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>params</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_SYS_TREE_OIDS</name><argument_list>(<argument><expr><name>treeOids</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Unlock tree: give a chance for concurrent deletion */</comment>
		<expr_stmt><expr><call><name>o_tables_rel_unlock_extended</name><argument_list>(<argument><expr><operator>&amp;</operator><name>treeOids</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>STOPEVENTS_ENABLED</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>prepare_checkpoint_step_params</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
													<argument><expr><name>message</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>STOPEVENT</name><argument_list>(<argument><expr><name>STOPEVENT_CHECKPOINT_WRITEBACK</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>perform_writeback</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>writeback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>indexDescr</name> <operator>=</operator> <call><name>o_fetch_index_descr</name><argument_list>(<argument><expr><name>treeOids</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>indexDescr</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>desc</name> <operator>=</operator> <operator>&amp;</operator><name><name>indexDescr</name><operator>-&gt;</operator><name>desc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>perform_writeback</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>writeback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>desc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_writeback</name><parameter_list>(<parameter><decl><type><name>CheckpointWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>writeback</name><operator>-&gt;</operator><name>extents</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>List</name> <modifier>*</modifier></type>
<name>add_index_id_item</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexIdItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexIdItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>oids</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>List</name> <modifier>*</modifier></type>
<name>add_free_extents_item</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>free</name></decl></parameter>, <parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>add_index_id_item</name><argument_list>(<argument><expr><name>free</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>List</name> <modifier>*</modifier></type>
<name>add_map_cleanup_item</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cleanup</name></decl></parameter>, <parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>remove_old_checkpoint_files</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>cleanup</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OCompressIsValid</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>desc</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>tag</name><operator>.</operator><name>type</name></name> <operator>==</operator> <literal type="char">'m'</literal>
		<operator>&amp;&amp;</operator> <name><name>desc</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>tag</name><operator>.</operator><name>num</name></name> <operator>==</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>cleanup</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><call><name>add_index_id_item</name><argument_list>(<argument><expr><name>cleanup</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wait all the committing transactions to finish completely.  Ensures all the
 * transactions finished afterwards will have greater WAL position than given
 * `redo_pos`.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>wait_finish_active_commits</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>redo_pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>location</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_procs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<while>while <condition>(<expr><operator>(</operator><name>location</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oProcData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>commitInProgressXlogLocation</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>location</name> <operator>&gt;</operator> <name>redo_pos</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>unlink_xids_file</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>checkpointnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>xip_filename</name> <init>= <expr><call><name>psprintf</name><argument_list>(<argument><expr><name>XID_FILENAME_FORMAT</name></expr></argument>, <argument><expr><name>checkpointnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>xip_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>xip_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Open xids file corresponding to the current checkpoint.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>open_xids_file</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>checkpointnum</name> <init>= <expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidQueueCheckpointNum</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>xidFile</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>xidFileCheckpointnum</name> <operator>!=</operator> <name>checkpointnum</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mctx</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>xidFilename</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>xidFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>xidFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>xidFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>xidFilename</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><name>XID_FILENAME_FORMAT</name></expr></argument>, <argument><expr><name>checkpointnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>xidFile</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>xidFilename</name></expr></argument>, <argument><expr><name>O_WRONLY</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>xidFile</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open xid file %s"</literal></expr></argument>, <argument><expr><name>xidFilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>xidFileCheckpointnum</name> <operator>=</operator> <name>checkpointnum</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>flush_xids_queue</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>startPos</name></decl>,
				<decl><type ref="prev"/><name>location</name></decl>,
				<decl><type ref="prev"/><name>endPos</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>open_xids_file</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>startPos</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecFlushPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>endPos</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecLastPos</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>startPos</name> <operator>+</operator> <name>XID_RECS_QUEUE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>location</name> <operator>=</operator> <name>startPos</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>OXidIsValid</name><argument_list>(<argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecQueue</name><index>[<expr><name>location</name> <operator>%</operator> <name>XID_RECS_QUEUE_SIZE</name></expr>]</index></name><operator>.</operator><name>oxid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <name>location</name> <operator>&lt;</operator> <name>endPos</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>location</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><name>endPos</name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>startPos</name> <operator>%</operator> <name>XID_RECS_QUEUE_SIZE</name> <operator>&lt;</operator> <name>endPos</name> <operator>%</operator> <name>XID_RECS_QUEUE_SIZE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>OFileWrite</name><argument_list>(<argument><expr><name>xidFile</name></expr></argument>,
					   <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecQueue</name><index>[<expr><name>startPos</name> <operator>%</operator> <name>XID_RECS_QUEUE_SIZE</name></expr>]</index></name></expr></argument>,
					   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XidFileRec</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>endPos</name> <operator>-</operator> <name>startPos</name><operator>)</operator></expr></argument>,
					   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XidFileRec</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>startPos</name></expr></argument>,
					   <argument><expr><name>WAIT_EVENT_SLRU_WRITE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XidFileRec</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>endPos</name> <operator>-</operator> <name>startPos</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write xid record to file %s"</literal></expr></argument>, <argument><expr><name>xidFilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>len1</name></decl>,
					<decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>len1</name> <operator>=</operator> <name>XID_RECS_QUEUE_SIZE</name> <operator>-</operator> <name>startPos</name> <operator>%</operator> <name>XID_RECS_QUEUE_SIZE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len2</name> <operator>=</operator> <name>endPos</name> <operator>%</operator> <name>XID_RECS_QUEUE_SIZE</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OFileWrite</name><argument_list>(<argument><expr><name>xidFile</name></expr></argument>,
					   <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecQueue</name><index>[<expr><name>startPos</name> <operator>%</operator> <name>XID_RECS_QUEUE_SIZE</name></expr>]</index></name></expr></argument>,
					   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XidFileRec</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len1</name></expr></argument>,
					   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XidFileRec</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>startPos</name></expr></argument>,
					   <argument><expr><name>WAIT_EVENT_SLRU_WRITE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XidFileRec</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len1</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write xid record to file %s"</literal></expr></argument>, <argument><expr><name>xidFilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OFileWrite</name><argument_list>(<argument><expr><name>xidFile</name></expr></argument>,
					   <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecQueue</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XidFileRec</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len2</name></expr></argument>,
					   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XidFileRec</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>startPos</name> <operator>+</operator> <name>len1</name><operator>)</operator></expr></argument>,
					   <argument><expr><name>WAIT_EVENT_SLRU_WRITE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XidFileRec</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len2</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write xid record to file %s"</literal></expr></argument>, <argument><expr><name>xidFilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<for>for <control>(<init><expr><name>location</name> <operator>=</operator> <name>startPos</name></expr>;</init> <condition><expr><name>location</name> <operator>&lt;</operator> <name>endPos</name></expr>;</condition> <incr><expr><name>location</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecQueue</name><index>[<expr><name>location</name> <operator>%</operator> <name>XID_RECS_QUEUE_SIZE</name></expr>]</index></name><operator>.</operator><name>oxid</name> <operator>=</operator> <name>InvalidOXid</name></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecFlushPos</name></name></expr></argument>, <argument><expr><name>endPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>try_flush_xids_queue</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>LWLockAcquireOrWait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oXidQueueFlushLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>flush_xids_queue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oXidQueueFlushLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write single xid record to queue.
 */</comment>
<function><type><name>void</name></type>
<name>write_to_xids_queue</name><parameter_list>(<parameter><decl><type><name>XidFileRec</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>location</name> <init>= <expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecLastPos</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XidFileRec</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecQueue</name><index>[<expr><name>location</name> <operator>%</operator> <name>XID_RECS_QUEUE_SIZE</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Flush queue to the file till our position is available for write.
	 */</comment>
	<while>while <condition>(<expr><name>location</name> <operator>&gt;=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecFlushPos</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>XID_RECS_QUEUE_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>try_flush_xids_queue</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>undoLocation</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>oxid</name></name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>oxid</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>VALGRIND_CHECK_MEM_IS_DEFINED</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>target</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare xids queue for writes.
 */</comment>
<function><type><name>void</name></type>
<name>before_writing_xids_file</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>chkpnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidQueueCheckpointNum</name></name> <operator>&lt;</operator> <name>chkpnum</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidQueueCheckpointNum</name></name> <operator>=</operator> <name>chkpnum</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecLastPos</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecFlushPos</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecQueue</name></name></expr></argument>,
			   <argument><expr><literal type="number">0</literal></expr></argument>,
			   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XidFileRec</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>XID_RECS_QUEUE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>XID_RECS_QUEUE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecQueue</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>oxid</name> <operator>=</operator> <name>InvalidOXid</name></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Flush xids queue, fsync and close xids file.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>close_xids_file</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>count</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>open_xids_file</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecFlushPos</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
		   <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecLastPos</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>flush_xids_queue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>xidRecLastPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OFileWrite</name><argument_list>(<argument><expr><name>xidFile</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>count</name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_SLRU_WRITE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write xid record to file %s"</literal></expr></argument>, <argument><expr><name>xidFilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FileSync</name><argument_list>(<argument><expr><name>xidFile</name></expr></argument>, <argument><expr><name>WAIT_EVENT_SLRU_SYNC</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not sync xid file %s"</literal></expr></argument>, <argument><expr><name>xidFilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>xidFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>xidFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xidFilename</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>xidFile</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Start writing xid records to the xid file.  After this, information about
 * committed/aborted transactions will be written by backends to the xids
 * queue.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>start_write_xids</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>chkpnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_procs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oProcData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>undoStackLocationsFlushLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oProcData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flushUndoLocations</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oProcData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>undoStackLocationsFlushLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>finishRequestCheckpointNumber</name></name> <operator>=</operator> <name>chkpnum</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write information about undo locations of in-progress transactions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>finish_write_xids</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>chkpnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XidFileRec</name></type>	<name>xidRec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xidRec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xidRec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_procs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oProcData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>undoStackLocationsFlushLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>PROC_XID_ARRAY_SIZE</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<while>while <condition>(<expr><name>true</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>OXidIsValid</name><argument_list>(<argument><expr><name><name>oProcData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vxids</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>oxid</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>xidRec</name><operator>.</operator><name>oxid</name></name> <operator>=</operator> <name><name>oProcData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vxids</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>oxid</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>read_shared_undo_locations</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xidRec</name><operator>.</operator><name>undoLocation</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oProcData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>undoStackLocations</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>xidRec</name><operator>.</operator><name>oxid</name></name> <operator>!=</operator> <name><name>oProcData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vxids</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>oxid</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>write_to_xids_queue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xidRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></while>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>oProcData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flushUndoLocations</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oProcData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>undoStackLocationsFlushLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>immediateRequestCheckpointNumber</name></name> <operator>=</operator> <name>chkpnum</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Wait till recovery undo position will be flushed.
	 */</comment>
	<while>while <condition>(<expr><name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>completedCheckpointNumber</name></name> <operator>&lt;</operator>
		   <name><name>recovery_undo_loc_flush</name><operator>-&gt;</operator><name>immediateRequestCheckpointNumber</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">10000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>o_perform_checkpoint</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>redo_pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CheckpointTablesArg</name></type> <name>chkp_tbl_arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CheckpointControl</name></type> <name>control</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>old_enable_stopevents</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>cur_chkp_num</name> <init>= <expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>prev_chkp_num</name> <init>= <expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>prev_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sys_tree_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ODBProcData</name> <modifier>*</modifier></type><name>my_proc_info</name> <init>= <expr><call><name>GET_CUR_PROCDATA</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>checkpoint_start_loc</name></decl>,
				<decl><type ref="prev"/><name>checkpoint_end_loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OXid</name></type>		<name>checkpoint_xmin</name></decl>,
				<decl><type ref="prev"/><name>checkpoint_xmax</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>orioledb_check_shmem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>IsPostmasterEnvironment</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"orioledb checkpoint %u started"</literal></expr></argument>,
		 <argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>o_set_syscache_hooks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>control</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>control</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>chkp_tbl_arg</name><operator>.</operator><name>cleanupMap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chkp_tbl_arg</name><operator>.</operator><name>freeExtents</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chkp_tbl_arg</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>dirtyPagesEstimate</name></name> <operator>=</operator> <call><name>get_dirty_pages_count_sum</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>dirtyPagesEstimate</name></name> <operator>*=</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>+</operator> <name>CheckPointCompletionTarget</name>
											 <operator>*</operator> <name>o_checkpoint_completion_ratio</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>pagesWritten</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>toastConsistentPtr</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>chkp_mem_context</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>chkp_mem_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
												 <argument><expr><literal type="string">"checkpoint temporary context"</literal></expr></argument>,
												 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>old_enable_stopevents</name> <operator>=</operator> <name>enable_stopevents</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * does not count debug events from o_tables and o_opclass checkpoint
	 */</comment>
	<expr_stmt><expr><name>enable_stopevents</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>prev_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>chkp_mem_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>checkpoint_start_loc</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minProcTransactionRetainLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>checkpoint_xmin</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>runXmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_proc_info</name><operator>-&gt;</operator><name>snapshotRetainUndoLocation</name></name></expr></argument>, <argument><expr><name>checkpoint_start_loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_proc_info</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><name>checkpoint_xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>replayStartPtr</name></name> <operator>=</operator> <call><name>GetXLogInsertRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>wait_finish_active_commits</name><argument_list>(<argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>replayStartPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oXidQueueLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>before_writing_xids_file</name><argument_list>(<argument><expr><name>cur_chkp_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>start_write_xids</name><argument_list>(<argument><expr><name>cur_chkp_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oSysTreesLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>sys_tree_num</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>sys_tree_num</name> <operator>&lt;=</operator> <name>SYS_TREES_NUM</name></expr>;</condition> <incr><expr><name>sys_tree_num</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>		<name>success</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>sys_tree_get_storage_type</name><argument_list>(<argument><expr><name>sys_tree_num</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BTreeStorageInMemory</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>get_sys_tree</name><argument_list>(<argument><expr><name>sys_tree_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>storageType</name></name> <operator>==</operator> <name>BTreeStoragePersistence</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>checkpoint_ix</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* System trees can't be concurrently deleted */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sort_checkpoint_map_file</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>cur_chkp_num</name> <operator>%</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sort_checkpoint_tmp_file</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>cur_chkp_num</name> <operator>%</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>chkp_tbl_arg</name><operator>.</operator><name>cleanupMap</name></name> <operator>=</operator> <call><name>add_map_cleanup_item</name><argument_list>(<argument><expr><name><name>chkp_tbl_arg</name><operator>.</operator><name>cleanupMap</name></name></expr></argument>,
														   <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>checkpoint_temporary_tree</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sort_checkpoint_tmp_file</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>cur_chkp_num</name> <operator>%</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oSysTreesLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>prev_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextResetOnly</name><argument_list>(<argument><expr><name>chkp_mem_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>enable_stopevents</name> <operator>=</operator> <name>old_enable_stopevents</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oTablesAddLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>o_indices_foreach_oids</name><argument_list>(<argument><expr><name>checkpoint_tables_callback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>chkp_tbl_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>chkp_inc_changecount_before</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>treeType</name></name> <operator>=</operator> <name>oIndexInvalid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>datoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>reloid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>relnode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>completed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>chkp_inc_changecount_after</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oTablesAddLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It might happen there is no secondary indices, but we still need to set
	 * toastConsistentPtr.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>toastConsistentPtr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>toastConsistentPtr</name></name> <operator>=</operator> <call><name>GetXLogInsertRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>finish_write_xids</name><argument_list>(<argument><expr><name>cur_chkp_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>close_xids_file</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oXidQueueLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>checkpoint_end_loc</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>lastUsedLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>checkpoint_xmax</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>use_mmap</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>msync</name><argument_list>(<argument><expr><name>mmap_data</name></expr></argument>, <argument><expr><name>device_length</name></expr></argument>, <argument><expr><name>MS_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>fsync_undo_range</name><argument_list>(<argument><expr><name>checkpoint_start_loc</name></expr></argument>,
					 <argument><expr><name>checkpoint_end_loc</name></expr></argument>,
					 <argument><expr><name>WAIT_EVENT_DATA_FILE_IMMEDIATE_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fsync_xidmap_range</name><argument_list>(<argument><expr><name>checkpoint_xmin</name></expr></argument>,
					   <argument><expr><name>checkpoint_xmax</name></expr></argument>,
					   <argument><expr><name>WAIT_EVENT_DATA_FILE_IMMEDIATE_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minUndoLocationsMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>checkpointRetainStartLocation</name></name></expr></argument>, <argument><expr><name>checkpoint_start_loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>checkpointRetainEndLocation</name></name></expr></argument>, <argument><expr><name>checkpoint_end_loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>minUndoLocationsMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>xminMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>checkpointRetainXmin</name></name></expr></argument>, <argument><expr><name>checkpoint_xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>checkpointRetainXmax</name></name></expr></argument>, <argument><expr><name>checkpoint_xmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>xminMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_proc_info</name><operator>-&gt;</operator><name>snapshotRetainUndoLocation</name></name></expr></argument>, <argument><expr><name>InvalidUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>control</name><operator>.</operator><name>lastCheckpointNumber</name></name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>control</name><operator>.</operator><name>lastCSN</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextCommitSeqNo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>control</name><operator>.</operator><name>lastXid</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>control</name><operator>.</operator><name>lastUndoLocation</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>lastUsedLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>control</name><operator>.</operator><name>replayStartPtr</name></name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>replayStartPtr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>control</name><operator>.</operator><name>toastConsistentPtr</name></name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>toastConsistentPtr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>control</name><operator>.</operator><name>mmapDataLength</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>mmapDataLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>control</name><operator>.</operator><name>checkpointRetainStartLocation</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>checkpointRetainStartLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>control</name><operator>.</operator><name>checkpointRetainEndLocation</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>checkpointRetainEndLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>control</name><operator>.</operator><name>checkpointRetainXmin</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>checkpointRetainXmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>control</name><operator>.</operator><name>checkpointRetainXmax</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xid_meta</name><operator>-&gt;</operator><name>checkpointRetainXmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>control</name><operator>.</operator><name>binaryVersion</name></name> <operator>=</operator> <name>ORIOLEDB_BINARY_VERSION</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>write_checkpoint_control</name><argument_list>(<argument><expr><operator>&amp;</operator><name>control</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now we can free extents for compressed indices
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_IS_SHUTDOWN</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>chkp_tbl_arg</name><operator>.</operator><name>freeExtents</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexIdItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>chkp_tbl_arg.freeExtents</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>IndexIdItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>o_fetch_index_descr</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
										<argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>descr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* table might be deleted */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>add_free_extents_from_tmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>,
									  <argument><expr><name>remove_old_checkpoint_files</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>o_tables_rel_unlock_extended</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name><name>chkp_tbl_arg</name><operator>.</operator><name>freeExtents</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Remove old files if needed
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>remove_old_checkpoint_files</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexIdItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SeqBufTag</name></type>	<name>cleanup_tag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>unlink_xids_file</name><argument_list>(<argument><expr><name>prev_chkp_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>cleanup_tag</name><operator>.</operator><name>type</name></name> <operator>=</operator> <literal type="char">'m'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cleanup_tag</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name>prev_chkp_num</name></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>chkp_tbl_arg.cleanupMap</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>IndexIdItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cleanup_tag</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cleanup_tag</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>seq_buf_remove_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cleanup_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name><name>chkp_tbl_arg</name><operator>.</operator><name>cleanupMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>CheckPointProgress</name> <operator>=</operator> <name>o_checkpoint_completion_ratio</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_proc_info</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><name>InvalidOXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>o_reset_syscache_hooks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"orioledb checkpoint %u complete"</literal></expr></argument>,
		 <argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>next_CheckPoint_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>next_CheckPoint_hook</name><argument_list>(<argument><expr><name>redo_pos</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Make checkpoint of an index.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkpoint_temporary_tree</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeMetaPage</name> <modifier>*</modifier></type><name>meta_page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SeqBufTag</name></type>	<name>next_tmp_tag</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cur_chkp_index</name></decl>,
				<decl><type ref="prev"/><name>next_chkp_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>datoid</name> <init>= <expr><name><name>descr</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relnode</name> <init>= <expr><name><name>descr</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>success</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CheckpointWriteBack</name></type> <name>writeback</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OCompressIsValid</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * TODO: can we make checkpoint on evicted or unloaded tree?
	 */</comment>
	<expr_stmt><expr><call><name>checkpoint_ix_init_state</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cur_chkp_index</name> <operator>=</operator> <operator>(</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>next_chkp_index</name> <operator>=</operator> <operator>(</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>%</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>meta_page</name> <operator>=</operator> <call><name>BTREE_GET_META</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ORootPageIsValid</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OMetaPageIsValid</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize next tmp file */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_seq_buf_pages</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>next_chkp_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free_seq_buf_pages</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>next_chkp_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Unable to get pages for sequence buffers."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>next_tmp_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>next_tmp_tag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>next_tmp_tag</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name>datoid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>next_tmp_tag</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name>relnode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>next_tmp_tag</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>next_tmp_tag</name><operator>.</operator><name>type</name></name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>init_seq_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>next_chkp_index</name></expr>]</index></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>next_chkp_index</name></expr>]</index></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>next_tmp_tag</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not init a new sequence buffer file %s"</literal></expr></argument>,
						<argument><expr><call><name>get_seq_buf_filename</name><argument_list>(<argument><expr><operator>&amp;</operator><name>next_tmp_tag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Make checkpoint of the tree itself */</comment>
	<expr_stmt><expr><call><name>init_writeback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writeback</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>checkpoint_btree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>descr</name></expr></argument>, <argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>writeback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>perform_writeback_and_relock</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>writeback</name></expr></argument>,
										<argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_writeback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writeback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>curKeyType</name></name> <operator>==</operator> <name>CurKeyGreatest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>STOPEVENT</name><argument_list>(<argument><expr><name>STOPEVENT_BEFORE_BLKNO_LOCK</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Need a lock to be sure, that nobody is concurrently copying block
	 * number from previous checkpoint to current.  See write_page() for
	 * details.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>copyBlknoLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>chkp_inc_changecount_before</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>curKeyType</name></name> <operator>=</operator> <name>CurKeyFinished</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>chkp_inc_changecount_after</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>copyBlknoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* finalizes *.tmp file */</comment>
	<expr_stmt><expr><call><name>seq_buf_finalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>cur_chkp_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_seq_buf_pages</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name><name>descr</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>cur_chkp_index</name></expr>]</index></name><operator>.</operator><name>shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>chkp_inc_changecount_before</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>completed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>chkp_inc_changecount_after</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>o_after_checkpoint_cleanup_hook</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>checkPointRedo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>CHECKPOINT_IS_SHUTDOWN</name> <operator>|</operator> <name>CHECKPOINT_END_OF_RECOVERY</name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>o_sys_caches_delete_by_lsn</name><argument_list>(<argument><expr><name>checkPointRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write checkpoint control file to the disk (and sync).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_checkpoint_control</name><parameter_list>(<parameter><decl><type><name>CheckpointControl</name> <modifier>*</modifier></type><name>control</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>File</name></type>		<name>controlFile</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>, <argument><expr><name>control</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>CheckpointControl</name></expr></argument>, <argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>controlFile</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>CONTROL_FILENAME</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>controlFile</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open checkpoint control file %s"</literal></expr></argument>, <argument><expr><name>CONTROL_FILENAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OFileWrite</name><argument_list>(<argument><expr><name>controlFile</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>control</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>control</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				   <argument><expr><name>WAIT_EVENT_SLRU_WRITE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>control</name></expr></argument>)</argument_list></sizeof> <operator>||</operator>
		<call><name>FileSync</name><argument_list>(<argument><expr><name>controlFile</name></expr></argument>, <argument><expr><name>WAIT_EVENT_SLRU_SYNC</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write checkpoint control to file %s"</literal></expr></argument>, <argument><expr><name>CONTROL_FILENAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>controlFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>append_file_contents</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>target</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>source_filename</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>ORIOLEDB_BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>source</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>block_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>target_offset</name> <init>= <expr><call><name>FileSize</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>source</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>source_filename</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>source</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file for finalize checkpoint map: %s"</literal></expr></argument>,
							   <argument><expr><name>source_filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>block_len</name> <operator>=</operator> <call><name>OFileRead</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OFileWrite</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>block_len</name></expr></argument>, <argument><expr><name>target_offset</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_WRITE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>block_len</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not copy data for finalize checkpoint map: %s"</literal></expr></argument>, <argument><expr><name>source_filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>target_offset</name> <operator>+=</operator> <name>block_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>block_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>block_len</name></expr>;</expr_stmt>
	</block_content>}</block>
	while <condition>(<expr><name>block_len</name> <operator>==</operator> <name>ORIOLEDB_BLCKSZ</name></expr>)</condition>;</do>

	<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>finalize_chkp_map</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>chkp_file</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>input_filename</name></decl></parameter>,
				  <parameter><decl><type><name>uint64</name></type> <name>input_offset</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>input_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SeqBufTag</name></type>	<name>tmp_tag</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FileSize</name><argument_list>(<argument><expr><name>chkp_file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not move to offset %lu for making finalize checkpoint map: %s"</literal></expr></argument>,
							   <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name>chkp_file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>input_filename</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>append_file_contents</name><argument_list>(<argument><expr><name>chkp_file</name></expr></argument>, <argument><expr><name>input_filename</name></expr></argument>, <argument><expr><name>input_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>input_num</name><operator>++</operator></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>input_num</name> <operator>&lt;=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp_filename</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>tmp_tag</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>datoid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmp_tag</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>relnode</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmp_tag</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name>input_num</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmp_tag</name><operator>.</operator><name>type</name></name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>seq_buf_file_exist</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tmp_filename</name> <operator>=</operator> <call><name>get_seq_buf_filename</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>append_file_contents</name><argument_list>(<argument><expr><name>chkp_file</name></expr></argument>, <argument><expr><name>tmp_filename</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>input_num</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Comparator for sort ascending.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>uint32_offsets_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>val1</name> <init>= <expr><operator>*</operator><operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>val2</name> <init>= <expr><operator>*</operator><operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>val1</name> <operator>!=</operator> <name>val2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><name>val1</name> <operator>&gt;</operator> <name>val2</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Comparator for FileExtent.len sort descending.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>file_extents_len_off_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>val1</name> <init>= <expr><operator>(</operator><name>FileExtent</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>val2</name> <init>= <expr><operator>(</operator><name>FileExtent</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>val1</name><operator>-&gt;</operator><name>len</name></name> <operator>!=</operator> <name><name>val2</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><name><name>val1</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <name><name>val2</name><operator>-&gt;</operator><name>len</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>val1</name><operator>-&gt;</operator><name>off</name></name> <operator>!=</operator> <name><name>val2</name><operator>-&gt;</operator><name>off</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><name><name>val1</name><operator>-&gt;</operator><name>off</name></name> <operator>&gt;</operator> <name><name>val2</name><operator>-&gt;</operator><name>off</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Comparator for FileExtent.off sort ascending.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>file_extents_off_len_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>val1</name> <init>= <expr><operator>(</operator><name>FileExtent</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>val2</name> <init>= <expr><operator>(</operator><name>FileExtent</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>val1</name><operator>-&gt;</operator><name>off</name></name> <operator>!=</operator> <name><name>val2</name><operator>-&gt;</operator><name>off</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><name><name>val1</name><operator>-&gt;</operator><name>off</name></name> <operator>&gt;</operator> <name><name>val2</name><operator>-&gt;</operator><name>off</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>val1</name><operator>-&gt;</operator><name>len</name></name> <operator>!=</operator> <name><name>val2</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><name><name>val1</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <name><name>val2</name><operator>-&gt;</operator><name>len</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Comparator for FileExtent.off sort ascending.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>file_extents_writeback_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>val1</name> <init>= <expr><operator>(</operator><name>FileExtent</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>val2</name> <init>= <expr><operator>(</operator><name>FileExtent</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>val1</name><operator>-&gt;</operator><name>off</name></name> <operator>!=</operator> <name><name>val2</name><operator>-&gt;</operator><name>off</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><name><name>val1</name><operator>-&gt;</operator><name>off</name></name> <operator>&gt;</operator> <name><name>val2</name><operator>-&gt;</operator><name>off</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>val1</name><operator>-&gt;</operator><name>len</name></name> <operator>!=</operator> <name><name>val2</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The sort order helps in perform_writeback().
		 */</comment>
		<return>return <expr><ternary><condition><expr><name><name>val1</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <name><name>val2</name><operator>-&gt;</operator><name>len</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sort lists of free blocks in .map file to optimize disk access.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sort_checkpoint_map_file</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cur_chkp_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>free_blocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>free_blocks_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CheckpointFileHeader</name></type> <name>header</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ferror</name> <init>= <expr><name>false</name></expr></init></decl>,
				<decl><type ref="prev"/><name>is_compressed</name> <init>= <expr><call><name>OCompressIsValid</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>read_size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>get_seq_buf_filename</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>cur_chkp_index</name></expr>]</index></name><operator>.</operator><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not open checkpoint map file: %s"</literal></expr></argument>,
							   <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* reads header and blocks from map file */</comment>
	<expr_stmt><expr><name>ferror</name> <operator>=</operator> <call><name>OFileRead</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>header</name></expr></argument>,
					   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_READ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ferror</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not read data from checkpoint map file: %s"</literal></expr></argument>,
							   <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_compressed</name> <operator>||</operator> <name>use_device</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>free_blocks_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FileExtent</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>header</name><operator>.</operator><name>numFreeBlocks</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>free_blocks_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>header</name><operator>.</operator><name>numFreeBlocks</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>free_blocks</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>free_blocks_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>free_blocks_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>read_size</name> <operator>=</operator> <call><name>OFileRead</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>free_blocks</name></expr></argument>, <argument><expr><name>free_blocks_size</name></expr></argument>,
							  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>read_size</name> <operator>!=</operator> <name>free_blocks_size</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not read data from checkpoint map file: %s"</literal></expr></argument>,
								   <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* sorts blocks */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_compressed</name> <operator>||</operator> <name>use_device</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_qsort</name><argument_list>(<argument><expr><name>free_blocks</name></expr></argument>, <argument><expr><name><name>header</name><operator>.</operator><name>numFreeBlocks</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FileExtent</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>file_extents_len_off_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_qsort</name><argument_list>(<argument><expr><name>free_blocks</name></expr></argument>, <argument><expr><name><name>header</name><operator>.</operator><name>numFreeBlocks</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>uint32_offsets_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* writes sorted blocks to map file. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OFileWrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>free_blocks</name></expr></argument>, <argument><expr><name>free_blocks_size</name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_WRITE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>free_blocks_size</name> <operator>||</operator>
		<call><name>FileSync</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>WAIT_EVENT_SLRU_SYNC</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not write sorted data to checkpoint map file: %s"</literal></expr></argument>,
							   <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>free_blocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Sort lists of free blocks in .map file to optimize disk access.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sort_checkpoint_tmp_file</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cur_chkp_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>free_blocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>free_blocks_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_compressed</name> <init>= <expr><call><name>OCompressIsValid</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>read_size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>get_seq_buf_filename</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>cur_chkp_index</name></expr>]</index></name><operator>.</operator><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * *.tmp file does not exist, nothing to sort
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>free_blocks_size</name> <operator>=</operator> <call><name>FileSize</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>free_blocks</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>free_blocks_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>free_blocks_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>read_size</name> <operator>=</operator> <call><name>OFileRead</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>free_blocks</name></expr></argument>,
							  <argument><expr><name>free_blocks_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>read_size</name> <operator>!=</operator> <name>free_blocks_size</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not read data from checkpoint tmp file: %s %d %lu"</literal></expr></argument>,
								   <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>read_size</name></expr></argument>, <argument><expr><name>free_blocks_size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* sorts blocks */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_compressed</name> <operator>||</operator> <name>use_device</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_qsort</name><argument_list>(<argument><expr><name>free_blocks</name></expr></argument>, <argument><expr><name>free_blocks_size</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FileExtent</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FileExtent</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>file_extents_len_off_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_qsort</name><argument_list>(<argument><expr><name>free_blocks</name></expr></argument>, <argument><expr><name>free_blocks_size</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>uint32_offsets_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* writes sorted blocks to tmp file */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OFileWrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>free_blocks</name></expr></argument>,
				   <argument><expr><name>free_blocks_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_WRITE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>free_blocks_size</name> <operator>||</operator>
		<call><name>FileSync</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>WAIT_EVENT_SLRU_SYNC</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not write sorted data to checkpoint tmp file: %s"</literal></expr></argument>,
							   <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>free_blocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>checkpoint_ix_init_state</name><parameter_list>(<parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>chkp_inc_changecount_before</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>treeType</name></name> <operator>=</operator> <name><name>descr</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>datoid</name></name> <operator>=</operator> <name><name>descr</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>reloid</name></name> <operator>=</operator> <name><name>descr</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>reloid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>relnode</name></name> <operator>=</operator> <name><name>descr</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>completed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>curKeyType</name></name> <operator>=</operator> <name>CurKeyLeast</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>chkp_inc_changecount_after</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Marks a offset as free for given checkpoint number, throws an error on failure.
 *
 * It adds the offset to *.map and *.tmp files.
 */</comment>
<function><type><name>void</name></type>
<name>free_extent_for_checkpoint</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>chkp_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SeqBufDescPrivate</name> <modifier>*</modifier></type><name><name>bufs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>chkp_num</name> <operator>%</operator> <literal type="number">2</literal></expr>]</index></name></expr>, <expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>chkp_num</name> <operator>%</operator> <literal type="number">2</literal></expr>]</index></name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>success</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Don't have *.map files for BTreeStorageTemporary */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>desc</name><operator>-&gt;</operator><name>storageType</name></name> <operator>==</operator> <name>BTreeStorageTemporary</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OCompressIsValid</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name>use_device</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>seq_buf_write_file_extent</name><argument_list>(<argument><expr><name><name>bufs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>*</operator><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>offset</name> <init>= <expr><name><name>extent</name><operator>-&gt;</operator><name>off</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>extent</name><operator>-&gt;</operator><name>off</name></name> <operator>&lt;</operator> <name>UINT32_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>seq_buf_write_u32</name><argument_list>(<argument><expr><name><name>bufs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write offset %lu to file %s"</literal></expr></argument>,
								   <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name><name>extent</name><operator>-&gt;</operator><name>off</name></name></expr></argument>,
								   <argument><expr><call><name>get_seq_buf_filename</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>shared</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>extent</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>InvalidFileExtentLen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extent</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name>InvalidFileExtentOff</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if page with given page number is under in-progress
 * checkpointing.
 */</comment>
<function><type><name>bool</name></type>
<name>page_is_under_checkpoint</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>datoid</name></decl>,
				<decl><type ref="prev"/><name>relnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>level</name> <init>= <expr><call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>before_changecount</name></decl>,
				<decl><type ref="prev"/><name>after_changecount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CurKeyType</name></type>	<name>cur_key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>blkno_on_checkpoint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>hikey_blkno_on_checkpoint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexType</name></type>	<name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>chkp_save_changecount_before</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><name>before_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>before_changecount</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>treeType</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>datoid</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>datoid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>relnode</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>relnode</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>blkno_on_checkpoint</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hikey_blkno_on_checkpoint</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>hikeyBlkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cur_key</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>curKeyType</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>chkp_save_changecount_after</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><name>after_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>before_changecount</name> <operator>!=</operator> <name>after_changecount</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name> <operator>!=</operator> <name>datoid</name> <operator>||</operator>
			<name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name> <operator>!=</operator> <name>relnode</name> <operator>||</operator>
			<name><name>desc</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>type</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* BTree is not under checkpoint */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>cur_key</name> <operator>==</operator> <name>CurKeyFinished</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* checkpoint already finished */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>blkno_on_checkpoint</name> <operator>==</operator> <name>blkno</name> <operator>||</operator>
				 <name>hikey_blkno_on_checkpoint</name> <operator>==</operator> <name>blkno</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* page is under checkpoint */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>blkno_on_checkpoint</name> <operator>==</operator> <name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name> <operator>&amp;&amp;</operator> <call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEFTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* concurrent rootPageBlkno split may happens */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* page is not under checkpoint */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blkno_on_checkpoint</name> <operator>!=</operator> <name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>chkp_save_changecount_after</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><name>after_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>before_changecount</name> <operator>!=</operator> <name>after_changecount</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if btree is under in-progress checkpointing.
 */</comment>
<function><type><name>bool</name></type>
<name>tree_is_under_checkpoint</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>datoid</name></decl>,
				<decl><type ref="prev"/><name>relnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>before_changecount</name></decl>,
				<decl><type ref="prev"/><name>after_changecount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexType</name></type>	<name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>chkp_save_changecount_before</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><name>before_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>before_changecount</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>treeType</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>datoid</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>datoid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>relnode</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>relnode</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>chkp_save_changecount_after</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><name>after_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>before_changecount</name> <operator>!=</operator> <name>after_changecount</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name> <operator>!=</operator> <name>datoid</name> <operator>||</operator>
			<name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name> <operator>!=</operator> <name>relnode</name> <operator>||</operator>
			<name><name>desc</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>type</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* BTree is not under checkpoint */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>chkp_save_changecount_after</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><name>after_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>before_changecount</name> <operator>!=</operator> <name>after_changecount</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Returns -1 if page must be evicted to current in progress checkpoint.
 * Returns 1 if page must be evicted to next checkpoint.
 * Return 0 if page can not be evicted.
 *
 * We can't evict page if its hikey is in range [cur_key, lvl_hikey]:
 *
 * If we evict it to the current checkpoint (last_checkpoint_number + 1),
 * we may lost the page offset on concurrent split case.
 *
 * If we evict it to the next checkpoint (last_checkpoint_number + 2)
 * a page offset will be marked as free for current checkpoint,
 * than if we add downlink with the offset to an autonomous page, and restart
 * we will have the offset both free and busy for the current checkpoint.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>side_of_checkpoint_bound</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>,
						 <parameter><decl><type><name>OTuple</name></type> <name>cur_key</name></decl></parameter>, <parameter><decl><type><name>CurKeyType</name></type> <name>cur_key_type</name></decl></parameter>,
						 <parameter><decl><type><name>OTuple</name></type> <name>lvl_hikey</name></decl></parameter>, <parameter><decl><type><name>CheckpointBound</name></type> <name>bound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>hikey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>page_is_rightmost</name> <init>= <expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cur_key_type</name> <operator>==</operator> <name>CurKeyValue</name> <operator>||</operator> <name>cur_key_type</name> <operator>==</operator> <name>CurKeyGreatest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fast checks, helps to exclusive rightmost case */</comment>

	<if_stmt><if>if <condition>(<expr><name>cur_key_type</name> <operator>==</operator> <name>CurKeyGreatest</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* left bound on rightmost pages */</comment>
		<if_stmt><if>if <condition>(<expr><name>page_is_rightmost</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cur_key_type</name> <operator>==</operator> <name>CurKeyValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>page_is_rightmost</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* case for rightmost page (no hikey to compare) */</comment>
		<if_stmt><if>if <condition>(<expr><name>bound</name> <operator>==</operator> <name>CheckpointBoundRightmost</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * left bound comparison
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>page_is_rightmost</name> <operator>&amp;&amp;</operator> <name>cur_key_type</name> <operator>==</operator> <name>CurKeyValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hikey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cur_key</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* need to check right bound */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>bound</name> <operator>==</operator> <name>CheckpointBoundNone</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* right bound does not exist */</comment>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>bound</name> <operator>==</operator> <name>CheckpointBoundRightmost</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* right bound to the end of the BTree level */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * right bound comparison
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>page_is_rightmost</name> <operator>&amp;&amp;</operator> <name>bound</name> <operator>==</operator> <name>CheckpointBoundHikey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hikey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lvl_hikey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compare tree identifiers in the same order we process them on checkpoint.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>chkp_ordering_cmp</name><parameter_list>(<parameter><decl><type><name>OIndexType</name></type> <name>type1</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>datoid1</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relnode1</name></decl></parameter>,
				  <parameter><decl><type><name>OIndexType</name></type> <name>type2</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>datoid2</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relnode2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>datoid1</name> <operator>&lt;=</operator> <name>SYS_TREES_DATOID</name> <operator>&amp;&amp;</operator> <name>datoid2</name> <operator>&gt;</operator> <name>SYS_TREES_DATOID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>datoid1</name> <operator>&gt;</operator> <name>SYS_TREES_DATOID</name> <operator>&amp;&amp;</operator> <name>datoid2</name> <operator>&lt;=</operator> <name>SYS_TREES_DATOID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>type1</name> <operator>!=</operator> <name>type2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><name>type1</name> <operator>&lt;</operator> <name>type2</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>datoid1</name> <operator>!=</operator> <name>datoid2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><name>datoid1</name> <operator>&lt;</operator> <name>datoid2</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>relnode1</name> <operator>!=</operator> <name>relnode2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><name>relnode1</name> <operator>&lt;</operator> <name>relnode2</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determine which checkpoint `blkno` should be written to.
 */</comment>
<function><type><name>bool</name></type>
<name>get_checkpoint_number</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>,
					  <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>checkpoint_number</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>copy_blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CheckpointBound</name></type> <name>bound</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CurKeyType</name></type>	<name>cur_key_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OFixedKey</name></type>	<name>lvl_hikey</name></decl>,
				<decl><type ref="prev"/><name>cur_key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>datoid</name></decl>,
				<decl><type ref="prev"/><name>relnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>level</name> <init>= <expr><call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>before_changecount</name></decl>,
				<decl><type ref="prev"/><name>after_changecount</name></decl>,
				<decl><type ref="prev"/><name>cmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>last_checkpoint_number</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>chkp_lvl_blkno</name></decl>,
				<decl><type ref="prev"/><name>chkp_lvl_hikey_blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexType</name></type>	<name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>under_checkpoint</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>chkp_save_changecount_before</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><name>before_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>before_changecount</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>last_checkpoint_number</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>treeType</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>datoid</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>datoid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>relnode</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>relnode</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>chkp_lvl_blkno</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>chkp_lvl_hikey_blkno</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>hikeyBlkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bound</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>bound</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cur_key_type</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>curKeyType</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>chkp_save_changecount_after</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><name>after_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>before_changecount</name> <operator>!=</operator> <name>after_changecount</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>chkp_ordering_cmp</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr></argument>,
								<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr></argument>,
								<argument><expr><name>type</name></expr></argument>, <argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>relnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* easy case: BTree is not under checkpoint */</comment>
			<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Already passed checkpoint */</comment>
				<expr_stmt><expr><operator>*</operator><name>checkpoint_number</name> <operator>=</operator> <name>last_checkpoint_number</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>copy_blkno</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Not yet passed by checkpoint */</comment>
				<expr_stmt><expr><operator>*</operator><name>checkpoint_number</name> <operator>=</operator> <name>last_checkpoint_number</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>copy_blkno</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>chkp_save_changecount_after</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><name>after_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>before_changecount</name> <operator>!=</operator> <name>after_changecount</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>under_checkpoint</name> <operator>=</operator> <operator>(</operator><name>chkp_lvl_blkno</name> <operator>==</operator> <name>blkno</name> <operator>||</operator> <name>chkp_lvl_hikey_blkno</name> <operator>==</operator> <name>blkno</name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>under_checkpoint</name> <operator>&amp;&amp;</operator> <call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>LEFTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Page can be under checkpoint if concurrent rootPageBlkno split
			 * happens.
			 */</comment>
			<expr_stmt><expr><name>under_checkpoint</name> <operator>=</operator> <name>chkp_lvl_blkno</name> <operator>==</operator> <name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Can't evict page which is now under checkpoint: checkpoint
		 * algorithm does not allow this.
		 *
		 * That is reason why this check before curKeyType check.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>under_checkpoint</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>chkp_save_changecount_after</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><name>after_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>before_changecount</name> <operator>!=</operator> <name>after_changecount</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* the checkpointer does not write any page */</comment>
		<if_stmt><if>if <condition>(<expr><name>cur_key_type</name> <operator>==</operator> <name>CurKeyLeast</name> <operator>||</operator> <name>cur_key_type</name> <operator>==</operator> <name>CurKeyFinished</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>cur_key_type</name> <operator>==</operator> <name>CurKeyLeast</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>checkpoint_number</name> <operator>=</operator> <name>last_checkpoint_number</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>checkpoint_number</name> <operator>=</operator> <name>last_checkpoint_number</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>copy_blkno</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>chkp_save_changecount_after</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><name>after_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>before_changecount</name> <operator>!=</operator> <name>after_changecount</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>cur_key_type</name> <operator>==</operator> <name>CurKeyValue</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>copy_from_fixed_shmem_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>curKeyValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>bound</name> <operator>==</operator> <name>CheckpointBoundHikey</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>copy_from_fixed_shmem_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lvl_hikey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>hikey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>chkp_save_changecount_after</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><name>after_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>before_changecount</name> <operator>!=</operator> <name>after_changecount</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>side_of_checkpoint_bound</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>cur_key</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>cur_key_type</name></expr></argument>,
									   <argument><expr><name><name>lvl_hikey</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>chkp_save_changecount_after</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><name>after_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>before_changecount</name> <operator>!=</operator> <name>after_changecount</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>checkpoint_number</name> <operator>=</operator> <name>last_checkpoint_number</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>copy_blkno</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>checkpoint_number</name> <operator>=</operator> <name>last_checkpoint_number</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>copy_blkno</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Sets the autonomous level by backend. It should not be called for leafs.
 */</comment>
<function><type><name>void</name></type>
<name>backend_set_autonomous_level</name><parameter_list>(<parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>cur_level</name> <init>= <expr><name>ORIOLEDB_MAX_DEPTH</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* no sense in autonomous level for leafs */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>level</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * setups a new autonomous level if it less than current value of
	 * state-&gt;autonomousLevel
	 */</comment>
	<while>while <condition>(<expr><operator>!</operator><call><name>pg_atomic_compare_exchange_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>autonomousLevel</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>cur_level</name></expr></argument>,
										   <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>cur_level</name> <operator>&lt;=</operator> <name>level</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Make checkpoint of an index.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>checkpoint_ix</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileExtentsArray</name> <modifier>*</modifier></type><name>free_extents</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>finalize_filename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeMetaPage</name> <modifier>*</modifier></type><name>meta_page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>map_len</name></decl>,
				<decl><type ref="prev"/><name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>root_downlink</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CheckpointFileHeader</name></type> <name>header</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>file</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SeqBufTag</name></type>	<name>next_chkp_tag</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>,
				<decl><type ref="prev"/><name>next_tmp_tag</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>,
				<decl><type ref="prev"/><name>free_buf_tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cur_chkp_index</name></decl>,
				<decl><type ref="prev"/><name>next_chkp_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>datoid</name> <init>= <expr><name><name>descr</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relnode</name> <init>= <expr><name><name>descr</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>success</name></decl>,
				<decl><type ref="prev"/><name>is_compressed</name> <init>= <expr><call><name>OCompressIsValid</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CheckpointWriteBack</name></type> <name>writeback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>file_length</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * TODO: can we make checkpoint on evicted or unloaded tree?
	 */</comment>
	<expr_stmt><expr><call><name>checkpoint_ix_init_state</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cur_chkp_index</name> <operator>=</operator> <operator>(</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>next_chkp_index</name> <operator>=</operator> <operator>(</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>%</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>meta_page</name> <operator>=</operator> <call><name>BTREE_GET_META</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ORootPageIsValid</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OMetaPageIsValid</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize next checkpoint file and next tmp file */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>next_chkp_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>next_chkp_tag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>next_chkp_tag</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name>datoid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>next_chkp_tag</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name>relnode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>next_chkp_tag</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>next_chkp_tag</name><operator>.</operator><name>type</name></name> <operator>=</operator> <literal type="char">'m'</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_seq_buf_pages</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>next_chkp_index</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>init_seq_buf_pages</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>next_chkp_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free_seq_buf_pages</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>next_chkp_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free_seq_buf_pages</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>next_chkp_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Unable to get pages for sequence buffers."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>init_seq_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>next_chkp_index</name></expr>]</index></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>next_chkp_index</name></expr>]</index></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>next_chkp_tag</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CheckpointFileHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create a new sequence buffer file %s"</literal></expr></argument>,
						<argument><expr><call><name>get_seq_buf_filename</name><argument_list>(<argument><expr><operator>&amp;</operator><name>next_chkp_tag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>next_tmp_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>next_tmp_tag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>next_tmp_tag</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name>datoid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>next_tmp_tag</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name>relnode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>next_tmp_tag</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>next_tmp_tag</name><operator>.</operator><name>type</name></name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>init_seq_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>next_chkp_index</name></expr>]</index></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>next_chkp_index</name></expr>]</index></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>next_tmp_tag</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not init a new sequence buffer file %s"</literal></expr></argument>,
						<argument><expr><call><name>get_seq_buf_filename</name><argument_list>(<argument><expr><operator>&amp;</operator><name>next_tmp_tag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Make checkpoint of the tree itself */</comment>
	<expr_stmt><expr><call><name>init_writeback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writeback</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>is_compressed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>root_downlink</name> <operator>=</operator> <call><name>checkpoint_btree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>descr</name></expr></argument>, <argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>writeback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DiskDownlinkIsValid</name><argument_list>(<argument><expr><name>root_downlink</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free_writeback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writeback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>perform_writeback_and_relock</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>writeback</name></expr></argument>,
										 <argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_writeback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writeback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>descr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>curKeyType</name></name> <operator>==</operator> <name>CurKeyGreatest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DiskDownlinkIsValid</name><argument_list>(<argument><expr><name>root_downlink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_device</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_compressed</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>file_length</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>datafileLength</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <name>ORIOLEDB_COMP_BLCKSZ</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>file_length</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>datafileLength</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <name>ORIOLEDB_BLCKSZ</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>btree_smgr_sync</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>file_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_compressed</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>free_extents</name> <operator>=</operator> <call><name>file_extents_array_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>foreach_free_extent</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>foreach_extent_append</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>free_extents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>STOPEVENT</name><argument_list>(<argument><expr><name>STOPEVENT_BEFORE_BLKNO_LOCK</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Need a lock to be sure, that nobody is concurrently copying block
	 * number from previous checkpoint to current.  See write_page() for
	 * details.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>copyBlknoLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>chkp_inc_changecount_before</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>curKeyType</name></name> <operator>=</operator> <name>CurKeyFinished</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>chkp_inc_changecount_after</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make header for the map file... */</comment>
	<expr_stmt><expr><name><name>header</name><operator>.</operator><name>rootDownlink</name></name> <operator>=</operator> <name>root_downlink</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>.</operator><name>datafileLength</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>datafileLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>.</operator><name>leafPagesNum</name></name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>leafPagesNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>.</operator><name>ctid</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>ctid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_compressed</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>seq_buf_get_offset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>freeBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>free_buf_tag</name> <operator>=</operator> <name><name>descr</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>shared</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>copyBlknoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* finalizes *.tmp file */</comment>
	<expr_stmt><expr><call><name>seq_buf_finalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>cur_chkp_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_seq_buf_pages</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name><name>descr</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>cur_chkp_index</name></expr>]</index></name><operator>.</operator><name>shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* finalizes *.map file */</comment>
	<expr_stmt><expr><name>map_len</name> <operator>=</operator> <call><name>seq_buf_finalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>cur_chkp_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_seq_buf_pages</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name><name>descr</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>cur_chkp_index</name></expr>]</index></name><operator>.</operator><name>shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>get_seq_buf_filename</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>cur_chkp_index</name></expr>]</index></name><operator>.</operator><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open checkpoint file %s"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_compressed</name> <operator>&amp;&amp;</operator> <name><name>free_extents</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We need to combine a *.map file content and the free_extents array
		 * and remove all intersections
		 */</comment>
		<decl_stmt><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>map_extents</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>off_t</name></type>		<name>map_extents_size</name></decl>,
					<decl><type ref="prev"/><name>write_offset</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>CheckpointFileHeader</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>free_extents</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>map_extents_size</name> <operator>=</operator> <operator>(</operator><name>map_len</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CheckpointFileHeader</name></expr></argument>)</argument_list></sizeof><operator>)</operator>
			<operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FileExtent</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>map_extents_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* read and sort *.map file data */</comment>
			<decl_stmt><decl><type><name>off_t</name></type>		<name>map_extents_bytes</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>map_extents_bytes</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FileExtent</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>map_extents_size</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>map_extents</name> <operator>=</operator> <operator>(</operator><name>FileExtent</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>map_extents_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OFileRead</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>map_extents</name></expr></argument>, <argument><expr><name>map_extents_bytes</name></expr></argument>,
						  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CheckpointFileHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						  <argument><expr><name>WAIT_EVENT_DATA_FILE_READ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>map_extents_bytes</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not to read extents from file %s"</literal></expr></argument>,
									   <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* sort it */</comment>
			<expr_stmt><expr><call><name>pg_qsort</name><argument_list>(<argument><expr><name>map_extents</name></expr></argument>, <argument><expr><name>map_extents_size</name></expr></argument>,
					 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FileExtent</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>file_extents_off_len_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* and truncate the file because it may be less than original */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>FileTruncate</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CheckpointFileHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							 <argument><expr><name>WAIT_EVENT_DATA_FILE_TRUNCATE</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not to truncate file %s"</literal></expr></argument>,
									   <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>free_extents</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* checked above */</comment>
		<if_stmt><if>if <condition>(<expr><name>map_extents_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* easy case - just write sorted file extents */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>write_bytes</name> <init>= <expr><name><name>free_extents</name><operator>-&gt;</operator><name>size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FileExtent</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>OFileWrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>free_extents</name><operator>-&gt;</operator><name>extents</name></name></expr></argument>,
						   <argument><expr><name>write_bytes</name></expr></argument>, <argument><expr><name>write_offset</name></expr></argument>, <argument><expr><name>WAIT_EVENT_SLRU_WRITE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>write_bytes</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not to write extents to file %s"</literal></expr></argument>,
									   <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>header</name><operator>.</operator><name>numFreeBlocks</name></name> <operator>=</operator> <name><name>free_extents</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* create a new combined *.map file */</comment>
			<decl_stmt><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>write_buf</name><index>[<expr><name>ORIOLEDB_BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>f_i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
						<decl><type ref="prev"/><name>m_i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
						<decl><type ref="prev"/><name>write_buf_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>header</name><operator>.</operator><name>numFreeBlocks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>f_i</name> <operator>&lt;</operator> <name><name>free_extents</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>m_i</name> <operator>&lt;</operator> <name>map_extents_size</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>f_i</name> <operator>==</operator> <name><name>free_extents</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>cur</name> <operator>=</operator> <operator>&amp;</operator><name><name>map_extents</name><index>[<expr><name>m_i</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>m_i</name> <operator>==</operator> <name>map_extents_size</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>cur</name> <operator>=</operator> <operator>&amp;</operator><name><name>free_extents</name><operator>-&gt;</operator><name>extents</name><index>[<expr><name>f_i</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>map_extents</name><index>[<expr><name>m_i</name></expr>]</index></name><operator>.</operator><name>off</name> <operator>&lt;</operator> <name><name>free_extents</name><operator>-&gt;</operator><name>extents</name><index>[<expr><name>f_i</name></expr>]</index></name><operator>.</operator><name>off</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>cur</name> <operator>=</operator> <operator>&amp;</operator><name><name>map_extents</name><index>[<expr><name>m_i</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>cur</name> <operator>=</operator> <operator>&amp;</operator><name><name>free_extents</name><operator>-&gt;</operator><name>extents</name><index>[<expr><name>f_i</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
					<while>while <condition>(<expr><name>m_i</name> <operator>&lt;</operator> <name>map_extents_size</name>
						   <operator>&amp;&amp;</operator> <name><name>map_extents</name><index>[<expr><name>m_i</name></expr>]</index></name><operator>.</operator><name>off</name> <operator>&lt;</operator> <name><name>cur</name><operator>-&gt;</operator><name>off</name></name> <operator>+</operator> <name><name>cur</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* skip intersection */</comment>
						<expr_stmt><expr><name>m_i</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></while>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>write_buf_len</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FileExtent</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name>ORIOLEDB_BLCKSZ</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* flush the buffer */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>OFileWrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>write_buf</name></expr></argument>, <argument><expr><name>write_buf_len</name></expr></argument>, <argument><expr><name>write_offset</name></expr></argument>,
								   <argument><expr><name>WAIT_EVENT_SLRU_WRITE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>write_buf_len</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
										<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not to write extents to file %s"</literal></expr></argument>,
											   <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>write_offset</name> <operator>+=</operator> <name>write_buf_len</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>write_buf_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>write_buf</name> <operator>+</operator> <name>write_buf_len</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FileExtent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>write_buf_len</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FileExtent</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>header</name><operator>.</operator><name>numFreeBlocks</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>

			<if_stmt><if>if <condition>(<expr><name>write_buf_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>OFileWrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>write_buf</name></expr></argument>, <argument><expr><name>write_buf_len</name></expr></argument>, <argument><expr><name>write_offset</name></expr></argument>,
							   <argument><expr><name>WAIT_EVENT_SLRU_WRITE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>write_buf_len</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
									<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not to write extents to file %s"</literal></expr></argument>,
										   <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* free allocated bytes */</comment>
		<if_stmt><if>if <condition>(<expr><name>map_extents_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>map_extents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>file_extents_array_free</name><argument_list>(<argument><expr><name>free_extents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>is_compressed</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_compressed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>finalize_filename</name> <operator>=</operator> <ternary><condition><expr><call><name>seq_buf_file_exist</name><argument_list>(<argument><expr><operator>&amp;</operator><name>free_buf_tag</name></expr></argument>)</argument_list></call></expr>
			?</condition><then> <expr><call><name>get_seq_buf_filename</name><argument_list>(<argument><expr><operator>&amp;</operator><name>free_buf_tag</name></expr></argument>)</argument_list></call></expr>
			</then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>map_len</name> <operator>=</operator> <call><name>finalize_chkp_map</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>map_len</name></expr></argument>, <argument><expr><name>finalize_filename</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
									<argument><expr><name><name>free_buf_tag</name><operator>.</operator><name>num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>finalize_filename</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>finalize_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>header</name><operator>.</operator><name>numFreeBlocks</name></name> <operator>=</operator> <operator>(</operator><name>map_len</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CheckpointFileHeader</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>/</operator> <operator>(</operator><ternary><condition><expr><name>use_device</name></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>FileExtent</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* nothing to do */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>is_compressed</name> <operator>&amp;&amp;</operator> <name><name>free_extents</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>.</operator><name>numFreeBlocks</name></name> <operator>=</operator> <operator>(</operator><name>map_len</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CheckpointFileHeader</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FileExtent</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OFileWrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				   <argument><expr><name>WAIT_EVENT_SLRU_WRITE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof> <operator>||</operator>
		<call><name>FileSync</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>WAIT_EVENT_SLRU_SYNC</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write checkpoint header to file %s"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>chkp_inc_changecount_before</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>completed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>chkp_inc_changecount_after</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Checkpointer walk over particular B-tree. Returns rootPageBlkno page offset.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>checkpoint_btree</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier><modifier>*</modifier></type><name>descrPtr</name></decl></parameter>, <parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
				 <parameter><decl><type><name>CheckpointWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>root_downlink</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tmp_context</name></decl>,
				<decl><type ref="prev"/><name>prev_context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tmp_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
										<argument><expr><literal type="string">"checkpoint temporary context"</literal></expr></argument>,
										<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>tmp_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_skip_ucm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Walk the tree recursively starting from rootPageBlkno */</comment>
	<expr_stmt><expr><name>root_downlink</name> <operator>=</operator> <call><name>checkpoint_btree_loop</name><argument_list>(<argument><expr><name>descrPtr</name></expr></argument>,
										  <argument><expr><name>state</name></expr></argument>,
										  <argument><expr><name>writeback</name></expr></argument>,
										  <argument><expr><name>tmp_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unset_skip_ucm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>checkpoint_reset_stack</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>prev_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>tmp_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>root_downlink</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Resets autonomous level to default value and returns previous value.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint32</name></type>
<name>checkpointer_reset_autonomous_level</name><parameter_list>(<parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>cur_level</name> <init>= <expr><name>ORIOLEDB_MAX_DEPTH</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * CAS read of current autonomous level and setup it to default value
	 */</comment>
	<while>while <condition>(<expr><operator>!</operator><call><name>pg_atomic_compare_exchange_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>autonomousLevel</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>cur_level</name></expr></argument>,
										   <argument><expr><name>ORIOLEDB_MAX_DEPTH</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>
	<return>return <expr><name>cur_level</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Setups autonomous flag for stack items from state-&gt;autonomousLevel.
 *
 * Should be used only under lock_page() for avoid concurrent issues in
 * min_level == autonomous_level case.
 *
 * min_level used only for assertion.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>checkpointer_update_autonomous</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>cur_chkp_num</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>autonomous_level</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>autonomous_level</name> <operator>=</operator> <call><name>checkpointer_reset_autonomous_level</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>autonomous_level</name> <operator>==</operator> <name>ORIOLEDB_MAX_DEPTH</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * autonomous level is default value, no need to setup autonomous
		 * flags
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>curKeyType</name></name> <operator>==</operator> <name>CurKeyLeast</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * we do not make any leaf write, no sense yet.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>autonomous_level</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OInMemoryBlknoIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>autonomous_level</name></expr>]</index></name><operator>.</operator><name>blkno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* go upwards for the stack and setup autonomous flag if needed */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>autonomous_level</name></expr>;</init> <condition><expr><call><name>OInMemoryBlknoIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OrioleDBPageDesc</name> <modifier>*</modifier></type><name>page_desc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>autonomous</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>autonomous</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>autonomousLeftmost</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>leftmost</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>page_desc</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>checkpointNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>FileExtentIsValid</name><argument_list>(<argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* the offset will not be used in current checkpoint */</comment>
				<expr_stmt><expr><call><name>free_extent_for_checkpoint</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>, <argument><expr><name>cur_chkp_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MARK_DIRTY</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* stack last item must be the rootPageBlkno page */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>blkno</name> <operator>==</operator> <name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Locks page, updates autonomous flags and stack after rootPageBlkno split.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkpoint_lock_page</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
					 <parameter><decl><type><name>OInMemoryBlkno</name> <modifier>*</modifier></type><name>blkno</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>page_chage_count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>,
				<decl><type ref="prev"/><name>img</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>l</name></decl>,
				<decl><type ref="prev"/><name>page_level</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>next_blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>autonomous</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>lock_page</name><argument_list>(<argument><expr><operator>*</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><operator>*</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page_level</name> <operator>=</operator> <call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>page_level</name> <operator>==</operator> <name>level</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>checkpointer_update_autonomous</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>blkno</name> <operator>!=</operator> <name><name>descr</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>page_chage_count</name> <operator>!=</operator> <name>InvalidOPageChangeCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>page_chage_count</name> <operator>!=</operator> <call><name>O_PAGE_GET_CHANGE_COUNT</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * only rootPageBlkno page split increases page level (and only for
	 * rootPageBlkno page)
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>page_level</name> <operator>&gt;</operator> <name>level</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>blkno</name> <operator>==</operator> <name><name>descr</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Concurrent rootPageBlkno spit happens. We need to fill stack from a new
	 * rootPageBlkno level (page_level) to old rootPageBlkno level (level).
	 */</comment>

	<comment type="block">/* we need to setup autonomous flag the same to old rootPageBlkno level */</comment>
	<expr_stmt><expr><name>autonomous</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>autonomous</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>chkp_inc_changecount_before</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>l</name> <operator>=</operator> <name>page_level</name></expr>;</init> <condition><expr><name>l</name> <operator>&gt;</operator> <name>level</name></expr>;</condition> <incr><expr><name>l</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>pageLoc</name></decl>,
					<decl><type ref="prev"/><name>imageLoc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LocationIndex</name></type> <name>itemsize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>downlink</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_FIRST</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pageLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemsize</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pageLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>l</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OInMemoryBlknoIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name>blkno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name>autonomous</name> <operator>=</operator> <name>autonomous</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>autonomous</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we did not forget about merge */</comment>
			<expr_stmt><expr><call><name>copy_fixed_shmem_hikey</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name>hikey</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name>bound</name> <operator>=</operator> <name>CheckpointBoundHikey</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name>blkno</name> <operator>=</operator> <operator>*</operator><name>blkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name>hikeyBlkno</name> <operator>=</operator> <operator>*</operator><name>blkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pageLoc</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name>NextKeyNone</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name>leftmost</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name>autonomousLeftmost</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>chkp_inc_changecount_after</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>img</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name>image</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>init_page_first_chunk</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_FIRST</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>imageLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>page_locator_insert_item</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>imageLoc</name></expr></argument>, <argument><expr><name>itemsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>imageLoc</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pageLoc</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>itemsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTREE_PAGE_SET_ITEM_FLAGS</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>imageLoc</name></expr></argument>, <argument><expr><call><name>BTREE_PAGE_GET_ITEM_FLAGS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pageLoc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tuphdr</name> <operator>=</operator> <operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pageLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>downlink</name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr>;</expr_stmt>

		<comment type="block">/* Page under checkpoint shouldn't be evicted... */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DOWNLINK_IS_IN_MEMORY</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>next_blkno</name> <operator>=</operator> <call><name>DOWNLINK_GET_IN_MEMORY_BLKNO</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><operator>*</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>blkno</name> <operator>=</operator> <name>next_blkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lock_page</name><argument_list>(<argument><expr><operator>*</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><operator>*</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>chkp_inc_changecount_before</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>l</name> <operator>==</operator> <name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* can not be merged */</comment>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>blkno</name> <operator>=</operator> <operator>*</operator><name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>hikeyBlkno</name> <operator>=</operator> <operator>*</operator><name>blkno</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>checkpointer_update_autonomous</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>autonomous</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>copy_fixed_shmem_hikey</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>hikey</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>bound</name> <operator>=</operator> <name>CheckpointBoundHikey</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>autonomous</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * autonomous state of the level updated while we traverse down,
		 * update parents state
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>bound</name> <operator>==</operator> <name>CheckpointBoundRightmost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>l</name> <operator>=</operator> <name>page_level</name></expr>;</init> <condition><expr><name>l</name> <operator>&gt;</operator> <name>level</name></expr>;</condition> <incr><expr><name>l</name><operator>--</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name>autonomous</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name>bound</name> <operator>=</operator> <name>CheckpointBoundRightmost</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>chkp_inc_changecount_after</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>checkpoint_try_merge_page</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
						  <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>parentBlkno</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>blkno</name></expr></init></decl>,
				<decl><type ref="prev"/><name>rightBlkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>parentPage</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>parentBlkno</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>rightPage</name></decl>,
				<decl><type ref="prev"/><name>page</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name>		<name>key</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>mergeParent</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RightLinkIsValid</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_GET_RIGHTLINK</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>hikeyBlkno</name> <operator>==</operator> <name>blkno</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>try_lock_page</name><argument_list>(<argument><expr><name>parentBlkno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>offset</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator>
		<name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>offset</name> <operator>&gt;=</operator> <call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>parentPage</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>parentBlkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>BTREE_PAGE_OFFSET_GET_LOCATOR</name><argument_list>(<argument><expr><name>parentPage</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>offset</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>parentPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTREE_PAGE_READ_INTERNAL_ITEM</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>parentPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DOWNLINK_IS_IN_MEMORY</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>DOWNLINK_GET_IN_MEMORY_BLKNO</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>blkno</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>parentBlkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name>parentPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>parentPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTREE_PAGE_READ_INTERNAL_ITEM</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>parentPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DOWNLINK_IS_IN_MEMORY</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>parentBlkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>rightBlkno</name> <operator>=</operator> <call><name>DOWNLINK_GET_IN_MEMORY_BLKNO</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightPage</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>rightBlkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>try_lock_page</name><argument_list>(<argument><expr><name>rightBlkno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>parentBlkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RightLinkIsValid</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_GET_RIGHTLINK</name><argument_list>(<argument><expr><name>rightPage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>parentBlkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>rightBlkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>btree_try_merge_pages</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>parentBlkno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mergeParent</name></expr></argument>,
							  <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>, <argument><expr><name>rightBlkno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>release_undo_size</name><argument_list>(<argument><expr><name>UndoReserveTxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free_retained_undo_location</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>reserve_undo_size</name><argument_list>(<argument><expr><name>UndoReserveTxn</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>O_MERGE_UNDO_IMAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>parentBlkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>rightBlkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Locks a given page for safely processing by the checkpointer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkpoint_fix_split_and_lock_page</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
								   <parameter><decl><type><name>OInMemoryBlkno</name> <modifier>*</modifier></type><name>blkno</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>page_chage_count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>old_blkno</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>reserve_undo_size</name><argument_list>(<argument><expr><name>UndoReserveTxn</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>O_MERGE_UNDO_IMAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>relocked</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>old_blkno</name> <operator>=</operator> <operator>*</operator><name>blkno</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>checkpoint_lock_page</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>page_chage_count</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>old_blkno</name> <operator>==</operator> <operator>*</operator><name>blkno</name> <operator>&amp;&amp;</operator> <name>page_chage_count</name> <operator>!=</operator> <name>InvalidOPageChangeCount</name> <operator>&amp;&amp;</operator>
			<call><name>O_GET_IN_MEMORY_PAGE_CHANGE_COUNT</name><argument_list>(<argument><expr><operator>*</operator><name>blkno</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>page_chage_count</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>o_btree_split_is_incomplete</name><argument_list>(<argument><expr><operator>*</operator><name>blkno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relocked</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>o_btree_split_fix_and_unlock</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>*</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>reserve_undo_size</name><argument_list>(<argument><expr><name>UndoReserveTxn</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>O_MERGE_UNDO_IMAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>level</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>blkno</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>hikeyBlkno</name><operator>)</operator> <operator>&amp;&amp;</operator>
				 <call><name>is_page_too_sparse</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><operator>*</operator><name>blkno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Try merge page to the right.  Skip merge for autonomous pages,
			 * because we could miss the expected hikey then.
			 */</comment>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>checkpoint_try_merge_page</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>*</operator><name>blkno</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>relocked</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><operator>*</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>release_undo_size</name><argument_list>(<argument><expr><name>UndoReserveTxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_retained_undo_location</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>next_key_to_jsonb</name><parameter_list>(<parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier><modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>,
				  <parameter><decl><type><name>NextKeyType</name></type> <name>keyType</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>keyValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_BEGIN_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>keyType</name> <operator>==</operator> <name>NextKeyGreatest</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>jsonb_push_string_key</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><literal type="string">"greatest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>keyType</name> <operator>==</operator> <name>NextKeyNone</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>jsonb_push_string_key</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>keyType</name> <operator>==</operator> <name>NextKeyValue</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>jsonb_push_string_key</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jsonb_push_key</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>o_btree_key_to_jsonb</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>keyValue</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Jsonb</name> <modifier>*</modifier></type>
<name>prepare_checkpoint_step_params</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>,
							   <parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>chkpState</name></decl></parameter>,
							   <parameter><decl><type><name>WalkMessage</name> <modifier>*</modifier></type><name>message</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mctx</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>stopevents_cxt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>WJB_BEGIN_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>btree_desc_stopevent_params_internal</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jsonb_push_int8_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"level"</literal></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>message</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>jsonb_push_string_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"action"</literal></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>message</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>WalkDownwards</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>jsonb_push_string_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"action"</literal></expr></argument>, <argument><expr><literal type="string">"walkDownwards"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jsonb_push_int8_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"blkno"</literal></expr></argument>, <argument><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>downwards</name><operator>.</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jsonb_push_int8_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"pageChangeCount"</literal></expr></argument>, <argument><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>downwards</name><operator>.</operator><name>pageChangeCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>downwards</name><operator>.</operator><name>lokey</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>jsonb_push_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"lokey"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>o_btree_key_to_jsonb</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>downwards</name><operator>.</operator><name>lokey</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>jsonb_push_null_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"lokey"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>message</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>WalkUpwards</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>jsonb_push_string_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"action"</literal></expr></argument>, <argument><expr><literal type="string">"walkUpwards"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jsonb_push_bool_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"parentDirty"</literal></expr></argument>, <argument><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>parentDirty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jsonb_push_bool_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"saveTuple"</literal></expr></argument>, <argument><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>saveTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jsonb_push_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"downlink"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>WJB_BEGIN_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jsonb_push_int8_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><call><name>DOWNLINK_GET_DISK_OFF</name><argument_list>(<argument><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>diskDownlink</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jsonb_push_int8_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"length"</literal></expr></argument>, <argument><expr><call><name>DOWNLINK_GET_DISK_LEN</name><argument_list>(<argument><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>diskDownlink</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>WJB_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>saveTuple</name></name> <operator>||</operator> <call><name>DiskDownlinkIsValid</name><argument_list>(<argument><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>diskDownlink</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>jsonb_push_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"nextKey"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>next_key_to_jsonb</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>, <argument><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>nextkeyType</name></name></expr></argument>,
							  <argument><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>nextkey</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>message</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>WalkContinue</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CheckpointPageInfo</name> <modifier>*</modifier></type><name>pageInfo</name> <init>= <expr><operator>&amp;</operator><name><name>chkpState</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>jsonb_push_string_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"action"</literal></expr></argument>, <argument><expr><literal type="string">"walkContinue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jsonb_push_bool_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"autonomous"</literal></expr></argument>, <argument><expr><name><name>pageInfo</name><operator>-&gt;</operator><name>autonomous</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jsonb_push_bool_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"leftmost"</literal></expr></argument>, <argument><expr><name><name>pageInfo</name><operator>-&gt;</operator><name>leftmost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jsonb_push_int8_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"blkno"</literal></expr></argument>, <argument><expr><name><name>pageInfo</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jsonb_push_int8_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><name><name>pageInfo</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jsonb_push_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"nextKey"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>next_key_to_jsonb</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>, <argument><expr><name><name>pageInfo</name><operator>-&gt;</operator><name>nextkeyType</name></name></expr></argument>,
						  <argument><expr><call><name>fixed_shmem_key_get_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pageInfo</name><operator>-&gt;</operator><name>nextkey</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>WJB_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Jsonb</name> <modifier>*</modifier></type>
<name>prepare_checkpoint_table_start_params</name><parameter_list>(<parameter><decl><type><name>ORelOids</name></type> <name>tableOids</name></decl></parameter>, <parameter><decl><type><name>ORelOids</name></type> <name>treeOids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mctx</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>stopevents_cxt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>WJB_BEGIN_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jsonb_push_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>WJB_BEGIN_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jsonb_push_int8_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"datoid"</literal></expr></argument>, <argument><expr><name><name>tableOids</name><operator>.</operator><name>datoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jsonb_push_int8_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"reloid"</literal></expr></argument>, <argument><expr><name><name>tableOids</name><operator>.</operator><name>reloid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jsonb_push_int8_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"relnode"</literal></expr></argument>, <argument><expr><name><name>tableOids</name><operator>.</operator><name>relnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>WJB_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jsonb_push_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"tree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>WJB_BEGIN_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jsonb_push_int8_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"datoid"</literal></expr></argument>, <argument><expr><name><name>treeOids</name><operator>.</operator><name>datoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jsonb_push_int8_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"reloid"</literal></expr></argument>, <argument><expr><name><name>treeOids</name><operator>.</operator><name>reloid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jsonb_push_int8_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"relnode"</literal></expr></argument>, <argument><expr><name><name>treeOids</name><operator>.</operator><name>relnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>WJB_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>WJB_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Jsonb</name> <modifier>*</modifier></type>
<name>prepare_checkpoint_tree_start_params</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mctx</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>stopevents_cxt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>WJB_BEGIN_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>btree_desc_stopevent_params_internal</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>WJB_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>checkpoint_btree_loop</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier><modifier>*</modifier></type><name>descrPtr</name></decl></parameter>,
					  <parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
					  <parameter><decl><type><name>CheckpointWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>,
					  <parameter><decl><type><name>MemoryContext</name></type> <name>tmp_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WalkMessage</name></type> <name>message</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>downlink</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>level</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name> <init>= <expr><operator>*</operator><name>descrPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name> <init>= <expr><name><name>descr</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>page_chage_count</name> <init>= <expr><name>InvalidOPageChangeCount</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type>		<name>blcksz</name> <init>= <expr><ternary><condition><expr><call><name>OCompressIsValid</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>ORIOLEDB_COMP_BLCKSZ</name></expr> </then><else>: <expr><name>ORIOLEDB_BLCKSZ</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>params</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>message</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalkMessage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare message start walk from the rootPageBlkno */</comment>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>level</name> <operator>=</operator> <call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>message</name><operator>.</operator><name>action</name></name> <operator>=</operator> <name>WalkDownwards</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>downwards</name><operator>.</operator><name>blkno</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>downwards</name><operator>.</operator><name>pageChangeCount</name></name> <operator>=</operator> <call><name>O_PAGE_GET_CHANGE_COUNT</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>clear_fixed_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>downwards</name><operator>.</operator><name>lokey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>chkp_inc_changecount_before</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>level</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ORIOLEDB_MAX_DEPTH</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bound</name> <operator>=</operator> <name>CheckpointBoundRightmost</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hikeyBlkno</name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* avoid fail on first traverse to rootPageBlkno */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>blkno</name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>chkp_inc_changecount_after</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>level</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>have_locked_pages</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>have_retained_undo_location</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>tmp_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>STOPEVENTS_ENABLED</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>prepare_checkpoint_step_params</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>message</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>STOPEVENT</name><argument_list>(<argument><expr><name>STOPEVENT_CHECKPOINT_STEP</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>message</name><operator>.</operator><name>action</name></name> <operator>==</operator> <name>WalkDownwards</name> <operator>&amp;&amp;</operator>
			<name>level</name> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator>
			<name><name>writeback</name><operator>-&gt;</operator><name>extentsNumber</name></name> <operator>&gt;=</operator> <name>checkpoint_flush_after</name> <operator>*</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <name>blcksz</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>perform_writeback_and_relock</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>writeback</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>message</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>descr</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>InvalidDiskDownlink</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>descrPtr</name> <operator>=</operator> <name>descr</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>message</name><operator>.</operator><name>action</name></name> <operator>==</operator> <name>WalkDownwards</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>was_dirty</name></decl>,
						<decl><type ref="prev"/><name>parent_dirty</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Page</name></type>		<name>img</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OrioleDBPageDesc</name> <modifier>*</modifier></type><name>page_desc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>level</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>level</name><operator>--</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>downwards</name><operator>.</operator><name>blkno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>page_chage_count</name> <operator>=</operator> <name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>downwards</name><operator>.</operator><name>pageChangeCount</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>checkpoint_fix_split_and_lock_page</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>, <argument><expr><name>page_chage_count</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Check if it not the page we expected, because it might
			 * disappear due to concurrent eviction.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_GET_CHANGE_COUNT</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>downwards</name><operator>.</operator><name>pageChangeCount</name></name>
				<operator>&amp;&amp;</operator> <name>blkno</name> <operator>==</operator> <name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>downwards</name><operator>.</operator><name>blkno</name></name></expr>)</condition>	<comment type="block">/* rootPageBlkno level
																 * does not change */</comment>
			<block>{<block_content>
				<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>message</name><operator>.</operator><name>action</name></name> <operator>=</operator> <name>WalkUpwards</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>parentDirty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>diskDownlink</name></name> <operator>=</operator> <name>InvalidDiskDownlink</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>saveTuple</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>img</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>image</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>autonomous</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Updates right checkpoint bound. */</comment>
				<expr_stmt><expr><call><name>chkp_inc_changecount_before</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>copy_fixed_shmem_hikey</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>hikey</name></expr></argument>,
										   <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>bound</name> <operator>=</operator> <name>CheckpointBoundHikey</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>hikeyBlkno</name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>bound</name> <operator>=</operator> <name>CheckpointBoundRightmost</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>hikeyBlkno</name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><call><name>chkp_inc_changecount_after</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>level</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>autonomous</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Downwards to autonomous node, we must free file offset if
				 * it exist.
				 */</comment>
				<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>page_desc</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>checkpointNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>FileExtentIsValid</name><argument_list>(<argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* the offset will not be used in current checkpoint */</comment>
					<expr_stmt><expr><call><name>free_extent_for_checkpoint</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>,
											   <argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>MARK_DIRTY</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Leaf pages are going to be written immediately.  So, check
			 * there is no IO in progress.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>ionum</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>page_desc</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ionum</name> <operator>=</operator> <name><name>page_desc</name><operator>-&gt;</operator><name>ionum</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ionum</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>wait_for_io_completion</name><argument_list>(<argument><expr><name>ionum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>level</name><operator>++</operator></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>chkp_inc_changecount_before</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>blkno</name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>chkp_inc_changecount_after</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>was_dirty</name> <operator>=</operator> <call><name>IS_DIRTY</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>was_dirty</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Code above ensured there is no IO in progress */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>ionum</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>ionum</name></name> <operator>=</operator> <call><name>assign_io_num</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * we assume that concurrent eviction of the parent is
					 * forbidden by get_checkpoint_number() in walk_page()
					 */</comment>
					<expr_stmt><expr><call><name>CLEAN_DIRTY</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* prepare_leaf_page() unlocks page */</comment>
					<expr_stmt><expr><call><name>prepare_leaf_page</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>downlink</name> <operator>=</operator> <call><name>perform_page_io</name><argument_list>(<argument><expr><name>descr</name></expr></argument>,
											   <argument><expr><name>blkno</name></expr></argument>,
											   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>image</name></expr></argument>,
											   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>parent_dirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DiskDownlinkIsValid</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unable to perform page IO for page %d to file %s with offset %lu"</literal></expr></argument>,
							 <argument><expr><name>blkno</name></expr></argument>,
							 <argument><expr><call><name>btree_smgr_filename</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name><operator>.</operator><name>off</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name><operator>.</operator><name>off</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><call><name>writeback_put_extent</name><argument_list>(<argument><expr><name>writeback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>unlock_io</name><argument_list>(<argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>ionum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>ionum</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>autonomous</name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>parent_dirty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>downlink</name> <operator>=</operator> <call><name>MAKE_ON_DISK_DOWNLINK</name><argument_list>(<argument><expr><call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fileExtent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* prepare_leaf_page() unlocks page */</comment>
					<expr_stmt><expr><call><name>prepare_leaf_page</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/* Indicate that we've finished that page image */</comment>
				<expr_stmt><expr><name><name>message</name><operator>.</operator><name>action</name></name> <operator>=</operator> <name>WalkUpwards</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DiskDownlinkIsValid</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>parentDirty</name></name> <operator>=</operator> <name>parent_dirty</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>diskDownlink</name></name> <operator>=</operator> <name>downlink</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>saveTuple</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>nextkeyType</name></name> <operator>=</operator> <name>NextKeyGreatest</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>nextkeyType</name></name> <operator>=</operator> <name>NextKeyValue</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>copy_fixed_hikey</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>nextkey</name></name></expr></argument>, <argument><expr><name>img</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>img</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name>NextKeyNone</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* else level != 0 */</comment>

			<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>img</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>init_page_first_chunk</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* saves lokey for the node */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>downwards</name><operator>.</operator><name>lokey</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>leftmost</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>leftmost</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>copy_fixed_shmem_key</name><argument_list>(<argument><expr><name>descr</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>lokey</name></expr></argument>,
									 <argument><expr><name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>downwards</name><operator>.</operator><name>lokey</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>message</name><operator>.</operator><name>action</name></name> <operator>==</operator> <name>WalkUpwards</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Page</name></type>		<name>img</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>save_item</name></decl>,
						<decl><type ref="prev"/><name>valid_doff</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>save_item</name> <operator>=</operator> <name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>saveTuple</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>valid_doff</name> <operator>=</operator> <call><name>DiskDownlinkIsValid</name><argument_list>(<argument><expr><name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>diskDownlink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>level</name> <operator>=</operator> <name>level</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>page_chage_count</name> <operator>=</operator> <name>InvalidOPageChangeCount</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>autonomousTupleExist</name> <operator>=</operator> <name>save_item</name></expr>;</expr_stmt>
			<comment type="block">/* Is everything done? */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OInMemoryBlknoIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>valid_doff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>diskDownlink</name></name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>img</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>image</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>img</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Did we manage to write the page? */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid_doff</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>save_item</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Setup next key */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>img</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>img</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>init_page_first_chunk</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name>NextKeyNone</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_LAST</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name>NextKeyValue</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>copy_fixed_shmem_page_key</name><argument_list>(<argument><expr><name>descr</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkey</name></expr></argument>,
											  <argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>page_locator_delete_item</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>offset</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>nextkeyType</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>==</operator> <name>NextKeyValue</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>copy_fixed_shmem_key</name><argument_list>(<argument><expr><name>descr</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkey</name></expr></argument>,
										 <argument><expr><name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>nextkey</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>save_item</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* make downlink */</comment>
					<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>valid_doff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_LAST</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>tuphdr</name> <operator>=</operator> <operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator>
						<call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name> <operator>=</operator> <name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>diskDownlink</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>checkpoint_fix_split_and_lock_page</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>, <argument><expr><name>page_chage_count</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>message</name><operator>.</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>parentDirty</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>MARK_DIRTY</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>message</name><operator>.</operator><name>action</name></name> <operator>==</operator> <name>WalkContinue</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>checkpoint_fix_split_and_lock_page</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>, <argument><expr><name>page_chage_count</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>checkpoint_internal_pass</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>writeback</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Return true if an item successfully added to checkpoint image.
 * Returns false if no enough space at the image for the item. It may happens
 * only for autonomous images.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>checkpoint_image_add_item</name><parameter_list>(<parameter><decl><type><name>CheckpointPageInfo</name> <modifier>*</modifier></type><name>page_info</name></decl></parameter>,
						  <parameter><decl><type><name>StackImageAddType</name></type> <name>type</name></decl></parameter>,
						  <parameter><decl><type><name>OTuple</name></type> <name>key</name></decl></parameter>,
						  <parameter><decl><type><name>uint</name></type> <name>key_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>img</name> <init>= <expr><name><name>page_info</name><operator>-&gt;</operator><name>image</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>img_count</name> <init>= <expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>img</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type>		<name>item_size</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>StackImageAddHikey</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* hikey insert case */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>key_size</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>item_size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>key_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>page_info</name><operator>-&gt;</operator><name>autonomous</name></name> <operator>||</operator> <name>img_count</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>page_fits_hikey</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><name>item_size</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OTuple</name></type>		<name>hikey</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>page_resize_hikey</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><name>item_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BTREE_PAGE_SET_HIKEY_FLAGS</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>formatFlags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>img</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hikey</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>key_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>

		<comment type="block">/* downlink insert case */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>type</name> <operator>==</operator> <name>StackImageAddDownlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* we need additional space for BTreeNonLeafTuphdr */</comment>
		<expr_stmt><expr><name>item_size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>BTreeNonLeafTuphdrSize</name> <operator>+</operator> <name>key_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_TAIL</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>page_info</name><operator>-&gt;</operator><name>autonomous</name></name> <operator>||</operator> <name>img_count</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>page_locator_fits_new_item</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>, <argument><expr><name>item_size</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>page_locator_insert_item</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>, <argument><expr><name>item_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>key_size</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Pointer</name></type>		<name>image_key</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>image_key</name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>BTreeNonLeafTuphdrSize</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>image_key</name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>key_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>BTREE_PAGE_SET_ITEM_FLAGS</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>formatFlags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>page_info</name><operator>-&gt;</operator><name>autonomous</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Splits the autonomous image. Last tuple is divided into two parts:
 *
 * 1. Key will be set as hikey of splitted image.
 * 2. BTreeNonLeafTuphdr will be returned.
 */</comment>
<function><type><specifier>static</specifier> <name>BTreeNonLeafTuphdr</name></type>
<name>autonomous_image_split</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>CheckpointPageInfo</name> <modifier>*</modifier></type><name>page_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OFixedKey</name></type>	<name>saved_key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>hikey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>img</name> <init>= <expr><name><name>page_info</name><operator>-&gt;</operator><name>image</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>key_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>page_info</name><operator>-&gt;</operator><name>autonomous</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* page must contain a full node tuple (downlink + key) */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>img</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_LAST</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* save internal header */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
		   <argument><expr><call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTreeNonLeafTuphdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* save key to the buffer */</comment>
	<expr_stmt><expr><call><name>copy_fixed_page_key</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved_key</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>key_len</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>o_btree_len</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name><name>saved_key</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>OKeyLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* remove tuple */</comment>
	<expr_stmt><expr><call><name>page_locator_delete_item</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add a new hikey */</comment>
	<expr_stmt><expr><call><name>page_resize_hikey</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTREE_PAGE_SET_HIKEY_FLAGS</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><name><name>saved_key</name><operator>.</operator><name>tuple</name><operator>.</operator><name>formatFlags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>img</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hikey</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>saved_key</name><operator>.</operator><name>tuple</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Writes the autonomous image of given stack level to disk.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>autonomous_image_write</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
					   <parameter><decl><type><name>CheckpointWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>img</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>image</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>img_header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>downlink</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FileExtent</name></type>	<name>extent</name></decl>;</decl_stmt>

	<comment type="block">/* prepare the image header */</comment>
	<expr_stmt><expr><name>img_header</name> <operator>=</operator> <operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>img</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>img_header</name><operator>-&gt;</operator><name>checkpointNum</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>img_header</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>img_header</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <name>COMMITSEQNO_FROZEN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>img_header</name><operator>-&gt;</operator><name>rightLink</name></name> <operator>=</operator> <name>InvalidRightLink</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>img_header</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PAGE_SET_N_ONDISK</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>img</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PAGE_SET_LEVEL</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>extent</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>InvalidFileExtentLen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extent</name><operator>.</operator><name>off</name></name> <operator>=</operator> <name>InvalidFileExtentOff</name></expr>;</expr_stmt>

	<comment type="block">/* write the image to disk */</comment>
	<expr_stmt><expr><call><name>split_page_by_chunks</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>img</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>downlink</name> <operator>=</operator> <call><name>perform_page_io_autonomous</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>writeback_put_extent</name><argument_list>(<argument><expr><name>writeback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DiskDownlinkIsValid</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The BTree is not contain a page with the offset, so we need to free it
	 * for next checkpoint because it will not be possible in the future.
	 */</comment>
	<expr_stmt><expr><call><name>free_extent_for_checkpoint</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* the next page no more can be leftmost for the current level */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>autonomousLeftmost</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name>downlink</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Updates lowest level hikeys and reset autonomous flag if needed.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>update_lowest_level_hikey</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>to_level</name></decl></parameter>,
						  <parameter><decl><type><name>OTuple</name></type> <name>hikey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CheckpointPageInfo</name> <modifier>*</modifier></type><name>page_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>autonomous</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>to_level</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>pageHikey</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>page_info</name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>hikey</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* no more pages on the level */</comment>
			<expr_stmt><expr><name><name>page_info</name><operator>-&gt;</operator><name>autonomous</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>page_info</name><operator>-&gt;</operator><name>bound</name></name> <operator>=</operator> <name>CheckpointBoundRightmost</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>page_info</name><operator>-&gt;</operator><name>hikeyBlkno</name></name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>autonomous</name> <operator>=</operator> <name><name>page_info</name><operator>-&gt;</operator><name>autonomous</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pageHikey</name> <operator>=</operator> <call><name>fixed_shmem_key_get_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page_info</name><operator>-&gt;</operator><name>hikey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>autonomous</name> <operator>||</operator> <operator>(</operator><name><name>page_info</name><operator>-&gt;</operator><name>bound</name></name> <operator>==</operator> <name>CheckpointBoundHikey</name> <operator>&amp;&amp;</operator>
							<call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>descr</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>pageHikey</name></expr></argument>,
										<argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>hikey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* update hikey if no need in autonomous flag */</comment>
			<expr_stmt><expr><name><name>page_info</name><operator>-&gt;</operator><name>bound</name></name> <operator>=</operator> <name>CheckpointBoundHikey</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>page_info</name><operator>-&gt;</operator><name>autonomous</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>page_info</name><operator>-&gt;</operator><name>hikeyBlkno</name></name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>copy_fixed_shmem_key</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>page_info</name><operator>-&gt;</operator><name>hikey</name></name></expr></argument>, <argument><expr><name>hikey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * There is no free space left on the current autonomous image. The image
 * should be splitted and then written. Downlink to written image should be
 * inserted into parent image.
 *
 * But there are also may no left free space. All upper images should be
 * splitted until not found image in which downlink to child image
 * will be succesfully inserted.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkpoint_stack_image_split_flush</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
								   <parameter><decl><type><name>CheckpointWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>downlink</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cur_level</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>inserted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>header</name></decl>,
				<decl><type ref="prev"/><name>savedHeader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OFixedKey</name></type>	<name><name>hikey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name><name>hikeySize</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>curKey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>curKeySize</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>curKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>curKeySize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>autonomous</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cur_level</name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>curLoc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CheckpointPageInfo</name> <modifier>*</modifier></type><name>curItem</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>cur_level</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>flags</name> <init>= <expr><ternary><condition><expr><name><name>curItem</name><operator>-&gt;</operator><name>autonomousLeftmost</name></name></expr> ?</condition><then> <expr><name>O_BTREE_FLAG_LEFTMOST</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * It might happen that "checkpointed" tree grow up higher than
		 * original tree.  Thus, we might need to initialize the new
		 * rootPageBlkno here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name><name>curItem</name><operator>-&gt;</operator><name>image</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>init_page_first_chunk</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name><name>curItem</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_FIRST</name><argument_list>(<argument><expr><name><name>curItem</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>page_locator_insert_item</name><argument_list>(<argument><expr><name><name>curItem</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>, <argument><expr><name>BTreeNonLeafTuphdrSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>curItem</name><operator>-&gt;</operator><name>autonomous</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>curItem</name><operator>-&gt;</operator><name>autonomousLeftmost</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>curItem</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>curItem</name><operator>-&gt;</operator><name>hikeyBlkno</name></name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>cur_level</name> <operator>!=</operator> <name>level</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_LAST</name><argument_list>(<argument><expr><name><name>curItem</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>curLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name><name>curItem</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>curLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>downlink</name></name> <operator>=</operator> <name>downlink</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>inserted</name> <operator>=</operator> <call><name>checkpoint_image_add_item</name><argument_list>(<argument><expr><name>curItem</name></expr></argument>,
												 <argument><expr><name>StackImageAddDownlink</name></expr></argument>,
												 <argument><expr><name>curKey</name></expr></argument>,
												 <argument><expr><name>curKeySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>inserted</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/* It still might happen, that we can insert item as a hikey */</comment>
			<expr_stmt><expr><name>inserted</name> <operator>=</operator> <call><name>checkpoint_image_add_item</name><argument_list>(<argument><expr><name>curItem</name></expr></argument>,
												 <argument><expr><name>StackImageAddHikey</name></expr></argument>,
												 <argument><expr><name>curKey</name></expr></argument>,
												 <argument><expr><name>curKeySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>savedHeader</name><operator>.</operator><name>downlink</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inserted</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>savedHeader</name> <operator>=</operator> <call><name>autonomous_image_split</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>cur_level</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>downlink</name> <operator>=</operator> <call><name>autonomous_image_write</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>writeback</name></expr></argument>, <argument><expr><name>cur_level</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>copy_fixed_hikey</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hikey</name><index>[<expr><name>cur_level</name> <operator>%</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>curItem</name><operator>-&gt;</operator><name>image</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hikeySize</name><index>[<expr><name>cur_level</name> <operator>%</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>BTREE_PAGE_GET_HIKEY_SIZE</name><argument_list>(<argument><expr><name><name>curItem</name><operator>-&gt;</operator><name>image</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>init_page_first_chunk</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name><name>curItem</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_FIRST</name><argument_list>(<argument><expr><name><name>curItem</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>curLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>page_locator_insert_item</name><argument_list>(<argument><expr><name><name>curItem</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>curLoc</name></expr></argument>, <argument><expr><name>BTreeNonLeafTuphdrSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name><name>curItem</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>curLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>header</name> <operator>=</operator> <name>savedHeader</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>cur_level</name> <operator>!=</operator> <name>level</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>inserted</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>inserted</name> <operator>=</operator> <call><name>checkpoint_image_add_item</name><argument_list>(<argument><expr><name>curItem</name></expr></argument>,
												 <argument><expr><name>StackImageAddDownlink</name></expr></argument>,
												 <argument><expr><name>curKey</name></expr></argument>,
												 <argument><expr><name>curKeySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inserted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>curKey</name> <operator>=</operator> <name><name>hikey</name><index>[<expr><name>cur_level</name> <operator>%</operator> <literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>tuple</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>curKeySize</name> <operator>=</operator> <name><name>hikeySize</name><index>[<expr><name>cur_level</name> <operator>%</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>cur_level</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cur_level</name> <operator>&lt;</operator> <name>ORIOLEDB_MAX_DEPTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * For regular pages just add a new item to current level image.
 *
 * For autonomous pages it can modify stack if on the page is not enough space.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkpoint_stack_image_add_item</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
								<parameter><decl><type><name>CheckpointWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>,
								<parameter><decl><type><name>StackImageAddType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>item</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>item_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name>		<name>inserted</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>checkpoint_image_add_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>item_size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* no space for the item */</comment>
	<expr_stmt><expr><call><name>checkpoint_stack_image_split_flush</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>writeback</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* repeat insert must be success */</comment>
	<expr_stmt><expr><name>inserted</name> <operator>=</operator> <call><name>checkpoint_image_add_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name></expr></argument>, <argument><expr><name>type</name></expr></argument>,
										 <argument><expr><name>item</name></expr></argument>, <argument><expr><name>item_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inserted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Flushes autonomous stack to the disk with the hikey to a given level
 * as upper stack limit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>autonomous_stack_flush_to_disk</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
							   <parameter><decl><type><name>CheckpointWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>to_level</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>hikey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hikey_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>downlink</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cur_level</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Finds the lowest level on which images has tuples.
	 */</comment>
	<for>for <control>(<init><expr><name>cur_level</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>cur_level</name> <operator>&lt;</operator> <name>to_level</name></expr>;</condition> <incr><expr><name>cur_level</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>cur_level</name></expr>]</index></name><operator>.</operator><name>image</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* It must be autonomous */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>cur_level</name></expr>]</index></name><operator>.</operator><name>autonomous</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Loops had been separated just for simplicity and it can be merged.
	 */</comment>
	<for>for <control>(<init>;</init> <condition><expr><name>cur_level</name> <operator>&lt;</operator> <name>to_level</name></expr>;</condition> <incr><expr><name>cur_level</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>parent_img</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>cur_level</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>image</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>

		<comment type="block">/* write the autonomous image with given hikey */</comment>
		<expr_stmt><expr><call><name>checkpoint_stack_image_add_item</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>writeback</name></expr></argument>, <argument><expr><name>cur_level</name></expr></argument>,
										<argument><expr><name>StackImageAddHikey</name></expr></argument>, <argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>hikey_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>flags</name> <operator>=</operator> <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>cur_level</name></expr>]</index></name><operator>.</operator><name>leftmost</name></expr> ?</condition><then> <expr><name>O_BTREE_FLAG_LEFTMOST</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>downlink</name> <operator>=</operator> <call><name>autonomous_image_write</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>writeback</name></expr></argument>,
										  <argument><expr><name>cur_level</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* update last parent downlink with the offset */</comment>

		<comment type="block">/* we do not loose a valid downlink here */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cur_level</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>to_level</name>
			   <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>cur_level</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>autonomousTupleExist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_LAST</name><argument_list>(<argument><expr><name>parent_img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuphdr</name> <operator>=</operator> <operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>parent_img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name> <operator>=</operator> <name>downlink</name></expr>;</expr_stmt>

		<comment type="block">/* reset stack values for the current level */</comment>

		<expr_stmt><expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>cur_level</name></expr>]</index></name><operator>.</operator><name>image</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>cur_level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name>NextKeyNone</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>cur_level</name></expr>]</index></name><operator>.</operator><name>autonomousTupleExist</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkpoint_internal_pass</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
						 <parameter><decl><type><name>CheckpointWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>WalkMessage</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OrioleDBPageDesc</name> <modifier>*</modifier></type><name>page_desc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>write_hikey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>,
				<decl><type ref="prev"/><name>img</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>downlink</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>page_count</name></decl>,
				<decl><type ref="prev"/><name>ionum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>was_dirty</name></decl>,
				<decl><type ref="prev"/><name>autonomous</name></decl>,
				<decl><type ref="prev"/><name>write_img</name></decl>,
				<decl><type ref="prev"/><name>write_rightmost</name></decl>,
				<decl><type ref="prev"/><name>prev_less</name> <init>= <expr><name>false</name></expr></init></decl>,
				<decl><type ref="prev"/><name>tuple_processed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>autonomous</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>autonomous</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTREE_PAGE_OFFSET_GET_LOCATOR</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>img</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>image</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>page_count</name> <operator>=</operator> <call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>level</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>==</operator> <name>NextKeyGreatest</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no sense in the while loop */</comment>
		<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_SET_INVALID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tuple_processed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>key</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>BTREE_PAGE_READ_INTERNAL_ITEM</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuphdr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>downlink</name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>leftmost</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>fixed_shmem_key_get_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>lokey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>!=</operator> <name>NextKeyNone</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>==</operator> <name>NextKeyValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>cmp</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>OTuple</name></type>	<name>levelNextKey</name> <init>= <expr><call><name>fixed_shmem_key_get_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>descr</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>levelNextKey</name></expr></argument>,
								  <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The key we met is less than nextkey.  That may happen due
				 * to concurrent inserts.  So, skip it.
				 */</comment>
				<decl_stmt><decl><type><name>OTuple</name></type>		<name>hikey</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>OTuple</name></type>		<name>levelHikey</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>prev_less</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name>autonomous</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>levelHikey</name> <operator>=</operator> <call><name>fixed_shmem_key_get_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hikey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>levelHikey</name></expr></argument>,
								<argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * the page is autonomous and nextkey location is last
					 * page downlink
					 */</comment>
					<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_PREV</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<continue>continue;</continue>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_PREV</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>prev_less</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>autonomous</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>prev_less</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuple_processed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* the offset may change */</comment>
		<if_stmt><if>if <condition>(<expr><name>autonomous</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tuphdr</name> <operator>=</operator> <operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>downlink</name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>DOWNLINK_IS_IN_MEMORY</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>DOWNLINK_IS_ON_DISK</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>autonomousTupleExist</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* we need to add a new downlink to img */</comment>
				<decl_stmt><decl><type><name>OTuple</name></type>		<name>downlink_key</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>uint</name></type>		<name>downlink_key_size</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>nextkey</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>==</operator> <name>NextKeyValue</name></expr></init></decl>,
							<decl><type ref="prev"/><name>first_off</name> <init>= <expr><call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>,
							<decl><type ref="prev"/><name>page_key</name> <init>= <expr><operator>!</operator><name>autonomous</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name>nextkey</name> <operator>||</operator> <name>first_off</name><operator>)</operator></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>img</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>downlink_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>downlink_key_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>page_key</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* easy case */</comment>
					<expr_stmt><expr><call><name>BTREE_PAGE_READ_INTERNAL_TUPLE</name><argument_list>(<argument><expr><name>downlink_key</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>downlink_key_size</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call>
						<operator>-</operator> <name>BTreeNonLeafTuphdrSize</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>nextkey</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>downlink_key</name> <operator>=</operator> <call><name>fixed_shmem_key_get_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>downlink_key_size</name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>downlink_key</name></expr></argument>, <argument><expr><name>OKeyLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>first_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>img</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>leftmost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>downlink_key</name> <operator>=</operator> <call><name>fixed_shmem_key_get_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>lokey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>downlink_key_size</name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>downlink_key</name></expr></argument>, <argument><expr><name>OKeyLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>checkpoint_image_add_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name></expr></argument>,
											   <argument><expr><name>StackImageAddDownlink</name></expr></argument>,
											   <argument><expr><name>downlink_key</name></expr></argument>, <argument><expr><name>downlink_key_size</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * unable to add downlink into the image, we need to write
					 * autonomous image data
					 */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>autonomous</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * but we need to unlock page first and be ready to
					 * continue
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>first_off</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name>NextKeyNone</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name>NextKeyValue</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>copy_fixed_shmem_page_key</name><argument_list>(<argument><expr><name>descr</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkey</name></expr></argument>,
												  <argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>checkpoint_stack_image_split_flush</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>writeback</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * and repeat try to add downlink
					 */</comment>
					<expr_stmt><expr><name><name>message</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>WalkContinue</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* downlink may be saved only for autonomous pages */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>autonomous</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>autonomousTupleExist</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>DOWNLINK_IS_IN_MEMORY</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>nextLoc</name> <init>= <expr><name>loc</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nextLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nextLoc</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name>NextKeyValue</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>copy_fixed_shmem_page_key</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkey</name></expr></argument>,
										  <argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nextLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name>NextKeyGreatest</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name>NextKeyValue</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>copy_fixed_shmem_hikey</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkey</name></expr></argument>,
										   <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>leftmost</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>clear_fixed_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>downwards</name><operator>.</operator><name>lokey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>OFixedKey</name>  <modifier>*</modifier></type><name>lokey</name> <init>= <expr><operator>&amp;</operator><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>downwards</name><operator>.</operator><name>lokey</name></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>copy_from_fixed_shmem_key</name><argument_list>(<argument><expr><name>lokey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>lokey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>copy_fixed_page_key</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>downwards</name><operator>.</operator><name>lokey</name></name></expr></argument>,
									<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>message</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>WalkDownwards</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>downwards</name><operator>.</operator><name>blkno</name></name> <operator>=</operator> <call><name>DOWNLINK_GET_IN_MEMORY_BLKNO</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>downwards</name><operator>.</operator><name>pageChangeCount</name></name> <operator>=</operator> <call><name>DOWNLINK_GET_IN_MEMORY_CHANGECOUNT</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>DOWNLINK_IS_ON_DISK</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>nextLoc</name></decl>,
						<decl><type ref="prev"/><name>imgLastLoc</name></decl>;</decl_stmt>

			<comment type="block">/* copy internal header with downlink */</comment>
			<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_LAST</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>imgLastLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>imgLastLoc</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name>BTreeNonLeafTuphdrSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>image</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OTuple</name></type>		<name>hikey</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>hikey_size</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Lowest levels of the stack have autonomous images with
				 * tuples. We need to flush it to disk.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>autonomous</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>leftmost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name>NextKeyNone</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>hikey</name> <operator>=</operator> <call><name>fixed_shmem_key_get_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>lokey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name>NextKeyValue</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>copy_fixed_shmem_page_key</name><argument_list>(<argument><expr><name>descr</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkey</name></expr></argument>,
											  <argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>hikey</name> <operator>=</operator> <call><name>fixed_shmem_key_get_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>hikey_size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>o_btree_len</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>OKeyLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>autonomous_stack_flush_to_disk</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>writeback</name></expr></argument>,
											   <argument><expr><name>level</name></expr></argument>, <argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>hikey_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* after this we can repeat */</comment>
				<expr_stmt><expr><name><name>message</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>WalkContinue</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Page is already on the disk, but we have to advance current key
			 * ourselves...
			 */</comment>
			<expr_stmt><expr><name>nextLoc</name> <operator>=</operator> <name>loc</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nextLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nextLoc</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>chkp_inc_changecount_before</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>curKeyType</name></name> <operator>=</operator> <name>CurKeyValue</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nextLoc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>copy_fixed_shmem_page_key</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>curKeyValue</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>nextLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>copy_fixed_shmem_hikey</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>curKeyValue</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>update_lowest_level_hikey</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>level</name></expr></argument>,
										  <argument><expr><call><name>fixed_shmem_key_get_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>curKeyValue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>chkp_inc_changecount_after</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>OTuple</name></type>		<name>nullTup</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>chkp_inc_changecount_before</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>curKeyType</name></name> <operator>=</operator> <name>CurKeyGreatest</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>nullTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>update_lowest_level_hikey</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>nullTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>chkp_inc_changecount_after</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>autonomous</name> <operator>&amp;&amp;</operator> <call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>page_count</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>copy_fixed_shmem_hikey</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkey</name></expr></argument>,
										   <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name>NextKeyValue</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name>NextKeyGreatest</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name>NextKeyNone</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>DOWNLINK_IS_IN_IO</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Save the key we need to continue from */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name>NextKeyNone</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name>NextKeyValue</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>copy_fixed_shmem_page_key</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkey</name></expr></argument>,
										  <argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name><name>message</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>WalkContinue</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* IO is in-progress.  So, wait for completeness and retry. */</comment>
			<expr_stmt><expr><call><name>wait_for_io_completion</name><argument_list>(<argument><expr><call><name>DOWNLINK_GET_IO_LOCKNUM</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>write_rightmost</name> <operator>=</operator> <call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>==</operator> <name>NextKeyGreatest</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>write_img</name> <operator>=</operator> <operator>!</operator><name>autonomous</name> <operator>||</operator> <name>write_rightmost</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>write_hikey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>autonomous</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>write_rightmost</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>bound</name> <operator>==</operator> <name>CheckpointBoundHikey</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we may need to write the autonomous image if hikeys is equal */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>hikey</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>levelHikey</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>levelHikey</name> <operator>=</operator> <call><name>fixed_shmem_key_get_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>hikey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>levelHikey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>hikey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cmp</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>write_img</name> <operator>=</operator> <name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>write_img</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>write_hikey</name> <operator>=</operator> <name>levelHikey</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name>tuple_processed</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OTuple</name></type>	<name>levelNextKey</name> <init>= <expr><call><name>fixed_shmem_key_get_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>levelHikey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>levelNextKey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cmp</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* we already write the child with the hikey */</comment>
				<expr_stmt><expr><name>write_hikey</name> <operator>=</operator> <name>levelHikey</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>write_img</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>autonomous</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no more need in page data */</comment>
		<expr_stmt><expr><call><name>chkp_inc_changecount_before</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>blkno</name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>write_img</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>hikeyBlkno</name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>chkp_inc_changecount_after</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>write_img</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* no need to write the autonomous image */</comment>
			<expr_stmt><expr><name><name>message</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>WalkUpwards</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>copy_from_fixed_shmem_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>nextkey</name></name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>nextkeyType</name></name> <operator>=</operator> <name>NextKeyValue</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>parentDirty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>diskDownlink</name></name> <operator>=</operator> <name>InvalidDiskDownlink</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>saveTuple</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name>NextKeyValue</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* If IO is in-progress then wait for its completion */</comment>
		<expr_stmt><expr><name>page_desc</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ionum</name> <operator>=</operator> <name><name>page_desc</name><operator>-&gt;</operator><name>ionum</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ionum</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Save the key we need to continue from */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name>NextKeyGreatest</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name>NextKeyValue</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>copy_fixed_shmem_hikey</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkey</name></expr></argument>,
									   <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name><name>message</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>WalkContinue</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>wait_for_io_completion</name><argument_list>(<argument><expr><name>ionum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* we should write the image */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>write_img</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* but first add a hikey to the image if needed */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>write_rightmost</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>hikey_len</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>write_hikey</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>autonomous</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hikey_len</name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>write_hikey</name></expr></argument>, <argument><expr><name>OKeyLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>autonomous</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>write_hikey</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hikey_len</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_HIKEY_SIZE</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>checkpoint_stack_image_add_item</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
										<argument><expr><name>writeback</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>StackImageAddHikey</name></expr></argument>,
										<argument><expr><name>write_hikey</name></expr></argument>,
										<argument><expr><name>hikey_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>autonomous</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Indicate that we've finished that page image */</comment>
	<expr_stmt><expr><name><name>message</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>WalkUpwards</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>saveTuple</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>autonomous</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>written_downlink</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>autonomousLeftmost</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>O_BTREE_FLAG_LEFTMOST</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>write_rightmost</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>O_BTREE_FLAG_RIGHTMOST</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>written_downlink</name> <operator>=</operator> <call><name>autonomous_image_write</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>writeback</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>diskDownlink</name></name> <operator>=</operator> <name>written_downlink</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>parentDirty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>img_header</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>page_header</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>written_downlink</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>parent_dirty</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>page_header</name> <operator>=</operator> <operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>page</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>img_header</name> <operator>=</operator> <operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>img</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>img_header</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>=</operator> <name><name>page_header</name><operator>-&gt;</operator><name>undoLocation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>img_header</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <name><name>page_header</name><operator>-&gt;</operator><name>csn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>img_header</name><operator>-&gt;</operator><name>checkpointNum</name></name> <operator>=</operator> <name><name>page_header</name><operator>-&gt;</operator><name>checkpointNum</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>img_header</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>page_header</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>img_header</name><operator>-&gt;</operator><name>rightLink</name></name> <operator>=</operator> <name>InvalidRightLink</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PAGE_SET_N_ONDISK</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>img</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PAGE_SET_LEVEL</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We don't allow concurrent downlinks inserts into processed part of
		 * the page.  So, just cleaning dirty flag should be correct.
		 */</comment>
		<expr_stmt><expr><name>was_dirty</name> <operator>=</operator> <call><name>IS_DIRTY</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>was_dirty</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>page_desc</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>ionum</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* already checked above */</comment>
			<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>ionum</name></name> <operator>=</operator> <call><name>assign_io_num</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * we assume that concurrent eviction of the parent is forbidden
			 * by get_checkpoint_number() in walk_page()
			 */</comment>
			<expr_stmt><expr><call><name>CLEAN_DIRTY</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* We've finished operation with the page, allow concurrent operations */</comment>
		<expr_stmt><expr><call><name>chkp_inc_changecount_before</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>blkno</name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>hikeyBlkno</name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>chkp_inc_changecount_after</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>was_dirty</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * TODO: Non-leaf page isn't modified during checkpoint.  We can
			 * reuse original chunks layout/max key length.
			 */</comment>
			<expr_stmt><expr><call><name>split_page_by_chunks</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>img</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>written_downlink</name> <operator>=</operator> <call><name>perform_page_io</name><argument_list>(<argument><expr><name>descr</name></expr></argument>,
											   <argument><expr><name>blkno</name></expr></argument>,
											   <argument><expr><name>img</name></expr></argument>,
											   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>parent_dirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DiskDownlinkIsValid</name><argument_list>(<argument><expr><name>written_downlink</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>page_desc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unable to perform page IO for page %d to file %s with offset %lu"</literal></expr></argument>,
					 <argument><expr><name>blkno</name></expr></argument>,
					 <argument><expr><call><name>btree_smgr_filename</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name><operator>.</operator><name>off</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><operator>(</operator><name>long</name> <name>unsigned</name><operator>)</operator> <name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name><operator>.</operator><name>off</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>writeback_put_extent</name><argument_list>(<argument><expr><name>writeback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>unlock_io</name><argument_list>(<argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>ionum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>ionum</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>parent_dirty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>written_downlink</name> <operator>=</operator> <call><name>MAKE_ON_DISK_DOWNLINK</name><argument_list>(<argument><expr><call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fileExtent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileExtentIsValid</name><argument_list>(<argument><expr><call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fileExtent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DiskDownlinkIsValid</name><argument_list>(<argument><expr><name>written_downlink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>diskDownlink</name></name> <operator>=</operator> <name>written_downlink</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>parentDirty</name></name> <operator>=</operator> <name>parent_dirty</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>write_rightmost</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>nextkeyType</name></name> <operator>=</operator> <name>NextKeyGreatest</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>nextkeyType</name></name> <operator>=</operator> <name>NextKeyValue</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>copy_fixed_hikey</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>message</name><operator>-&gt;</operator><name>content</name><operator>.</operator><name>upwards</name><operator>.</operator><name>nextkey</name></name></expr></argument>, <argument><expr><name>img</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nextkeyType</name> <operator>=</operator> <name>NextKeyNone</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>img</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Prepare particular leaf B-tree page for checkpointing.  Checkpointer
 * state stack item is already filled and page is locked.
 *
 * Unlocks page.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>prepare_leaf_page</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>CheckpointState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>blkno</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Update checkpoint bound key.
	 */</comment>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>chkp_inc_changecount_before</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>curKeyType</name></name> <operator>=</operator> <name>CurKeyGreatest</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>curKeyType</name></name> <operator>=</operator> <name>CurKeyValue</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>copy_fixed_shmem_hikey</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>curKeyValue</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>chkp_inc_changecount_after</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkpoint_tables_callback</name><parameter_list>(<parameter><decl><type><name>OIndexType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>ORelOids</name></type> <name>treeOids</name></decl></parameter>,
						   <parameter><decl><type><name>ORelOids</name></type> <name>tableOids</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CheckpointTablesArg</name> <modifier>*</modifier></type><name>tbl_arg</name> <init>= <expr><operator>(</operator><name>CheckpointTablesArg</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cur_chkp_index</name> <init>= <expr><operator>(</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>prev_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>params</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oTablesAddLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>prev_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>chkp_mem_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>STOPEVENTS_ENABLED</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>prepare_checkpoint_table_start_params</name><argument_list>(<argument><expr><name>tableOids</name></expr></argument>, <argument><expr><name>treeOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>STOPEVENT</name><argument_list>(<argument><expr><name>STOPEVENT_CHECKPOINT_TABLE_START</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>o_fetch_index_descr</name><argument_list>(<argument><expr><name>treeOids</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>descr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>td</name> <init>= <expr><operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>desc</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>success</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"CHKP %u, (%u, %u, %u) =&gt; (%u, %u, %u)"</literal></expr></argument>,
			 <argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>treeOids</name><operator>.</operator><name>datoid</name></name></expr></argument>, <argument><expr><name><name>treeOids</name><operator>.</operator><name>reloid</name></name></expr></argument>, <argument><expr><name><name>treeOids</name><operator>.</operator><name>relnode</name></name></expr></argument>,
			 <argument><expr><name><name>tableOids</name><operator>.</operator><name>datoid</name></name></expr></argument>, <argument><expr><name><name>tableOids</name><operator>.</operator><name>reloid</name></name></expr></argument>, <argument><expr><name><name>tableOids</name><operator>.</operator><name>relnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>have_locked_pages</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>have_retained_undo_location</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>td</name><operator>-&gt;</operator><name>type</name></name> <operator>&gt;=</operator> <name>oIndexUnique</name> <operator>&amp;&amp;</operator>
			<call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>toastConsistentPtr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>toastConsistentPtr</name></name> <operator>=</operator> <call><name>GetXLogInsertRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>STOPEVENTS_ENABLED</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>prepare_checkpoint_tree_start_params</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>STOPEVENT</name><argument_list>(<argument><expr><name>STOPEVENT_CHECKPOINT_INDEX_START</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>checkpoint_ix</name><argument_list>(<argument><expr><name><name>tbl_arg</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>success</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>sort_checkpoint_map_file</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name>cur_chkp_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sort_checkpoint_tmp_file</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name>cur_chkp_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OCompressIsValid</name><argument_list>(<argument><expr><name><name>td</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tbl_arg</name><operator>-&gt;</operator><name>freeExtents</name></name> <operator>=</operator> <call><name>add_free_extents_item</name><argument_list>(<argument><expr><name><name>tbl_arg</name><operator>-&gt;</operator><name>freeExtents</name></name></expr></argument>, <argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>tbl_arg</name><operator>-&gt;</operator><name>cleanupMap</name></name> <operator>=</operator> <call><name>add_map_cleanup_item</name><argument_list>(<argument><expr><name><name>tbl_arg</name><operator>-&gt;</operator><name>cleanupMap</name></name></expr></argument>, <argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>o_tables_rel_unlock_extended</name><argument_list>(<argument><expr><operator>&amp;</operator><name>treeOids</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>prev_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextResetOnly</name><argument_list>(<argument><expr><name>chkp_mem_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oTablesAddLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_eviction_filename</name><parameter_list>(<parameter><decl><type><name>ORelOids</name></type> <name>oids</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>chkp_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* this format is used by recovery_cleanup_old_files() */</comment>
	<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><name>ORIOLEDB_DATA_DIR</name> <literal type="string">"/%u_%u-%u."</literal> <name>ORIOLEDB_EVT_EXTENSION</name></expr></argument>,
					<argument><expr><name><name>oids</name><operator>.</operator><name>datoid</name></name></expr></argument>, <argument><expr><name><name>oids</name><operator>.</operator><name>relnode</name></name></expr></argument>, <argument><expr><name>chkp_num</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns actual lastCheckpointNumber for current tree.
 */</comment>
<function><type><name>uint32</name></type>
<name>get_cur_checkpoint_number</name><parameter_list>(<parameter><decl><type><name>ORelOids</name> <modifier>*</modifier></type><name>oids</name></decl></parameter>, <parameter><decl><type><name>OIndexType</name></type> <name>type</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>checkpoint_concurrent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexType</name></type>	<name>chkp_tree_type</name> <init>= <expr><name>oIndexInvalid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>datoid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>,
				<decl><type ref="prev"/><name>relnode</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>before_changecount</name></decl>,
				<decl><type ref="prev"/><name>after_changecount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>result</name></decl>,
				<decl><type ref="prev"/><name>completed</name></decl>;</decl_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><call><name>chkp_save_changecount_before</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><name>before_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>before_changecount</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>chkp_tree_type</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>treeType</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>datoid</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>datoid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>relnode</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>relnode</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>completed</name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>completed</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>chkp_save_changecount_after</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><name>after_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>before_changecount</name> <operator>!=</operator> <name>after_changecount</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* datoid, relnode and ix_num setups inside changecount section */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>chkp_ordering_cmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>oids</name><operator>-&gt;</operator><name>datoid</name></name></expr></argument>, <argument><expr><name><name>oids</name><operator>-&gt;</operator><name>relnode</name></name></expr></argument>,
								  <argument><expr><name>chkp_tree_type</name></expr></argument>, <argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>relnode</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* BTree is already processed by current checkpoint */</comment>
				<expr_stmt><expr><name>result</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* else checkpoint is not in progress */</comment>

		<expr_stmt><expr><operator>*</operator><name>checkpoint_concurrent</name> <operator>=</operator> <name><name>oids</name><operator>-&gt;</operator><name>datoid</name></name> <operator>==</operator> <name>datoid</name> <operator>&amp;&amp;</operator> <name><name>oids</name><operator>-&gt;</operator><name>relnode</name></name> <operator>==</operator> <name>relnode</name>
			<operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>chkp_tree_type</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>completed</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>chkp_save_changecount_after</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><name>after_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>before_changecount</name> <operator>==</operator> <name>after_changecount</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block> while <condition>(<expr><name>true</name></expr>)</condition>;</do>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if we can already re-use space freed in given checkpoint.
 */</comment>
<function><type><name>bool</name></type>
<name>can_use_checkpoint_extents</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>chkp_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeMetaPage</name> <modifier>*</modifier></type><name>metaPageBlkno</name> <init>= <expr><call><name>BTREE_GET_META</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt><empty_stmt>;</empty_stmt>

	<if_stmt><if>if <condition>(<expr><name>chkp_num</name> <operator>&gt;</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Prevent situtation when checkpoint was finished and new sequential scan
	 * started between out checks for numSeqScans and lastCheckpointNumber.
	 */</comment>
	<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPageBlkno</name><operator>-&gt;</operator><name>numSeqScans</name><index>[<expr><name>chkp_num</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>init_seq_buf_pages</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>SeqBufDescShared</name> <modifier>*</modifier></type><name>shared</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OInMemoryBlknoIsValid</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>pages</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OInMemoryBlknoIsValid</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>pages</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>pages</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ppool_get_metapage</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OInMemoryBlknoIsValid</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>pages</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>pages</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ppool_get_metapage</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OInMemoryBlknoIsValid</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>pages</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ppool_free_page</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name><name>shared</name><operator>-&gt;</operator><name>pages</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>free_seq_buf_pages</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>SeqBufDescShared</name> <modifier>*</modifier></type><name>shared</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>FREE_PAGE_IF_VALID</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name><name>shared</name><operator>-&gt;</operator><name>pages</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FREE_PAGE_IF_VALID</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name><name>shared</name><operator>-&gt;</operator><name>pages</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>checkpointable_tree_fill_seq_buffers</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>td</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>init</name></decl></parameter>,
									 <parameter><decl><type><name>EvictedTreeData</name> <modifier>*</modifier></type><name>evicted_tree_data</name></decl></parameter>,
									 <parameter><decl><type><name>uint32</name></type> <name>chkp_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EvictedSeqBufData</name> <modifier>*</modifier></type><name>evicted_free</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>evicted_next</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>evicted_tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SeqBufTag</name></type>	<name>prev_chkp_tag</name></decl>,
				<decl><type ref="prev"/><name>cur_chkp_tag</name></decl>,
				<decl><type ref="prev"/><name>tmp_tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeMetaPage</name> <modifier>*</modifier></type><name>meta_page</name> <init>= <expr><call><name>BTREE_GET_META</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>chkp_index</name> <init>= <expr><operator>(</operator><name>chkp_num</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_compressed</name> <init>= <expr><call><name>OCompressIsValid</name><argument_list>(<argument><expr><name><name>td</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>evicted_free</name> <operator>=</operator> <ternary><condition><expr><name>evicted_tree_data</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>evicted_tree_data</name><operator>-&gt;</operator><name>freeBuf</name></name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>evicted_next</name> <operator>=</operator> <ternary><condition><expr><name>evicted_tree_data</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>evicted_tree_data</name><operator>-&gt;</operator><name>nextChkp</name></name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>evicted_tmp</name> <operator>=</operator> <ternary><condition><expr><name>evicted_tree_data</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>evicted_tree_data</name><operator>-&gt;</operator><name>tmpBuf</name></name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prev_chkp_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SeqBufTag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_chkp_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SeqBufTag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SeqBufTag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>evicted_free</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>prev_chkp_tag</name> <operator>=</operator> <name><name>evicted_free</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>prev_chkp_tag</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name><name>td</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prev_chkp_tag</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>td</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prev_chkp_tag</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name>chkp_num</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prev_chkp_tag</name><operator>.</operator><name>type</name></name> <operator>=</operator> <literal type="char">'m'</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>cur_chkp_tag</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name><name>td</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cur_chkp_tag</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>td</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cur_chkp_tag</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name>chkp_num</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cur_chkp_tag</name><operator>.</operator><name>type</name></name> <operator>=</operator> <literal type="char">'m'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>evicted_next</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>SeqBufTagEqual</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_chkp_tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>evicted_next</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tmp_tag</name> <operator>=</operator> <name>cur_chkp_tag</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp_tag</name><operator>.</operator><name>type</name></name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>evicted_tmp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>SeqBufTagEqual</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>evicted_tmp</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>init</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SeqBufDescShared</name> <modifier>*</modifier></type><name><name>shareds</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>chkp_index</name></expr>]</index></name></expr>,
			<expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>chkp_index</name></expr>]</index></name></expr>,
		<expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>freeBuf</name></name></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><ternary><condition><expr><name>is_compressed</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_seq_buf_pages</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name><name>shareds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_compressed</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no need to initialize freeBuf shared memory */</comment>
		<expr_stmt><expr><name><name>td</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>tag</name></name> <operator>=</operator> <name>prev_chkp_tag</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>init</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>meta_page</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>tag</name></name> <operator>=</operator> <name>prev_chkp_tag</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_seq_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>td</name><operator>-&gt;</operator><name>freeBuf</name></name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>freeBuf</name></name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>prev_chkp_tag</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>init</name></expr></argument>,
						  <argument><expr><ternary><condition><expr><name><name>prev_chkp_tag</name><operator>.</operator><name>type</name></name> <operator>==</operator> <literal type="char">'m'</literal></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>CheckpointFileHeader</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
						  <argument><expr><name>evicted_free</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_seq_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>td</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>chkp_index</name></expr>]</index></name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>chkp_index</name></expr>]</index></name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>cur_chkp_tag</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>init</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CheckpointFileHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>evicted_next</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_seq_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>td</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><literal type="number">1</literal> <operator>-</operator> <name>chkp_index</name></expr>]</index></name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><literal type="number">1</literal> <operator>-</operator> <name>chkp_index</name></expr>]</index></name></expr></argument>,
					  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CheckpointFileHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_seq_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>td</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>chkp_index</name></expr>]</index></name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>chkp_index</name></expr>]</index></name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>tmp_tag</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>init</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>evicted_tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_seq_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>td</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><literal type="number">1</literal> <operator>-</operator> <name>chkp_index</name></expr>]</index></name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><literal type="number">1</literal> <operator>-</operator> <name>chkp_index</name></expr>]</index></name></expr></argument>,
					  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initializes metaPageBlkno information for a B-tree with pages eviction support.
 *
 * We can try to use exist on-disk data for the B-tree metaPageBlkno information or
 * initialize clear tree.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>evictable_tree_init_meta</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>EvictedTreeData</name> <modifier>*</modifier><modifier>*</modifier></type><name>evicted_data</name></decl></parameter>,
						 <parameter><decl><type><name>uint32</name></type> <name>chkp_num</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>clear_tree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CheckpointFileHeader</name></type> <name>file_header</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeMetaPage</name> <modifier>*</modifier></type><name>meta_page</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TREE_HAS_OIDS</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>clear_tree</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No need to create or read a map file */</comment>
		<expr_stmt><expr><name><name>file_header</name><operator>.</operator><name>rootDownlink</name></name> <operator>=</operator> <name>InvalidDiskDownlink</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>file_header</name><operator>.</operator><name>datafileLength</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>file_header</name><operator>.</operator><name>numFreeBlocks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>file_header</name><operator>.</operator><name>leafPagesNum</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>file_header</name><operator>.</operator><name>ctid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prev_chkp_fname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>File</name></type>		<name>prev_chkp_file</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SeqBufTag</name></type>	<name>prev_chkp_tag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>prev_chkp_file_exist</name></decl>,
					<decl><type ref="prev"/><name>ferror</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prev_chkp_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prev_chkp_tag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prev_chkp_tag</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prev_chkp_tag</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prev_chkp_tag</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name>chkp_num</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prev_chkp_tag</name><operator>.</operator><name>type</name></name> <operator>=</operator> <literal type="char">'m'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev_chkp_fname</name> <operator>=</operator> <call><name>get_seq_buf_filename</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prev_chkp_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev_chkp_file</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>prev_chkp_fname</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev_chkp_file_exist</name> <operator>=</operator> <name>prev_chkp_file</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>prev_chkp_file_exist</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Creates file with default header
			 */</comment>
			<expr_stmt><expr><name><name>file_header</name><operator>.</operator><name>rootDownlink</name></name> <operator>=</operator> <name>InvalidDiskDownlink</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>file_header</name><operator>.</operator><name>datafileLength</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>file_header</name><operator>.</operator><name>numFreeBlocks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>file_header</name><operator>.</operator><name>leafPagesNum</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>file_header</name><operator>.</operator><name>ctid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name>prev_chkp_file</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>prev_chkp_fname</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>prev_chkp_file</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create map file %s"</literal></expr></argument>, <argument><expr><name>prev_chkp_fname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>ferror</name> <operator>=</operator> <call><name>OFileWrite</name><argument_list>(<argument><expr><name>prev_chkp_file</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>file_header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>file_header</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								<argument><expr><name>WAIT_EVENT_SLRU_WRITE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>file_header</name></expr></argument>)</argument_list></sizeof> <operator>||</operator>
				<call><name>FileSync</name><argument_list>(<argument><expr><name>prev_chkp_file</name></expr></argument>, <argument><expr><name>WAIT_EVENT_SLRU_SYNC</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>ferror</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not to write header to map file %s"</literal></expr></argument>,
									   <argument><expr><name>prev_chkp_fname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else					<comment type="block">/* if checkpoint file exist */</comment>
		<block>{<block_content>
			<comment type="block">/*
			 * Reads header from file.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>evicted_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>evicted_data</name> <operator>=</operator> <call><name>read_evicted_data</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>, <argument><expr><name>chkp_num</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>evicted_data</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name> <init>= <expr><call><name>get_eviction_filename</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>, <argument><expr><name>chkp_num</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not unlink eviction file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>file_header</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>evicted_data</name><operator>)</operator><operator>-&gt;</operator><name>file_header</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>ferror</name> <operator>=</operator> <call><name>OFileRead</name><argument_list>(<argument><expr><name>prev_chkp_file</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>file_header</name></expr></argument>,
								   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>file_header</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_SLRU_READ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>file_header</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ferror</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
									<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not to read header of map file %s"</literal></expr></argument>,
										   <argument><expr><name>prev_chkp_fname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>prev_chkp_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>prev_chkp_fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>o_btree_init</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>meta_page</name> <operator>=</operator> <call><name>BTREE_GET_META</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>numFreeBlocks</name></name></expr></argument>, <argument><expr><name><name>file_header</name><operator>.</operator><name>numFreeBlocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>datafileLength</name></name></expr></argument>, <argument><expr><name><name>file_header</name><operator>.</operator><name>datafileLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>leafPagesNum</name></name></expr></argument>, <argument><expr><name><name>file_header</name><operator>.</operator><name>leafPagesNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>ctid</name></name></expr></argument>, <argument><expr><name><name>file_header</name><operator>.</operator><name>ctid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>VALGRIND_CHECK_MEM_IS_DEFINED</name><argument_list>(<argument><expr><name>meta_page</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DiskDownlinkIsValid</name><argument_list>(<argument><expr><name><name>file_header</name><operator>.</operator><name>rootDownlink</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OrioleDBPageDesc</name> <modifier>*</modifier></type><name>root_desc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>ORIOLEDB_BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>rerror</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>lock_page</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>root_desc</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rerror</name> <operator>=</operator> <operator>!</operator><call><name>read_page_from_disk</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>file_header</name><operator>.</operator><name>rootDownlink</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>root_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rerror</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read rootPageBlkno page from %s"</literal></expr></argument>,
								   <argument><expr><call><name>btree_smgr_filename</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><call><name>DOWNLINK_GET_DISK_OFF</name><argument_list>(<argument><expr><name><name>file_header</name><operator>.</operator><name>rootDownlink</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>put_page_image</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CLEAN_DIRTY</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root_desc</name><operator>-&gt;</operator><name>flags</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* TODO: move this method ? */</comment>
<function><type><name>bool</name></type>
<name>tbl_data_exists</name><parameter_list>(<parameter><decl><type><name>ORelOids</name> <modifier>*</modifier></type><name>oids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>file</name></decl>;</decl_stmt>

	<comment type="block">/* TODO: more smart check */</comment>
	<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><name>ORIOLEDB_DATA_DIR</name> <literal type="string">"/%u_%u"</literal></expr></argument>, <argument><expr><name><name>oids</name><operator>-&gt;</operator><name>datoid</name></name></expr></argument>, <argument><expr><name><name>oids</name><operator>-&gt;</operator><name>relnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initializes B-tree with a page eviction support, but without checkpoint support.
 */</comment>
<function><type><name>void</name></type>
<name>evictable_tree_init</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>init_shmem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>chkp_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>chkp_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SeqBufTag</name></type>	<name>tmp_tag</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>checkpoint_concurrent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeMetaPage</name> <modifier>*</modifier></type><name>meta_page</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>btree_open_smgr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>init_shmem</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>evictable_tree_init_meta</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>chkp_num</name> <operator>=</operator> <call><name>get_cur_checkpoint_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>checkpoint_concurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>chkp_index</name> <operator>=</operator> <operator>(</operator><name>chkp_num</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp_tag</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp_tag</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp_tag</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name>chkp_num</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp_tag</name><operator>.</operator><name>type</name></name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>meta_page</name> <operator>=</operator> <call><name>BTREE_GET_META</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>init_shmem</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_seq_buf_pages</name><argument_list>(<argument><expr><name>desc</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>freeBuf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(
								   <argument><expr><literal type="string">"could not init sequence buffer pages."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_seq_buf_pages</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>chkp_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(
								   <argument><expr><literal type="string">"could not init sequence buffer pages."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_seq_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>freeBuf</name></name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>freeBuf</name></name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>tmp_tag</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>init_shmem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fill sequence buffers."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_seq_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>chkp_index</name></expr>]</index></name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>chkp_index</name></expr>]</index></name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>tmp_tag</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>init_shmem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fill sequence buffers."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_seq_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><literal type="number">1</literal> <operator>-</operator> <name>chkp_index</name></expr>]</index></name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name><name>meta_page</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><literal type="number">1</literal> <operator>-</operator> <name>chkp_index</name></expr>]</index></name></expr></argument>,
					  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fill sequence buffers."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initializes B-tree with checkpoint support.
 */</comment>
<function><type><name>void</name></type>
<name>checkpointable_tree_init</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>init_shmem</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>was_evicted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>checkpoint_concurrent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>chkp_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EvictedTreeData</name> <modifier>*</modifier></type><name>evicted_tree_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>chkp_num</name> <operator>=</operator> <call><name>get_cur_checkpoint_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>checkpoint_concurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We shouldn't initialize shared memory concurrently to checkpoint.
	 * Checkpointer should have initilized that before start working on this
	 * tree.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>init_shmem</name> <operator>||</operator> <operator>!</operator><name>checkpoint_concurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>btree_open_smgr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>init_shmem</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>evictable_tree_init_meta</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>evicted_tree_data</name></expr></argument>, <argument><expr><name>chkp_num</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>checkpointable_tree_fill_seq_buffers</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>init_shmem</name></expr></argument>,
											  <argument><expr><name>evicted_tree_data</name></expr></argument>, <argument><expr><name>chkp_num</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fill sequence buffers."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>init_shmem</name> <operator>&amp;&amp;</operator> <name>was_evicted</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>was_evicted</name> <operator>=</operator> <name>evicted_tree_data</name> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>evicted_tree_data</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>evicted_tree_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>checkpointable_tree_free</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>btree_close_smgr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>seq_buf_close_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>freeBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>seq_buf_close_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>seq_buf_close_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>seq_buf_close_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>seq_buf_close_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>metaPageBlkno</name></name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FileExtentsArray</name> <modifier>*</modifier></type>
<name>file_extents_array_init</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileExtentsArray</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FileExtentsArray</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>file_extents_array_free</name><parameter_list>(<parameter><decl><type><name>FileExtentsArray</name> <modifier>*</modifier></type><name>array</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>array</name><operator>-&gt;</operator><name>extents</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>array</name><operator>-&gt;</operator><name>extents</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>file_extents_array_append</name><parameter_list>(<parameter><decl><type><name>FileExtentsArray</name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>array</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>array</name><operator>-&gt;</operator><name>allocated</name></name> <operator>==</operator> <name><name>array</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>array</name><operator>-&gt;</operator><name>allocated</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>allocated</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>extents</name></name> <operator>=</operator> <operator>(</operator><name>FileExtent</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FileExtent</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>array</name><operator>-&gt;</operator><name>allocated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>allocated</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>extents</name></name> <operator>=</operator> <operator>(</operator><name>FileExtent</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>array</name><operator>-&gt;</operator><name>extents</name></name></expr></argument>,
													 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FileExtent</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>array</name><operator>-&gt;</operator><name>allocated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>array</name><operator>-&gt;</operator><name>extents</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>extents</name><index>[<expr><name><name>array</name><operator>-&gt;</operator><name>size</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>extent</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>foreach_extent_append</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>FileExtent</name></type> <name>extent</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileExtentsArray</name> <modifier>*</modifier></type><name>array</name> <init>= <expr><operator>(</operator><name>FileExtentsArray</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><ternary><condition><expr><name><name>array</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>array</name><operator>-&gt;</operator><name>extents</name><index>[<expr><name><name>array</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>append</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>prev</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>prev</name><operator>-&gt;</operator><name>off</name></name> <operator>+</operator> <name><name>prev</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <name><name>extent</name><operator>.</operator><name>off</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* cutting in progress, skip this part */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>prev</name><operator>-&gt;</operator><name>off</name></name> <operator>+</operator> <name><name>prev</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <name><name>extent</name><operator>.</operator><name>off</name></name> <operator>+</operator> <name><name>extent</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>append</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>append</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>append</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>file_extents_array_append</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * we expect that the array will be sorted in ascending sort order
		 * (off, len)
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>array</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">1</literal>
			   <operator>||</operator> <operator>(</operator><name><name>array</name><operator>-&gt;</operator><name>extents</name><index>[<expr><name><name>array</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>off</name> <operator>&lt;</operator> <name><name>array</name><operator>-&gt;</operator><name>extents</name><index>[<expr><name><name>array</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>off</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>systrees_lock_callback</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>UndoStackItem</name> <modifier>*</modifier></type><name>baseItem</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>abort</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>changeCountsValid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SysTreesLockUndoStackItem</name> <modifier>*</modifier></type><name>lockItem</name> <init>= <expr><operator>(</operator><name>SysTreesLockUndoStackItem</name> <operator>*</operator><operator>)</operator> <name>baseItem</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>abort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lockItem</name><operator>-&gt;</operator><name>lock</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oSysTreesLock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oSysTreesLock</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oSysTreesLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_systrees_lock_undo</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>location</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysTreesLockUndoStackItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>SysTreesLockUndoStackItem</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>SysTreesLockUndoStackItem</name> <operator>*</operator><operator>)</operator> <call><name>get_undo_record_unreserved</name><argument_list>(<argument><expr><name>UndoReserveTxn</name></expr></argument>,
																	<argument><expr><operator>&amp;</operator><name>location</name></expr></argument>,
																	<argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>lock</name></name> <operator>=</operator> <name>lock</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>SysTreesLockUndoItemType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>indexType</name></name> <operator>=</operator> <name>oIndexPrimary</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>itemSize</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>add_new_undo_stack_item</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>release_undo_size</name><argument_list>(<argument><expr><name>UndoReserveTxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * systrees_modify_start() and systrees_modify_end() should surround code
 * blocks, which modifies system trees and shouldn't be done concurrently to
 * checkpoint.
 *
 * oSysTreesLock is held during undo replay.
 */</comment>
<function><type><name>void</name></type>
<name>systrees_modify_start</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oSysTreesLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_systrees_lock_undo</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>systrees_modify_end</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oSysTreesLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_systrees_lock_undo</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
