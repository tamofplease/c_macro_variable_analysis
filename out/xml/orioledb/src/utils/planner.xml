<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/utils/planner.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * o_tables.c
 * 		Routines for query processing.
 *
 * Copyright (c) 2021-2022, Oriole DB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/utils/planner.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/o_sys_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/planner.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_amop.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_amproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_language.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/functions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pathnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_target.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prosrc</name></decl>;</decl_stmt>
}</block></struct></type> <name>validate_error_callback_arg</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>hint_msg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proname</name></decl>;</decl_stmt>
}</block></struct></type> <name>validate_function_arg</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>validate_function</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>o_wrap_top_funcexpr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>o_collect_function_walker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>inputcollid</name></decl></parameter>,
									  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>plan_tree_walker</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>()</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">150000</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pg_analyze_and_rewrite_params</name></cpp:macro> <cpp:value>pg_analyze_and_rewrite_withcb</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

 <comment type="block">/*
  * error context callback to let us supply a call-stack traceback
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sql_validate_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>validate_error_callback_arg</name> <modifier>*</modifier></type><name>callback_arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>syntaxerrposition</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>callback_arg</name> <operator>=</operator> <operator>(</operator><name>validate_error_callback_arg</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>

	<comment type="block">/* If it's a syntax error, convert to internal syntax error report */</comment>
	<expr_stmt><expr><name>syntaxerrposition</name> <operator>=</operator> <call><name>geterrposition</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>syntaxerrposition</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>errposition</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>internalerrposition</name><argument_list>(<argument><expr><name>syntaxerrposition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>internalerrquery</name><argument_list>(<argument><expr><name><name>callback_arg</name><operator>-&gt;</operator><name>prosrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"SQL function \"%s\" during body validation"</literal></expr></argument>,
			   <argument><expr><name><name>callback_arg</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>o_process_sql_function</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>procedureTuple</name></decl></parameter>, <parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>()</parameter_list></function_decl></parameter>,
					   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>inputcollid</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procedureStruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mycxt</name></decl>,
				<decl><type ref="prev"/><name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>sqlerrcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>validate_error_callback_arg</name></type> <name>callback_arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>proc_body</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>haspolyarg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>querytree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>procedureStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make a temporary memory context, so that we don't leak all the stuff
	 * that parsing might create.
	 */</comment>
	<expr_stmt><expr><name>mycxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
								  <argument><expr><literal type="string">"inline_function"</literal></expr></argument>,
								  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mycxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>haspolyarg</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>procedureStruct</name><operator>-&gt;</operator><name>pronargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>get_typtype</name><argument_list>(<argument><expr><name><name>procedureStruct</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPTYPE_PSEUDO</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name><name>procedureStruct</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>haspolyarg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Setup error traceback support for ereport(). This is so that we can
	 * finger the function that bad information came from.
	 */</comment>
	<expr_stmt><expr><name><name>callback_arg</name><operator>.</operator><name>proname</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>procedureStruct</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch the function body */</comment>
	<expr_stmt><expr><name>proc_body</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>procedureTuple</name></expr></argument>, <argument><expr><name>Anum_pg_proc_prosrc</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null prosrc for function %u"</literal></expr></argument>, <argument><expr><name>functionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>callback_arg</name><operator>.</operator><name>prosrc</name></name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>proc_body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sqlerrcontext</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>sql_validate_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sqlerrcontext</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>callback_arg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sqlerrcontext</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>sqlerrcontext</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>
	<comment type="block">/* If we have prosqlbody, pay attention to that not prosrc */</comment>
	<expr_stmt><expr><name>proc_body</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>procedureTuple</name></expr></argument>,
								<argument><expr><name>Anum_pg_proc_prosqlbody</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>stored_query_list</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>proc_body</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>stored_query_list</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>stored_query_list</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stored_query_list</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>querytree_sublist</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>AcquireRewriteLocks</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>querytree_sublist</name> <operator>=</operator> <call><name>pg_rewrite_query</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>, <argument><expr><name>querytree_sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>raw_parsetree_list</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>raw_parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name><name>callback_arg</name><operator>.</operator><name>prosrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>haspolyarg</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SQLFunctionParseInfoPtr</name></type> <name>pinfo</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>pinfo</name> <operator>=</operator> <call><name>prepare_sql_fn_parse_info</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											  <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>raw_parsetree_list</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>querytree_sublist</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>querytree_sublist</name> <operator>=</operator> <call><name>pg_analyze_and_rewrite_params</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>,
																  <argument><expr><name><name>callback_arg</name><operator>.</operator><name>prosrc</name></name></expr></argument>,
																  <argument><expr><operator>(</operator><name>ParserSetupHook</name><operator>)</operator> <name>sql_fn_parser_setup</name></expr></argument>,
																  <argument><expr><name>pinfo</name></expr></argument>,
																  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>,
										 <argument><expr><name>querytree_sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>


	<comment type="block">/*
	 * The single command must be a simple "SELECT expression".
	 *
	 * Note: if you change the tests involved in this, see also plpgsql's
	 * exec_simple_check_plan().  That generally needs to have the same idea
	 * of what's a "simple expression", so that inlining a function that
	 * previously wasn't inlined won't change plpgsql's conclusion.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>haspolyarg</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>rettype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>rettupdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>resulttlist</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>querytree_list</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sublist</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>sublist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>new_query</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>colnames</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_query</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>new_query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>new_query</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * We need a moderately realistic colnames list for the
				 * subquery RTE
				 */</comment>
				<expr_stmt><expr><name>colnames</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>query-&gt;targetList</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>,
									   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr> ?</condition><then> <expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>

				<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_SUBQUERY</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>query</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"*SELECT*"</literal></expr></argument>, <argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>new_query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>new_query</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mycxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block>

		<expr_stmt><expr><call><name>check_sql_fn_statements</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_func_result_type</name><argument_list>(<argument><expr><name><name>procedureStruct</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rettype</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>rettupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>check_sql_fn_retval</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>, <argument><expr><name>rettype</name></expr></argument>, <argument><expr><name>rettupdesc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>resulttlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>mycxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>sqlerrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Node</name> <modifier>*</modifier></type>
<name>o_wrap_top_funcexpr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>NamedArgExpr</name></type> <name>named_arg</name> <init>= <expr><block>{<expr><operator>.</operator><name>xpr</name> <operator>=</operator> <block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_NamedArgExpr</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<expr_stmt><expr><name><name>named_arg</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>named_arg</name></expr>;</return>
		<default>default:</default>
			<return>return <expr><name>node</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 *	o_process_functions_in_node -
 *	  apply checker() to each function OID contained in given expression node
 *
 * Returns true if the checker() function does; for nodes representing more
 * than one function call, returns true if the checker() function does so
 * for any of those functions.  Returns false if node does not invoke any
 * SQL-visible function.  Caller must not pass node == NULL.
 *
 * This function examines only the given node; it does not recurse into any
 * sub-expressions.  Callers typically prefer to keep control of the recursion
 * for themselves, in case additional checks should be made, or because they
 * have special rules about which parts of the tree need to be visited.
 *
 * Note: we ignore MinMaxExpr, SQLValueFunction, XmlExpr, CoerceToDomain,
 * and NextValueExpr nodes, because they do not contain SQL function OIDs.
 * However, they can invoke SQL-visible functions, so callers should take
 * thought about how to treat them.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>o_process_functions_in_node</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>func_walker</name>) <parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>,
												 <parameter><decl><type><name>Oid</name></type> <name>inputcollid</name></decl></parameter>,
												 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
												 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list></function_decl></parameter>,
							<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>functionId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>inputcollid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>functionId</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>inputcollid</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>args</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>func_walker</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><name>inputcollid</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>functionId</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>winfnoid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>inputcollid</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>args</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>func_walker</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><name>inputcollid</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>functionId</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>inputcollid</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>args</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>func_walker</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><name>inputcollid</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>	<comment type="block">/* struct-equivalent to OpExpr */</comment>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>		<comment type="block">/* struct-equivalent to OpExpr */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Set opfuncid if it wasn't set already */</comment>
				<expr_stmt><expr><call><name>set_opfuncid</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>functionId</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>inputcollid</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>args</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>func_walker</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><name>inputcollid</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>set_sa_opfuncid</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>functionId</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>inputcollid</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>args</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>func_walker</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><name>inputcollid</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>iofunc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>typioparam</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>typisvarlena</name></decl>;</decl_stmt>

				<comment type="block">/* check the result type's input function */</comment>
				<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>iofunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>functionId</name> <operator>=</operator> <name>iofunc</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>inputcollid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>func_walker</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><name>inputcollid</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* check the input type's output function */</comment>
				<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>iofunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>functionId</name> <operator>=</operator> <name>iofunc</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>inputcollid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>func_walker</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><name>inputcollid</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>rcexpr</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>opid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>collid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>larg</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rarg</name></decl>;</decl_stmt>

				<macro><name>forfour</name><argument_list>(<argument>opid</argument>, <argument>rcexpr-&gt;opnos</argument>,
						<argument>collid</argument>, <argument>rcexpr-&gt;inputcollids</argument>,
						<argument>larg</argument>, <argument>rcexpr-&gt;largs</argument>,
						<argument>rarg</argument>, <argument>rcexpr-&gt;rargs</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><name>functionId</name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>opid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>inputcollid</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>larg</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>rarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>func_walker</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><name>inputcollid</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>validate_function_walker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>inputcollid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
						 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>procedureTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procedureStruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>validate_function_arg</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>validate_function_arg</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>procedureTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>functionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>procedureStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>proname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>procedureStruct</name><operator>-&gt;</operator><name>proname</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>procedureStruct</name><operator>-&gt;</operator><name>prolang</name></name> <operator>&gt;</operator> <name>SQLlanguageId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"%s\" cannot be used here"</literal></expr></argument>,
						<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"only C and SQL functions%s"</literal></expr></argument>,
						 <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>hint_msg</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>procedureStruct</name><operator>-&gt;</operator><name>provolatile</name></name> <operator>!=</operator> <name>PROVOLATILE_IMMUTABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"%s\" cannot be used here"</literal></expr></argument>,
						<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"only immutable functions%s"</literal></expr></argument>,
						 <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>hint_msg</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>procedureStruct</name><operator>-&gt;</operator><name>prolang</name></name> <operator>==</operator> <name>SQLlanguageId</name> <operator>&amp;&amp;</operator>
		<name><name>procedureStruct</name><operator>-&gt;</operator><name>prokind</name></name> <operator>==</operator> <name>PROKIND_FUNCTION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>o_process_sql_function</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>, <argument><expr><name>validate_function</name></expr></argument>,
							   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>functionId</name></expr></argument>, <argument><expr><name>inputcollid</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>validate_function</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>validate_function_arg</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>validate_function_arg</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NextValueExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"%s\" cannot be used here"</literal></expr></argument>,
						<argument><expr><call><name>FigureColname</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"only immutable functions%s"</literal></expr></argument>,
						 <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>hint_msg</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>o_process_functions_in_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>validate_function_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Recurse to check arguments */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rtable</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>rtable</argument>, <argument>query-&gt;rtable</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"%s\" cannot be used here"</literal></expr></argument>,
								<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"only queries without relation "</literal>
								 <literal type="string">"references%s"</literal></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>hint_msg</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>validate_function</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>validate_function</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>o_validate_funcexpr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>hint_msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>validate_function_arg</name></type> <name>arg</name> <init>= <expr><block>{<expr><operator>.</operator><name>hint_msg</name> <operator>=</operator> <name>hint_msg</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><call><name>o_wrap_top_funcexpr</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>validate_function</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>arg</name><operator>.</operator><name>proname</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>arg</name><operator>.</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>o_validate_function_by_oid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>procoid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>hint_msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>procedureTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procedureStruct</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>procedureTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>procoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>procoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>procedureStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcid</name></name> <operator>=</operator> <name>procoid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name> <operator>=</operator> <name><name>procedureStruct</name><operator>-&gt;</operator><name>prorettype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcretset</name></name> <operator>=</operator> <name><name>procedureStruct</name><operator>-&gt;</operator><name>proretset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcvariadic</name></name> <operator>=</operator> <name><name>procedureStruct</name><operator>-&gt;</operator><name>provariadic</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>=</operator> <name>COERCE_EXPLICIT_CALL</name></expr>;</expr_stmt>	<comment type="block">/* doesn't matter */</comment>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funccollid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt> <comment type="block">/* doesn't matter */</comment>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>o_validate_funcexpr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fexpr</name></expr></argument>, <argument><expr><name>hint_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>is_a_plan</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>T_Plan</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>T_Limit</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>o_collect_function</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>o_process_functions_in_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>o_collect_function_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>opexpr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>cur_lsn</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>datoid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>OClassArg</name></type>	<name>arg</name> <init>= <expr><block>{<expr><operator>.</operator><name>sys_table</name> <operator>=</operator> <name>true</name></expr>}</block></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>o_sys_cache_set_datoid_lsn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>o_class_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>OperatorRelationId</name></expr></argument>, <argument><expr><name>cur_lsn</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>o_operator_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>,
											   <argument><expr><name>cur_lsn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>cur_lsn</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>datoid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>OClassArg</name></type>	<name>arg</name> <init>= <expr><block>{<expr><operator>.</operator><name>sys_table</name> <operator>=</operator> <name>true</name></expr>}</block></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>aggref</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>o_sys_cache_set_datoid_lsn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>o_class_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>AggregateRelationId</name></expr></argument>, <argument><expr><name>cur_lsn</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>o_class_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>OperatorRelationId</name></expr></argument>, <argument><expr><name>cur_lsn</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>o_class_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>cur_lsn</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>o_aggregate_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>,
												<argument><expr><name>cur_lsn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>o_type_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggtype</name></name></expr></argument>,
										   <argument><expr><name>cur_lsn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>aggref-&gt;aggargtypes</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><call><name>o_type_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>cur_lsn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Agg</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Agg</name>		   <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>agg</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>eq_opr</name> <init>= <expr><name><name>agg</name><operator>-&gt;</operator><name>grpOperators</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>OClassArg</name></type>	<name>arg</name> <init>= <expr><block>{<expr><operator>.</operator><name>sys_table</name> <operator>=</operator> <name>true</name></expr>}</block></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>cur_lsn</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>datoid</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>o_sys_cache_set_datoid_lsn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>o_class_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>OperatorRelationId</name></expr></argument>,
												<argument><expr><name>cur_lsn</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>o_operator_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>eq_opr</name></expr></argument>, <argument><expr><name>cur_lsn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Search pg_amop to see if the target operator is
					 * registered as the "=" operator of any hash opfamily. If
					 * the operator is registered in multiple opfamilies,
					 * assume we can use any one.
					 */</comment>
					<expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>,
												  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>eq_opr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>aform</name> <init>= <expr><operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>o_class_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>,
													<argument><expr><name>AccessMethodOperatorRelationId</name></expr></argument>,
													<argument><expr><name>cur_lsn</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>o_amop_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amopopr</name></name></expr></argument>,
												   <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoppurpose</name></name></expr></argument>,
												   <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr></argument>, <argument><expr><name>cur_lsn</name></expr></argument>,
												   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amopmethod</name></name> <operator>==</operator> <name>HASH_AM_OID</name> <operator>&amp;&amp;</operator>
							<name><name>aform</name><operator>-&gt;</operator><name>amopstrategy</name></name> <operator>==</operator> <name>HTEqualStrategyNumber</name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

							<comment type="block">/*
							 * Get the matching support function(s).  Failure
							 * probably shouldn't happen --- it implies a
							 * bogus opfamily --- but continue looking if so.
							 */</comment>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr></argument>,
													   <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr></argument>,
													   <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr></argument>,
													   <argument><expr><name>HASHSTANDARD_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<continue>continue;</continue></block_content></block></if></if_stmt>

							<expr_stmt><expr><call><name>o_class_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>,
														<argument><expr><name>AccessMethodProcedureRelationId</name></expr></argument>,
														<argument><expr><name>cur_lsn</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>o_amproc_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr></argument>,
														 <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr></argument>,
														 <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr></argument>,
														 <argument><expr><name>HASHSTANDARD_PROC</name></expr></argument>,
														 <argument><expr><name>cur_lsn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<comment type="block">/*
							 * Only one lookup needed if given operator is
							 * single-type
							 */</comment>
							<if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name> <operator>==</operator> <name><name>aform</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr>)</condition><block type="pseudo"><block_content>
								<break>break;</break></block_content></block></if></if_stmt>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr></argument>,
													   <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr></argument>,
													   <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr></argument>,
													   <argument><expr><name>HASHSTANDARD_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<continue>continue;</continue></block_content></block></if></if_stmt>
							<expr_stmt><expr><call><name>o_amproc_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr></argument>,
														 <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr></argument>,
														 <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr></argument>,
														 <argument><expr><name>HASHSTANDARD_PROC</name></expr></argument>,
														 <argument><expr><name>cur_lsn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></for>

					<expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>cur_lsn</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>datoid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>OClassArg</name></type>	<name>arg</name> <init>= <expr><block>{<expr><operator>.</operator><name>sys_table</name> <operator>=</operator> <name>true</name></expr>}</block></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>o_sys_cache_set_datoid_lsn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>o_class_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>cur_lsn</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>cur_lsn</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>datoid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>OClassArg</name></type>	<name>arg</name> <init>= <expr><block>{<expr><operator>.</operator><name>sys_table</name> <operator>=</operator> <name>true</name></expr>}</block></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>window_func</name> <init>= <expr><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>o_sys_cache_set_datoid_lsn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>o_class_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>AggregateRelationId</name></expr></argument>, <argument><expr><name>cur_lsn</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>o_class_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>OperatorRelationId</name></expr></argument>, <argument><expr><name>cur_lsn</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>o_class_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>cur_lsn</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>o_aggregate_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name><name>window_func</name><operator>-&gt;</operator><name>winfnoid</name></name></expr></argument>,
												<argument><expr><name>cur_lsn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>o_type_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name><name>window_func</name><operator>-&gt;</operator><name>wintype</name></name></expr></argument>,
										   <argument><expr><name>cur_lsn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>cur_lsn</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>datoid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>MinMaxExpr</name> <modifier>*</modifier></type><name>minmaxexpr</name> <init>= <expr><operator>(</operator><name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>o_sys_cache_set_datoid_lsn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>o_type_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name><name>minmaxexpr</name><operator>-&gt;</operator><name>minmaxtype</name></name></expr></argument>,
										   <argument><expr><name>cur_lsn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Recurse to check arguments */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>o_collect_function</name></expr></argument>,
								 <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>is_a_plan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>plan_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>o_collect_function</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>o_collect_function</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>o_collect_funcexpr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>o_sys_caches_add_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><call><name>o_wrap_top_funcexpr</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>o_collect_function</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_FINALLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>o_sys_caches_add_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>o_collect_function_walker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>inputcollid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
						  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>cur_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>datoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OClassArg</name></type>	<name>arg</name> <init>= <expr><block>{<expr><operator>.</operator><name>sys_table</name> <operator>=</operator> <name>true</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>procedureTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procedureStruct</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>procedureTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>procedureStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>o_sys_cache_set_datoid_lsn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>o_proc_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>functionId</name></expr></argument>, <argument><expr><name>cur_lsn</name></expr></argument>,
							   <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>o_class_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>AuthIdRelationId</name></expr></argument>, <argument><expr><name>cur_lsn</name></expr></argument>,
								<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>procedureStruct</name><operator>-&gt;</operator><name>prolang</name></name> <operator>==</operator> <name>SQLlanguageId</name> <operator>&amp;&amp;</operator>
		<name><name>procedureStruct</name><operator>-&gt;</operator><name>prokind</name></name> <operator>==</operator> <name>PROKIND_FUNCTION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>o_process_sql_function</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>, <argument><expr><name>o_collect_function</name></expr></argument>,
							   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>functionId</name></expr></argument>, <argument><expr><name>inputcollid</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>o_collect_function_by_oid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>procoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>inputcollid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>procedureTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procedureStruct</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>procedureTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>procoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>procoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>procedureStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcid</name></name> <operator>=</operator> <name>procoid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name> <operator>=</operator> <name><name>procedureStruct</name><operator>-&gt;</operator><name>prorettype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcretset</name></name> <operator>=</operator> <name><name>procedureStruct</name><operator>-&gt;</operator><name>proretset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcvariadic</name></name> <operator>=</operator> <name><name>procedureStruct</name><operator>-&gt;</operator><name>provariadic</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>=</operator> <name>COERCE_EXPLICIT_CALL</name></expr>;</expr_stmt>	<comment type="block">/* doesn't matter */</comment>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funccollid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt> <comment type="block">/* doesn't matter */</comment>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name>inputcollid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><call><name>o_wrap_top_funcexpr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fexpr</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>o_collect_function</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>plan_tree_walker</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>()</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Guard against stack overflow due to overly complex plan trees */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
							   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>,
							   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* lefttree */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* righttree */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>innerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><call><name>innerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * control nodes
			 */</comment>
		<case>case <expr><name>T_Result</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Result</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>Result</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>result</name><operator>-&gt;</operator><name>resconstantqual</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ModifyTable</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>modify_table</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>modify_table</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>modify_table</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>modify_table</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>modify_table</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>modify_table</name><operator>-&gt;</operator><name>exclRelTlist</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_Append</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Append</name>	   <modifier>*</modifier></type><name>append</name> <init>= <expr><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>append-&gt;appendplans</argument>)</argument_list></macro>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MergeAppend</name> <modifier>*</modifier></type><name>merge_append</name> <init>= <expr><operator>(</operator><name>MergeAppend</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>merge_append-&gt;mergeplans</argument>)</argument_list></macro>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_BitmapAnd</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapAnd</name>  <modifier>*</modifier></type><name>bitmap_and</name> <init>= <expr><operator>(</operator><name>BitmapAnd</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>bitmap_and-&gt;bitmapplans</argument>)</argument_list></macro>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_BitmapOr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapOr</name>   <modifier>*</modifier></type><name>bitmap_or</name> <init>= <expr><operator>(</operator><name>BitmapOr</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>bitmap_or-&gt;bitmapplans</argument>)</argument_list></macro>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_SampleScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SampleScan</name> <modifier>*</modifier></type><name>sample_scan</name> <init>= <expr><operator>(</operator><name>SampleScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sample_scan</name><operator>-&gt;</operator><name>tablesample</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_IndexScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexScan</name>  <modifier>*</modifier></type><name>index_scan</name> <init>= <expr><operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>index_scan</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>index_scan</name><operator>-&gt;</operator><name>indexqualorig</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>index_scan</name><operator>-&gt;</operator><name>indexorderby</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>index_scan</name><operator>-&gt;</operator><name>indexorderbyorig</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexOnlyScan</name> <modifier>*</modifier></type><name>index_only_scan</name> <init>= <expr><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>index_only_scan</name><operator>-&gt;</operator><name>recheckqual</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>index_only_scan</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>index_only_scan</name><operator>-&gt;</operator><name>indexorderby</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>index_only_scan</name><operator>-&gt;</operator><name>indextlist</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapIndexScan</name> <modifier>*</modifier></type><name>bitmap_index_scan</name> <init>= <expr><operator>(</operator><name>BitmapIndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>bitmap_index_scan</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>bitmap_index_scan</name><operator>-&gt;</operator><name>indexqualorig</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapHeapScan</name> <modifier>*</modifier></type><name>bitmap_heap_scan</name> <init>= <expr><operator>(</operator><name>BitmapHeapScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>bitmap_heap_scan</name><operator>-&gt;</operator><name>bitmapqualorig</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_TidScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TidScan</name>    <modifier>*</modifier></type><name>tid_scan</name> <init>= <expr><operator>(</operator><name>TidScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tid_scan</name><operator>-&gt;</operator><name>tidquals</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>
		<case>case <expr><name>T_TidRangeScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TidRangeScan</name> <modifier>*</modifier></type><name>tid_range_scan</name> <init>= <expr><operator>(</operator><name>TidRangeScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tid_range_scan</name><operator>-&gt;</operator><name>tidrangequals</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>subquery_scan</name> <init>= <expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name><name>subquery_scan</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>,
									 <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FunctionScan</name> <modifier>*</modifier></type><name>function_scan</name> <init>= <expr><operator>(</operator><name>FunctionScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>function_scan</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TableFuncScan</name> <modifier>*</modifier></type><name>table_func_scan</name> <init>= <expr><operator>(</operator><name>TableFuncScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>table_func_scan</name><operator>-&gt;</operator><name>tablefunc</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ValuesScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ValuesScan</name> <modifier>*</modifier></type><name>values_scan</name> <init>= <expr><operator>(</operator><name>ValuesScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>values_scan</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ForeignScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>foreign_scan</name> <init>= <expr><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>foreign_scan</name><operator>-&gt;</operator><name>fdw_exprs</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>foreign_scan</name><operator>-&gt;</operator><name>fdw_recheck_quals</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>foreign_scan</name><operator>-&gt;</operator><name>fdw_scan_tlist</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CustomScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>custom_scan</name> <init>= <expr><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>custom_scan</name><operator>-&gt;</operator><name>custom_scan_tlist</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>custom_scan</name><operator>-&gt;</operator><name>custom_exprs</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>custom_scan</name><operator>-&gt;</operator><name>custom_scan_tlist</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>custom_scan-&gt;custom_plans</argument>)</argument_list></macro>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_NestLoop</name></expr>:</case>
		<case>case <expr><name>T_MergeJoin</name></expr>:</case>
		<case>case <expr><name>T_HashJoin</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Join</name>	   <modifier>*</modifier></type><name>join</name> <init>= <expr><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>join</name><operator>-&gt;</operator><name>joinqual</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>join</name></expr></argument>, <argument><expr><name>NestLoop</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>NestLoop</name>   <modifier>*</modifier></type><name>nl</name> <init>= <expr><operator>(</operator><name>NestLoop</name> <operator>*</operator><operator>)</operator> <name>join</name></expr></init></decl>;</decl_stmt>

					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>nl-&gt;nestParams</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>NestLoopParam</name> <modifier>*</modifier></type><name>nlp</name> <init>= <expr><operator>(</operator><name>NestLoopParam</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name></expr></argument>,
												   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>join</name></expr></argument>, <argument><expr><name>MergeJoin</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>MergeJoin</name>  <modifier>*</modifier></type><name>mj</name> <init>= <expr><operator>(</operator><name>MergeJoin</name> <operator>*</operator><operator>)</operator> <name>join</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>mj</name><operator>-&gt;</operator><name>mergeclauses</name></name></expr></argument>,
											   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>join</name></expr></argument>, <argument><expr><name>HashJoin</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>HashJoin</name>   <modifier>*</modifier></type><name>hj</name> <init>= <expr><operator>(</operator><name>HashJoin</name> <operator>*</operator><operator>)</operator> <name>join</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>hj</name><operator>-&gt;</operator><name>hashclauses</name></name></expr></argument>,
											   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>hj</name><operator>-&gt;</operator><name>hashkeys</name></name></expr></argument>,
											   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>
		<case>case <expr><name>T_Memoize</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Memoize</name>    <modifier>*</modifier></type><name>memoize</name> <init>= <expr><operator>(</operator><name>Memoize</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>memoize</name><operator>-&gt;</operator><name>param_exprs</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<case>case <expr><name>T_WindowAgg</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WindowAgg</name>  <modifier>*</modifier></type><name>window_agg</name> <init>= <expr><operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>window_agg</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>window_agg</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_Hash</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Hash</name>	   <modifier>*</modifier></type><name>hash</name> <init>= <expr><operator>(</operator><name>Hash</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>hash</name><operator>-&gt;</operator><name>hashkeys</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_Limit</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Limit</name>	   <modifier>*</modifier></type><name>limit</name> <init>= <expr><operator>(</operator><name>Limit</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>limit</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>limit</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_Agg</name></expr>:</case>
		<case>case <expr><name>T_CteScan</name></expr>:</case>
		<case>case <expr><name>T_Gather</name></expr>:</case>
		<case>case <expr><name>T_GatherMerge</name></expr>:</case>
		<case>case <expr><name>T_Group</name></expr>:</case>
		<case>case <expr><name>T_IncrementalSort</name></expr>:</case>
		<case>case <expr><name>T_LockRows</name></expr>:</case>
		<case>case <expr><name>T_Material</name></expr>:</case>
		<case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
		<case>case <expr><name>T_ProjectSet</name></expr>:</case>
		<case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
		<case>case <expr><name>T_SeqScan</name></expr>:</case>
		<case>case <expr><name>T_SetOp</name></expr>:</case>
		<case>case <expr><name>T_Sort</name></expr>:</case>
		<case>case <expr><name>T_Unique</name></expr>:</case>
		<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"%s: unrecognized node type: %d"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plan-&gt;initPlan</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>initPlan</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>plannedstatement_tree_walker</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
							 <parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>()</parameter_list></function_decl></parameter>,
							 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><name><name>pstmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProjectSet</name> <modifier>*</modifier></type><name>project_set</name></decl>;</decl_stmt>

	<comment type="block">/* Guard against stack overflow due to overly complex plan trees */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>project_set</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ProjectSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>project_set</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name> <operator>=</operator> <name>plan</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>project_set</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* subPlan-s */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pstmt-&gt;subplans</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>sp</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>sp</name> <operator>&amp;&amp;</operator> <call><name>plan_tree_walker</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>o_collect_functions_pstmt</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>plannedstatement_tree_walker</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>o_collect_function</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
