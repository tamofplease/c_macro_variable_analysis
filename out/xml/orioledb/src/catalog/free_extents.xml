<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/catalog/free_extents.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * free_extents.c
 * 		Implementation of an orioledb free file extents list.
 *
 * We use two B-trees for holding list of free file extents for indices:
 *
 *	1. Sorted by (datoid, relnode, ixType, extent.offset, extent.length)
 *	- (off, len) as short version in the code.
 *	2. Sorted by (datoid, relnode, ixType, extent.length, extent.offset)
 *	- (len, off) as short version.
 *
 * Pages of this B-trees can be evicted to a disk but a B-tree's state
 * is reset after reboot of the database engine and the state must
 * be restored after it.
 *
 * Copyright (c) 2021-2022, Oriole DB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/catalog/free_extents.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/btree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/find.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/iterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/merge.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/modify.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/page_chunks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/free_extents.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tableam/descr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/stopevent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/page_pool.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/wait_event.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTENTS_IX_EQ</name><parameter_list>(<parameter><type><name>ex1</name></type></parameter>, <parameter><type><name>ex2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((ex1).ixType == (ex2).ixType &amp;&amp; \
								 (ex1).datoid == (ex2).datoid &amp;&amp; \
								 (ex1).relnode == (ex2).relnode)</cpp:value></cpp:define>

<comment type="block">/*
 * Returns free file extent with length = len.
 *
 * get_extend()/free_extend() operations optimized for more fast get_extend()
 * execution because as more critical for performance part.
 *
 * The main idea of get_extend()/free_extend() B-tree modification:
 * We guarantee successful atomic modification after we fetch a free extent from
 * the (len, off) B-tree.
 *
 * So for successful delete an extent in order (len, off) -&gt; (off, len) we need
 * to insert an extent in (off, len) -&gt; (len, off) order.
 *
 * get_extent() algorithm:
 * 1. Iterate through (len, off) B-tree and delete found extent in-place. For
 * that reason we iterate through the B-tree leafs under lock_page().
 * 2. If found extent is more than needed than return a remaining part into
 * the (off, len) B-tree. It helps do not lost extent on iteration.
 * 3. Delete founded extent from the (off, len) B-tree.
 * 4. If found extent is more than needed than return the remaining part into
 * the (len, off) B-tree.
 */</comment>
<function><type><name>FileExtent</name></type>
<name>get_extent</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeMetaPage</name> <modifier>*</modifier></type><name>metaPage</name> <init>= <expr><call><name>BTREE_GET_META</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreeTreeTuple</name></type> <name>tup</name></decl>,
				<decl><type ref="prev"/><name>deleted_tup</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>cur_tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FileExtent</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>old_enable_stopevents</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>,
				<decl><type ref="prev"/><name>end</name> <init>= <expr><name>false</name></expr></init></decl>,
				<decl><type ref="prev"/><name>modify_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>len_off_tree</name> <init>= <expr><call><name>get_sys_tree</name><argument_list>(<argument><expr><name>SYS_TREES_EXTENTS_LEN_OFF</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>off_len_tree</name> <init>= <expr><call><name>get_sys_tree</name><argument_list>(<argument><expr><name>SYS_TREES_EXTENTS_OFF_LEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>tmpTup</name></decl>;</decl_stmt>

	<comment type="block">/* a fast check */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>numFreeBlocks</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>len</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* free extent can not be founded, increase file length */</comment>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>use_device</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>.</operator><name>off</name></name> <operator>=</operator> <call><name>orioledb_device_alloc</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>len</name> <operator>*</operator> <name>ORIOLEDB_COMP_BLCKSZ</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>ORIOLEDB_COMP_BLCKSZ</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>.</operator><name>off</name></name> <operator>=</operator> <call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>datafileLength</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>old_enable_stopevents</name> <operator>=</operator> <name>enable_stopevents</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>enable_stopevents</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>ixType</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_page_find_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>len_off_tree</name></expr></argument>, <argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>,
						   <argument><expr><name>BTREE_PAGE_FIND_MODIFY</name> <operator>|</operator> <name>BTREE_PAGE_FIND_FIX_LEAF_SPLIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* try to find a free extent */</comment>
	<while>while <condition>(<expr><operator>!</operator><name>found</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>end</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>tup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>find_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>tmpTup</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>&amp;</operator><name><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr>;</expr_stmt>

		<while>while <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>tmpTup</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cur_tup</name> <operator>=</operator> <operator>(</operator><name>FreeTreeTuple</name> <operator>*</operator><operator>)</operator> <name><name>tmpTup</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EXTENTS_IX_EQ</name><argument_list>(<argument><expr><operator>*</operator><name>cur_tup</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>end</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>deleted</name></name> <operator>==</operator> <name>false</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>end</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>end</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>OTuple</name></type>		<name>hikey</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cur_tup</name> <operator>=</operator> <operator>(</operator><name>FreeTreeTuple</name> <operator>*</operator><operator>)</operator> <name><name>hikey</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EXTENTS_IX_EQ</name><argument_list>(<argument><expr><operator>*</operator><name>cur_tup</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>end</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>tup</name> <operator>=</operator> <operator>*</operator><name>cur_tup</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* free extent not founded, increase file length */</comment>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>use_device</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>.</operator><name>off</name></name> <operator>=</operator> <call><name>orioledb_device_alloc</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>len</name> <operator>*</operator> <name>ORIOLEDB_COMP_BLCKSZ</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>ORIOLEDB_COMP_BLCKSZ</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>.</operator><name>off</name></name> <operator>=</operator> <call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>datafileLength</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>enable_stopevents</name> <operator>=</operator> <name>old_enable_stopevents</name></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>header</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cur_tup</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_fetch_sub_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>numFreeBlocks</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* delete the extent from the (len, off) B-tree in-place */</comment>
	<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>deleted</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>xactInfo</name></name> <operator>=</operator> <call><name>OXID_GET_XACT_INFO</name><argument_list>(<argument><expr><name>BootstrapTransactionId</name></expr></argument>, <argument><expr><name>RowLockUpdate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PAGE_ADD_N_VACATED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BTreeLeafTuphdrSize</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FreeTreeTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>deleted_tup</name> <operator>=</operator> <operator>*</operator><name>cur_tup</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MARK_DIRTY</name><argument_list>(<argument><expr><name><name>len_off_tree</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>is_page_too_sparse</name><argument_list>(<argument><expr><name>len_off_tree</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>btree_try_merge_and_unlock</name><argument_list>(<argument><expr><name>len_off_tree</name></expr></argument>,
										  <argument><expr><name><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr></argument>,
										  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>deleted_tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name> <operator>&gt;=</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tup</name> <operator>=</operator> <name>deleted_tup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we have a remaining part, insert it into (off, len) B-tree */</comment>
		<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>tup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>modify_result</name> <operator>=</operator> <call><name>o_btree_autonomous_insert</name><argument_list>(<argument><expr><name>off_len_tree</name></expr></argument>, <argument><expr><name>tmpTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>modify_result</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"unable to insert extent (%lu, %lu) into the (off, len) B-tree"</literal></expr></argument>,
				 <argument><expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* delete the extent from the (off, len) B-tree */</comment>
	<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>deleted_tup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>modify_result</name> <operator>=</operator> <call><name>o_btree_autonomous_delete</name><argument_list>(<argument><expr><name>off_len_tree</name></expr></argument>, <argument><expr><name>tmpTup</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>modify_result</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"unable to delete extent (%lu, %lu) from the (off, len) B-tree"</literal></expr></argument>,
			 <argument><expr><name><name>deleted_tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>deleted_tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * we have a remaining part, insert it into (len, off) B-tree after
		 * this remaining part may be gotten
		 */</comment>
		<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>tup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>modify_result</name> <operator>=</operator> <call><name>o_btree_autonomous_insert</name><argument_list>(<argument><expr><name>len_off_tree</name></expr></argument>, <argument><expr><name>tmpTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>modify_result</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"unable to insert extent (%lu, %lu) into the (len, off) B-tree"</literal></expr></argument>,
				 <argument><expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>result</name><operator>.</operator><name>off</name></name> <operator>=</operator> <name><name>deleted_tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>enable_stopevents</name> <operator>=</operator> <name>old_enable_stopevents</name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Adds the extent to a free extents list.
 *
 * See description of the get_extent() function.
 *
 * free_extent() algorithm:
 *
 * 1. Find neighbors tuples of the extent in the (off, len) B-tree.
 * 2. Remove neighbors from (len, off) and (off, len) B-trees. If remove from
 * the (len, off) B-tree fails than goto 1.
 * 3. Add merged extent to (off, len) and (len, off) B-trees.
 *
 * TODO: add hints support
 */</comment>
<function><type><name>void</name></type>
<name>free_extent</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>FileExtent</name></type> <name>extent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreeTreeTuple</name></type> <name>tup</name></decl>,
				<decl><type ref="prev"/><name>right</name></decl>,
				<decl><type ref="prev"/><name>left</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>old_enable_stopevents</name> <init>= <expr><name>enable_stopevents</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>modify_result</name></decl>,
				<decl><type ref="prev"/><name>merge_right</name></decl>,
				<decl><type ref="prev"/><name>merge_left</name></decl>,
				<decl><type ref="prev"/><name>inserted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>len_off_tree</name> <init>= <expr><call><name>get_sys_tree</name><argument_list>(<argument><expr><name>SYS_TREES_EXTENTS_LEN_OFF</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>off_len_tree</name> <init>= <expr><call><name>get_sys_tree</name><argument_list>(<argument><expr><name>SYS_TREES_EXTENTS_OFF_LEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>tmpTup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>enable_stopevents</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileExtentIsValid</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreeTreeTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreeTreeTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreeTreeTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>ixType</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>!</operator><name>inserted</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* reset status */</comment>
		<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name><name>extent</name><operator>.</operator><name>off</name></name> <operator>+</operator> <name><name>extent</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>merge_right</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>merge_left</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>it</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>btree_iterator_free</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* finds neighbors tuples in the (off, len) B-tree */</comment>
		<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>tup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>o_btree_iterator_create</name><argument_list>(<argument><expr><name>off_len_tree</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>tmpTup</name></expr></argument>,
									 <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>,
									 <argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>,
									 <argument><expr><name>BackwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmpTup</name> <operator>=</operator> <call><name>o_btree_iterator_fetch</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cur</name> <operator>=</operator> <operator>(</operator><name>FreeTreeTuple</name> <operator>*</operator><operator>)</operator> <name><name>tmpTup</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cur</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>EXTENTS_IX_EQ</name><argument_list>(<argument><expr><operator>*</operator><name>cur</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>merge_right</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>merge_left</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cur</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>cur</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>extent</name><operator>.</operator><name>offset</name></name> <operator>!=</operator> <name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>extent</name><operator>.</operator><name>offset</name></name> <operator>&lt;</operator> <name><name>extent</name><operator>.</operator><name>off</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>merge_right</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>merge_left</name> <operator>=</operator> <operator>(</operator><name><name>cur</name><operator>-&gt;</operator><name>extent</name><operator>.</operator><name>offset</name></name> <operator>+</operator> <name><name>cur</name><operator>-&gt;</operator><name>extent</name><operator>.</operator><name>length</name></name><operator>)</operator> <operator>==</operator> <name><name>extent</name><operator>.</operator><name>off</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>merge_left</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>left</name> <operator>=</operator> <operator>*</operator><name>cur</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>extent</name><operator>.</operator><name>offset</name></name> <operator>==</operator> <name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>merge_right</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>right</name> <operator>=</operator> <operator>*</operator><name>cur</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tmpTup</name> <operator>=</operator> <call><name>o_btree_iterator_fetch</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cur</name> <operator>=</operator> <operator>(</operator><name>FreeTreeTuple</name> <operator>*</operator><operator>)</operator> <name><name>tmpTup</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cur</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>EXTENTS_IX_EQ</name><argument_list>(<argument><expr><operator>*</operator><name>cur</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call>
				<operator>&amp;&amp;</operator> <name><name>cur</name><operator>-&gt;</operator><name>extent</name><operator>.</operator><name>offset</name></name> <operator>+</operator> <name><name>cur</name><operator>-&gt;</operator><name>extent</name><operator>.</operator><name>length</name></name> <operator>==</operator> <name><name>extent</name><operator>.</operator><name>off</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>merge_left</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>left</name> <operator>=</operator> <operator>*</operator><name>cur</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>cur</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* delete neighbors from the (len, off) B-tree */</comment>
		<if_stmt><if>if <condition>(<expr><name>merge_right</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>right</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>modify_result</name> <operator>=</operator> <call><name>o_btree_autonomous_delete</name><argument_list>(<argument><expr><name>len_off_tree</name></expr></argument>, <argument><expr><name>tmpTup</name></expr></argument>,
													  <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>modify_result</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>merge_left</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>left</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>modify_result</name> <operator>=</operator> <call><name>o_btree_autonomous_delete</name><argument_list>(<argument><expr><name>len_off_tree</name></expr></argument>,
													  <argument><expr><name>tmpTup</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>modify_result</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>merge_right</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>right</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>modify_result</name> <operator>=</operator> <call><name>o_btree_autonomous_insert</name><argument_list>(<argument><expr><name>len_off_tree</name></expr></argument>,
															  <argument><expr><name>tmpTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>modify_result</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"unable to return extent (%lu, %lu) into the (len, off) B-tree"</literal></expr></argument>,
							 <argument><expr><name><name>right</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>right</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Ok, now delete neighbors from the (off, len) B-tree
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>merge_right</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>right</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>modify_result</name> <operator>=</operator> <call><name>o_btree_autonomous_delete</name><argument_list>(<argument><expr><name>off_len_tree</name></expr></argument>,
													  <argument><expr><name>tmpTup</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>modify_result</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"unable to delete extent (%lu, %lu) from the (off, len) B-tree"</literal></expr></argument>,
					 <argument><expr><name><name>right</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>right</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>merge_left</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>left</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>modify_result</name> <operator>=</operator> <call><name>o_btree_autonomous_delete</name><argument_list>(<argument><expr><name>off_len_tree</name></expr></argument>,
													  <argument><expr><name>tmpTup</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>modify_result</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"unable to delete extent (%lu, %lu) from the (off, len) B-tree"</literal></expr></argument>,
					 <argument><expr><name><name>left</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>left</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Ok, now insert the merged extent into B-trees.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>merge_left</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name><name>left</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name> <operator>+</operator> <name><name>left</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name> <operator>==</operator> <name><name>extent</name><operator>.</operator><name>off</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name><name>left</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name> <operator>+</operator> <name><name>extent</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name><name>extent</name><operator>.</operator><name>off</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name><name>extent</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>merge_right</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name> <operator>+</operator> <name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name> <operator>==</operator> <name><name>right</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name> <operator>+=</operator> <name><name>right</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>tup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>modify_result</name> <operator>=</operator> <call><name>o_btree_autonomous_insert</name><argument_list>(<argument><expr><name>off_len_tree</name></expr></argument>, <argument><expr><name>tmpTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>modify_result</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"unable to insert extent (%lu, %lu) to the (off, len) B-tree"</literal></expr></argument>,
				 <argument><expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>tup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmpTup</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>modify_result</name> <operator>=</operator> <call><name>o_btree_autonomous_insert</name><argument_list>(<argument><expr><name>len_off_tree</name></expr></argument>, <argument><expr><name>tmpTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>modify_result</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"unable to insert extent (%lu, %lu) to the (len, off) B-tree"</literal></expr></argument>,
				 <argument><expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>tup</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>inserted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>btree_iterator_free</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>enable_stopevents</name> <operator>=</operator> <name>old_enable_stopevents</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Calls the callback for each free file extent for a BTree on given csn.
 *
 * Be careful, there are can be some intersections, see get_extent() algorithm.
 */</comment>
<function><type><name>void</name></type>
<name>foreach_free_extent</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>ForEachExtentCallback</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreeTreeTuple</name></type> <name>from</name></decl>,
				<decl><type ref="prev"/><name>to</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FileExtent</name></type>	<name>cur_extent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>old_enable_stopevents</name> <init>= <expr><name>enable_stopevents</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>off_len_tree</name> <init>= <expr><call><name>get_sys_tree</name><argument_list>(<argument><expr><name>SYS_TREES_EXTENTS_OFF_LEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>tmpTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>toTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>fromTup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>enable_stopevents</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>from</name><operator>.</operator><name>ixType</name></name> <operator>=</operator> <name><name>to</name><operator>.</operator><name>ixType</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>from</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name><name>to</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>from</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>to</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>from</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name><name>to</name><operator>.</operator><name>extent</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>from</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name><name>to</name><operator>.</operator><name>extent</name><operator>.</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fromTup</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>from</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fromTup</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* iterate from begin and to the end of the index */</comment>
	<expr_stmt><expr><name><name>to</name><operator>.</operator><name>relnode</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>toTup</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>to</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>toTup</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>from</name><operator>.</operator><name>relnode</name></name> <operator>&lt;</operator> <name><name>to</name><operator>.</operator><name>relnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>o_btree_iterator_create</name><argument_list>(<argument><expr><name>off_len_tree</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>fromTup</name></expr></argument>,
								 <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>,
								 <argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>,
								 <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tmpTup</name> <operator>=</operator> <call><name>o_btree_iterator_fetch</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>toTup</name></expr></argument>,
										<argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tmpTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>cur</name> <operator>=</operator> <operator>(</operator><name>FreeTreeTuple</name> <operator>*</operator><operator>)</operator> <name><name>tmpTup</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>ixType</name></name> <operator>==</operator> <name><name>desc</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>datoid</name></name> <operator>==</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>relnode</name></name> <operator>==</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* FreeTreeFileExtent.length may be more than FileExtent.len */</comment>
		<while>while <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>extent</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <name>UINT16_MAX</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cur_extent</name><operator>.</operator><name>off</name></name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>extent</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cur_extent</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>UINT16_MAX</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>callback</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>cur_extent</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>extent</name><operator>.</operator><name>offset</name></name> <operator>+=</operator> <name>UINT16_MAX</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>extent</name><operator>.</operator><name>length</name></name> <operator>-=</operator> <name>UINT16_MAX</name></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><name><name>cur_extent</name><operator>.</operator><name>off</name></name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>extent</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cur_extent</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>extent</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>callback</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>cur_extent</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>btree_iterator_free</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>enable_stopevents</name> <operator>=</operator> <name>old_enable_stopevents</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Adds free extents from .tmp file to the trees.  Optionally removes the .tmp
 * file.
 */</comment>
<function><type><name>void</name></type>
<name>add_free_extents_from_tmp</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>remove</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeMetaPage</name> <modifier>*</modifier></type><name>metaPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>,
				<decl><type ref="prev"/><name><name>buf</name><index>[<expr><name>ORIOLEDB_BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>i</name></decl>,
				<decl><type ref="prev"/><name>buf_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>chkp_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>metaLock</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metaPage</name> <operator>=</operator> <call><name>BTREE_GET_META</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metaLock</name> <operator>=</operator> <operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>metaLock</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>chkp_num</name> <operator>=</operator> <name><name>metaPage</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>tag</name><operator>.</operator><name>num</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>can_use_checkpoint_extents</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name><name>metaPage</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>tag</name><operator>.</operator><name>num</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>metaLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>chkp_num</name> <operator>=</operator> <name><name>metaPage</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>tag</name><operator>.</operator><name>num</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>can_use_checkpoint_extents</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>chkp_num</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>metaPage</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>tag</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name>chkp_num</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>metaPage</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>tag</name><operator>.</operator><name>type</name></name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>seq_buf_file_exist</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* table may be deleted or *.tmp file not created */</comment>
			<expr_stmt><expr><name>chkp_num</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* free extents from *.tmp file */</comment>
		<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>get_seq_buf_filename</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>file</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file %s"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<do>do
		<block>{<block_content>
			<decl_stmt><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>cur_off</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>buf_len</name> <operator>=</operator> <call><name>OFileRead</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cur_off</name> <operator>=</operator> <operator>(</operator><name>FileExtent</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>buf_len</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FileExtent</name></expr></argument>)</argument_list></sizeof></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>numFreeBlocks</name></name></expr></argument>,
										<argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name><name>cur_off</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free_extent</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>*</operator><name>cur_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cur_off</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>buf_len</name></expr>;</expr_stmt>
		</block_content>}</block>
		while <condition>(<expr><name>buf_len</name> <operator>==</operator> <name>ORIOLEDB_BLCKSZ</name></expr>)</condition>;</do>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>remove_old_checkpoint_files</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>seq_buf_remove_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>metaLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
