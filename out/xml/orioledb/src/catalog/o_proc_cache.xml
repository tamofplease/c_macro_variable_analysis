<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/catalog/o_proc_cache.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 *  o_proc_cache.c
 *		Routines for orioledb proc cache.
 *
 * proc_cache is tree that contains cached metadata from pg_proc.
 *
 * Copyright (c) 2021-2022, OrioleDB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/catalog/o_proc_cache.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/o_tables.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/o_sys_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/sys_trees.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"recovery/recovery.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/toast_compression.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">150000</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogrecovery.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">140000</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_language.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/functions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">140000</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/print.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgrtab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>OSysCache</name> <modifier>*</modifier></type><name>proc_cache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>sql_func_data</name>
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>returnsTuple</name></decl>;</decl_stmt>	<comment type="block">/* true if returning whole tuple result */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>readonly_func</name></decl>;</decl_stmt>	<comment type="block">/* true to run in "read only" mode */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>lazyEval</name></decl>;</decl_stmt>		<comment type="block">/* true if using lazyEval for result query */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>jf_natts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nnqtlists</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>has_argnames</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>jf_targetList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>jf_atts</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>argnames</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>nqtlists</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	 <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>qtlists</name></decl>;</decl_stmt>
}</block></struct></type> <name>sql_func_data</name>;</typedef>

<struct>struct <name>OProc</name>
<block>{
	<decl_stmt><decl><type><name>OSysCacheKey1</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rettype</name></decl>;</decl_stmt>		<comment type="block">/* actual return type */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>strict</name></decl>;</decl_stmt>			<comment type="block">/* T if function is "strict" */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>retset</name></decl>;</decl_stmt>			<comment type="block">/* T if function returns a set */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>prolang</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>proowner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>nargs</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prosrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>probin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>argtypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sql_func_data</name> <modifier>*</modifier></type><name>sql_func</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>cxt</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">140000</literal></expr></cpp:if>
<comment type="block">/*
 * Data structure needed by the parser callback hooks to resolve parameter
 * references during parsing of a SQL function's body.  This is separate from
 * SQLFunctionCache since we sometimes do parsing separately from execution.
 */</comment>
<typedef>typedef <type><struct>struct <name>SQLFunctionParseInfo</name>
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>			<comment type="block">/* function's name */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>			<comment type="block">/* number of input arguments */</comment>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>argtypes</name></decl>;</decl_stmt>		<comment type="block">/* resolved types of input arguments */</comment>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>argnames</name></decl>;</decl_stmt>		<comment type="block">/* names of input arguments; NULL if none */</comment>
	<comment type="block">/* Note that argnames[i] can be NULL, if some args are unnamed */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collation</name></decl>;</decl_stmt>		<comment type="block">/* function's input collation, if known */</comment>
}</block></struct></type> <name>SQLFunctionParseInfo</name>;</typedef>


<comment type="block">/*
 * Perform rewriting of a query produced by parse analysis.
 *
 * Note: query must just have come from the parser, because we do not do
 * AcquireRewriteLocks() on it.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>pg_rewrite_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>querytree_list</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>Debug_print_parse</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog_node_display</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"parse tree"</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>,
						  <argument><expr><name>Debug_pretty_print</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* don't rewrite utilities, just dump 'em into result list */</comment>
		<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* rewrite regular queries */</comment>
		<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>QueryRewrite</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"REWRITER STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COPY_PARSE_PLAN_TREES</name></cpp:ifdef>
	<comment type="block">/* Optional debugging check: pass querytree through copyObject() */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_list</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>new_list</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* This checks both copyObject() and the equal() routines... */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>new_list</name></expr></argument>, <argument><expr><name>querytree_list</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"copyObject() failed to produce equal parse tree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <name>new_list</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WRITE_READ_PARSE_PLAN_TREES</name></cpp:ifdef>
	<comment type="block">/* Optional debugging check: pass querytree through outfuncs/readfuncs */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We currently lack outfuncs/readfuncs support for most utility
		 * statement types, so only attempt to write/read non-utility queries.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>querytree_list</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_UTILITY</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>nodeToString</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>new_query</name> <init>= <expr><call><name>stringToNodeWithLocations</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * queryId is not saved in stored rules, but we must preserve
				 * it here to avoid breaking pg_stat_statements.
				 */</comment>
				<expr_stmt><expr><name><name>new_query</name><operator>-&gt;</operator><name>queryId</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>queryId</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><name>new_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_list</name></expr></argument>, <argument><expr><name>new_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>new_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_list</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>

		<comment type="block">/* This checks both outfuncs/readfuncs and the equal() routines... */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>new_list</name></expr></argument>, <argument><expr><name>querytree_list</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"outfuncs/readfuncs failed to produce equal parse tree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <name>new_list</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>Debug_print_rewritten</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog_node_display</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"rewritten parse tree"</literal></expr></argument>, <argument><expr><name>querytree_list</name></expr></argument>,
						  <argument><expr><name>Debug_pretty_print</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>querytree_list</name></expr>;</return>
</block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">150000</literal></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pg_analyze_and_rewrite_params</name></cpp:macro> <cpp:value>pg_analyze_and_rewrite_withcb</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * An SQLFunctionCache record is built during the first call,
 * and linked to from the fn_extra field of the FmgrInfo struct.
 *
 * Note that currently this has only the lifespan of the calling query.
 * Someday we should rewrite this code to use plancache.c to save parse/plan
 * results for longer than that.
 *
 * Physically, though, the data has the lifespan of the FmgrInfo that's used
 * to call the function, and there are cases (particularly with indexes)
 * where the FmgrInfo might survive across transactions.  We cannot assume
 * that the parse/plan trees are good for longer than the (sub)transaction in
 * which parsing was done, so we must mark the record with the LXID/subxid of
 * its creation time, and regenerate everything if that's obsolete.  To avoid
 * memory leakage when we do have to regenerate things, all the data is kept
 * in a sub-context of the FmgrInfo's fn_mcxt.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>			<comment type="block">/* function name (for error msgs) */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>			<comment type="block">/* function body text (for error msgs) */</comment>

	<decl_stmt><decl><type><name>SQLFunctionParseInfoPtr</name></type> <name>pinfo</name></decl>;</decl_stmt>	<comment type="block">/* data for parser callback hooks */</comment>

	<decl_stmt><decl><type><name>Oid</name></type>			<name>rettype</name></decl>;</decl_stmt>		<comment type="block">/* actual return type */</comment>
	<decl_stmt><decl><type><name>int16</name></type>		<name>typlen</name></decl>;</decl_stmt>			<comment type="block">/* length of the return type */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>		<comment type="block">/* true if return type is pass by value */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>returnsSet</name></decl>;</decl_stmt>		<comment type="block">/* true if returning multiple rows */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>returnsTuple</name></decl>;</decl_stmt>	<comment type="block">/* true if returning whole tuple result */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shutdown_reg</name></decl>;</decl_stmt>	<comment type="block">/* true if registered shutdown callback */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>readonly_func</name></decl>;</decl_stmt>	<comment type="block">/* true to run in "read only" mode */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>lazyEval</name></decl>;</decl_stmt>		<comment type="block">/* true if using lazyEval for result query */</comment>

	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>		<comment type="block">/* Param list representing current args */</comment>

	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tstore</name></decl>;</decl_stmt>	<comment type="block">/* where we accumulate result tuples */</comment>

	<decl_stmt><decl><type><name>JunkFilter</name> <modifier>*</modifier></type><name>junkFilter</name></decl>;</decl_stmt>		<comment type="block">/* will be NULL if function returns VOID */</comment>

	<comment type="block">/*
	 * func_state is a List of execution_state records, each of which is the
	 * first for its original parsetree, with any additional records chained
	 * to it via the "next" fields.  This sublist structure is needed to keep
	 * track of where the original query boundaries are.
	 */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>func_state</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>fcontext</name></decl>;</decl_stmt>		<comment type="block">/* memory context holding this struct and all
								 * subsidiary data */</comment>

	<decl_stmt><decl><type><name>LocalTransactionId</name></type> <name>lxid</name></decl>;</decl_stmt>	<comment type="block">/* lxid in which cache was made */</comment>
	<decl_stmt><decl><type><name>SubTransactionId</name></type> <name>subxid</name></decl>;</decl_stmt>	<comment type="block">/* subxid in which cache was made */</comment>
}</block></struct></type> <name>SQLFunctionCache</name>;</typedef>

<typedef>typedef <type><name>SQLFunctionCache</name> <modifier>*</modifier></type><name>SQLFunctionCachePtr</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_sql_fcache</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>lazyEvalOK</name></decl></parameter>, <parameter><decl><type><name>sql_func_data</name> <modifier>*</modifier></type><name>out_sql_func</name></decl></parameter>,
							<parameter><decl><type><name>MemoryContext</name></type> <name>out_sql_func_cxt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sql_exec_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Pointer</name></type> <name>o_proc_cache_serialize_entry</name><parameter_list>(<parameter><decl><type><name>Pointer</name></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Pointer</name></type> <name>o_proc_cache_deserialize_entry</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>data</name></decl></parameter>,
											  <parameter><decl><type><name>Size</name></type> <name>length</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>o_proc_cache_free_entry</name><parameter_list>(<parameter><decl><type><name>Pointer</name></type> <name>entry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>o_proc_cache_fill_entry</name><parameter_list>(<parameter><decl><type><name>Pointer</name> <modifier>*</modifier></type><name>entry_ptr</name></decl></parameter>, <parameter><decl><type><name>OSysCacheKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
									<parameter><decl><type><name>Pointer</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><call><name>O_SYS_CACHE_FUNCS</name><argument_list>(<argument><expr><name>proc_cache</name></expr></argument>, <argument><expr><name>OProc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>OSysCacheFuncs</name></type> <name>proc_cache_funcs</name> <init>=
<expr><block>{
	<expr><operator>.</operator><name>free_entry</name> <operator>=</operator> <name>o_proc_cache_free_entry</name></expr>,
	<expr><operator>.</operator><name>fill_entry</name> <operator>=</operator> <name>o_proc_cache_fill_entry</name></expr>,
	<expr><operator>.</operator><name>toast_serialize_entry</name> <operator>=</operator> <name>o_proc_cache_serialize_entry</name></expr>,
	<expr><operator>.</operator><name>toast_deserialize_entry</name> <operator>=</operator> <name>o_proc_cache_deserialize_entry</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Initializes the proc sys cache memory.
 */</comment>
<macro><name>O_SYS_CACHE_INIT_FUNC</name><argument_list>(<argument>proc_cache</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>keytypes</name><index>[]</index></name> <init>= <expr><block>{<expr><name>OIDOID</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>proc_cache</name> <operator>=</operator> <call><name>o_create_sys_cache</name><argument_list>(<argument><expr><name>SYS_TREES_PROC_CACHE</name></expr></argument>,
									<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									<argument><expr><name>ProcedureOidIndexId</name></expr></argument>, <argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
									<argument><expr><name>keytypes</name></expr></argument>, <argument><expr><name>fastcache</name></expr></argument>,
									<argument><expr><name>mcxt</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>proc_cache_funcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<function><type><name>void</name></type>
<name>o_proc_cache_fill_entry</name><parameter_list>(<parameter><decl><type><name>Pointer</name> <modifier>*</modifier></type><name>entry_ptr</name></decl></parameter>, <parameter><decl><type><name>OSysCacheKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>proctup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OProc</name>	   <modifier>*</modifier></type><name>o_proc</name> <init>= <expr><operator>(</operator><name>OProc</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>entry_ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>fncollation</name> <init>= <expr><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>lazyEvalOK</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>procoid</name> <init>= <expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>proctup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>procoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>procform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>o_proc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>			<comment type="block">/* Existed o_proc updated */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>o_proc</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OProc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>o_proc</name><operator>-&gt;</operator><name>cxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>proc_cache</name><operator>-&gt;</operator><name>mcxt</name></name></expr></argument>, <argument><expr><literal type="string">"o_proc mcxt"</literal></expr></argument>,
											<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>entry_ptr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>o_proc</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>o_proc</name><operator>-&gt;</operator><name>rettype</name></name> <operator>=</operator> <name><name>procform</name><operator>-&gt;</operator><name>prorettype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>o_proc</name><operator>-&gt;</operator><name>strict</name></name> <operator>=</operator> <name><name>procform</name><operator>-&gt;</operator><name>proisstrict</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>o_proc</name><operator>-&gt;</operator><name>retset</name></name> <operator>=</operator> <name><name>procform</name><operator>-&gt;</operator><name>proretset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>o_proc</name><operator>-&gt;</operator><name>prolang</name></name> <operator>=</operator> <name><name>procform</name><operator>-&gt;</operator><name>prolang</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>o_proc</name><operator>-&gt;</operator><name>proowner</name></name> <operator>=</operator> <name><name>procform</name><operator>-&gt;</operator><name>proowner</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>o_proc</name><operator>-&gt;</operator><name>nargs</name></name> <operator>=</operator> <name><name>procform</name><operator>-&gt;</operator><name>pronargs</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>o_proc</name><operator>-&gt;</operator><name>proname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>o_proc</name><operator>-&gt;</operator><name>nargs</name></name> <operator>=</operator> <name><name>procform</name><operator>-&gt;</operator><name>pronargs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>o_proc</name><operator>-&gt;</operator><name>argtypes</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>nargs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>argtypes</name></name></expr></argument>, <argument><expr><name><name>procform</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name></name></expr></argument>,
		   <argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>nargs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>o_proc</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>o_type_cache_add_if_needed</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>datoid</name></name></expr></argument>, <argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
								   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>lsn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>fmgr_symbol</name><argument_list>(<argument><expr><name>procoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>o_proc</name><operator>-&gt;</operator><name>probin</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>o_proc</name><operator>-&gt;</operator><name>prosrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>o_proc</name><operator>-&gt;</operator><name>prosrc</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>o_proc</name><operator>-&gt;</operator><name>probin</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %u not found"</literal></expr></argument>, <argument><expr><name>procoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>o_proc</name><operator>-&gt;</operator><name>prolang</name></name> <operator>==</operator> <name>SQLlanguageId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>finfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OClassArg</name></type>	<name>arg</name> <init>= <expr><block>{<expr><operator>.</operator><name>sys_table</name> <operator>=</operator> <name>true</name></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>cur_lsn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>datoid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>finfo</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fcinfo</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>SizeForFunctionCallInfo</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>procoid</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
								 <argument><expr><operator>*</operator><name>fncollation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check call context */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_retset</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * For simplicity, we require callers to support both set eval
			 * modes. There are cases where we must use one or must use the
			 * other, and it's not really worthwhile to postpone the check
			 * till we know. But note we do not require caller to provide an
			 * expectedDesc.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rsi</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_ValuePerCall</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context "</literal>
								<literal type="string">"that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>lazyEvalOK</name> <operator>=</operator> <operator>!</operator><operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Preferred</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>lazyEvalOK</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>o_proc</name><operator>-&gt;</operator><name>sql_func</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sql_func_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>init_sql_fcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>fncollation</name></name></expr></argument>, <argument><expr><name>lazyEvalOK</name></expr></argument>,
						<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>sql_func</name></name></expr></argument>, <argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>o_sys_cache_set_datoid_lsn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>o_class_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>cur_lsn</name></expr></argument>,
									<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>o_proc</name><operator>-&gt;</operator><name>sql_func</name><operator>-&gt;</operator><name>nnqtlists</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>o_proc</name><operator>-&gt;</operator><name>sql_func</name><operator>-&gt;</operator><name>nqtlists</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>sql_func</name><operator>-&gt;</operator><name>qtlists</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>o_collect_functions_pstmt</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></for>
		<expr_stmt><expr><name>fcache</name> <operator>=</operator> <operator>(</operator><name>SQLFunctionCachePtr</name><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>o_proc_cache_free_entry</name><parameter_list>(<parameter><decl><type><name>Pointer</name></type> <name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OProc</name>	   <modifier>*</modifier></type><name>o_proc</name> <init>= <expr><operator>(</operator><name>OProc</name> <operator>*</operator><operator>)</operator> <name>entry</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>o_proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Pointer</name></type>
<name>o_proc_cache_serialize_entry</name><parameter_list>(<parameter><decl><type><name>Pointer</name></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OProc</name>	   <modifier>*</modifier></type><name>o_proc</name> <init>= <expr><operator>(</operator><name>OProc</name> <operator>*</operator><operator>)</operator> <name>entry</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>o_proc</name></expr></argument>,
						   <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>OProc</name></expr></argument>, <argument><expr><name>proname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>o_serialize_string</name><argument_list>(<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>o_serialize_string</name><argument_list>(<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>prosrc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>o_serialize_string</name><argument_list>(<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>probin</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name><name>o_proc</name><operator>-&gt;</operator><name>argtypes</name></name></expr></argument>,
						   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>o_proc</name><operator>-&gt;</operator><name>nargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>o_proc</name><operator>-&gt;</operator><name>prolang</name></name> <operator>==</operator> <name>SQLlanguageId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>sql_func_data</name> <modifier>*</modifier></type><name>sql_func</name> <init>= <expr><name><name>o_proc</name><operator>-&gt;</operator><name>sql_func</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>o_serialize_string</name><argument_list>(<argument><expr><name><name>sql_func</name><operator>-&gt;</operator><name>src</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>Pointer</name><operator>)</operator> <name>sql_func</name><operator>)</operator> <operator>+</operator>
							   <call><name>offsetof</name><argument_list>(<argument><expr><name>sql_func_data</name></expr></argument>, <argument><expr><name>returnsTuple</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>sql_func_data</name></expr></argument>, <argument><expr><name>jf_targetList</name></expr></argument>)</argument_list></call> <operator>-</operator>
							   <call><name>offsetof</name><argument_list>(<argument><expr><name>sql_func_data</name></expr></argument>, <argument><expr><name>returnsTuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>o_serialize_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sql_func</name><operator>-&gt;</operator><name>jf_targetList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name><name>sql_func</name><operator>-&gt;</operator><name>jf_atts</name></name></expr></argument>,
							   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>sql_func</name><operator>-&gt;</operator><name>jf_natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>sql_func</name><operator>-&gt;</operator><name>has_argnames</name></name></expr>)</condition><block type="pseudo"><block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>o_proc</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>o_serialize_string</name><argument_list>(<argument><expr><name><name>sql_func</name><operator>-&gt;</operator><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name><name>sql_func</name><operator>-&gt;</operator><name>nqtlists</name></name></expr></argument>,
							   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>sql_func</name><operator>-&gt;</operator><name>nnqtlists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sql_func</name><operator>-&gt;</operator><name>nnqtlists</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>sql_func</name><operator>-&gt;</operator><name>nqtlists</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>o_serialize_node</name><argument_list>(<argument><expr><name><name>sql_func</name><operator>-&gt;</operator><name>qtlists</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name><name>str</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
	<return>return <expr><name><name>str</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Pointer</name></type>
<name>o_proc_cache_deserialize_entry</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>ptr</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OProc</name>	   <modifier>*</modifier></type><name>o_proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_mcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>o_proc</name> <operator>=</operator> <operator>(</operator><name>OProc</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OProc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>OProc</name></expr></argument>, <argument><expr><name>proname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ptr</name> <operator>-</operator> <name>data</name><operator>)</operator> <operator>+</operator> <name>len</name> <operator>&lt;=</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>o_proc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>o_proc</name><operator>-&gt;</operator><name>cxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>mcxt</name></expr></argument>, <argument><expr><literal type="string">"o_proc mcxt"</literal></expr></argument>,
										<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>old_mcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>o_proc</name><operator>-&gt;</operator><name>proname</name></name> <operator>=</operator> <call><name>o_deserialize_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>o_proc</name><operator>-&gt;</operator><name>prosrc</name></name> <operator>=</operator> <call><name>o_deserialize_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>o_proc</name><operator>-&gt;</operator><name>probin</name></name> <operator>=</operator> <call><name>o_deserialize_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>o_proc</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ptr</name> <operator>-</operator> <name>data</name><operator>)</operator> <operator>+</operator> <name>len</name> <operator>&lt;=</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>o_proc</name><operator>-&gt;</operator><name>argtypes</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>argtypes</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>o_proc</name><operator>-&gt;</operator><name>prolang</name></name> <operator>==</operator> <name>SQLlanguageId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>sql_func_data</name> <modifier>*</modifier></type><name>sql_func</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sql_func</name> <operator>=</operator> <operator>(</operator><name>sql_func_data</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sql_func_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>o_proc</name><operator>-&gt;</operator><name>sql_func</name></name> <operator>=</operator> <name>sql_func</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>sql_func</name><operator>-&gt;</operator><name>src</name></name> <operator>=</operator> <call><name>o_deserialize_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>sql_func_data</name></expr></argument>, <argument><expr><name>jf_targetList</name></expr></argument>)</argument_list></call> <operator>-</operator>
			<call><name>offsetof</name><argument_list>(<argument><expr><name>sql_func_data</name></expr></argument>, <argument><expr><name>returnsTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ptr</name> <operator>-</operator> <name>data</name><operator>)</operator> <operator>+</operator> <name>len</name> <operator>&lt;=</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Pointer</name><operator>)</operator> <name>sql_func</name><operator>)</operator> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>sql_func_data</name></expr></argument>, <argument><expr><name>returnsTuple</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>sql_func</name><operator>-&gt;</operator><name>jf_targetList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>o_deserialize_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>sql_func</name><operator>-&gt;</operator><name>jf_natts</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ptr</name> <operator>-</operator> <name>data</name><operator>)</operator> <operator>+</operator> <name>len</name> <operator>&lt;=</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sql_func</name><operator>-&gt;</operator><name>jf_atts</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>sql_func</name><operator>-&gt;</operator><name>jf_atts</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>o_proc</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>sql_func</name><operator>-&gt;</operator><name>has_argnames</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>sql_func</name><operator>-&gt;</operator><name>argnames</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>o_proc</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>sql_func</name><operator>-&gt;</operator><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>o_deserialize_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>sql_func</name><operator>-&gt;</operator><name>nnqtlists</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ptr</name> <operator>-</operator> <name>data</name><operator>)</operator> <operator>+</operator> <name>len</name> <operator>&lt;=</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sql_func</name><operator>-&gt;</operator><name>nqtlists</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>sql_func</name><operator>-&gt;</operator><name>nqtlists</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sql_func</name><operator>-&gt;</operator><name>qtlists</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>sql_func</name><operator>-&gt;</operator><name>nnqtlists</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Node</name> <operator>*</operator><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sql_func</name><operator>-&gt;</operator><name>nnqtlists</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>sql_func</name><operator>-&gt;</operator><name>qtlists</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>sql_func</name><operator>-&gt;</operator><name>nqtlists</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator>
										   <sizeof>sizeof<argument_list>(<argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>sql_func</name><operator>-&gt;</operator><name>nqtlists</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>sql_func</name><operator>-&gt;</operator><name>qtlists</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>o_deserialize_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_mcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>o_proc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Specialized DestReceiver for collecting query output in a SQL function
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>DestReceiver</name></type> <name>pub</name></decl>;</decl_stmt>			<comment type="block">/* publicly-known function pointers */</comment>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tstore</name></decl>;</decl_stmt>	<comment type="block">/* where to put result tuples */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>cxt</name></decl>;</decl_stmt>			<comment type="block">/* context containing tstore */</comment>
	<decl_stmt><decl><type><name>JunkFilter</name> <modifier>*</modifier></type><name>filter</name></decl>;</decl_stmt>			<comment type="block">/* filter to convert tuple type */</comment>
}</block></struct></type> <name>DR_sqlfunction</name>;</typedef>

<comment type="block">/*
 * We have an execution_state record for each query in a function.  Each
 * record contains a plantree for its query.  If the query is currently in
 * F_EXEC_RUN state then there's a QueryDesc too.
 *
 * The "next" fields chain together all the execution_state records generated
 * from a single original parsetree.  (There will only be more than one in
 * case of rule expansion of the original parsetree.)
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>F_EXEC_START</name></decl>, <decl><name>F_EXEC_RUN</name></decl>, <decl><name>F_EXEC_DONE</name></decl>
}</block></enum></type> <name>ExecStatus</name>;</typedef>

<typedef>typedef <type><struct>struct <name>execution_state</name>
<block>{
	<decl_stmt><decl><type><name><name>struct</name> <name>execution_state</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecStatus</name></type>	<name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>setsResult</name></decl>;</decl_stmt>		<comment type="block">/* true if this query produces func's result */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>lazyEval</name></decl>;</decl_stmt>		<comment type="block">/* true if should fetch one row at a time */</comment>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>			<comment type="block">/* plan for this query */</comment>
	<decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>qd</name></decl>;</decl_stmt>				<comment type="block">/* null unless status == RUN */</comment>
}</block></struct></type> <name>execution_state</name>;</typedef>

<comment type="block">/*
 * Set up the per-query execution_state records for a SQL function.
 *
 * The input is a List of Lists of parsed and rewritten, but not planned,
 * querytrees.  The sublist structure denotes the original query boundaries.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>init_execution_state</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>queryTree_list</name></decl></parameter>,
					 <parameter><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>lazyEvalOK</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>eslist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>lasttages</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>queryTree_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>qtlist</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>firstes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>preves</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>qtlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>queryTree</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>newes</name></decl>;</decl_stmt>

			<comment type="block">/* Plan the query if needed */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>queryTree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Utility commands require no planning. */</comment>
				<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>stmt_location</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>stmt_len</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>pg_plan_query</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>,
									 <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>src</name></name></expr></argument>,
									 <argument><expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Precheck all commands for validity in a function.  This should
			 * generally match the restrictions spi.c applies.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>CopyStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>(</operator><operator>(</operator><name>CopyStmt</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name><operator>)</operator><operator>-&gt;</operator><name>filename</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot COPY to/from client in an SQL function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>TransactionStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					<comment type="block">/* translator: %s is a SQL statement name */</comment>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed in an SQL function"</literal></expr></argument>,
									<argument><expr><call><name>CreateCommandName</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>readonly_func</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>CommandIsReadOnly</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				<comment type="block">/* translator: %s is a SQL statement name */</comment>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed in a non-volatile function"</literal></expr></argument>,
								<argument><expr><call><name>CreateCommandName</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* OK, build the execution_state for this query */</comment>
			<expr_stmt><expr><name>newes</name> <operator>=</operator> <operator>(</operator><name>execution_state</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>execution_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>preves</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>preves</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>newes</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>firstes</name> <operator>=</operator> <name>newes</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name><name>newes</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newes</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>F_EXEC_START</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newes</name><operator>-&gt;</operator><name>setsResult</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* might change below */</comment>
			<expr_stmt><expr><name><name>newes</name><operator>-&gt;</operator><name>lazyEval</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* might change below */</comment>
			<expr_stmt><expr><name><name>newes</name><operator>-&gt;</operator><name>stmt</name></name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newes</name><operator>-&gt;</operator><name>qd</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>queryTree</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>lasttages</name> <operator>=</operator> <name>newes</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>preves</name> <operator>=</operator> <name>newes</name></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name>eslist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>eslist</name></expr></argument>, <argument><expr><name>firstes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Mark the last canSetTag query as delivering the function result; then,
	 * if it is a plain SELECT, mark it for lazy evaluation. If it's not a
	 * SELECT we must always run it to completion.
	 *
	 * Note: at some point we might add additional criteria for whether to use
	 * lazy eval.  However, we should prefer to use it whenever the function
	 * doesn't return set, since fetching more than one row is useless in that
	 * case.
	 *
	 * Note: don't set setsResult if the function returns VOID, as evidenced
	 * by not having made a junkfilter.  This ensures we'll throw away any
	 * output from the last statement in such a function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>lasttages</name> <operator>&amp;&amp;</operator> <name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lasttages</name><operator>-&gt;</operator><name>setsResult</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>lazyEvalOK</name> <operator>&amp;&amp;</operator>
			<name><name>lasttages</name><operator>-&gt;</operator><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>lasttages</name><operator>-&gt;</operator><name>stmt</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>lazyEval</name></name> <operator>=</operator> <name><name>lasttages</name><operator>-&gt;</operator><name>lazyEval</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>eslist</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>jf_cleanTupType_init_entry</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>desc</name></decl></parameter>,
						   <parameter><decl><type><name>AttrNumber</name></type> <name>attributeNumber</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attributeName</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>oidtypeid</name></decl></parameter>,
						   <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>attdim</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>jf_atttypid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>attributeNumber</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>attributeNumber</name> <operator>&lt;=</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize the attribute fields
	 */</comment>
	<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>attributeNumber</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attrelid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* dummy value */</comment>

	<comment type="block">/*
	 * Note: attributeName can be NULL, because the planner doesn't always
	 * fill in valid resname values in targetlists, particularly for resjunk
	 * attributes. Also, do nothing if caller wants to re-use the old attname.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>attributeName</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>attributeName</name> <operator>!=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>att</name><operator>-&gt;</operator><name>attname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>attributeNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attndims</name></name> <operator>=</operator> <name>attdim</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>atthasdef</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>atthasmissing</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attislocal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* attacl, attoptions and attfdwoptions are not present in tupledescs */</comment>

	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>=</operator> <name>oidtypeid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>o_type_cache_fill_info</name><argument_list>(<argument><expr><name>jf_atttypid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>att</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>att</name><operator>-&gt;</operator><name>attstorage</name></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attcompression</name></name> <operator>=</operator> <name>InvalidCompressionMethod</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare the SQLFunctionParseInfo struct for parsing a SQL function body
 *
 * This includes resolving actual types of polymorphic arguments.
 *
 * call_expr can be passed as NULL, but then we will fail if there are any
 * polymorphic arguments.
 */</comment>
<function><type><specifier>static</specifier> <name>SQLFunctionParseInfoPtr</name></type>
<name>o_prepare_sql_fn_parse_info</name><parameter_list>(<parameter><decl><type><name>OProc</name> <modifier>*</modifier></type><name>o_proc</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>call_expr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>inputCollation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SQLFunctionParseInfoPtr</name></type> <name>pinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sql_func_data</name> <modifier>*</modifier></type><name>sql_func</name> <init>= <expr><name><name>o_proc</name><operator>-&gt;</operator><name>sql_func</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>pinfo</name> <operator>=</operator> <operator>(</operator><name>SQLFunctionParseInfoPtr</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SQLFunctionParseInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Function's name (only) can be used to qualify argument names */</comment>
	<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>fname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Save the function's input collation */</comment>
	<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name>inputCollation</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy input argument types from the pg_proc entry, then resolve any
	 * polymorphic types.
	 */</comment>
	<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>nargs</name></name> <operator>=</operator> <name>nargs</name> <operator>=</operator> <name><name>o_proc</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>argOidVect</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>argnum</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>argOidVect</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>argOidVect</name></expr></argument>, <argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>argtypes</name></name></expr></argument>, <argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>argnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>argnum</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>argnum</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>argtype</name> <init>= <expr><name><name>argOidVect</name><index>[<expr><name>argnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>argtype</name> <operator>=</operator> <call><name>get_call_expr_argtype</name><argument_list>(<argument><expr><name>call_expr</name></expr></argument>, <argument><expr><name>argnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>argtype</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine actual type of argument declared %s"</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>argOidVect</name><index>[<expr><name>argnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>argOidVect</name><index>[<expr><name>argnum</name></expr>]</index></name> <operator>=</operator> <name>argtype</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>argtypes</name></name> <operator>=</operator> <name>argOidVect</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Collect names of arguments, too, if any
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>argnames</name></name> <operator>=</operator> <name><name>sql_func</name><operator>-&gt;</operator><name>argnames</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>argnames</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>pinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the SQLFunctionCache for a SQL function
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_sql_fcache</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lazyEvalOK</name></decl></parameter>,
				<parameter><decl><type><name>sql_func_data</name> <modifier>*</modifier></type><name>out_sql_func</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>out_sql_func_cxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>finfo</name> <init>= <expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>foid</name> <init>= <expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>fcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>rettupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>procedureTuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procedureStruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>queryTree_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>resulttlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>cur_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>datoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OProc</name>	   <modifier>*</modifier></type><name>o_proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sql_func_data</name> <modifier>*</modifier></type><name>sql_func</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>o_sys_cache_set_datoid_lsn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>o_proc</name> <operator>=</operator> <call><name>o_proc_cache_search</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>, <argument><expr><name>cur_lsn</name></expr></argument>,
								 <argument><expr><name><name>proc_cache</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>o_proc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sql_func</name> <operator>=</operator> <name><name>o_proc</name><operator>-&gt;</operator><name>sql_func</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Create memory context that holds all the SQLFunctionCache data.  It
	 * must be a child of whatever context holds the FmgrInfo.
	 */</comment>
	<expr_stmt><expr><name>fcontext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>,
									 <argument><expr><literal type="string">"SQL function"</literal></expr></argument>,
									 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>fcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the struct proper, link it to fcontext and fn_extra.  Once this
	 * is done, we'll be able to recover the memory after failure, even if the
	 * FmgrInfo is long-lived.
	 */</comment>
	<expr_stmt><expr><name>fcache</name> <operator>=</operator> <operator>(</operator><name>SQLFunctionCachePtr</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SQLFunctionCache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>fcontext</name></name> <operator>=</operator> <name>fcontext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>fcache</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>o_proc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>fname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * get the procedure tuple corresponding to the given function Oid
		 */</comment>
		<expr_stmt><expr><name>procedureTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>foid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>foid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>procedureStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * copy function name immediately for use by error reporting callback,
		 * and for use as memory context identifier
		 */</comment>
		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>fname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>procedureStruct</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSetIdentifier</name><argument_list>(<argument><expr><name>fcontext</name></expr></argument>, <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>o_proc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rettype</name> <operator>=</operator> <name><name>o_proc</name><operator>-&gt;</operator><name>rettype</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Resolve any polymorphism, obtaining the actual result type, and the
		 * corresponding tupdesc if it's a rowtype.
		 */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rettype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rettupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>rettype</name></name> <operator>=</operator> <name>rettype</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>o_proc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>o_type_cache_fill_info</name><argument_list>(<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name><name>fcache</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcache</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>returnsSet</name></name> <operator>=</operator> <name><name>o_proc</name><operator>-&gt;</operator><name>retset</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>readonly_func</name></name> <operator>=</operator> <name><name>sql_func</name><operator>-&gt;</operator><name>readonly_func</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Fetch the typlen and byval info for the result type */</comment>
		<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcache</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcache</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Remember whether we're returning setof something */</comment>
		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>returnsSet</name></name> <operator>=</operator> <name><name>procedureStruct</name><operator>-&gt;</operator><name>proretset</name></name></expr>;</expr_stmt>


		<comment type="block">/* Remember if function is STABLE/IMMUTABLE */</comment>
		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>readonly_func</name></name> <operator>=</operator>
			<operator>(</operator><name><name>procedureStruct</name><operator>-&gt;</operator><name>provolatile</name></name> <operator>!=</operator> <name>PROVOLATILE_VOLATILE</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>o_proc</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We need the actual argument types to pass to the parser.  Also make
		 * sure that parameter symbols are considered to have the function's
		 * resolved input collation.
		 */</comment>
		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>pinfo</name></name> <operator>=</operator> <call><name>o_prepare_sql_fn_parse_info</name><argument_list>(<argument><expr><name>o_proc</name></expr></argument>,
													<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_expr</name></name></expr></argument>,
													<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We need the actual argument types to pass to the parser.  Also make
		 * sure that parameter symbols are considered to have the function's
		 * resolved input collation.
		 */</comment>
		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>pinfo</name></name> <operator>=</operator> <call><name>prepare_sql_fn_parse_info</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>,
												  <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_expr</name></name></expr></argument>,
												  <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>o_proc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>src</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>sql_func</name><operator>-&gt;</operator><name>src</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * And of course we need the function body text.
		 */</comment>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>,
							  <argument><expr><name>procedureTuple</name></expr></argument>,
							  <argument><expr><name>Anum_pg_proc_prosrc</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null prosrc for function %u"</literal></expr></argument>, <argument><expr><name>foid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>src</name></name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">140000</literal></expr></cpp:if>
		<expr_stmt><expr><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:elif>
		<comment type="block">/* If we have prosqlbody, pay attention to that not prosrc. */</comment>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>,
							  <argument><expr><name>procedureTuple</name></expr></argument>,
							  <argument><expr><name>Anum_pg_proc_prosqlbody</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * Parse and rewrite the queries in the function text.  Use sublists
		 * to keep track of the original query boundaries.
		 *
		 * Note: since parsing and planning is done in fcontext, we will
		 * generate a lot of cruft that lives as long as the fcache does. This
		 * is annoying but we'll not worry about it until the module is
		 * rewritten to use plancache.c.
		 */</comment>
		<expr_stmt><expr><name>queryTree_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>stored_query_list</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>stored_query_list</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>stored_query_list</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stored_query_list</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>queryTree_sublist</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>AcquireRewriteLocks</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>queryTree_sublist</name> <operator>=</operator> <call><name>pg_rewrite_query</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>queryTree_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>queryTree_list</name></expr></argument>, <argument><expr><name>queryTree_sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>raw_parsetree_list</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>raw_parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>src</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>raw_parsetree_list</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>queryTree_sublist</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>queryTree_sublist</name> <operator>=</operator> <call><name>pg_analyze_and_rewrite_params</name><argument_list>(
																  <argument><expr><name>parsetree</name></expr></argument>,
																  <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>src</name></name></expr></argument>,
																  <argument><expr><operator>(</operator><name>ParserSetupHook</name><operator>)</operator> <name>sql_fn_parser_setup</name></expr></argument>,
																  <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>pinfo</name></name></expr></argument>,
																  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>queryTree_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>queryTree_list</name></expr></argument>, <argument><expr><name>queryTree_sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Check that there are no statements we don't want to allow.
		 */</comment>
		<expr_stmt><expr><call><name>check_sql_fn_statements</name><argument_list>(<argument><expr><name>queryTree_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>o_proc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>returnsTuple</name></name> <operator>=</operator> <name><name>sql_func</name><operator>-&gt;</operator><name>returnsTuple</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Check that the function returns the type it claims to.  Although in
		 * simple cases this was already done when the function was defined,
		 * we have to recheck because database objects used in the function's
		 * queries might have changed type.  We'd have to recheck anyway if
		 * the function had any polymorphic arguments.  Moreover,
		 * check_sql_fn_retval takes care of injecting any required column
		 * type coercions.  (But we don't ask it to insert nulls for dropped
		 * columns; the junkfilter handles that.)
		 *
		 * Note: we set fcache-&gt;returnsTuple according to whether we are
		 * returning the whole tuple result or just a single column.  In the
		 * latter case we clear returnsTuple because we need not act different
		 * from the scalar result case, even if it's a rowtype column.
		 * (However, we have to force lazy eval mode in that case; otherwise
		 * we'd need extra code to expand the rowtype column into multiple
		 * columns, since we have no way to notify the caller that it should
		 * do that.)
		 */</comment>
		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>returnsTuple</name></name> <operator>=</operator> <call><name>check_sql_fn_retval</name><argument_list>(<argument><expr><name>queryTree_list</name></expr></argument>,
												   <argument><expr><name>rettype</name></expr></argument>,
												   <argument><expr><name>rettupdesc</name></expr></argument>,
												   <argument><expr><name>false</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>resulttlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Construct a JunkFilter we can use to coerce the returned rowtype to the
	 * desired form, unless the result type is VOID, in which case there's
	 * nothing to coerce to.  (XXX Frequently, the JunkFilter isn't doing
	 * anything very interesting, but much of this module expects it to be
	 * there anyway.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rettype</name> <operator>!=</operator> <name>VOIDOID</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>o_proc</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>cleanLength</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>cleanMap</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>typeInfo</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>cur_resno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>JunkFilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name><operator>-&gt;</operator><name>jf_targetList</name></name> <operator>=</operator> <name><name>sql_func</name><operator>-&gt;</operator><name>jf_targetList</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ExecCleanTargetListLength</name><argument_list>(<argument><expr><name><name>sql_func</name><operator>-&gt;</operator><name>jf_targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>typeInfo</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>sql_func-&gt;jf_targetList</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>jf_cleanTupType_init_entry</name><argument_list>(<argument><expr><name>typeInfo</name></expr></argument>,
										   <argument><expr><name>cur_resno</name></expr></argument>,
										   <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>,
										   <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><literal type="number">0</literal></expr></argument>,
										   <argument><expr><name><name>sql_func</name><operator>-&gt;</operator><name>jf_atts</name><index>[<expr><name>cur_resno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>TupleDescInitEntryCollation</name><argument_list>(<argument><expr><name>typeInfo</name></expr></argument>,
											<argument><expr><name>cur_resno</name></expr></argument>,
											<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cur_resno</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name><operator>-&gt;</operator><name>jf_cleanTupType</name></name> <operator>=</operator> <name>typeInfo</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Now calculate the mapping between the original tuple's
			 * attributes and the "clean" tuple's attributes.
			 *
			 * The "map" is an array of "cleanLength" attribute numbers, i.e.
			 * one entry for every attribute of the "clean" tuple. The value
			 * of this entry is the attribute number of the corresponding
			 * attribute of the "original" tuple.  (Zero indicates a NULL
			 * output attribute, but we do not use that feature in this
			 * routine.)
			 */</comment>
			<expr_stmt><expr><name>cleanLength</name> <operator>=</operator> <name><name>typeInfo</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cleanLength</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>cleanResno</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>cleanMap</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>cleanLength</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cleanResno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>t</argument>, <argument>sql_func-&gt;jf_targetList</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>cleanMap</name><index>[<expr><name>cleanResno</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name>cleanResno</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cleanResno</name> <operator>==</operator> <name>cleanLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>cleanMap</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>typeInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name><operator>-&gt;</operator><name>jf_cleanMap</name></name> <operator>=</operator> <name>cleanMap</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name><operator>-&gt;</operator><name>jf_resultSlot</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If the result is composite, *and* we are returning the whole
			 * tuple result, we need to insert nulls for any dropped columns.
			 * In the single-column-result case, there might be dropped
			 * columns within the composite column value, but it's not our
			 * problem here.  There should be no resjunk entries in
			 * resulttlist, so in the second case the JunkFilter is certainly
			 * a no-op.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>rettupdesc</name> <operator>&amp;&amp;</operator> <name><name>fcache</name><operator>-&gt;</operator><name>returnsTuple</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name></name> <operator>=</operator> <call><name>ExecInitJunkFilterConversion</name><argument_list>(<argument><expr><name>resulttlist</name></expr></argument>,
																  <argument><expr><name>rettupdesc</name></expr></argument>,
																  <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name></name> <operator>=</operator> <call><name>ExecInitJunkFilter</name><argument_list>(<argument><expr><name>resulttlist</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>returnsTuple</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Make sure output rowtype is properly blessed */</comment>
		<expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name><operator>-&gt;</operator><name>jf_resultSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>returnsSet</name></name> <operator>&amp;&amp;</operator> <call><name>type_is_rowtype</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Returning rowtype as if it were scalar --- materialize won't work.
		 * Right now it's sufficient to override any caller preference for
		 * materialize mode, but to add more smarts in init_execution_state
		 * about this, we'd probably need a three-way flag instead of bool.
		 */</comment>
		<expr_stmt><expr><name>lazyEvalOK</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>o_proc</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>lastes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
					<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>func_state</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>lazyEval</name></name> <operator>=</operator> <name><name>sql_func</name><operator>-&gt;</operator><name>lazyEval</name></name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sql_func</name><operator>-&gt;</operator><name>nnqtlists</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>firstes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>preves</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>sql_func</name><operator>-&gt;</operator><name>nqtlists</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>newes</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>newes</name> <operator>=</operator> <operator>(</operator><name>execution_state</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>execution_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>preves</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>preves</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>newes</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>firstes</name> <operator>=</operator> <name>newes</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name><name>newes</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newes</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>F_EXEC_START</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newes</name><operator>-&gt;</operator><name>setsResult</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* might change below */</comment>
				<expr_stmt><expr><name><name>newes</name><operator>-&gt;</operator><name>lazyEval</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* might change below */</comment>
				<expr_stmt><expr><name><name>newes</name><operator>-&gt;</operator><name>stmt</name></name> <operator>=</operator> <operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator>
					<call><name>copyObject</name><argument_list>(<argument><expr><name><name>sql_func</name><operator>-&gt;</operator><name>qtlists</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newes</name><operator>-&gt;</operator><name>qd</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>preves</name> <operator>=</operator> <name>newes</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>lastes</name> <operator>=</operator> <name>newes</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>func_state</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>func_state</name></name></expr></argument>, <argument><expr><name>firstes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>lastes</name> <operator>&amp;&amp;</operator> <name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>lastes</name><operator>-&gt;</operator><name>setsResult</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lastes</name><operator>-&gt;</operator><name>lazyEval</name></name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>lazyEval</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Finally, plan the queries */</comment>
		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>func_state</name></name> <operator>=</operator> <call><name>init_execution_state</name><argument_list>(<argument><expr><name>queryTree_list</name></expr></argument>,
												  <argument><expr><name>fcache</name></expr></argument>,
												  <argument><expr><name>lazyEvalOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Mark fcache with time of creation to show it's valid */</comment>
	<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>lxid</name></name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>subxid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>o_proc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>out_sql_func</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
					<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>cur_resno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JunkFilter</name> <modifier>*</modifier></type><name>jf</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>out_sql_func_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>out_sql_func</name><operator>-&gt;</operator><name>src</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>src</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out_sql_func</name><operator>-&gt;</operator><name>returnsTuple</name></name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>returnsTuple</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out_sql_func</name><operator>-&gt;</operator><name>readonly_func</name></name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>readonly_func</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out_sql_func</name><operator>-&gt;</operator><name>lazyEval</name></name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>lazyEval</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>jf</name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>jf</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>out_sql_func</name><operator>-&gt;</operator><name>jf_targetList</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>jf</name><operator>-&gt;</operator><name>jf_targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>procedureStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>pinfo</name><operator>-&gt;</operator><name>argnames</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>out_sql_func</name><operator>-&gt;</operator><name>argnames</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>procedureStruct</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>*</operator>
											 <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>procedureStruct</name><operator>-&gt;</operator><name>pronargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>pinfo</name><operator>-&gt;</operator><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>out_sql_func</name><operator>-&gt;</operator><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
						<call><name>pstrdup</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>pinfo</name><operator>-&gt;</operator><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name><name>out_sql_func</name><operator>-&gt;</operator><name>has_argnames</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>out_sql_func</name><operator>-&gt;</operator><name>argnames</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>out_sql_func</name><operator>-&gt;</operator><name>has_argnames</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>jf</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>out_sql_func</name><operator>-&gt;</operator><name>jf_natts</name></name> <operator>=</operator> <name><name>jf</name><operator>-&gt;</operator><name>jf_cleanTupType</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>out_sql_func</name><operator>-&gt;</operator><name>jf_atts</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
											<name><name>out_sql_func</name><operator>-&gt;</operator><name>jf_natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>out_sql_func-&gt;jf_targetList</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>FormData_pg_attribute</name> <modifier>*</modifier></type><name>att</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>att</name> <operator>=</operator> <operator>&amp;</operator><name><name>jf</name><operator>-&gt;</operator><name>jf_cleanTupType</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>cur_resno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>out_sql_func</name><operator>-&gt;</operator><name>jf_atts</name><index>[<expr><name>cur_resno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>o_type_cache_add_if_needed</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name>cur_lsn</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cur_resno</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>out_sql_func</name><operator>-&gt;</operator><name>nnqtlists</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>func_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out_sql_func</name><operator>-&gt;</operator><name>nqtlists</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
										 <name><name>out_sql_func</name><operator>-&gt;</operator><name>nnqtlists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out_sql_func</name><operator>-&gt;</operator><name>qtlists</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Node</name> <operator>*</operator><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator>
										<name><name>out_sql_func</name><operator>-&gt;</operator><name>nnqtlists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>func_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>out_sql_func</name><operator>-&gt;</operator><name>nnqtlists</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>head</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cur</name> <operator>=</operator> <name>head</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>cur</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>cur</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			</block_content>}</block></while>

			<expr_stmt><expr><name><name>out_sql_func</name><operator>-&gt;</operator><name>nqtlists</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>out_sql_func</name><operator>-&gt;</operator><name>qtlists</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cur</name> <operator>=</operator> <name>head</name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>out_sql_func</name><operator>-&gt;</operator><name>qtlists</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cur</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>func_state</name></name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Start up execution of one execution_state node */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postquel_start</name><parameter_list>(<parameter><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this query produces the function result, send its output to the
	 * tuplestore; else discard any output.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>setsResult</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DR_sqlfunction</name> <modifier>*</modifier></type><name>myState</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>DestSQLFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* pass down the needed info to the dest receiver routines */</comment>
		<expr_stmt><expr><name>myState</name> <operator>=</operator> <operator>(</operator><name>DR_sqlfunction</name> <operator>*</operator><operator>)</operator> <name>dest</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>myState</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>mydest</name></name> <operator>==</operator> <name>DestSQLFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myState</name><operator>-&gt;</operator><name>tstore</name></name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myState</name><operator>-&gt;</operator><name>cxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myState</name><operator>-&gt;</operator><name>filter</name></name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>dest</name> <operator>=</operator> <name>None_Receiver</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name> <operator>=</operator> <call><name>CreateQueryDesc</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>,
							 <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>src</name></name></expr></argument>,
							 <argument><expr><name>InvalidSnapshot</name></expr></argument>,
							 <argument><expr><name>InvalidSnapshot</name></expr></argument>,
							 <argument><expr><name>dest</name></expr></argument>,
							 <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>paramLI</name></name></expr></argument>,
							 <argument><expr><ternary><condition><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name></expr> ?</condition><then> <expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>queryEnv</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Utility commands don't need Executor. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>operation</name></name> <operator>!=</operator> <name>CMD_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In lazyEval mode, do not let the executor set up an AfterTrigger
		 * context.  This is necessary not just an optimization, because we
		 * mustn't exit from the function execution with a stacked
		 * AfterTrigger level still active.  We are careful not to select
		 * lazyEval mode for any statement that could possibly queue triggers.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>eflags</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>lazyEval</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>eflags</name> <operator>=</operator> <name>EXEC_FLAG_SKIP_TRIGGERS</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>eflags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>			<comment type="block">/* default run-to-completion flags */</comment>
		<expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>F_EXEC_RUN</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Run one execution_state; either to completion or to first result row */</comment>
<comment type="block">/* Returns true if we ran to completion */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>postquel_getnext</name><parameter_list>(<parameter><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ProcessUtility</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>,
					   <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>src</name></name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>
					   <argument><expr><name>false</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					   <argument><expr><name>PROCESS_UTILITY_QUERY</name></expr></argument>,
					   <argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>params</name></name></expr></argument>,
					   <argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>,
					   <argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>			<comment type="block">/* never stops early */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Run regular commands to completion unless lazyEval */</comment>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>count</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>es</name><operator>-&gt;</operator><name>lazyEval</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><operator>!</operator><name><name>fcache</name><operator>-&gt;</operator><name>returnsSet</name></name> <operator>||</operator> <operator>!</operator><name><name>es</name><operator>-&gt;</operator><name>lazyEval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we requested run to completion OR there was no tuple returned,
		 * command must be complete.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>count</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Shut down execution of one execution_state node */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postquel_end</name><parameter_list>(<parameter><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* mark status done to ensure we don't do ExecutorEnd twice */</comment>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>F_EXEC_DONE</name></expr>;</expr_stmt>

	<comment type="block">/* Utility commands don't need Executor. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>operation</name></name> <operator>!=</operator> <name>CMD_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecutorFinish</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecutorEnd</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>rDestroy</name></name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeQueryDesc</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Build ParamListInfo array representing current arguments */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postquel_sub_params</name><parameter_list>(<parameter><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name></decl></parameter>,
					<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name> <init>= <expr><name><name>fcinfo</name><operator>-&gt;</operator><name>nargs</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>paramLI</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>makeParamList</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>paramLI</name></name> <operator>=</operator> <name>paramLI</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>paramLI</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>paramLI</name><operator>-&gt;</operator><name>numParams</name></name> <operator>==</operator> <name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><name><name>paramLI</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>pflags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>pinfo</name><operator>-&gt;</operator><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>paramLI</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Extract the SQL function's value from a single result row.  This is used
 * both for scalar (non-set) functions and for each row of a lazy-eval set
 * result.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>postquel_get_single_result</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						   <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
						   <parameter><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name></decl></parameter>,
						   <parameter><decl><type><name>MemoryContext</name></type> <name>resultcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Set up to return the function value.  For pass-by-reference datatypes,
	 * be sure to allocate the result in resultcontext, not the current memory
	 * context (which has query lifespan).  We can't leave the data in the
	 * TupleTableSlot because we intend to clear the slot before returning.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>resultcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>returnsTuple</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We must return the whole tuple as a Datum. */</comment>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ExecFetchSlotHeapTupleDatum</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Returning a scalar, which we have to extract from the first column
		 * of the SELECT result, and then copy into result context if needed.
		 */</comment>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>, <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * callback function in case a function-returning-set needs to be shut down
 * before it has been run to completion
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ShutdownSQLFunction</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name> <init>= <expr><operator>(</operator><name>SQLFunctionCachePtr</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>es</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fcache-&gt;func_state</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>es</name> <operator>=</operator> <operator>(</operator><name>execution_state</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>es</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Shut down anything still running */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>F_EXEC_RUN</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Re-establish active snapshot for any called functions */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcache</name><operator>-&gt;</operator><name>readonly_func</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>postquel_end</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcache</name><operator>-&gt;</operator><name>readonly_func</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Reset states to START in case we're called again */</comment>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>F_EXEC_START</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>es</name> <operator>=</operator> <name><name>es</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block>

	<comment type="block">/* Release tuplestore if we have one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* execUtils will deregister the callback... */</comment>
	<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>shutdown_reg</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * o_fmgr_sql: function call manager for SQL functions
 */</comment>
<function><type><name>Datum</name></type>
<name>o_fmgr_sql</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>sqlerrcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>randomAccess</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>lazyEvalOK</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_first</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>pushed_snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>es</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>eslist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>eslc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Setup error traceback support for ereport()
	 */</comment>
	<expr_stmt><expr><name><name>sqlerrcontext</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>sql_exec_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sqlerrcontext</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sqlerrcontext</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>sqlerrcontext</name></expr>;</expr_stmt>

	<comment type="block">/* Check call context */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_retset</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * For simplicity, we require callers to support both set eval modes.
		 * There are cases where we must use one or must use the other, and
		 * it's not really worthwhile to postpone the check till we know. But
		 * note we do not require caller to provide an expectedDesc.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rsi</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_ValuePerCall</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>randomAccess</name> <operator>=</operator> <name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Random</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lazyEvalOK</name> <operator>=</operator> <operator>!</operator><operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Preferred</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>randomAccess</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lazyEvalOK</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Initialize fcache (build plans) if first time through; or re-initialize
	 * if the cache is stale.
	 */</comment>
	<expr_stmt><expr><name>fcache</name> <operator>=</operator> <operator>(</operator><name>SQLFunctionCachePtr</name><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fcache</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>lxid</name></name> <operator>!=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name> <operator>||</operator>
			<operator>!</operator><call><name>SubTransactionIsActive</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>subxid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* It's stale; unlink and delete */</comment>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>fcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fcache</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>fcache</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>init_sql_fcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>fncollation</name></name></expr></argument>, <argument><expr><name>lazyEvalOK</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fcache</name> <operator>=</operator> <operator>(</operator><name>SQLFunctionCachePtr</name><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Switch to context in which the fcache lives.  This ensures that our
	 * tuplestore etc will have sufficient lifetime.  The sub-executor is
	 * responsible for deleting per-tuple information.  (XXX in the case of a
	 * long-lived FmgrInfo, this policy represents more memory leakage, but
	 * it's not entirely clear where to keep stuff instead.)
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>fcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find first unfinished query in function, and note whether it's the
	 * first query.
	 */</comment>
	<expr_stmt><expr><name>eslist</name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>func_state</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>es</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>is_first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>eslc</argument>, <argument>eslist</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>es</name> <operator>=</operator> <operator>(</operator><name>execution_state</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>eslc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><name>es</name> <operator>&amp;&amp;</operator> <name><name>es</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>F_EXEC_DONE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>is_first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>es</name> <operator>=</operator> <name><name>es</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		</block_content>}</block></while>

		<if_stmt><if>if <condition>(<expr><name>es</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Convert params to appropriate format if starting a fresh execution. (If
	 * continuing execution, we can re-use prior params.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_first</name> <operator>&amp;&amp;</operator> <name>es</name> <operator>&amp;&amp;</operator> <name><name>es</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>F_EXEC_START</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>postquel_sub_params</name><argument_list>(<argument><expr><name>fcache</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build tuplestore to hold results, if we don't have one already. Note
	 * it's in the query-lifespan context.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>randomAccess</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Execute each command in the function one after another until we either
	 * run out of commands or get a result row from a lazily-evaluated SELECT.
	 *
	 * Notes about snapshot management:
	 *
	 * In a read-only function, we just use the surrounding query's snapshot.
	 *
	 * In a non-read-only function, we rely on the fact that we'll never
	 * suspend execution between queries of the function: the only reason to
	 * suspend execution before completion is if we are returning a row from a
	 * lazily-evaluated SELECT.  So, when first entering this loop, we'll
	 * either start a new query (and push a fresh snapshot) or re-establish
	 * the active snapshot from the existing query descriptor.  If we need to
	 * start a new query in a subsequent execution of the loop, either we need
	 * a fresh snapshot (and pushed_snapshot is false) or the existing
	 * snapshot is on the active stack and we can just bump its command ID.
	 */</comment>
	<expr_stmt><expr><name>pushed_snapshot</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>es</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>completed</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>F_EXEC_START</name></expr>)</condition>
		<block>{<block_content>

			<comment type="block">/*
			 * If not read-only, be sure to advance the command counter for
			 * each command, so that all work to date in this transaction is
			 * visible.  Take a new snapshot if we don't have one yet,
			 * otherwise just bump the command ID in the existing snapshot.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcache</name><operator>-&gt;</operator><name>readonly_func</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pushed_snapshot</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>pushed_snapshot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>UpdateActiveSnapshotCommandId</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>postquel_start</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><name>fcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>fcache</name><operator>-&gt;</operator><name>readonly_func</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pushed_snapshot</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Re-establish active snapshot when re-entering function */</comment>
			<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>qd</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pushed_snapshot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>completed</name> <operator>=</operator> <call><name>postquel_getnext</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><name>fcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we ran the command to completion, we can shut it down now. Any
		 * row(s) we need to return are safely stashed in the tuplestore, and
		 * we want to be sure that, for example, AFTER triggers get fired
		 * before we return anything.  Also, if the function doesn't return
		 * set, we can shut it down anyway because it must be a SELECT and we
		 * don't care about fetching any more result rows.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>completed</name> <operator>||</operator> <operator>!</operator><name><name>fcache</name><operator>-&gt;</operator><name>returnsSet</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>postquel_end</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Break from loop if we didn't shut down (implying we got a
		 * lazily-evaluated row).  Otherwise we'll press on till the whole
		 * function is done, relying on the tuplestore to keep hold of the
		 * data to eventually be returned.  This is necessary since an
		 * INSERT/UPDATE/DELETE RETURNING that sets the result might be
		 * followed by additional rule-inserted commands, and we want to
		 * finish doing all those commands before we return anything.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>F_EXEC_DONE</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Advance to next execution_state, which might be in the next list.
		 */</comment>
		<expr_stmt><expr><name>es</name> <operator>=</operator> <name><name>es</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>!</operator><name>es</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>eslc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>eslist</name></expr></argument>, <argument><expr><name>eslc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eslc</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* end of function */</comment>

			<expr_stmt><expr><name>es</name> <operator>=</operator> <operator>(</operator><name>execution_state</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>eslc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Flush the current snapshot so that we will take a new one for
			 * the new query list.  This ensures that new snaps are taken at
			 * original-query boundaries, matching the behavior of interactive
			 * execution.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>pushed_snapshot</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pushed_snapshot</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></while>

	<comment type="block">/*
	 * The tuplestore now contains whatever row(s) we are supposed to return.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>returnsSet</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>es</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we stopped short of being done, we must have a lazy-eval
			 * row.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>lazyEval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Re-use the junkfilter's output slot to fetch back the tuple */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name><operator>-&gt;</operator><name>jf_resultSlot</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to fetch lazy-eval tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* Extract the result as a datum, and copy out from the slot */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>postquel_get_single_result</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>,
												<argument><expr><name>fcache</name></expr></argument>, <argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Clear the tuplestore, but keep it for next time */</comment>
			<comment type="block">/* NB: this might delete the slot's content, but we don't care */</comment>
			<expr_stmt><expr><call><name>tuplestore_clear</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Let caller know we're not finished.
			 */</comment>
			<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>isDone</name></name> <operator>=</operator> <name>ExprMultipleResult</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Ensure we will get shut down cleanly if the exprcontext is not
			 * run to completion.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcache</name><operator>-&gt;</operator><name>shutdown_reg</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>RegisterExprContextCallback</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>econtext</name></name></expr></argument>,
											<argument><expr><name>ShutdownSQLFunction</name></expr></argument>,
											<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>fcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>shutdown_reg</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>lazyEval</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We are done with a lazy evaluation.  Clean up.
			 */</comment>
			<expr_stmt><expr><call><name>tuplestore_clear</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Let caller know we're finished.
			 */</comment>
			<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>isDone</name></name> <operator>=</operator> <name>ExprEndResult</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/* Deregister shutdown callback, if we made one */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>shutdown_reg</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>UnregisterExprContextCallback</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>econtext</name></name></expr></argument>,
											  <argument><expr><name>ShutdownSQLFunction</name></expr></argument>,
											  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>fcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>shutdown_reg</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We are done with a non-lazy evaluation.  Return whatever is in
			 * the tuplestore.  (It is now caller's responsibility to free the
			 * tuplestore when done.)
			 */</comment>
			<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<comment type="block">/* must copy desc because execSRF.c will free it */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name><operator>-&gt;</operator><name>jf_cleanTupType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/* Deregister shutdown callback, if we made one */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>shutdown_reg</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>UnregisterExprContextCallback</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>econtext</name></name></expr></argument>,
											  <argument><expr><name>ShutdownSQLFunction</name></expr></argument>,
											  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>fcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>shutdown_reg</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Non-set function.  If we got a row, return it; else return NULL.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Re-use the junkfilter's output slot to fetch back the tuple */</comment>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>junkFilter</name><operator>-&gt;</operator><name>jf_resultSlot</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>postquel_get_single_result</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>,
													<argument><expr><name>fcache</name></expr></argument>, <argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Should only get here for VOID functions and procedures */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>rettype</name></name> <operator>==</operator> <name>VOIDOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Clear the tuplestore, but keep it for next time */</comment>
		<expr_stmt><expr><call><name>tuplestore_clear</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>tstore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Pop snapshot if we have pushed one */</comment>
	<if_stmt><if>if <condition>(<expr><name>pushed_snapshot</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we've gone through every command in the function, we are done. Reset
	 * the execution states to start over again on next call.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>es</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>eslc</argument>, <argument>fcache-&gt;func_state</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>es</name> <operator>=</operator> <operator>(</operator><name>execution_state</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>eslc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>es</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>F_EXEC_START</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>es</name> <operator>=</operator> <name><name>es</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>sqlerrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * error context callback to let us supply a call-stack traceback
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sql_exec_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>flinfo</name> <init>= <expr><operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SQLFunctionCachePtr</name></type> <name>fcache</name> <init>= <expr><operator>(</operator><name>SQLFunctionCachePtr</name><operator>)</operator> <name><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>syntaxerrposition</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We can do nothing useful if init_sql_fcache() didn't get as far as
	 * saving the function name
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fcache</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>fcache</name><operator>-&gt;</operator><name>fname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If there is a syntax error position, convert to internal syntax error
	 */</comment>
	<expr_stmt><expr><name>syntaxerrposition</name> <operator>=</operator> <call><name>geterrposition</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>syntaxerrposition</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>fcache</name><operator>-&gt;</operator><name>src</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>errposition</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>internalerrposition</name><argument_list>(<argument><expr><name>syntaxerrposition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>internalerrquery</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>src</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Try to determine where in the function we failed.  If there is a query
	 * with non-null QueryDesc, finger it.  (We check this rather than looking
	 * for F_EXEC_RUN state, so that errors during ExecutorStart or
	 * ExecutorEnd are blamed on the appropriate query; see postquel_start and
	 * postquel_end.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>func_state</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>execution_state</name> <modifier>*</modifier></type><name>es</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>query_num</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>es</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>query_num</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fcache-&gt;func_state</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>es</name> <operator>=</operator> <operator>(</operator><name>execution_state</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>es</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>qd</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"SQL function \"%s\" statement %d"</literal></expr></argument>,
							   <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>, <argument><expr><name>query_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>es</name> <operator>=</operator> <name><name>es</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			</block_content>}</block></while>
			<if_stmt><if>if <condition>(<expr><name>es</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>query_num</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>es</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * couldn't identify a running query; might be function entry,
			 * function exit, or between queries.
			 */</comment>
			<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"SQL function \"%s\""</literal></expr></argument>, <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Assume we failed during init_sql_fcache().  (It's possible that the
		 * function actually has an empty body, but in that case we may as
		 * well report all errors as being "during startup".)
		 */</comment>
		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"SQL function \"%s\" during startup"</literal></expr></argument>, <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>o_proc_cache_validate_add</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>datoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>procoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>fncollation</name></decl></parameter>,
						  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>func_type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>used_for</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" should be used as B-tree %s support function "</literal>
					 <literal type="string">"in operator class used for %s "</literal>
					 <literal type="string">"of orioledb index"</literal></expr></argument>, <argument><expr><name>func_type</name></expr></argument>, <argument><expr><name>used_for</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>o_validate_function_by_oid</name><argument_list>(<argument><expr><name>procoid</name></expr></argument>, <argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>o_collect_function_by_oid</name><argument_list>(<argument><expr><name>procoid</name></expr></argument>, <argument><expr><name>fncollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>o_proc_cache_fill_finfo</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>procoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>cur_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>datoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OProc</name>	   <modifier>*</modifier></type><name>o_proc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>FmgrBuiltin</name> <modifier>*</modifier></type><name>fbp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>finfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>o_sys_cache_set_datoid_lsn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>o_proc</name> <operator>=</operator> <call><name>o_proc_cache_search</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>procoid</name></expr></argument>, <argument><expr><name>cur_lsn</name></expr></argument>,
								 <argument><expr><name><name>proc_cache</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>o_proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fbp</name> <operator>=</operator> <call><name>fmgr_isbuiltin</name><argument_list>(<argument><expr><name>procoid</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Fast path for builtin functions: don't bother consulting pg_proc
		 */</comment>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_stats</name></name> <operator>=</operator> <name>TRACK_FUNC_ALL</name></expr>;</expr_stmt>	<comment type="block">/* ie, never track */</comment>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_addr</name></name> <operator>=</operator> <name><name>fbp</name><operator>-&gt;</operator><name>func</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>o_proc</name><operator>-&gt;</operator><name>prolang</name></name> <operator>==</operator> <name>INTERNALlanguageId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fbp</name> <operator>=</operator> <call><name>fmgr_lookupByName</name><argument_list>(<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>prosrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fbp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"internal function \"%s\" is not in "</literal>
							<literal type="string">"internal lookup table"</literal></expr></argument>,
							<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>prosrc</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_stats</name></name> <operator>=</operator> <name>TRACK_FUNC_ALL</name></expr>;</expr_stmt>	<comment type="block">/* ie, never track */</comment>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_addr</name></name> <operator>=</operator> <name><name>fbp</name><operator>-&gt;</operator><name>func</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>o_proc</name><operator>-&gt;</operator><name>prolang</name></name> <operator>==</operator> <name>ClanguageId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_stats</name></name> <operator>=</operator> <name>TRACK_FUNC_PL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_addr</name></name> <operator>=</operator> <call><name>load_external_function</name><argument_list>(<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>probin</name></name></expr></argument>,
												<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>prosrc</name></name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>o_proc</name><operator>-&gt;</operator><name>prolang</name></name> <operator>==</operator> <name>SQLlanguageId</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>o_is_syscache_hooks_set</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_addr</name></name> <operator>=</operator> <name>o_fmgr_sql</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_addr</name></name> <operator>=</operator> <name>fmgr_sql</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_stats</name></name> <operator>=</operator> <name>TRACK_FUNC_PL</name></expr>;</expr_stmt>	<comment type="block">/* ie, track if ALL */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* TODO: Add another language support */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Function language is not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_oid</name></name> <operator>=</operator> <name>procoid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_nargs</name></name> <operator>=</operator> <name><name>o_proc</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_strict</name></name> <operator>=</operator> <name><name>o_proc</name><operator>-&gt;</operator><name>strict</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_retset</name></name> <operator>=</operator> <name><name>o_proc</name><operator>-&gt;</operator><name>retset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>HeapTuple</name></type>
<name>o_proc_cache_search_htup</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>procoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>cur_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>datoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_proc</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_proc</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OProc</name>	   <modifier>*</modifier></type><name>o_proc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>o_sys_cache_set_datoid_lsn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>o_proc</name> <operator>=</operator> <call><name>o_proc_cache_search</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>procoid</name></expr></argument>, <argument><expr><name>cur_lsn</name></expr></argument>, <argument><expr><name><name>proc_cache</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>o_proc</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>parameterTypes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>NameData</name></type>	<name>procname</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>parameterTypes</name> <operator>=</operator> <call><name>buildoidvector</name><argument_list>(<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>argtypes</name></name></expr></argument>, <argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>nargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>procname</name></expr></argument>, <argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_prorettype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_proargtypes</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>parameterTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_proname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>procname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_proowner</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>proowner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_prolang</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>prolang</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_prosrc</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>prosrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>o_proc</name><operator>-&gt;</operator><name>probin</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_probin</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
				<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>o_proc</name><operator>-&gt;</operator><name>probin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_proc_probin</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_proc_proallargtypes</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_proc_proargmodes</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_proc_proargnames</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_proc_proargdefaults</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_proc_protrftypes</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_proc_prosqlbody</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_proc_proconfig</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_proc_proacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
