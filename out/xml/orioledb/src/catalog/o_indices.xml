<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/catalog/o_indices.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * o_indices.c
 * 		Routines for orioledb indices system tree.
 *
 * Copyright (c) 2021-2022, Oriole DB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/catalog/o_indices.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/btree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indices.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/o_indices.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/o_sys_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/o_tables.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"checkpoint/checkpoint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"recovery/recovery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tableam/descr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tuple/toast.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>orioledb_index_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>orioledb_index_description</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>orioledb_index_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><specifier>static</specifier> <name>OIndex</name> <modifier>*</modifier></type><name>make_ctid_o_index</name><parameter_list>(<parameter><decl><type><name>OTable</name> <modifier>*</modifier></type><name>table</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>BTreeDescr</name> <modifier>*</modifier></type>
<name>oIndicesGetBTreeDesc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><operator>(</operator><name>BTreeDescr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>desc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>oIndicesGetMaxChunkSize</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>max_chunk_size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>max_chunk_size</name> <operator>=</operator> <call><name>MAXALIGN_DOWN</name><argument_list>(<argument><expr><operator>(</operator><name>O_BTREE_MAX_TUPLE_SIZE</name> <operator>*</operator> <literal type="number">3</literal> <operator>-</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OIndexChunkKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>OIndexChunk</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>max_chunk_size</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>oIndicesUpdateKey</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexChunkKey</name> <modifier>*</modifier></type><name>ckey</name> <init>= <expr><operator>(</operator><name>OIndexChunkKey</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ckey</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>oIndicesGetNextKey</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexChunkKey</name> <modifier>*</modifier></type><name>ckey</name> <init>= <expr><operator>(</operator><name>OIndexChunkKey</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>OIndexChunkKey</name></type> <name>nextKey</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nextKey</name> <operator>=</operator> <operator>*</operator><name>ckey</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nextKey</name><operator>.</operator><name>oids</name><operator>.</operator><name>relnode</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nextKey</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name>nextKey</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OTuple</name></type>
<name>oIndicesCreateTuple</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexChunkKey</name> <modifier>*</modifier></type><name>ckey</name> <init>= <expr><operator>(</operator><name>OIndexChunkKey</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexChunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ckey</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <operator>(</operator><name>OIndexChunk</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>OIndexChunk</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <operator>*</operator><name>ckey</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>dataLength</name></name> <operator>=</operator> <name>length</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>chunk</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OTuple</name></type>
<name>oIndicesCreateKey</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexChunkKey</name> <modifier>*</modifier></type><name>ckey</name> <init>= <expr><operator>(</operator><name>OIndexChunkKey</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexChunkKey</name> <modifier>*</modifier></type><name>ckeyCopy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ckeyCopy</name> <operator>=</operator> <operator>(</operator><name>OIndexChunkKey</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OIndexChunkKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>ckeyCopy</name> <operator>=</operator> <operator>*</operator><name>ckey</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>ckeyCopy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Pointer</name></type>
<name>oIndicesGetTupleData</name><parameter_list>(<parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexChunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><operator>(</operator><name>OIndexChunk</name> <operator>*</operator><operator>)</operator> <name><name>tuple</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>chunk</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>oIndicesGetTupleOffset</name><parameter_list>(<parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexChunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><operator>(</operator><name>OIndexChunk</name> <operator>*</operator><operator>)</operator> <name><name>tuple</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>chunk</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>offset</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>oIndicesGetTupleDataSize</name><parameter_list>(<parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexChunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><operator>(</operator><name>OIndexChunk</name> <operator>*</operator><operator>)</operator> <name><name>tuple</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>chunk</name><operator>-&gt;</operator><name>dataLength</name></name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>ToastAPI</name></type>	<name>oIndicesToastAPI</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>getBTreeDesc</name> <operator>=</operator> <name>oIndicesGetBTreeDesc</name></expr>,
	<expr><operator>.</operator><name>getMaxChunkSize</name> <operator>=</operator> <name>oIndicesGetMaxChunkSize</name></expr>,
	<expr><operator>.</operator><name>updateKey</name> <operator>=</operator> <name>oIndicesUpdateKey</name></expr>,
	<expr><operator>.</operator><name>getNextKey</name> <operator>=</operator> <name>oIndicesGetNextKey</name></expr>,
	<expr><operator>.</operator><name>createTuple</name> <operator>=</operator> <name>oIndicesCreateTuple</name></expr>,
	<expr><operator>.</operator><name>createKey</name> <operator>=</operator> <name>oIndicesCreateKey</name></expr>,
	<expr><operator>.</operator><name>getTupleData</name> <operator>=</operator> <name>oIndicesGetTupleData</name></expr>,
	<expr><operator>.</operator><name>getTupleOffset</name> <operator>=</operator> <name>oIndicesGetTupleOffset</name></expr>,
	<expr><operator>.</operator><name>getTupleDataSize</name> <operator>=</operator> <name>oIndicesGetTupleDataSize</name></expr>,
	<expr><operator>.</operator><name>deleteLogFullTuple</name> <operator>=</operator> <name>true</name></expr>,
	<expr><operator>.</operator><name>versionCallback</name> <operator>=</operator> <name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_builtin_field</name><parameter_list>(<parameter><decl><type><name>OTableField</name> <modifier>*</modifier></type><name>leafField</name></decl></parameter>, <parameter><decl><type><name>OTableIndexField</name> <modifier>*</modifier></type><name>internalField</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opclass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>leafField</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>leafField</name> <operator>=</operator> <operator>*</operator><call><name>o_tables_get_builtin_field</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leafField</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>internalField</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>internalField</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>internalField</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>internalField</name><operator>-&gt;</operator><name>opclass</name></name> <operator>=</operator> <name>opclass</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>internalField</name><operator>-&gt;</operator><name>ordering</name></name> <operator>=</operator> <name>SORTBY_ASC</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OIndex</name> <modifier>*</modifier></type>
<name>make_ctid_o_index</name><parameter_list>(<parameter><decl><type><name>OTable</name> <modifier>*</modifier></type><name>table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndex</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>OIndex</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OIndex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>table</name><operator>-&gt;</operator><name>has_primary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>indexOids</name></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>oids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>indexType</name></name> <operator>=</operator> <name>oIndexPrimary</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"ctid_primary"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>tableOids</name></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>oids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>primaryIsCtid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>compress</name></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>primary_compress</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nLeafFields</name></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>nfields</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nNonLeafFields</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nPrimaryFields</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nKeyFields</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>nUniqueFields</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>nNonLeafFields</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>leafFields</name></name> <operator>=</operator> <operator>(</operator><name>OTableField</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OTableField</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
												 <name><name>result</name><operator>-&gt;</operator><name>nLeafFields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nonLeafFields</name></name> <operator>=</operator> <operator>(</operator><name>OTableIndexField</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OTableIndexField</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
														 <name><name>result</name><operator>-&gt;</operator><name>nNonLeafFields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>make_builtin_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>leafFields</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>nonLeafFields</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					   <argument><expr><name>TIDOID</name></expr></argument>, <argument><expr><literal type="string">"ctid"</literal></expr></argument>, <argument><expr><name>SelfItemPointerAttributeNumber</name></expr></argument>,
					   <argument><expr><name><name>table</name><operator>-&gt;</operator><name>tid_btree_ops_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>table</name><operator>-&gt;</operator><name>nfields</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>leafFields</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>find_existing_field</name><parameter_list>(<parameter><decl><type><name>OIndex</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxIndex</name></decl></parameter>, <parameter><decl><type><name>OTableIndexField</name> <modifier>*</modifier></type><name>field</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>maxIndex</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>field</name><operator>-&gt;</operator><name>attnum</name></name> <operator>!=</operator> <name>EXPR_ATTNUM</name> <operator>&amp;&amp;</operator>
			<name><name>field</name><operator>-&gt;</operator><name>attnum</name></name> <operator>==</operator> <name><name>index</name><operator>-&gt;</operator><name>nonLeafFields</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>attnum</name> <operator>&amp;&amp;</operator>
			<name><name>field</name><operator>-&gt;</operator><name>opclass</name></name> <operator>==</operator> <name><name>index</name><operator>-&gt;</operator><name>nonLeafFields</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>opclass</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>i</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OIndex</name> <modifier>*</modifier></type>
<name>make_primary_o_index</name><parameter_list>(<parameter><decl><type><name>OTable</name> <modifier>*</modifier></type><name>table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTableIndex</name> <modifier>*</modifier></type><name>tableIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndex</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>OIndex</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OIndex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>has_primary</name></name> <operator>&amp;&amp;</operator> <name><name>table</name><operator>-&gt;</operator><name>nindices</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tableIndex</name> <operator>=</operator> <operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>indices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>indexOids</name></name> <operator>=</operator> <name><name>tableIndex</name><operator>-&gt;</operator><name>oids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>indexType</name></name> <operator>=</operator> <name>oIndexPrimary</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tableIndex</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tableIndex</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>oIndexPrimary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>tableOids</name></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>oids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>primaryIsCtid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OCompressIsValid</name><argument_list>(<argument><expr><name><name>tableIndex</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>compress</name></name> <operator>=</operator> <name><name>tableIndex</name><operator>-&gt;</operator><name>compress</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>compress</name></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>primary_compress</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nLeafFields</name></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>nfields</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nNonLeafFields</name></name> <operator>=</operator> <name><name>tableIndex</name><operator>-&gt;</operator><name>nfields</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nPrimaryFields</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>leafFields</name></name> <operator>=</operator> <operator>(</operator><name>OTableField</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OTableField</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
												 <name><name>result</name><operator>-&gt;</operator><name>nLeafFields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nonLeafFields</name></name> <operator>=</operator> <operator>(</operator><name>OTableIndexField</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OTableIndexField</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
														 <name><name>result</name><operator>-&gt;</operator><name>nNonLeafFields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>result</name><operator>-&gt;</operator><name>nLeafFields</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>leafFields</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>result</name><operator>-&gt;</operator><name>nNonLeafFields</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>find_existing_field</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tableIndex</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nonLeafFields</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>tableIndex</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>j</name> <operator>&lt;=</operator> <name><name>result</name><operator>-&gt;</operator><name>nNonLeafFields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nKeyFields</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>nUniqueFields</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>nNonLeafFields</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_index_fields</name><parameter_list>(<parameter><decl><type><name>OIndex</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>OTable</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>OTableIndex</name> <modifier>*</modifier></type><name>tableIndex</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>j</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>fillPrimary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>expr_field</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tableIndex</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fillPrimary</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mcxt</name> <init>= <expr><call><name>OGetIndexContext</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_mcxt</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mcxt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>predicate</name></name> <operator>=</operator> <call><name>list_copy_deep</name><argument_list>(<argument><expr><name><name>tableIndex</name><operator>-&gt;</operator><name>predicate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>predicate</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>predicate_str</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>tableIndex</name><operator>-&gt;</operator><name>predicate_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>expressions</name></name> <operator>=</operator> <call><name>list_copy_deep</name><argument_list>(<argument><expr><name><name>tableIndex</name><operator>-&gt;</operator><name>expressions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_mcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tableIndex</name><operator>-&gt;</operator><name>nfields</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>tableIndex</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>attnum</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>k</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>find_existing_field</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><operator>*</operator><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tableIndex</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>primaryFieldsAttnums</name><index>[<expr><name><name>index</name><operator>-&gt;</operator><name>nPrimaryFields</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>k</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>!=</operator> <name>EXPR_ATTNUM</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>leafFields</name><index>[<expr><operator>*</operator><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>leafFields</name><index>[<expr><operator>*</operator><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>tableIndex</name><operator>-&gt;</operator><name>exprfields</name><index>[<expr><name>expr_field</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>leafFields</name><index>[<expr><operator>*</operator><name>j</name></expr>]</index></name><operator>.</operator><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>nonLeafFields</name><index>[<expr><operator>*</operator><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>tableIndex</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>fillPrimary</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>primaryFieldsAttnums</name><index>[<expr><name><name>index</name><operator>-&gt;</operator><name>nPrimaryFields</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>j</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>make_builtin_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>index</name><operator>-&gt;</operator><name>leafFields</name><index>[<expr><operator>*</operator><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>index</name><operator>-&gt;</operator><name>nonLeafFields</name><index>[<expr><operator>*</operator><name>j</name></expr>]</index></name></expr></argument>,
						   <argument><expr><name>TIDOID</name></expr></argument>, <argument><expr><literal type="string">"ctid"</literal></expr></argument>, <argument><expr><name>SelfItemPointerAttributeNumber</name></expr></argument>,
						   <argument><expr><name><name>table</name><operator>-&gt;</operator><name>tid_btree_ops_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fillPrimary</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>primaryFieldsAttnums</name><index>[<expr><name><name>index</name><operator>-&gt;</operator><name>nPrimaryFields</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>j</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OIndex</name> <modifier>*</modifier></type>
<name>make_secondary_o_index</name><parameter_list>(<parameter><decl><type><name>OTable</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>OTableIndex</name> <modifier>*</modifier></type><name>tableIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTableIndex</name> <modifier>*</modifier></type><name>primary</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndex</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>OIndex</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OIndex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>table</name><operator>-&gt;</operator><name>has_primary</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>primary</name> <operator>=</operator> <operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>indices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>primary</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>oIndexPrimary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>indexOids</name></name> <operator>=</operator> <name><name>tableIndex</name><operator>-&gt;</operator><name>oids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>indexType</name></name> <operator>=</operator> <name><name>tableIndex</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tableIndex</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>tableOids</name></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>oids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>primaryIsCtid</name></name> <operator>=</operator> <operator>!</operator><name><name>table</name><operator>-&gt;</operator><name>has_primary</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>compress</name></name> <operator>=</operator> <name><name>tableIndex</name><operator>-&gt;</operator><name>compress</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nLeafFields</name></name> <operator>=</operator> <name><name>tableIndex</name><operator>-&gt;</operator><name>nfields</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>table</name><operator>-&gt;</operator><name>has_primary</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nLeafFields</name></name> <operator>+=</operator> <name><name>primary</name><operator>-&gt;</operator><name>nfields</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nLeafFields</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nNonLeafFields</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>nLeafFields</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>leafFields</name></name> <operator>=</operator> <operator>(</operator><name>OTableField</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OTableField</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
												 <name><name>result</name><operator>-&gt;</operator><name>nLeafFields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nonLeafFields</name></name> <operator>=</operator> <operator>(</operator><name>OTableIndexField</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OTableIndexField</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
														 <name><name>result</name><operator>-&gt;</operator><name>nNonLeafFields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_index_fields</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>tableIndex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>j</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>j</name> <operator>&lt;=</operator> <name><name>tableIndex</name><operator>-&gt;</operator><name>nfields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nKeyFields</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_index_fields</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>primary</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>j</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>j</name> <operator>&lt;=</operator> <name><name>result</name><operator>-&gt;</operator><name>nLeafFields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nLeafFields</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>nNonLeafFields</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tableIndex</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>oIndexUnique</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nUniqueFields</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>nKeyFields</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nUniqueFields</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>nNonLeafFields</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OIndex</name> <modifier>*</modifier></type>
<name>make_toast_o_index</name><parameter_list>(<parameter><decl><type><name>OTable</name> <modifier>*</modifier></type><name>table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTableIndex</name> <modifier>*</modifier></type><name>primary</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndex</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>OIndex</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OIndex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>table</name><operator>-&gt;</operator><name>has_primary</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>primary</name> <operator>=</operator> <operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>indices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>primary</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>oIndexPrimary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>indexOids</name></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>toast_oids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>indexType</name></name> <operator>=</operator> <name>oIndexToast</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"toast"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>tableOids</name></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>oids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>primaryIsCtid</name></name> <operator>=</operator> <operator>!</operator><name><name>table</name><operator>-&gt;</operator><name>has_primary</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>compress</name></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>toast_compress</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>table</name><operator>-&gt;</operator><name>has_primary</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nLeafFields</name></name> <operator>=</operator> <name><name>primary</name><operator>-&gt;</operator><name>nfields</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nNonLeafFields</name></name> <operator>=</operator> <name><name>primary</name><operator>-&gt;</operator><name>nfields</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nLeafFields</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nNonLeafFields</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nLeafFields</name></name> <operator>+=</operator> <name>TOAST_LEAF_FIELDS_NUM</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nNonLeafFields</name></name> <operator>+=</operator> <name>TOAST_NON_LEAF_FIELDS_NUM</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>leafFields</name></name> <operator>=</operator> <operator>(</operator><name>OTableField</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OTableField</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
												 <name><name>result</name><operator>-&gt;</operator><name>nLeafFields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nonLeafFields</name></name> <operator>=</operator> <operator>(</operator><name>OTableIndexField</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OTableIndexField</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
														 <name><name>result</name><operator>-&gt;</operator><name>nNonLeafFields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_index_fields</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>primary</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>j</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_builtin_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>leafFields</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>nonLeafFields</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
					   <argument><expr><name>INT2OID</name></expr></argument>, <argument><expr><literal type="string">"attnum"</literal></expr></argument>, <argument><expr><name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
					   <argument><expr><name>INT2_BTREE_OPS_OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_builtin_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>leafFields</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>nonLeafFields</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
					   <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
					   <argument><expr><name>INT4_BTREE_OPS_OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>j</name> <operator>&lt;=</operator> <name><name>result</name><operator>-&gt;</operator><name>nNonLeafFields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nNonLeafFields</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_builtin_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>leafFields</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					   <argument><expr><name>BYTEAOID</name></expr></argument>, <argument><expr><literal type="string">"data"</literal></expr></argument>, <argument><expr><name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
					   <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>j</name> <operator>&lt;=</operator> <name><name>result</name><operator>-&gt;</operator><name>nLeafFields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nLeafFields</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nKeyFields</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>nUniqueFields</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>nNonLeafFields</name></name></expr>;</expr_stmt>


	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>free_o_index</name><parameter_list>(<parameter><decl><type><name>OIndex</name> <modifier>*</modifier></type><name>o_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>o_index</name><operator>-&gt;</operator><name>leafFields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>o_index</name><operator>-&gt;</operator><name>nonLeafFields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>o_index</name><operator>-&gt;</operator><name>index_mctx</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>o_index</name><operator>-&gt;</operator><name>index_mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>o_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>o_serialize_string</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>serialized</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>str_len</name> <init>= <expr><ternary><condition><expr><name>serialized</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>serialized</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>str_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>serialized</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>serialized</name></expr></argument>, <argument><expr><name>str_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>o_deserialize_string</name><parameter_list>(<parameter><decl><type><name>Pointer</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>str_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str_len</name></expr></argument>, <argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>str_len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <name>str_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>o_serialize_node</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>node_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>node_str_len</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>node_str</name> <operator>=</operator> <call><name>nodeToString</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>node_str_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>node_str</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>node_str_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>node_str</name></expr></argument>, <argument><expr><name>node_str_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>node_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Node</name> <modifier>*</modifier></type>
<name>o_deserialize_node</name><parameter_list>(<parameter><decl><type><name>Pointer</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>node_str_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>node_str_len</name></expr></argument>, <argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>node_str_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Pointer</name></type>
<name>serialize_o_index</name><parameter_list>(<parameter><decl><type><name>OIndex</name> <modifier>*</modifier></type><name>o_index</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
						   <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>o_index</name> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>OIndex</name></expr></argument>, <argument><expr><name>tableOids</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>OIndex</name></expr></argument>, <argument><expr><name>leafFields</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>OIndex</name></expr></argument>, <argument><expr><name>tableOids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name><name>o_index</name><operator>-&gt;</operator><name>leafFields</name></name></expr></argument>,
						   <argument><expr><name><name>o_index</name><operator>-&gt;</operator><name>nLeafFields</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>o_index</name><operator>-&gt;</operator><name>leafFields</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name><name>o_index</name><operator>-&gt;</operator><name>nonLeafFields</name></name></expr></argument>,
						   <argument><expr><name><name>o_index</name><operator>-&gt;</operator><name>nNonLeafFields</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>o_index</name><operator>-&gt;</operator><name>nonLeafFields</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>o_serialize_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>o_index</name><operator>-&gt;</operator><name>predicate</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>o_index</name><operator>-&gt;</operator><name>predicate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>o_serialize_string</name><argument_list>(<argument><expr><name><name>o_index</name><operator>-&gt;</operator><name>predicate_str</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>o_serialize_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>o_index</name><operator>-&gt;</operator><name>expressions</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name><name>str</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
	<return>return <expr><name><name>str</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OIndex</name> <modifier>*</modifier></type>
<name>deserialize_o_index</name><parameter_list>(<parameter><decl><type><name>OIndexChunkKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>ptr</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndex</name>	   <modifier>*</modifier></type><name>oIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl>,
				<decl><type ref="prev"/><name>old_mcxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oIndex</name> <operator>=</operator> <operator>(</operator><name>OIndex</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OIndex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oIndex</name><operator>-&gt;</operator><name>indexOids</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>oids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oIndex</name><operator>-&gt;</operator><name>indexType</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>OIndex</name></expr></argument>, <argument><expr><name>leafFields</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>OIndex</name></expr></argument>, <argument><expr><name>tableOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ptr</name> <operator>-</operator> <name>data</name><operator>)</operator> <operator>+</operator> <name>len</name> <operator>&lt;=</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>oIndex</name> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>OIndex</name></expr></argument>, <argument><expr><name>tableOids</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>oIndex</name><operator>-&gt;</operator><name>nLeafFields</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OTableField</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oIndex</name><operator>-&gt;</operator><name>leafFields</name></name> <operator>=</operator> <operator>(</operator><name>OTableField</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ptr</name> <operator>-</operator> <name>data</name><operator>)</operator> <operator>+</operator> <name>len</name> <operator>&lt;=</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>oIndex</name><operator>-&gt;</operator><name>leafFields</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>oIndex</name><operator>-&gt;</operator><name>nNonLeafFields</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OTableIndexField</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oIndex</name><operator>-&gt;</operator><name>nonLeafFields</name></name> <operator>=</operator> <operator>(</operator><name>OTableIndexField</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ptr</name> <operator>-</operator> <name>data</name><operator>)</operator> <operator>+</operator> <name>len</name> <operator>&lt;=</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>oIndex</name><operator>-&gt;</operator><name>nonLeafFields</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>mcxt</name> <operator>=</operator> <call><name>OGetIndexContext</name><argument_list>(<argument><expr><name>oIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_mcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oIndex</name><operator>-&gt;</operator><name>predicate</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>o_deserialize_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>oIndex</name><operator>-&gt;</operator><name>predicate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>oIndex</name><operator>-&gt;</operator><name>predicate_str</name></name> <operator>=</operator> <call><name>o_deserialize_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>oIndex</name><operator>-&gt;</operator><name>expressions</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>o_deserialize_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_mcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ptr</name> <operator>-</operator> <name>data</name><operator>)</operator> <operator>==</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>oIndex</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>OIndex</name> <modifier>*</modifier></type>
<name>make_o_index</name><parameter_list>(<parameter><decl><type><name>OTable</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>OIndexNumber</name></type> <name>ixNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>primaryIsCtid</name> <init>= <expr><name><name>table</name><operator>-&gt;</operator><name>nindices</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>table</name><operator>-&gt;</operator><name>indices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>type</name> <operator>!=</operator> <name>oIndexPrimary</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndex</name>	   <modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ixNum</name> <operator>==</operator> <name>PrimaryIndexNumber</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>primaryIsCtid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>make_ctid_o_index</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>make_primary_o_index</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>ixNum</name> <operator>==</operator> <name>TOASTIndexNumber</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>make_toast_o_index</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTableIndex</name> <modifier>*</modifier></type><name>tableIndex</name> <init>= <expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>ixNum</name> <operator>-</operator> <operator>(</operator><ternary><condition><expr><name>primaryIsCtid</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>make_secondary_o_index</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>tableIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>index</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>fillFixedFormatSpec</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>OTupleFixedFormatSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>mayHaveToast</name></decl></parameter>, <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>primary_init_nfields</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>primary_init_nfields</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>natts</name> <operator>=</operator> <operator>*</operator><name>primary_init_nfields</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>natts</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>o_index_fill_descr</name><parameter_list>(<parameter><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>OIndex</name> <modifier>*</modifier></type><name>oIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxTableAttnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name>	   <modifier>*</modifier></type><name>primary_init_nfields</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl>,
				<decl><type ref="prev"/><name>old_mcxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>descr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>oids</name></name> <operator>=</operator> <name><name>oIndex</name><operator>-&gt;</operator><name>indexOids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>tableOids</name></name> <operator>=</operator> <name><name>oIndex</name><operator>-&gt;</operator><name>tableOids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>refcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>oIndex</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>leafTupdesc</name></name> <operator>=</operator> <call><name>o_table_fields_make_tupdesc</name><argument_list>(<argument><expr><name><name>oIndex</name><operator>-&gt;</operator><name>leafFields</name></name></expr></argument>,
													 <argument><expr><name><name>oIndex</name><operator>-&gt;</operator><name>nLeafFields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>oIndex</name><operator>-&gt;</operator><name>indexType</name></name> <operator>==</operator> <name>oIndexPrimary</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTable</name>	   <modifier>*</modifier></type><name>o_table</name> <init>= <expr><call><name>o_tables_get</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>tableOids</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>o_table</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>o_tupdesc_load_constr</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>leafTupdesc</name></name></expr></argument>, <argument><expr><name>o_table</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>primary_init_nfields</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>primary_init_nfields</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>primary_init_nfields</name> <operator>=</operator> <name><name>o_table</name><operator>-&gt;</operator><name>primary_init_nfields</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>o_table_free</name><argument_list>(<argument><expr><name>o_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>oIndex</name><operator>-&gt;</operator><name>indexType</name></name> <operator>==</operator> <name>oIndexPrimary</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>nonLeafTupdesc</name></name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name><name>oIndex</name><operator>-&gt;</operator><name>nNonLeafFields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>oIndex</name><operator>-&gt;</operator><name>primaryIsCtid</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>oIndex</name><operator>-&gt;</operator><name>nNonLeafFields</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>oIndex</name><operator>-&gt;</operator><name>nonLeafFields</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>attnum</name> <operator>==</operator> <name>SelfItemPointerAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TupleDescCopyEntry</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>nonLeafTupdesc</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
							   <argument><expr><name><name>descr</name><operator>-&gt;</operator><name>leafTupdesc</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>oIndex</name><operator>-&gt;</operator><name>nNonLeafFields</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>oIndex</name><operator>-&gt;</operator><name>nonLeafFields</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>attnum</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>&lt;</operator> <name><name>oIndex</name><operator>-&gt;</operator><name>nLeafFields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>TupleDescCopyEntry</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>nonLeafTupdesc</name></name></expr></argument>,
								   <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								   <argument><expr><name><name>descr</name><operator>-&gt;</operator><name>leafTupdesc</name></name></expr></argument>,
								   <argument><expr><name>attnum</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>oIndex</name><operator>-&gt;</operator><name>indexType</name></name> <operator>==</operator> <name>oIndexRegular</name> <operator>||</operator>
			 <name><name>oIndex</name><operator>-&gt;</operator><name>indexType</name></name> <operator>==</operator> <name>oIndexUnique</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>oIndex</name><operator>-&gt;</operator><name>nNonLeafFields</name></name> <operator>==</operator> <name><name>oIndex</name><operator>-&gt;</operator><name>nLeafFields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>nonLeafTupdesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>leafTupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>oIndex</name><operator>-&gt;</operator><name>indexType</name></name> <operator>==</operator> <name>oIndexToast</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>oIndex</name><operator>-&gt;</operator><name>nLeafFields</name></name> <operator>-</operator> <name>TOAST_LEAF_FIELDS_NUM</name> <operator>==</operator> <name><name>oIndex</name><operator>-&gt;</operator><name>nNonLeafFields</name></name> <operator>-</operator> <name>TOAST_NON_LEAF_FIELDS_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>nonLeafTupdesc</name></name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name><name>oIndex</name><operator>-&gt;</operator><name>nNonLeafFields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>oIndex</name><operator>-&gt;</operator><name>nNonLeafFields</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>TupleDescCopyEntry</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>nonLeafTupdesc</name></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
							   <argument><expr><name><name>descr</name><operator>-&gt;</operator><name>leafTupdesc</name></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>primaryIsCtid</name></name> <operator>=</operator> <name><name>oIndex</name><operator>-&gt;</operator><name>primaryIsCtid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>unique</name></name> <operator>=</operator> <operator>(</operator><name><name>oIndex</name><operator>-&gt;</operator><name>indexType</name></name> <operator>==</operator> <name>oIndexUnique</name> <operator>||</operator>
					 <name><name>oIndex</name><operator>-&gt;</operator><name>indexType</name></name> <operator>==</operator> <name>oIndexPrimary</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>nUniqueFields</name></name> <operator>=</operator> <name><name>oIndex</name><operator>-&gt;</operator><name>nUniqueFields</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>nFields</name></name> <operator>=</operator> <name><name>oIndex</name><operator>-&gt;</operator><name>nNonLeafFields</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>oIndex</name><operator>-&gt;</operator><name>nNonLeafFields</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OIndexField</name> <modifier>*</modifier></type><name>field</name> <init>= <expr><operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OTableIndexField</name> <modifier>*</modifier></type><name>iField</name> <init>= <expr><operator>&amp;</operator><name><name>oIndex</name><operator>-&gt;</operator><name>nonLeafFields</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>iField</name><operator>-&gt;</operator><name>attnum</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>SelfItemPointerAttributeNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>oIndex</name><operator>-&gt;</operator><name>primaryIsCtid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>attnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>attnum</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>attnum</name> <operator>!=</operator> <name>EXPR_ATTNUM</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>attnum</name> <operator>+=</operator> <ternary><condition><expr><name><name>oIndex</name><operator>-&gt;</operator><name>primaryIsCtid</name></name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>tableAttnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxTableAttnum</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>maxTableAttnum</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>nonLeafTupdesc</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcollation</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>iField</name><operator>-&gt;</operator><name>collation</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name><name>iField</name><operator>-&gt;</operator><name>collation</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>ascending</name></name> <operator>=</operator> <name><name>iField</name><operator>-&gt;</operator><name>ordering</name></name> <operator>!=</operator> <name>SORTBY_DESC</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>iField</name><operator>-&gt;</operator><name>nullsOrdering</name></name> <operator>==</operator> <name>SORTBY_NULLS_DEFAULT</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* default null ordering is LAST for ASC, FIRST for DESC */</comment>
			<expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>nullfirst</name></name> <operator>=</operator> <operator>!</operator><name><name>field</name><operator>-&gt;</operator><name>ascending</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>nullfirst</name></name> <operator>=</operator> <operator>(</operator><name><name>iField</name><operator>-&gt;</operator><name>nullsOrdering</name></name> <operator>==</operator> <name>SORTBY_NULLS_FIRST</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>oFillFieldOpClassAndComparator</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name><name>oIndex</name><operator>-&gt;</operator><name>tableOids</name><operator>.</operator><name>datoid</name></name></expr></argument>,
									   <argument><expr><name><name>iField</name><operator>-&gt;</operator><name>opclass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>mcxt</name> <operator>=</operator> <call><name>OGetIndexContext</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_mcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>predicate</name></name> <operator>=</operator> <call><name>list_copy_deep</name><argument_list>(<argument><expr><name><name>oIndex</name><operator>-&gt;</operator><name>predicate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>descr</name><operator>-&gt;</operator><name>predicate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>predicate_str</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>oIndex</name><operator>-&gt;</operator><name>predicate_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>expressions</name></name> <operator>=</operator> <call><name>list_copy_deep</name><argument_list>(<argument><expr><name><name>oIndex</name><operator>-&gt;</operator><name>expressions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>predicate_state</name></name> <operator>=</operator> <call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>predicate</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>expressions_state</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>descr-&gt;expressions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>expr_state</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>expr_state</name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>expressions_state</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>expressions_state</name></name></expr></argument>,
										   <argument><expr><name>expr_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_mcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>econtext</name></name> <operator>=</operator> <call><name>CreateStandaloneExprContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>maxTableAttnum</name></name> <operator>=</operator> <name>maxTableAttnum</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>nPrimaryFields</name></name> <operator>=</operator> <name><name>oIndex</name><operator>-&gt;</operator><name>nPrimaryFields</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>primaryFieldsAttnums</name></name></expr></argument>,
		   <argument><expr><name><name>oIndex</name><operator>-&gt;</operator><name>primaryFieldsAttnums</name></name></expr></argument>,
		   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>nPrimaryFields</name></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>primaryFieldsAttnums</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>compress</name></name> <operator>=</operator> <name><name>oIndex</name><operator>-&gt;</operator><name>compress</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fillFixedFormatSpec</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>leafTupdesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>leafSpec</name></name></expr></argument>,
						<argument><expr><operator>(</operator><name><name>oIndex</name><operator>-&gt;</operator><name>indexType</name></name> <operator>==</operator> <name>oIndexPrimary</name><operator>)</operator></expr></argument>,
						<argument><expr><name>primary_init_nfields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fillFixedFormatSpec</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>nonLeafTupdesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>nonLeafSpec</name></name></expr></argument>,
						<argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>primary_init_nfields</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>primary_init_nfields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>o_indices_add</name><parameter_list>(<parameter><decl><type><name>OTable</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>OIndexNumber</name></type> <name>ixNum</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexChunkKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndex</name>	   <modifier>*</modifier></type><name>oIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oIndex</name> <operator>=</operator> <call><name>make_o_index</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>ixNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oIndex</name><operator>-&gt;</operator><name>createOxid</name></name> <operator>=</operator> <name>oxid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>oids</name></name> <operator>=</operator> <name><name>oIndex</name><operator>-&gt;</operator><name>indexOids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>oIndex</name><operator>-&gt;</operator><name>indexType</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>serialize_o_index</name><argument_list>(<argument><expr><name>oIndex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_o_index</name><argument_list>(<argument><expr><name>oIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>generic_toast_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oIndicesToastAPI</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,
								  <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><call><name>get_sys_tree</name><argument_list>(<argument><expr><name>SYS_TREES_O_INDICES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>o_indices_del</name><parameter_list>(<parameter><decl><type><name>OTable</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>OIndexNumber</name></type> <name>ixNum</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexChunkKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndex</name>	   <modifier>*</modifier></type><name>oIndex</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oIndex</name> <operator>=</operator> <call><name>make_o_index</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>ixNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>oids</name></name> <operator>=</operator> <name><name>oIndex</name><operator>-&gt;</operator><name>indexOids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>oIndex</name><operator>-&gt;</operator><name>indexType</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_o_index</name><argument_list>(<argument><expr><name>oIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>generic_toast_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oIndicesToastAPI</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>,
								  <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><call><name>get_sys_tree</name><argument_list>(<argument><expr><name>SYS_TREES_O_INDICES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>OIndex</name> <modifier>*</modifier></type>
<name>o_indices_get</name><parameter_list>(<parameter><decl><type><name>ORelOids</name></type> <name>oids</name></decl></parameter>, <parameter><decl><type><name>OIndexType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexChunkKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>dataLength</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndex</name>	   <modifier>*</modifier></type><name>oIndex</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>oids</name></name> <operator>=</operator> <name>oids</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>generic_toast_get_any</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oIndicesToastAPI</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>dataLength</name></expr></argument>, <argument><expr><name>COMMITSEQNO_NON_DELETED</name></expr></argument>,
								   <argument><expr><call><name>get_sys_tree</name><argument_list>(<argument><expr><name>SYS_TREES_O_INDICES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oIndex</name> <operator>=</operator> <call><name>deserialize_o_index</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>dataLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>oIndex</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>o_indices_update</name><parameter_list>(<parameter><decl><type><name>OTable</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>OIndexNumber</name></type> <name>ixNum</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndex</name>	   <modifier>*</modifier></type><name>oIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexChunkKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oIndex</name> <operator>=</operator> <call><name>make_o_index</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>ixNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>serialize_o_index</name><argument_list>(<argument><expr><name>oIndex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>oids</name></name> <operator>=</operator> <name><name>oIndex</name><operator>-&gt;</operator><name>indexOids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>oIndex</name><operator>-&gt;</operator><name>indexType</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_o_index</name><argument_list>(<argument><expr><name>oIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systrees_modify_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>generic_toast_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oIndicesToastAPI</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,
								  <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><call><name>get_sys_tree</name><argument_list>(<argument><expr><name>SYS_TREES_O_INDICES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>systrees_modify_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>o_indices_find_table_oids</name><parameter_list>(<parameter><decl><type><name>ORelOids</name></type> <name>indexOids</name></decl></parameter>, <parameter><decl><type><name>OIndexType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>,
						  <parameter><decl><type><name>ORelOids</name> <modifier>*</modifier></type><name>tableOids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexChunkKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>dataSize</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>oids</name></name> <operator>=</operator> <name>indexOids</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>generic_toast_get_any</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oIndicesToastAPI</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dataSize</name></expr></argument>,
								 <argument><expr><name>csn</name></expr></argument>, <argument><expr><call><name>get_sys_tree</name><argument_list>(<argument><expr><name>SYS_TREES_O_INDICES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tableOids</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ORelOids</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>o_indices_foreach_oids</name><parameter_list>(<parameter><decl><type><name>OIndexOidsCallback</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexChunkKey</name></type> <name>chunkKey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ORelOids</name></type>	<name>oids</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>,
				<decl><type ref="prev"/><name>old_oids</name> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexType</name></type>	<name>type</name> <init>= <expr><name>oIndexInvalid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><call><name>get_sys_tree</name><argument_list>(<argument><expr><name>SYS_TREES_O_INDICES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>chunkKey</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkKey</name><operator>.</operator><name>oids</name></name> <operator>=</operator> <name>oids</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkKey</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>o_btree_iterator_create</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>chunkKey</name></expr></argument>, <argument><expr><name>BTreeKeyBound</name></expr></argument>,
								 <argument><expr><name>COMMITSEQNO_NON_DELETED</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>o_btree_iterator_fetch</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name>BTreeKeyNone</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_oids</name> <operator>=</operator> <name>oids</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OIndexChunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><operator>(</operator><name>OIndexChunk</name> <operator>*</operator><operator>)</operator> <name><name>tuple</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ORelOids</name></type>	<name>tableOids</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>oids</name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>oids</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>dataLength</name></name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tableOids</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tableOids</name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tableOids</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>offset</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ORelOidsIsValid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ORelOidsIsEqual</name><argument_list>(<argument><expr><name>old_oids</name></expr></argument>, <argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>old_oids</name> <operator>=</operator> <name>oids</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>callback</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>oids</name></expr></argument>, <argument><expr><name>tableOids</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>tuple</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>btree_iterator_free</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>oids</name><operator>.</operator><name>relnode</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>		<comment type="block">/* go to the next oid */</comment>
		<expr_stmt><expr><name><name>chunkKey</name><operator>.</operator><name>oids</name></name> <operator>=</operator> <name>oids</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>chunkKey</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>chunkKey</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>o_btree_iterator_create</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>chunkKey</name></expr></argument>, <argument><expr><name>BTreeKeyBound</name></expr></argument>,
									 <argument><expr><name>COMMITSEQNO_NON_DELETED</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>o_btree_iterator_fetch</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									   <argument><expr><name>BTreeKeyNone</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>index_type_to_str</name><parameter_list>(<parameter><decl><type><name>OIndexType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>oIndexToast</name></expr>:</case>
			<return>return <expr><literal type="string">"toast"</literal></expr>;</return>
		<case>case <expr><name>oIndexPrimary</name></expr>:</case>
			<return>return <expr><literal type="string">"primary"</literal></expr>;</return>
		<case>case <expr><name>oIndexUnique</name></expr>:</case>
			<return>return <expr><literal type="string">"unique"</literal></expr>;</return>
		<case>case <expr><name>oIndexRegular</name></expr>:</case>
			<return>return <expr><literal type="string">"regural"</literal></expr>;</return>
		<default>default:</default>
			<return>return <expr><literal type="string">"invalid"</literal></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OIndexType</name></type>
<name>index_type_from_str</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"toast"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>oIndexToast</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"primary"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>oIndexPrimary</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"unique"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>oIndexUnique</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"regural"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>oIndexRegular</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>oIndexInvalid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>o_index_oids_array_callback</name><parameter_list>(<parameter><decl><type><name>OIndexType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>ORelOids</name></type> <name>treeOids</name></decl></parameter>,
							<parameter><decl><type><name>ORelOids</name></type> <name>tableOids</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tableOids</name><operator>.</operator><name>datoid</name></name> <operator>==</operator> <name><name>treeOids</name><operator>.</operator><name>datoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>tableOids</name><operator>.</operator><name>datoid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>tableOids</name><operator>.</operator><name>reloid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>tableOids</name><operator>.</operator><name>relnode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>treeOids</name><operator>.</operator><name>reloid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>treeOids</name><operator>.</operator><name>relnode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><call><name>index_type_to_str</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name></expr></argument>, <argument><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>orioledb_index_oids</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build a tuple descriptor for our result type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>o_indices_foreach_oids</name><argument_list>(<argument><expr><name>o_index_oids_array_callback</name></expr></argument>, <argument><expr><name>rsinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>describe_index</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>ORelOids</name></type> <name>oids</name></decl></parameter>, <parameter><decl><type><name>OIndexType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndex</name>	   <modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>,
				<decl><type ref="prev"/><name>format</name></decl>,
				<decl><type ref="prev"/><name>title</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>column_str</name> <init>= <expr><literal type="string">"Column"</literal></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>type_str</name> <init>= <expr><literal type="string">"Type"</literal></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>collation_str</name> <init>= <expr><literal type="string">"Collation"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>max_column_str</name></decl>,
				<decl><type ref="prev"/><name>max_type_str</name></decl>,
				<decl><type ref="prev"/><name>max_collation_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>o_indices_get</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>index</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unable to find orioledb index description."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>max_column_str</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>column_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_type_str</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>type_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_collation_str</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>collation_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>index</name><operator>-&gt;</operator><name>nLeafFields</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTableField</name> <modifier>*</modifier></type><name>field</name> <init>= <expr><operator>&amp;</operator><name><name>index</name><operator>-&gt;</operator><name>leafFields</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typename</name> <init>= <expr><call><name>o_get_type_name</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>typid</name></name></expr></argument>, <argument><expr><name><name>field</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><call><name>o_get_collation_name</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>collation</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>max_column_str</name> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>max_column_str</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>max_type_str</name> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>typename</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>max_type_str</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>typename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>colname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>max_collation_str</name> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>max_collation_str</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><literal type="string">" %%%ds | %%%ds | %%%ds | Nullable | Droped \n"</literal></expr></argument>,
					 <argument><expr><name>max_column_str</name></expr></argument>,
					 <argument><expr><name>max_type_str</name></expr></argument>,
					 <argument><expr><name>max_collation_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>format</name></expr></argument>, <argument><expr><literal type="string">" %%%ds | %%%ds | %%%ds | %%8s | %%6s \n"</literal></expr></argument>,
					 <argument><expr><name>max_column_str</name></expr></argument>,
					 <argument><expr><name>max_type_str</name></expr></argument>,
					 <argument><expr><name>max_collation_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>title</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>column_str</name></expr></argument>, <argument><expr><name>type_str</name></expr></argument>, <argument><expr><name>collation_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>index</name><operator>-&gt;</operator><name>nLeafFields</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTableField</name> <modifier>*</modifier></type><name>field</name> <init>= <expr><operator>&amp;</operator><name><name>index</name><operator>-&gt;</operator><name>leafFields</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typename</name> <init>= <expr><call><name>o_get_type_name</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>typid</name></name></expr></argument>, <argument><expr><name><name>field</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><call><name>o_get_collation_name</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>collation</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>format</name><operator>.</operator><name>data</name></name></expr></argument>,
						 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>typename</name></expr></argument>,
						 <argument><expr><ternary><condition><expr><name>colname</name></expr> ?</condition><then> <expr><name>colname</name></expr> </then><else>: <expr><literal type="string">"(null)"</literal></expr></else></ternary></expr></argument>,
						 <argument><expr><ternary><condition><expr><name><name>field</name><operator>-&gt;</operator><name>notnull</name></name></expr> ?</condition><then> <expr><literal type="string">"false"</literal></expr> </then><else>: <expr><literal type="string">"true"</literal></expr></else></ternary></expr></argument>,
						 <argument><expr><ternary><condition><expr><name><name>field</name><operator>-&gt;</operator><name>droped</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nKey fields: ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>index</name><operator>-&gt;</operator><name>nNonLeafFields</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTableIndexField</name> <modifier>*</modifier></type><name>nonLeafField</name> <init>= <expr><operator>&amp;</operator><name><name>index</name><operator>-&gt;</operator><name>nonLeafFields</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OTableField</name> <modifier>*</modifier></type><name>leafField</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>oIndexPrimary</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>nonLeafField</name><operator>-&gt;</operator><name>attnum</name></name> <operator>==</operator> <name>SelfItemPointerAttributeNumber</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>primaryIsCtid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>leafField</name> <operator>=</operator> <operator>&amp;</operator><name><name>index</name><operator>-&gt;</operator><name>leafFields</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>primaryIsCtid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>leafField</name> <operator>=</operator> <operator>&amp;</operator><name><name>index</name><operator>-&gt;</operator><name>leafFields</name><index>[<expr><name><name>nonLeafField</name><operator>-&gt;</operator><name>attnum</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>leafField</name> <operator>=</operator> <operator>&amp;</operator><name><name>index</name><operator>-&gt;</operator><name>leafFields</name><index>[<expr><name><name>nonLeafField</name><operator>-&gt;</operator><name>attnum</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>leafField</name> <operator>=</operator> <operator>&amp;</operator><name><name>index</name><operator>-&gt;</operator><name>leafFields</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>leafField</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name><name>index</name><operator>-&gt;</operator><name>nUniqueFields</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>orioledb_index_description</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ORelOids</name></type>	<name>oids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>indexTypeText</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexType</name></type>	<name>indexType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>indexType</name> <operator>=</operator> <call><name>index_type_from_str</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>indexTypeText</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>indexTypeText</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oids</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oids</name><operator>.</operator><name>reloid</name></name> <operator>=</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oids</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><call><name>describe_index</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>oids</name></expr></argument>, <argument><expr><name>indexType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns amount of all rows and dead rows
 */</comment>
<function><type><name>Datum</name></type>
<name>orioledb_index_rows</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ix_reloid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>idx</name></decl>,
				<decl><type ref="prev"/><name>tbl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexNumber</name></type> <name>ix_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>dead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>td</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>ix_reloid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tbl</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>idx</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ix_num</name> <operator>=</operator> <call><name>o_find_ix_num_by_name</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name><name>idx</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ix_num</name> <operator>==</operator> <name>InvalidIndexNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>td</name> <operator>=</operator> <operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>ix_num</name></expr>]</index></name><operator>-&gt;</operator><name>desc</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build a tuple descriptor for our result type
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupleDesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>o_btree_iterator_create</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>,
								 <argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>end</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>tup</name> <init>= <expr><call><name>btree_iterate_raw</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>dead</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>total</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>true</name></expr>)</condition>;</do>

	<expr_stmt><expr><call><name>btree_iterator_free</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build and return the tuple
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>dead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
