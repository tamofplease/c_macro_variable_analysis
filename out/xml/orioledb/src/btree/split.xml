<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/btree/split.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * split.c
 *		Routines for implementation of splitting B-tree page.
 *
 * Copyright (c) 2021-2022, Oriole DB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/btree/split.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/find.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/split.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/page_chunks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"checkpoint/checkpoint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"recovery/recovery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transam/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/page_pool.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/stopevent.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>newitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>newoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>newitemSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>replace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>newitemIsCur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl>;</decl_stmt>
}</block></struct></type> <name>SplitItemIterator</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_split_item_interator</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>SplitItemIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>,
						  <parameter><decl><type><name>OTuple</name></type> <name>newitem</name></decl></parameter>, <parameter><decl><type><name>LocationIndex</name></type> <name>newitemSize</name></decl></parameter>,
						  <parameter><decl><type><name>OffsetNumber</name></type> <name>newoffset</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>replace</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>last</name></decl></parameter>,
						  <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>desc</name></name> <operator>=</operator> <name>desc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>newitem</name></name> <operator>=</operator> <name>newitem</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>newoffset</name></name> <operator>=</operator> <name>newoffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>newitemSize</name></name> <operator>=</operator> <name>newitemSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>replace</name></name> <operator>=</operator> <name>replace</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>last</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_FIRST</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>loc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>newitemIsCur</name></name> <operator>=</operator> <operator>(</operator><name><name>it</name><operator>-&gt;</operator><name>newoffset</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>count</name> <init>= <expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_LAST</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>loc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>newoffset</name></name> <operator>==</operator> <name>count</name> <operator>||</operator> <operator>(</operator><name>replace</name> <operator>&amp;&amp;</operator> <name><name>it</name><operator>-&gt;</operator><name>newoffset</name></name> <operator>==</operator> <name>count</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>newitemIsCur</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>newitemIsCur</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <name>csn</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>split_item_interator_next</name><parameter_list>(<parameter><decl><type><name>SplitItemIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>newitemIsCur</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>newitemIsCur</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>replace</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>loc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>loc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>loc</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>it</name><operator>-&gt;</operator><name>newoffset</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>newitemIsCur</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>split_item_interator_prev</name><parameter_list>(<parameter><decl><type><name>SplitItemIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>newitemIsCur</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>newitemIsCur</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_PREV</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>loc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>it</name><operator>-&gt;</operator><name>replace</name></name> <operator>&amp;&amp;</operator> <call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>loc</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>it</name><operator>-&gt;</operator><name>newoffset</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>newitemIsCur</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_PREV</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>loc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>replace</name></name> <operator>&amp;&amp;</operator> <call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>loc</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>it</name><operator>-&gt;</operator><name>newoffset</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>newitemIsCur</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>split_item_interator_size</name><parameter_list>(<parameter><decl><type><name>SplitItemIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>newitemIsCur</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name><name>it</name><operator>-&gt;</operator><name>newitemSize</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Take into account that split will remove the tuples deleted by
		 * finished transactions, and resize tuples to minimal size.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tupHdr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OTuple</name></type>		<name>tup</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>finished</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tupHdr</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>loc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>finished</name> <operator>=</operator> <call><name>XACT_INFO_FINISHED_FOR_EVERYBODY</name><argument_list>(<argument><expr><name><name>tupHdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>finished</name> <operator>&amp;&amp;</operator> <name><name>tupHdr</name><operator>-&gt;</operator><name>deleted</name></name> <operator>&amp;&amp;</operator>
				<operator>(</operator><call><name>COMMITSEQNO_IS_INPROGRESS</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>csn</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>XACT_INFO_MAP_CSN</name><argument_list>(<argument><expr><name><name>tupHdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>it</name><operator>-&gt;</operator><name>csn</name></name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>finished</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>BTreeLeafTuphdrSize</name> <operator>+</operator>
					<call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>o_btree_len</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>OTupleLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator>
					<sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof></expr>;</return></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>loc</name></name></expr></argument>)</argument_list></call> <operator>+</operator>
					<sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<return>return <expr><call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>loc</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get current item from split iterator.
 */</comment>
<function><type><specifier>static</specifier> <name>OTuple</name></type>
<name>split_item_interator_get</name><parameter_list>(<parameter><decl><type><name>SplitItemIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>newitemIsCur</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>newitem</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>BTREE_PAGE_READ_TUPLE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>loc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find the location for B-tree page split.  This function take into accouint
 * insertion of new tuple or replacement of existing one.  It tries to keep
 * as close as possible to `targetLocation`, or if `targetLocation == 0` close
 * to `spaceRatio`.  Also, this function takes advantage of reclaiming unused
 * space according to `csn`.  Returns number of items in new left page and
 * sets the first tuple of right page to `*split_item`.
 */</comment>
<function><type><name>OffsetNumber</name></type>
<name>btree_page_split_location</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl></parameter>,
						  <parameter><decl><type><name>LocationIndex</name></type> <name>tuplesize</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>replace</name></decl></parameter>,
						  <parameter><decl><type><name>OffsetNumber</name></type> <name>targetLocation</name></decl></parameter>, <parameter><decl><type><name>float4</name></type> <name>spaceRatio</name></decl></parameter>,
						  <parameter><decl><type><name>OTuple</name> <modifier>*</modifier></type><name>split_item</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>leftPageSpaceLeft</name></decl>,
				<decl><type ref="prev"/><name>rightPageSpaceLeft</name></decl>,
				<decl><type ref="prev"/><name>minLeftPageItemsCount</name></decl>,
				<decl><type ref="prev"/><name>maxLeftPageItemsCount</name></decl>,
				<decl><type ref="prev"/><name>totalCount</name></decl>,
				<decl><type ref="prev"/><name>maxKeyLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>newitem_size</name></decl>,
				<decl><type ref="prev"/><name>hikeys_end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SplitItemIterator</name></type> <name>left_it</name></decl>,
				<decl><type ref="prev"/><name>right_it</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>spaceRatio</name> <operator>&gt;</operator> <literal type="number">0.0f</literal> <operator>&amp;&amp;</operator> <name>spaceRatio</name> <operator>&lt;</operator> <literal type="number">1.0f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newitem_size</name> <operator>=</operator> <name>BTreeLeafTuphdrSize</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>tuplesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>newitem_size</name> <operator>=</operator> <name>BTreeNonLeafTuphdrSize</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>tuplesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>maxKeyLen</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>maxKeyLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>totalCount</name> <operator>=</operator> <call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>replace</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>hikeys_end</name> <operator>=</operator> <call><name>BTREE_PAGE_HIKEYS_END</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leftPageSpaceLeft</name> <operator>=</operator> <name>ORIOLEDB_BLCKSZ</name> <operator>-</operator> <call><name>Max</name><argument_list>(<argument><expr><name>hikeys_end</name></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTreePageHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <name>maxKeyLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rightPageSpaceLeft</name> <operator>=</operator> <name>ORIOLEDB_BLCKSZ</name> <operator>-</operator> <call><name>Max</name><argument_list>(<argument><expr><name>hikeys_end</name></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTreePageHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>BTREE_PAGE_GET_HIKEY_SIZE</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>rightPageSpaceLeft</name> <operator>=</operator> <name>ORIOLEDB_BLCKSZ</name> <operator>-</operator> <name>hikeys_end</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Left page should contain at least one item, and leaves at lest one item
	 * for the right page.
	 */</comment>
	<expr_stmt><expr><name>minLeftPageItemsCount</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxLeftPageItemsCount</name> <operator>=</operator> <name>totalCount</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_split_item_interator</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left_it</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>newitem_size</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
							  <argument><expr><name>replace</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_split_item_interator</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right_it</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>newitem_size</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
							  <argument><expr><name>replace</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leftPageSpaceLeft</name> <operator>-=</operator> <call><name>split_item_interator_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left_it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightPageSpaceLeft</name> <operator>-=</operator> <call><name>split_item_interator_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right_it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>split_item_interator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left_it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>split_item_interator_prev</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right_it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leftPageSpaceLeft</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rightPageSpaceLeft</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Shift minimal and maximal left page item counts till they are equal.
	 */</comment>
	<while>while <condition>(<expr><name>minLeftPageItemsCount</name> <operator>!=</operator> <name>maxLeftPageItemsCount</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>minLeftPageItemsCount</name> <operator>&lt;</operator> <name>maxLeftPageItemsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Choose page to add item.  At first only we try place new item to
		 * the page that have a space yet.  Then, we try to follow
		 * `targetLocation`.  If `targetLocation` isn't given, then follow
		 * `spaceRatio`.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>rightPageSpaceLeft</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>leftPageSpaceLeft</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
										<operator>(</operator><ternary><condition><expr><name>targetLocation</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then>
										 <expr><operator>(</operator><name>float4</name><operator>)</operator> <name>leftPageSpaceLeft</name> <operator>*</operator> <name>spaceRatio</name> <operator>&gt;</operator> <operator>(</operator><name>float4</name><operator>)</operator> <name>rightPageSpaceLeft</name> <operator>*</operator> <operator>(</operator><literal type="number">1.0f</literal> <operator>-</operator> <name>spaceRatio</name><operator>)</operator></expr> </then><else>:
										 <expr><name>minLeftPageItemsCount</name> <operator>&lt;</operator> <name>targetLocation</name></expr></else></ternary><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Try place item to the left page */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leftPageSpaceLeft</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>leftPageSpaceLeft</name> <operator>-=</operator> <call><name>split_item_interator_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left_it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>leftPageSpaceLeft</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>split_item_interator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left_it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>minLeftPageItemsCount</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Try place item to the right page */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rightPageSpaceLeft</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rightPageSpaceLeft</name> <operator>-=</operator> <call><name>split_item_interator_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right_it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>rightPageSpaceLeft</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>split_item_interator_prev</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right_it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>maxLeftPageItemsCount</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>split_item</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>split_item</name> <operator>=</operator> <call><name>split_item_interator_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left_it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>minLeftPageItemsCount</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>OffsetNumber</name></type>
<name>btree_get_split_left_count</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>,
						   <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>LocationIndex</name></type> <name>tuplesize</name></decl></parameter>,
						   <parameter><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>replace</name></decl></parameter>,
						   <parameter><decl><type><name>OTuple</name> <modifier>*</modifier></type><name>split_key</name></decl></parameter>, <parameter><decl><type><name>LocationIndex</name> <modifier>*</modifier></type><name>split_key_len</name></decl></parameter>,
						   <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>page</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>targetCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>spaceRatio</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>split_item</name></decl>;</decl_stmt>

	<comment type="block">/* The default target is to split the page 50%/50% */</comment>
	<expr_stmt><expr><name>targetCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>spaceRatio</name> <operator>=</operator> <literal type="number">0.5</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Try to autodetect ordered inserts and split near the insertion point.
	 * If we're close to the end of the page, split already inserted data away
	 * from the insertion point (if it gives at least 90% utilization).
	 * Otherwise, place already inserted data together with the insertion
	 * point. Hopefuly, we still have many tuple to insert and that will give
	 * us the good utilization.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <name><name>header</name><operator>-&gt;</operator><name>prevInsertOffset</name></name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>float</name><operator>)</operator> <name>offset</name> <operator>/</operator> <operator>(</operator><name>float</name><operator>)</operator> <name><name>header</name><operator>-&gt;</operator><name>itemsCount</name></name> <operator>&gt;=</operator> <literal type="number">0.9</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>targetCount</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>targetCount</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><operator>!</operator><name>replace</name> <operator>&amp;&amp;</operator> <name>offset</name> <operator>==</operator> <name><name>header</name><operator>-&gt;</operator><name>prevInsertOffset</name></name><operator>)</operator> <operator>||</operator>
			 <operator>(</operator><name>replace</name> <operator>&amp;&amp;</operator> <name>offset</name> <operator>==</operator> <name><name>header</name><operator>-&gt;</operator><name>prevInsertOffset</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>float</name><operator>)</operator> <name>offset</name> <operator>/</operator> <operator>(</operator><name>float</name><operator>)</operator> <name><name>header</name><operator>-&gt;</operator><name>itemsCount</name></name> <operator>&lt;=</operator> <literal type="number">0.1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>targetCount</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>targetCount</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>

	<comment type="block">/*
	 * If we don't autodetect the insertion order, we still assume TOAST and
	 * rightmost inserts are always assumed to be ordered ascendingly.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>desc</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>oIndexToast</name> <operator>&amp;&amp;</operator> <call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>spaceRatio</name> <operator>=</operator> <literal type="number">0.9</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>btree_page_split_location</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>tuplesize</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>replace</name></expr></argument>,
									   <argument><expr><name>targetCount</name></expr></argument>, <argument><expr><name>spaceRatio</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>split_item</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fill the split key.  Convert tuple to key if needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>split_key</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>allocated</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>split_item</name> <operator>=</operator> <call><name>o_btree_tuple_make_key</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>split_item</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>allocated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>split_key_len</name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>split_item</name></expr></argument>, <argument><expr><name>OKeyLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name>allocated</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>split_key</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>*</operator><name>split_key_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>split_key</name><operator>-&gt;</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>split_item</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>split_key</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>split_item</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><operator>*</operator><name>split_key_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>split_key</name> <operator>=</operator> <name>split_item</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Split B-tree page into two.
 *
 * Returns OInvalidInMemoryBlkno if the page can not be split due to the fact that
 * it is under processing by the checkpointer worker.
 */</comment>
<function><type><name>void</name></type>
<name>perform_page_split</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>new_blkno</name></decl></parameter>,
				   <parameter><decl><type><name>OffsetNumber</name></type> <name>left_count</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>splitkey</name></decl></parameter>,
				   <parameter><decl><type><name>LocationIndex</name></type> <name>splitkey_len</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>place_right</name></decl></parameter>,
				   <parameter><decl><type><name>Pointer</name></type> <name>tupleheader</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>LocationIndex</name></type> <name>tuplesize</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>replace</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name></type> <name>undoLoc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>left_page</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>right_page</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>new_blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>left_header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>left_page</name></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>right_header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>right_page</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>leaf</name> <init>= <expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>left_page</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>hikey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>hikeySize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>tuple_header_size</name> <init>= <expr><ternary><condition><expr><name>leaf</name></expr> ?</condition><then> <expr><name>BTreeLeafTuphdrSize</name></expr> </then><else>: <expr><name>BTreeNonLeafTuphdrSize</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItem</name></type> <name><name>items</name><index>[<expr><name>BTREE_PAGE_MAX_CHUNK_ITEMS</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>newItem</name><index>[<expr><call><name>Max</name><argument_list>(<argument><expr><name>BTreeLeafTuphdrSize</name></expr></argument>, <argument><expr><name>BTreeNonLeafTuphdrSize</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>O_BTREE_MAX_TUPLE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_new_btree_page</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>new_blkno</name></expr></argument>,
						<argument><expr><name><name>left_header</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>O_BTREE_FLAG_LEFTMOST</name><operator>)</operator></expr></argument>,
						<argument><expr><call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>left_page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fill the array of items for btree_page_reorg() function */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_FIRST</name><argument_list>(<argument><expr><name>left_page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>left_page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>i</name> <operator>==</operator> <operator>*</operator><name>offset</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <operator>*</operator><name>offset</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newItem</name></expr></argument>, <argument><expr><name>tupleheader</name></expr></argument>, <argument><expr><name>tuple_header_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newItem</name><index>[<expr><name>tuple_header_size</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>tuple</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>tuplesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>tuplesize</name> <operator>!=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>tuplesize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newItem</name><index>[<expr><name>tuple_header_size</name> <operator>+</operator> <name>tuplesize</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>tuplesize</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>tuplesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name> <operator>=</operator> <name>newItem</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name><name>tuple</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <name>tuple_header_size</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>tuplesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>newItem</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ORIOLEDB_CUT_FIRST_KEY</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>leaf</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>==</operator> <name>left_count</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <name>BTreeNonLeafTuphdrSize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>replace</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name>left_page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>left_page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * In leaf pages, get rid of tuples deleted by finished transactions.
		 * Also, resize tuples to minimal size.  In non-leaf pages, copy
		 * tuples as-is.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>leaf</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tupHdr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OTuple</name></type>		<name>tup</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>finished</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tupHdr</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>left_page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>finished</name> <operator>=</operator> <call><name>XACT_INFO_FINISHED_FOR_EVERYBODY</name><argument_list>(<argument><expr><name><name>tupHdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>finished</name> <operator>&amp;&amp;</operator> <name><name>tupHdr</name><operator>-&gt;</operator><name>deleted</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>!=</operator> <name>left_count</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><call><name>COMMITSEQNO_IS_INPROGRESS</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>XACT_INFO_MAP_CSN</name><argument_list>(<argument><expr><name><name>tupHdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>csn</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>left_count</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>left_count</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>offset</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>(</operator><operator>*</operator><name>offset</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name>left_page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>tupHdr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name><name>tup</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <ternary><condition><expr><name>finished</name></expr> ?</condition><then>
				<expr><operator>(</operator><name>BTreeLeafTuphdrSize</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>OTupleLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr> </then><else>:
				<expr><call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>left_page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>newItem</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>left_page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_ITEM_FLAGS</name><argument_list>(<argument><expr><name>left_page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>left_page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>newItem</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ORIOLEDB_CUT_FIRST_KEY</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>leaf</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>==</operator> <name>left_count</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <name>BTreeNonLeafTuphdrSize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name>left_page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name>count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>offset</name> <operator>&lt;</operator> <name>left_count</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>place_right</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>offset</name> <operator>-=</operator> <name>left_count</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>place_right</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>left_page</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>hikeySize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>hikey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>hikeySize</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_HIKEY_SIZE</name><argument_list>(<argument><expr><name>left_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>left_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>btree_page_reorg</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>right_page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>left_count</name></expr>]</index></name></expr></argument>, <argument><expr><name>count</name> <operator>-</operator> <name>left_count</name></expr></argument>,
					 <argument><expr><name>hikeySize</name></expr></argument>, <argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Start page modification.  It contains the required memory barrier
	 * between making undo image and setting the undo location.
	 */</comment>
	<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Link undo record with pages */</comment>
	<expr_stmt><expr><name><name>left_header</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>=</operator> <name>undoLoc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>right_header</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>=</operator> <name>undoLoc</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Memory barrier between write undo location and csn.  See comment in the
	 * o_btree_read_page() for details.
	 */</comment>
	<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>left_header</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <name>csn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>right_header</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <name>csn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>left_header</name><operator>-&gt;</operator><name>rightLink</name></name> <operator>=</operator> <call><name>MAKE_IN_MEMORY_RIGHTLINK</name><argument_list>(<argument><expr><name>new_blkno</name></expr></argument>,
													  <argument><expr><call><name>O_PAGE_GET_CHANGE_COUNT</name><argument_list>(<argument><expr><name>right_page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>left_header</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>O_BTREE_FLAG_RIGHTMOST</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>btree_page_reorg</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>left_page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>left_count</name></expr></argument>,
					 <argument><expr><name>splitkey_len</name></expr></argument>, <argument><expr><name>splitkey</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>o_btree_page_calculate_statistics</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>left_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>o_btree_page_calculate_statistics</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>right_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MARK_DIRTY</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MARK_DIRTY</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>new_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
