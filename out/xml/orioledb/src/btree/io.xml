<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/btree/io.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * io.c
 *		Routines for orioledb B-tree disk IO.
 *
 * Copyright (c) 2021-2022, Oriole DB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/btree/io.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;common/hashfn.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/find.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/merge.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/page_chunks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"checkpoint/checkpoint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/free_extents.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"recovery/recovery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tableam/descr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tableam/handler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/compress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/page_pool.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/seq_buf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/stopevent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ucm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"workers/bgwriter.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>writesStarted</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>writesFinished</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConditionVariable</name></type> <name><name>cv</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>IOShmem</name>;</typedef>

<typedef>typedef <type><struct>struct <name>TreeOffset</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>datoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FileExtent</name></type>	<name>fileExtent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>compressed</name></decl>;</decl_stmt>
}</block></struct></type> <name>TreeOffset</name>;</typedef>

<typedef>typedef <type><struct>struct <name>IOWriteBack</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>extentsNumber</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>extentsAllocated</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TreeOffset</name> <modifier>*</modifier></type><name>extents</name></decl>;</decl_stmt>
}</block></struct></type> <name>IOWriteBack</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>IOWriteBack</name></type> <name>io_writeback</name> <init>=
<expr><block>{
	<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>LWLockPadded</name> <modifier>*</modifier></type><name>io_locks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>IOShmem</name> <modifier>*</modifier></type><name>ioShmem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>num_io_lwlocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>io_in_progress</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>prepare_non_leaf_page</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>get_free_disk_offset</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>get_free_disk_extent</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>page_size</name></decl></parameter>, <parameter><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>get_free_disk_extent_copy_blkno</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>page_size</name></decl></parameter>,
											<parameter><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>checkpoint_number</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>write_page_to_disk</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>,
							   <parameter><decl><type><name>Pointer</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>page_size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>write_page</name><parameter_list>(<parameter><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>img</name></decl></parameter>,
					   <parameter><decl><type><name>uint32</name></type> <name>checkpoint_number</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>evict</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>copy_blkno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>tree_offsets_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>writeback_put_extent</name><parameter_list>(<parameter><decl><type><name>IOWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>, <parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>,
								 <parameter><decl><type><name>uint64</name></type> <name>downlink</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>perform_writeback</name><parameter_list>(<parameter><decl><type><name>IOWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>orioledb_evict_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>orioledb_write_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Size</name></type>
<name>btree_io_shmem_needs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>IOShmem</name></expr></argument>, <argument><expr><name>cv</name></expr></argument>)</argument_list></call> <operator>+</operator>
						  <sizeof>sizeof<argument_list>(<argument><expr><name>ConditionVariable</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>max_procs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>btree_io_shmem_init</name><parameter_list>(<parameter><decl><type><name>Pointer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>found</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>ptr</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ioShmem</name> <operator>=</operator> <operator>(</operator><name>IOShmem</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ioShmem</name><operator>-&gt;</operator><name>writesStarted</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ioShmem</name><operator>-&gt;</operator><name>writesFinished</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_procs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ConditionVariableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ioShmem</name><operator>-&gt;</operator><name>cv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>io_start</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>startNum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>max_io_concurrency</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>startNum</name> <operator>=</operator> <call><name>pg_atomic_add_fetch_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ioShmem</name><operator>-&gt;</operator><name>writesStarted</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>io_in_progress</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>startNum</name> <operator>&gt;</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ioShmem</name><operator>-&gt;</operator><name>writesFinished</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>max_io_concurrency</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ConditionVariableSleep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ioShmem</name><operator>-&gt;</operator><name>cv</name><index>[<expr><name>startNum</name> <operator>%</operator> <name>max_procs</name></expr>]</index></name></expr></argument>, <argument><expr><name>WAIT_EVENT_PG_SLEEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>ConditionVariableCancelSleep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>io_finish</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>finishNum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>max_io_concurrency</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>finishNum</name> <operator>=</operator> <call><name>pg_atomic_add_fetch_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ioShmem</name><operator>-&gt;</operator><name>writesFinished</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>io_in_progress</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ConditionVariableBroadcast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ioShmem</name><operator>-&gt;</operator><name>cv</name><index>[<expr><operator>(</operator><name>finishNum</name> <operator>+</operator> <name>max_io_concurrency</name><operator>)</operator> <operator>%</operator> <name>max_procs</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>OFileRead</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>amount</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>,
		  <parameter><decl><type><name>uint32</name></type> <name>wait_event_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>io_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FileRead</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>wait_event_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>io_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>OFileWrite</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>amount</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>,
		   <parameter><decl><type><name>uint32</name></type> <name>wait_event_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>io_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FileWrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>wait_event_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>io_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>btree_smgr_filename</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>num</name> <init>= <expr><name>offset</name> <operator>/</operator> <name>ORIOLEDB_SEGMENT_SIZE</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><name>ORIOLEDB_DATA_DIR</name> <literal type="string">"/%u_%u"</literal></expr></argument>,
						<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr></argument>,
						<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><name>ORIOLEDB_DATA_DIR</name> <literal type="string">"/%u_%u.%u"</literal></expr></argument>,
						<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr></argument>,
						<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr></argument>,
						<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>btree_open_smgr_file</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&gt;=</operator> <name><name>desc</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>filesAllocated</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>filesAllocated</name></name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>num</name> <operator>&gt;=</operator> <name><name>desc</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>filesAllocated</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>filesAllocated</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name></name> <operator>=</operator> <operator>(</operator><name>File</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name></name></expr></argument>,
											 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>File</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>desc</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>filesAllocated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>filesAllocated</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name><index>[<expr><name>num</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>btree_smgr_filename</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>num</name> <operator>*</operator> <name>ORIOLEDB_SEGMENT_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name><index>[<expr><name>num</name></expr>]</index></name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name><index>[<expr><name>num</name></expr>]</index></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open data file %s"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>btree_open_smgr</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>descr</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>filesAllocated</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name></name> <operator>=</operator> <operator>(</operator><name>File</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
													<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>File</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>descr</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>filesAllocated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>descr</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>filesAllocated</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>btree_open_smgr_file</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>btree_close_smgr</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>descr</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name></name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>descr</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>filesAllocated</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>descr</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>filesAllocated</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>descr</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>btree_smgr_write</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>amount</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>use_mmap</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <name>amount</name> <operator>&lt;=</operator> <name>device_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>mmap_data</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>amount</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>use_device</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <name>amount</name> <operator>&lt;=</operator> <name>device_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_DATA_FILE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_pwrite</name><argument_list>(<argument><expr><name>device_fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name>amount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>segno</name> <init>= <expr><name>offset</name> <operator>/</operator> <name>ORIOLEDB_SEGMENT_SIZE</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>btree_open_smgr_file</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>offset</name> <operator>+</operator> <name>amount</name><operator>)</operator> <operator>/</operator> <name>ORIOLEDB_SEGMENT_SIZE</name> <operator>==</operator> <name>segno</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>OFileWrite</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name><index>[<expr><name>segno</name></expr>]</index></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>,
								 <argument><expr><name>offset</name> <operator>%</operator> <name>ORIOLEDB_SEGMENT_SIZE</name></expr></argument>,
								 <argument><expr><name>WAIT_EVENT_DATA_FILE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>stepAmount</name> <init>= <expr><name>ORIOLEDB_SEGMENT_SIZE</name> <operator>-</operator> <name>offset</name> <operator>%</operator> <name>ORIOLEDB_SEGMENT_SIZE</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>amount</name> <operator>&gt;=</operator> <name>stepAmount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>OFileWrite</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name><index>[<expr><name>segno</name></expr>]</index></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>stepAmount</name></expr></argument>,
								 <argument><expr><name>offset</name> <operator>%</operator> <name>ORIOLEDB_SEGMENT_SIZE</name></expr></argument>,
								 <argument><expr><name>WAIT_EVENT_DATA_FILE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name>stepAmount</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>stepAmount</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>amount</name> <operator>-=</operator> <name>stepAmount</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>btree_smgr_read</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>amount</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>use_mmap</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <name>amount</name> <operator>&lt;=</operator> <name>device_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>mmap_data</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>amount</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>use_device</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <name>amount</name> <operator>&lt;=</operator> <name>device_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_DATA_FILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_pread</name><argument_list>(<argument><expr><name>device_fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name>amount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>segno</name> <init>= <expr><name>offset</name> <operator>/</operator> <name>ORIOLEDB_SEGMENT_SIZE</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>btree_open_smgr_file</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>offset</name> <operator>+</operator> <name>amount</name><operator>)</operator> <operator>/</operator> <name>ORIOLEDB_SEGMENT_SIZE</name> <operator>==</operator> <name>segno</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>OFileRead</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name><index>[<expr><name>segno</name></expr>]</index></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>,
								<argument><expr><name>offset</name> <operator>%</operator> <name>ORIOLEDB_SEGMENT_SIZE</name></expr></argument>,
								<argument><expr><name>WAIT_EVENT_DATA_FILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>stepAmount</name> <init>= <expr><name>ORIOLEDB_SEGMENT_SIZE</name> <operator>-</operator> <name>offset</name> <operator>%</operator> <name>ORIOLEDB_SEGMENT_SIZE</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>amount</name> <operator>&gt;=</operator> <name>stepAmount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>OFileRead</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name><index>[<expr><name>segno</name></expr>]</index></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>stepAmount</name></expr></argument>,
								<argument><expr><name>offset</name> <operator>%</operator> <name>ORIOLEDB_SEGMENT_SIZE</name></expr></argument>,
								<argument><expr><name>WAIT_EVENT_DATA_FILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name>stepAmount</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>stepAmount</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>amount</name> <operator>-=</operator> <name>stepAmount</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>btree_smgr_writeback</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>amount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>use_mmap</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <name>amount</name> <operator>&lt;=</operator> <name>device_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>msync</name><argument_list>(<argument><expr><name>mmap_data</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>MS_ASYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>use_device</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name>amount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>segno</name> <init>= <expr><name>offset</name> <operator>/</operator> <name>ORIOLEDB_SEGMENT_SIZE</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>btree_open_smgr_file</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>offset</name> <operator>+</operator> <name>amount</name><operator>)</operator> <operator>/</operator> <name>ORIOLEDB_SEGMENT_SIZE</name> <operator>==</operator> <name>segno</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FileWriteback</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name><index>[<expr><name>segno</name></expr>]</index></name></expr></argument>, <argument><expr><name>offset</name> <operator>%</operator> <name>ORIOLEDB_SEGMENT_SIZE</name></expr></argument>,
						  <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>stepAmount</name> <init>= <expr><name>ORIOLEDB_SEGMENT_SIZE</name> <operator>-</operator> <name>offset</name> <operator>%</operator> <name>ORIOLEDB_SEGMENT_SIZE</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>amount</name> <operator>&gt;=</operator> <name>stepAmount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FileWriteback</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name><index>[<expr><name>segno</name></expr>]</index></name></expr></argument>, <argument><expr><name>offset</name> <operator>%</operator> <name>ORIOLEDB_SEGMENT_SIZE</name></expr></argument>,
						  <argument><expr><name>stepAmount</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>stepAmount</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>amount</name> <operator>-=</operator> <name>stepAmount</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>btree_smgr_sync</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>num</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>use_mmap</name> <operator>||</operator> <name>use_device</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>num</name> <operator>&lt;</operator> <name>length</name> <operator>/</operator> <name>ORIOLEDB_SEGMENT_SIZE</name></expr>;</condition> <incr><expr><name>num</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>btree_open_smgr_file</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FileSync</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name><index>[<expr><name>num</name></expr>]</index></name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>btree_io_error_cleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>io_in_progress</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>io_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>request_btree_io_lwlocks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>num_io_lwlocks</name> <operator>=</operator> <name>max_procs</name> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RequestNamedLWLockTranche</name><argument_list>(<argument><expr><literal type="string">"orioledb_btree_io"</literal></expr></argument>, <argument><expr><name>num_io_lwlocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>init_btree_io_lwlocks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>io_locks</name> <operator>=</operator> <call><name>GetNamedLWLockTranche</name><argument_list>(<argument><expr><literal type="string">"orioledb_btree_io"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Assign number of IO operation to particular (blkno; offnum) pair.
 */</comment>
<function><type><name>int</name></type>
<name>assign_io_num</name><parameter_list>(<parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>locknum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32c</name></type>	<name>crc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offnum</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>locknum</name> <operator>=</operator> <name>crc</name> <operator>%</operator> <name>num_io_lwlocks</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_io_lwlocks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>LWLockConditionalAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>io_locks</name><index>[<expr><name>locknum</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>locknum</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>locknum</name> <operator>=</operator> <operator>(</operator><name>locknum</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>num_io_lwlocks</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>io_locks</name><index>[<expr><name>locknum</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>locknum</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wait until particular IO operation is completed.
 */</comment>
<function><type><name>void</name></type>
<name>wait_for_io_completion</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ionum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>io_locks</name><index>[<expr><name>ionum</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>io_locks</name><index>[<expr><name>ionum</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Report given IO operation to be finished.
 */</comment>
<function><type><name>void</name></type>
<name>unlock_io</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ionum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>io_locks</name><index>[<expr><name>ionum</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get next disk free offset for uncompressed on disk B-tree.
 * Returns InvalidFileExtentOff if fails.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>get_free_disk_offset</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeMetaPage</name> <modifier>*</modifier></type><name>metaPage</name> <init>= <expr><call><name>BTREE_GET_META</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>metaLock</name> <init>= <expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>metaLock</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>result</name></decl>,
				<decl><type ref="prev"/><name>numFreeBlocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>free_buf_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>gotBlock</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Switch to the next sequential buffer with free blocks numbers in
	 * needed.
	 */</comment>
	<expr_stmt><expr><name>numFreeBlocks</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>numFreeBlocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>free_buf_num</name> <operator>=</operator> <name><name>metaPage</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>tag</name><operator>.</operator><name>num</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>numFreeBlocks</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		   <call><name>can_use_checkpoint_extents</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>free_buf_num</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SeqBufTag</name></type>	<name>tag</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>,
					<decl><type ref="prev"/><name>old_tag</name> <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>shared</name><operator>-&gt;</operator><name>tag</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SeqBufReplaceResult</name></type> <name>replaceResult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>tag</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tag</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tag</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name>free_buf_num</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tag</name><operator>.</operator><name>type</name></name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>metaLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>replaceResult</name> <operator>=</operator> <call><name>seq_buf_try_replace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>freeBuf</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>numFreeBlocks</name></name></expr></argument>,
											<argument><expr><ternary><condition><expr><name>use_device</name></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>FileExtent</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>replaceResult</name> <operator>==</operator> <name>SeqBufReplaceSuccess</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>seq_buf_remove_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>metaLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>replaceResult</name> <operator>==</operator> <name>SeqBufReplaceError</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>InvalidFileExtentOff</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* SeqBufReplaceAlready requires no action, just retry if needed */</comment>

		<expr_stmt><expr><name>numFreeBlocks</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>numFreeBlocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>free_buf_num</name> <operator>=</operator> <name><name>metaPage</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>tag</name><operator>.</operator><name>num</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Try to get free block number from the buffer.  If not success, then
	 * extend the file.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>metaLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>gotBlock</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>numFreeBlocks</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_compare_exchange_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>numFreeBlocks</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>numFreeBlocks</name></expr></argument>,
										   <argument><expr><name>numFreeBlocks</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>gotBlock</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>gotBlock</name></expr>)</condition>
	<block>{<block_content>

		<if_stmt><if>if <condition>(<expr><name>use_device</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FileExtent</name></type>	<name>extent</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>seq_buf_read_file_extent</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>freeBuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>extent</name><operator>.</operator><name>off</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>InvalidFileExtentOff</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>offset</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>seq_buf_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>freeBuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>InvalidFileExtentOff</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>use_device</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>orioledb_device_alloc</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>ORIOLEDB_COMP_BLCKSZ</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>datafileLength</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>metaLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fills free file extent for B-tree.
 *
 * FileExtentIsValid(extent) == false if fails.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>get_free_disk_extent</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>page_size</name></decl></parameter>, <parameter><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OCompressIsValid</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>page_size</name> <operator>==</operator> <name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>extent</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <call><name>get_free_disk_offset</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extent</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Try to add free extents if we didn't manage to do after checkpoint */</comment>
		<expr_stmt><expr><call><name>add_free_extents_from_tmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>remove_old_checkpoint_files</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>extent</name> <operator>=</operator> <call><name>get_extent</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><call><name>FileExtentLen</name><argument_list>(<argument><expr><name>page_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><call><name>FileExtentIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>extent</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fills free file extent for B-tree under copy blkno lock.
 *
 * FileExtentIsValid(extent) == false if fails.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>get_free_disk_extent_copy_blkno</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>page_size</name></decl></parameter>,
								<parameter><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>checkpoint_number</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeMetaPage</name> <modifier>*</modifier></type><name>metaPage</name> <init>= <expr><call><name>BTREE_GET_META</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>copyBlknoLock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_free_disk_extent</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>page_size</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>copyBlknoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>storageType</name></name> <operator>==</operator> <name>BTreeStoragePersistence</name> <operator>&amp;&amp;</operator>
		<name><name>checkpoint_state</name><operator>-&gt;</operator><name>treeType</name></name> <operator>==</operator> <name><name>desc</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;&amp;</operator>
		<name><name>checkpoint_state</name><operator>-&gt;</operator><name>datoid</name></name> <operator>==</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name> <operator>&amp;&amp;</operator>
		<name><name>checkpoint_state</name><operator>-&gt;</operator><name>relnode</name></name> <operator>==</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name> <operator>&amp;&amp;</operator>
		<name><name>checkpoint_state</name><operator>-&gt;</operator><name>curKeyType</name></name> <operator>!=</operator> <name>CurKeyFinished</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We're writing to the next checkpoint, while current checkpoint is
		 * concurrently taking.  So, indicate this page is free in the
		 * checkpoint currently taking.  We have to take a lock in order to be
		 * sure that checkpoint map file will be finishing concurrently.
		 * Otherwise we might loose this block number.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>prev_chkp_index</name> <init>= <expr><operator>(</operator><name>checkpoint_number</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>success</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OCompressIsValid</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name>use_device</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>seq_buf_write_file_extent</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>prev_chkp_index</name></expr>]</index></name></expr></argument>, <argument><expr><operator>*</operator><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>offset</name> <init>= <expr><name><name>extent</name><operator>-&gt;</operator><name>off</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&lt;</operator> <name>UINT32_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>seq_buf_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>prev_chkp_index</name></expr>]</index></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>copyBlknoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>copyBlknoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>FileExtentIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>extent</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Reads a page from disk to the img from a valid downlink. It's fills an empty
 * array of offsets for the page.
 */</comment>
<function><type><name>bool</name></type>
<name>read_page_from_disk</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>img</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>downlink</name></decl></parameter>, <parameter><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>byte_offset</name></decl>,
				<decl><type ref="prev"/><name>read_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>offset</name> <init>= <expr><call><name>DOWNLINK_GET_DISK_OFF</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>len</name> <init>= <expr><call><name>DOWNLINK_GET_DISK_LEN</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>err</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileExtentOffIsValid</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileExtentLenIsValid</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OCompressIsValid</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* easy case, read page from uncompressed index */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extent</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extent</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>use_device</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>byte_offset</name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>offset</name> <operator>*</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>ORIOLEDB_COMP_BLCKSZ</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>byte_offset</name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>offset</name> <operator>*</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>ORIOLEDB_BLCKSZ</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>read_size</name> <operator>=</operator> <name>ORIOLEDB_BLCKSZ</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>btree_smgr_read</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><name>read_size</name></expr></argument>, <argument><expr><name>byte_offset</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>read_size</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>ORIOLEDB_BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>compressed</name> <init>= <expr><name>len</name> <operator>!=</operator> <operator>(</operator><name>ORIOLEDB_BLCKSZ</name> <operator>/</operator> <name>ORIOLEDB_COMP_BLCKSZ</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Pointer</name></type>		<name>read_buf</name> <init>= <expr><ternary><condition><expr><name>compressed</name></expr> ?</condition><then> <expr><name>buf</name></expr> </then><else>: <expr><name>img</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>extent</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extent</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>byte_offset</name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>offset</name> <operator>*</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>ORIOLEDB_COMP_BLCKSZ</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>read_size</name> <operator>=</operator> <name>len</name> <operator>*</operator> <name>ORIOLEDB_COMP_BLCKSZ</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>btree_smgr_read</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>read_buf</name></expr></argument>, <argument><expr><name>read_size</name></expr></argument>, <argument><expr><name>byte_offset</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>read_size</name></expr>;</expr_stmt><empty_stmt>;</empty_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>err</name> <operator>&amp;&amp;</operator> <name>compressed</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OCompressHeader</name></type> <name>header</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>header</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OCompressHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>o_decompress_page</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OCompressHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>img</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><operator>!</operator><name>err</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Writes a page to the disk. An array of file offsets must be valid.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>write_page_to_disk</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>,
				   <parameter><decl><type><name>Pointer</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>page_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>off_t</name></type>		<name>byte_offset</name></decl>,
				<decl><type ref="prev"/><name>write_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>err</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileExtentOffIsValid</name><argument_list>(<argument><expr><name><name>extent</name><operator>-&gt;</operator><name>off</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OCompressIsValid</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* easy case, write page to uncompressed index */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>extent</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>page_size</name> <operator>==</operator> <name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>use_device</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>byte_offset</name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name><name>extent</name><operator>-&gt;</operator><name>off</name></name> <operator>*</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>ORIOLEDB_COMP_BLCKSZ</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>byte_offset</name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name><name>extent</name><operator>-&gt;</operator><name>off</name></name> <operator>*</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>ORIOLEDB_BLCKSZ</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>write_size</name> <operator>=</operator> <name>ORIOLEDB_BLCKSZ</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>btree_smgr_write</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>write_size</name></expr></argument>, <argument><expr><name>byte_offset</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>write_size</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>byte_offset</name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name><name>extent</name><operator>-&gt;</operator><name>off</name></name> <operator>*</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>ORIOLEDB_COMP_BLCKSZ</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>page_size</name> <operator>!=</operator> <name>ORIOLEDB_BLCKSZ</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we need to write header first */</comment>
			<decl_stmt><decl><type><name>OCompressHeader</name></type> <name>header</name> <init>= <expr><name>page_size</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * overflow protection
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>page_size</name> <operator>&lt;</operator> <name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OCompressHeader</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ORIOLEDB_BLCKSZ</name> <operator>&lt;</operator> <name>UINT16_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>write_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OCompressHeader</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>btree_smgr_write</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>header</name></expr></argument>, <argument><expr><name>write_size</name></expr></argument>, <argument><expr><name>byte_offset</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>write_size</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>byte_offset</name> <operator>+=</operator> <name>write_size</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>write_size</name> <operator>=</operator> <name><name>extent</name><operator>-&gt;</operator><name>len</name></name> <operator>*</operator> <name>ORIOLEDB_COMP_BLCKSZ</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OCompressHeader</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>write_size</name> <operator>=</operator> <name>ORIOLEDB_BLCKSZ</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* write data */</comment>
		<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>btree_smgr_write</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>write_size</name></expr></argument>, <argument><expr><name>byte_offset</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>write_size</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><operator>!</operator><name>err</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Load the page where context is pointing from disk to memory, assuming parent
 * page is locked.
 */</comment>
<function><type><name>void</name></type>
<name>load_page</name><parameter_list>(<parameter><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OrioleDBPageDesc</name> <modifier>*</modifier></type><name>parent_page_desc</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>page_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>desc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>parent_blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>parent_page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>parent_loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>downlink</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>context_index</name></decl>,
				<decl><type ref="prev"/><name>ionum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>parent_change_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>int_hdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>ORIOLEDB_BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>was_modify</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>was_downlink_location</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>was_fetch</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>was_image</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>was_keep_lokey</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>context_index</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>parent_blkno</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>context_index</name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>parent_loc</name> <operator>=</operator> <operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>context_index</name></expr>]</index></name><operator>.</operator><name>locator</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>parent_change_count</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>context_index</name></expr>]</index></name><operator>.</operator><name>pageChangeCount</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>parent_page</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ionum</name> <operator>=</operator> <call><name>assign_io_num</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>, <argument><expr><call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>parent_page</name></expr></argument>, <argument><expr><name>parent_loc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Modify parent downlink: indicate that IO is in-progress */</comment>
	<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>int_hdr</name> <operator>=</operator> <operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>parent_page</name></expr></argument>, <argument><expr><name>parent_loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DOWNLINK_IS_ON_DISK</name><argument_list>(<argument><expr><name><name>int_hdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>downlink</name> <operator>=</operator> <name><name>int_hdr</name><operator>-&gt;</operator><name>downlink</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>int_hdr</name><operator>-&gt;</operator><name>downlink</name></name> <operator>=</operator> <call><name>MAKE_IO_DOWNLINK</name><argument_list>(<argument><expr><name>ionum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PAGE_GET_N_ONDISK</name><argument_list>(<argument><expr><name>parent_page</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PAGE_DEC_N_ONDISK</name><argument_list>(<argument><expr><name>parent_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare new page metaPage-data */</comment>
	<expr_stmt><expr><call><name>ppool_reserve_pages</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>PPOOL_RESERVE_FIND</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>ppool_get_page</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>PPOOL_RESERVE_FIND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OInMemoryBlknoIsValid</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>parent_page_desc</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page_desc</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Read page data and put it to the page */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_page_from_disk</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>downlink</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>int_hdr</name><operator>-&gt;</operator><name>downlink</name></name> <operator>=</operator> <name>downlink</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PAGE_INC_N_ONDISK</name><argument_list>(<argument><expr><name>parent_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlock_io</name><argument_list>(<argument><expr><name>ionum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read page with file offset "</literal> <name>UINT64_FORMAT</name> <literal type="string">" from %s"</literal></expr></argument>,
							   <argument><expr><call><name>DOWNLINK_GET_DISK_OFF</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>btree_smgr_filename</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><call><name>DOWNLINK_GET_DISK_OFF</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>put_page_image</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>page_change_usage_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>ppool</name><operator>-&gt;</operator><name>ucm</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name><operator>-&gt;</operator><name>ucm</name><operator>.</operator><name>epoch</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>%</operator> <name>UCM_USAGE_LEVELS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>parent_page_desc</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>oids</name></name> <operator>=</operator> <name><name>parent_page_desc</name><operator>-&gt;</operator><name>oids</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <operator>(</operator><call><name>PAGE_GET_N_ONDISK</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EA_LOAD_INC</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>STOPEVENTS_ENABLED</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>params</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>btree_page_stopevent_params</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STOPEVENT</name><argument_list>(<argument><expr><name>STOPEVENT_LOAD_PAGE_REFIND</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* re-find parent page (it might be changed due to concurrent operations) */</comment>
	<expr_stmt><expr><name>csn</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>csn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>was_modify</name> <operator>=</operator> <call><name>BTREE_PAGE_FIND_IS</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>MODIFY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>was_image</name> <operator>=</operator> <call><name>BTREE_PAGE_FIND_IS</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>IMAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTREE_PAGE_FIND_UNSET</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>IMAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>was_modify</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>was_fetch</name> <operator>=</operator> <call><name>BTREE_PAGE_FIND_IS</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>FETCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>was_fetch</name> <operator>||</operator> <name>was_image</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTREE_PAGE_FIND_UNSET</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>FETCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTREE_PAGE_FIND_SET</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>MODIFY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>was_keep_lokey</name> <operator>=</operator> <call><name>BTREE_PAGE_FIND_IS</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>KEEP_LOKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>was_keep_lokey</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>BTREE_PAGE_FIND_UNSET</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>KEEP_LOKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>was_downlink_location</name> <operator>=</operator> <call><name>BTREE_PAGE_FIND_IS</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>DOWNLINK_LOCATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>was_downlink_location</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>BTREE_PAGE_FIND_SET</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>DOWNLINK_LOCATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <name>COMMITSEQNO_INPROGRESS</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>refind_page</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyRightmost</name></expr></argument>, <argument><expr><call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
					<argument><expr><name>parent_blkno</name></expr></argument>, <argument><expr><name>parent_change_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>hikey</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>refind_page</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hikey</name></expr></argument>, <argument><expr><name>BTreeKeyPageHiKey</name></expr></argument>,
					<argument><expr><call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>parent_blkno</name></expr></argument>, <argument><expr><name>parent_change_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* restore context state */</comment>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <name>csn</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>was_modify</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>was_fetch</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>BTREE_PAGE_FIND_SET</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>FETCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>BTREE_PAGE_FIND_UNSET</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>MODIFY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>was_image</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>BTREE_PAGE_FIND_SET</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>IMAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>was_keep_lokey</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>BTREE_PAGE_FIND_SET</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>KEEP_LOKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>was_downlink_location</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>BTREE_PAGE_FIND_UNSET</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>DOWNLINK_LOCATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>context_index</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>parent_blkno</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>context_index</name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>parent_loc</name> <operator>=</operator> <operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>context_index</name></expr>]</index></name><operator>.</operator><name>locator</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>parent_change_count</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>context_index</name></expr>]</index></name><operator>.</operator><name>pageChangeCount</name></expr>;</expr_stmt>

	<comment type="block">/* Replace parent downlink with orioledb downlink */</comment>
	<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>parent_page</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>int_hdr</name> <operator>=</operator> <operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>parent_page</name></expr></argument>, <argument><expr><name>parent_loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>int_hdr</name><operator>-&gt;</operator><name>downlink</name></name> <operator>==</operator> <call><name>MAKE_IO_DOWNLINK</name><argument_list>(<argument><expr><name>ionum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>int_hdr</name><operator>-&gt;</operator><name>downlink</name></name> <operator>=</operator> <call><name>MAKE_IN_MEMORY_DOWNLINK</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>, <argument><expr><call><name>O_PAGE_HEADER</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pageChangeCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>unlock_io</name><argument_list>(<argument><expr><name>ionum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns pointer to writable image. It compresses page if needed.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>Pointer</name></type>
<name>get_write_img</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OCompressIsValid</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>o_compress_page</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>size</name> <operator>&gt;</operator> <operator>(</operator><name>ORIOLEDB_BLCKSZ</name> <operator>-</operator> <name>ORIOLEDB_COMP_BLCKSZ</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OCompressHeader</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * No sense to write compressed page
			 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name>ORIOLEDB_BLCKSZ</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name>ORIOLEDB_BLCKSZ</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>prewrite_image_check</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>

		<macro><name>BTREE_PAGE_FOREACH_ITEMS</name><argument_list>(<argument>p</argument>, <argument>&amp;loc</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name> <init>= <expr><operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DOWNLINK_IS_ON_DISK</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Returns downlink to the page or InvalidDiskDownlink if fails.
 */</comment>
<function><type><name>uint64</name></type>
<name>perform_page_io</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>,
				<parameter><decl><type><name>Page</name></type> <name>img</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>checkpoint_number</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>copy_blkno</name></decl></parameter>,
				<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>dirty_parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>page</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OrioleDBPageDesc</name> <modifier>*</modifier></type><name>page_desc</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>write_img</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>write_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>chkp_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>less_num</name></decl>,
				<decl><type ref="prev"/><name>err</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>prewrite_image_check</name><argument_list>(<argument><expr><name>img</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>EA_WRITE_INC</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>less_num</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>checkpointNum</name></name> <operator>&lt;</operator> <name>checkpoint_number</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>less_num</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Page wasn't yet written during given checkpoint, so we have to
		 * relocate it in order to implement copy-on-write checkpointing.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>page</name> <operator>!=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>img</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * we need to update the written checkpoint number for the img too
			 */</comment>
			<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>img</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>checkpointNum</name></name> <operator>=</operator> <name>checkpoint_number</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>page</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>checkpointNum</name></name> <operator>=</operator> <name>checkpoint_number</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>checkpointNum</name></name> <operator>==</operator> <name>checkpoint_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>write_img</name> <operator>=</operator> <call><name>get_write_img</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>write_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine the file position to write this page.
	 */</comment>
	<expr_stmt><expr><name>chkp_index</name> <operator>=</operator> <name>checkpoint_number</name> <operator>%</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>less_num</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Page wasn't yet written during given checkpoint, so we have to
		 * relocate it in order to implement copy-on-write checkpointing.
		 */</comment>

		<if_stmt><if>if <condition>(<expr><call><name>FileExtentIsValid</name><argument_list>(<argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
			<comment type="block">/*
			 * Shared seq_bufs should be initialized by checkpointer.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>storageType</name></name> <operator>!=</operator> <name>BTreeStorageTemporary</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>chkp_index</name></expr>]</index></name><operator>.</operator><name><name>shared</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>chkp_index</name></expr>]</index></name><operator>.</operator><name><name>shared</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>num</name></name> <operator>==</operator> <name>checkpoint_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>chkp_index</name></expr>]</index></name><operator>.</operator><name><name>shared</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>chkp_index</name></expr>]</index></name><operator>.</operator><name><name>shared</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>chkp_index</name></expr>]</index></name><operator>.</operator><name><name>shared</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>num</name></name> <operator>==</operator> <name>checkpoint_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>chkp_index</name></expr>]</index></name><operator>.</operator><name><name>shared</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>free_extent_for_checkpoint</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>, <argument><expr><name>checkpoint_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Get free disk page to locate new page image */</comment>
		<if_stmt><if>if <condition>(<expr><name>copy_blkno</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <operator>!</operator><call><name>get_free_disk_extent_copy_blkno</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>write_size</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>,
												   <argument><expr><name>checkpoint_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <operator>!</operator><call><name>get_free_disk_extent</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>write_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>dirty_parent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Has been already written during given checkpoint, so rewrite page
		 * in-place.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileExtentIsValid</name><argument_list>(<argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OCompressIsValid</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* easy case: no compression */</comment>
			<expr_stmt><expr><operator>*</operator><name>dirty_parent</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint16</name></type>		<name>old_len</name> <init>= <expr><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name><operator>.</operator><name>len</name></name></expr></init></decl>,
						<decl><type ref="prev"/><name>new_len</name> <init>= <expr><call><name>FileExtentLen</name><argument_list>(<argument><expr><name>write_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * check: is current image take as much space as previous written
			 * page?
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name><operator>.</operator><name>len</name></name> <operator>&lt;</operator> <name>new_len</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>free_extent_for_checkpoint</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>, <argument><expr><name>checkpoint_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* allocate more file blocks */</comment>
				<if_stmt><if>if <condition>(<expr><name>copy_blkno</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>err</name> <operator>=</operator> <operator>!</operator><call><name>get_free_disk_extent_copy_blkno</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>write_size</name></expr></argument>,
														   <argument><expr><operator>&amp;</operator><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>,
														   <argument><expr><name>checkpoint_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>err</name> <operator>=</operator> <operator>!</operator><call><name>get_free_disk_extent</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>write_size</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <name>new_len</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * free space
				 */</comment>
				<decl_stmt><decl><type><name>FileExtent</name></type>	<name>free_extent</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>free_extent</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name>new_len</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>free_extent</name><operator>.</operator><name>off</name></name> <operator>=</operator> <name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name><operator>.</operator><name>off</name></name> <operator>+</operator> <name>new_len</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>seq_buf_write_file_extent</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>chkp_index</name></expr>]</index></name></expr></argument>, <argument><expr><name>free_extent</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<operator>!</operator><call><name>seq_buf_write_file_extent</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>chkp_index</name></expr>]</index></name></expr></argument>, <argument><expr><name>free_extent</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>err</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>new_len</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><operator>*</operator><name>dirty_parent</name> <operator>=</operator> <name>old_len</name> <operator>!=</operator> <name>new_len</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not (re) allocate file blocks for page %d to file %s"</literal></expr></argument>,
							   <argument><expr><name>blkno</name></expr></argument>, <argument><expr><call><name>btree_smgr_filename</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileExtentIsValid</name><argument_list>(<argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>write_page_to_disk</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>, <argument><expr><name>write_img</name></expr></argument>, <argument><expr><name>write_size</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write page %d to file %s with offset %lu"</literal></expr></argument>,
							   <argument><expr><name>blkno</name></expr></argument>,
							   <argument><expr><call><name>btree_smgr_filename</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name><operator>.</operator><name>off</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name><operator>.</operator><name>off</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>InvalidDiskDownlink</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>MAKE_ON_DISK_DOWNLINK</name><argument_list>(<argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Performs page write for autonomous checkpoint images.
 *
 * Returns downlink to the page.
 */</comment>
<function><type><name>uint64</name></type>
<name>perform_page_io_autonomous</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>img</name></decl></parameter>, <parameter><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>write_img</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>write_size</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>prewrite_image_check</name><argument_list>(<argument><expr><name>img</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>write_img</name> <operator>=</operator> <call><name>get_write_img</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>write_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_free_disk_extent</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>write_size</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not get free file offset for write page to file %s"</literal></expr></argument>,
							   <argument><expr><call><name>btree_smgr_filename</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>InvalidDiskDownlink</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileExtentIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>extent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>write_page_to_disk</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>write_img</name></expr></argument>, <argument><expr><name>write_size</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write autonomous page to file %s with offset %lu"</literal></expr></argument>,
							   <argument><expr><call><name>btree_smgr_filename</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name><name>extent</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>off</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name><name>extent</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>off</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>InvalidDiskDownlink</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>MAKE_ON_DISK_DOWNLINK</name><argument_list>(<argument><expr><operator>*</operator><name>extent</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Performs page write for tree build.
 *
 * Returns downlink to the page.
 */</comment>
<function><type><name>uint64</name></type>
<name>perform_page_io_build</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>img</name></decl></parameter>, <parameter><decl><type><name>FileExtent</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>,
					  <parameter><decl><type><name>BTreeMetaPage</name> <modifier>*</modifier></type><name>metaPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>write_img</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>write_size</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>btree_page_update_max_key_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>img</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>prewrite_image_check</name><argument_list>(<argument><expr><name>img</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>write_img</name> <operator>=</operator> <call><name>get_write_img</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>write_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OCompressIsValid</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>write_size</name> <operator>==</operator> <name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>extent</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>use_device</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>extent</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <call><name>orioledb_device_alloc</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>ORIOLEDB_COMP_BLCKSZ</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>extent</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>datafileLength</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>extent</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <call><name>FileExtentLen</name><argument_list>(<argument><expr><name>write_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>use_device</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>extent</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <call><name>orioledb_device_alloc</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>ORIOLEDB_COMP_BLCKSZ</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>extent</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>datafileLength</name></name></expr></argument>, <argument><expr><name><name>extent</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FileExtentIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>extent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>write_page_to_disk</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>write_img</name></expr></argument>, <argument><expr><name>write_size</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write autonomous page to file %s with offset %lu"</literal></expr></argument>,
							   <argument><expr><call><name>btree_smgr_filename</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name><name>extent</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>off</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name><name>extent</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>off</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>InvalidDiskDownlink</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>MAKE_ON_DISK_DOWNLINK</name><argument_list>(<argument><expr><operator>*</operator><name>extent</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare internal page for writing to disk.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prepare_non_leaf_page</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>

	<macro><name>BTREE_PAGE_FOREACH_ITEMS</name><argument_list>(<argument>p</argument>, <argument>&amp;loc</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name> <init>= <expr><operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>DOWNLINK_IS_IN_IO</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>DOWNLINK_IS_IN_MEMORY</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>child</name> <init>= <expr><call><name>DOWNLINK_GET_IN_MEMORY_BLKNO</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OrioleDBPageDesc</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * It's worth less to write non-leaf page, if it's going to anyway
			 * become dirty after writing of child.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IS_DIRTY</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/* XXX: should we also consider checkpoint number of child page? */</comment>
			<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name> <operator>=</operator> <call><name>MAKE_ON_DISK_DOWNLINK</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>PAGE_SET_N_ONDISK</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Evict the page, assuming target page and its parent are locked.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_page</name><parameter_list>(<parameter><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>img</name></decl></parameter>,
		   <parameter><decl><type><name>uint32</name></type> <name>checkpoint_number</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>evict</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>copy_blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>desc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>parent_blkno</name> <init>= <expr><name>OInvalidInMemoryBlkno</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>parent_page</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>parent_loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ionum</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>context_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>int_hdr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>parent_change_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OrioleDBPageDesc</name> <modifier>*</modifier></type><name>page_desc</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_root</name> <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name> <operator>==</operator> <name>blkno</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* rootPageBlkno can not be evicted here */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>evict</name> <operator>||</operator> <operator>!</operator><name>is_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OInMemoryBlknoIsValid</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>page_is_locked</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EA_EVICT_INC</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_root</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>context_index</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parent_blkno</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>context_index</name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parent_loc</name> <operator>=</operator> <operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>context_index</name></expr>]</index></name><operator>.</operator><name>locator</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parent_change_count</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>context_index</name></expr>]</index></name><operator>.</operator><name>pageChangeCount</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>parent_page</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ionum</name> <operator>=</operator> <call><name>assign_io_num</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>, <argument><expr><call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>parent_page</name></expr></argument>, <argument><expr><name>parent_loc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Prepare to modify downlink in parent page */</comment>
		<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>int_hdr</name> <operator>=</operator> <operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>parent_page</name></expr></argument>, <argument><expr><name>parent_loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Root page still need ionum to prevent changing of checkpoint
		 * number.
		 */</comment>
		<expr_stmt><expr><name>ionum</name> <operator>=</operator> <call><name>assign_io_num</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>MaxOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_DIRTY</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>evict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Easy case: page isn't dirty and doesn't need to be written to the
		 * disk.  Then we just have to change downlink in the parent.
		 */</comment>
		<expr_stmt><expr><name><name>int_hdr</name><operator>-&gt;</operator><name>downlink</name></name> <operator>=</operator> <call><name>MAKE_ON_DISK_DOWNLINK</name><argument_list>(<argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PAGE_INC_N_ONDISK</name><argument_list>(<argument><expr><name>parent_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Concurrent readers should give up when we release the lock... */</comment>
		<expr_stmt><expr><call><name>O_PAGE_CHANGE_COUNT_INC</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlock_io</name><argument_list>(<argument><expr><name>ionum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>new_downlink</name></decl>,
					<decl><type ref="prev"/><name>old_downlink</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>dirty_parent</name></decl>;</decl_stmt>

		<comment type="block">/* Mark parent downlink as IO in-progress. */</comment>
		<if_stmt><if>if <condition>(<expr><name>evict</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>old_downlink</name> <operator>=</operator> <name><name>int_hdr</name><operator>-&gt;</operator><name>downlink</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>int_hdr</name><operator>-&gt;</operator><name>downlink</name></name> <operator>=</operator> <call><name>MAKE_IO_DOWNLINK</name><argument_list>(<argument><expr><name>ionum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>O_PAGE_CHANGE_COUNT_INC</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Caller (walk_page()) ensured that there is no IO in progress */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>ionum</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>ionum</name></name> <operator>=</operator> <name>ionum</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_root</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Perform actual IO */</comment>
		<if_stmt><if>if <condition>(<expr><name>evict</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_downlink</name> <operator>=</operator> <call><name>perform_page_io</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>p</name></expr></argument>,
										   <argument><expr><name>checkpoint_number</name></expr></argument>, <argument><expr><name>copy_blkno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dirty_parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>DiskDownlinkIsValid</name><argument_list>(<argument><expr><name>new_downlink</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>writeback_put_extent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>io_writeback</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>new_downlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Page is not dirty anymore */</comment>
			<expr_stmt><expr><call><name>CLEAN_DIRTY</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Non-leaf pages are already copied by caller */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>CLEAN_DIRTY_CONCURRENT</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>STOPEVENTS_ENABLED</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>params</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>btree_page_stopevent_params</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>STOPEVENT</name><argument_list>(<argument><expr><name>STOPEVENT_AFTER_IONUM_SET</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>new_downlink</name> <operator>=</operator> <call><name>perform_page_io</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>img</name></expr></argument>,
										   <argument><expr><name>checkpoint_number</name></expr></argument>, <argument><expr><name>copy_blkno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dirty_parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>DiskDownlinkIsValid</name><argument_list>(<argument><expr><name>new_downlink</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>writeback_put_extent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>io_writeback</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>new_downlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Clean dirty only if there are no concurrent writes */</comment>
			<expr_stmt><expr><call><name>lock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_DIRTY_CONCURRENT</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CLEAN_DIRTY</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DiskDownlinkIsValid</name><argument_list>(<argument><expr><name>new_downlink</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>ionum</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>unlock_io</name><argument_list>(<argument><expr><name>ionum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not evict page %d to disk"</literal></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><name>dirty_parent</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>ionum</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>unlock_io</name><argument_list>(<argument><expr><name>ionum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>perform_writeback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>io_writeback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_root</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Refind parent */</comment>
			<expr_stmt><expr><call><name>BTREE_PAGE_FIND_SET</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>DOWNLINK_LOCATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>refind_page</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyRightmost</name></expr></argument>,
							<argument><expr><call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
							<argument><expr><name>parent_blkno</name></expr></argument>, <argument><expr><name>parent_change_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>OTuple</name></type>		<name>hikey</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>refind_page</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hikey</name></expr></argument>, <argument><expr><name>BTreeKeyPageHiKey</name></expr></argument>, <argument><expr><call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
							<argument><expr><name>parent_blkno</name></expr></argument>, <argument><expr><name>parent_change_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>BTREE_PAGE_FIND_UNSET</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>DOWNLINK_LOCATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>context_index</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>parent_blkno</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>context_index</name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>parent_loc</name> <operator>=</operator> <operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>context_index</name></expr>]</index></name><operator>.</operator><name>locator</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>parent_change_count</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>context_index</name></expr>]</index></name><operator>.</operator><name>pageChangeCount</name></expr>;</expr_stmt>

			<comment type="block">/* Replace parent downlink with on-disk link */</comment>
			<expr_stmt><expr><name>parent_page</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>int_hdr</name> <operator>=</operator> <operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>parent_page</name></expr></argument>, <argument><expr><name>parent_loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DiskDownlinkIsValid</name><argument_list>(<argument><expr><name>new_downlink</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* error happens on write, rollback changes in shared memory */</comment>
				<if_stmt><if>if <condition>(<expr><name>evict</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>int_hdr</name><operator>-&gt;</operator><name>downlink</name></name> <operator>=</operator> <name>old_downlink</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>ionum</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>unlock_io</name><argument_list>(<argument><expr><name>ionum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not evict page %d to disk"</literal></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>dirty_parent</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>MARK_DIRTY</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>evict</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>int_hdr</name><operator>-&gt;</operator><name>downlink</name></name> <operator>=</operator> <name>new_downlink</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PAGE_INC_N_ONDISK</name><argument_list>(<argument><expr><name>parent_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>ionum</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlock_io</name><argument_list>(<argument><expr><name>ionum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_root</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>evict</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ppool_free_page</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>perform_writeback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>io_writeback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>btree_finalize_private_seq_bufs</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>EvictedTreeData</name> <modifier>*</modifier></type><name>evicted_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>chkp_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_compressed</name> <init>= <expr><call><name>OCompressIsValid</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>chkp_index</name> <operator>=</operator> <ternary><condition><expr><call><name>SEQ_BUF_SHARED_EXIST</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>shared</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* we must do not evict BTree under checkpoint */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>SEQ_BUF_SHARED_EXIST</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><literal type="number">1</literal> <operator>-</operator> <name>chkp_index</name></expr>]</index></name><operator>.</operator><name>shared</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>SEQ_BUF_SHARED_EXIST</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><literal type="number">1</literal> <operator>-</operator> <name>chkp_index</name></expr>]</index></name><operator>.</operator><name>shared</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>is_compressed</name> <operator>||</operator> <call><name>SEQ_BUF_SHARED_EXIST</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>shared</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SEQ_BUF_SHARED_EXIST</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>chkp_index</name></expr>]</index></name><operator>.</operator><name>shared</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SEQ_BUF_SHARED_EXIST</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>chkp_index</name></expr>]</index></name><operator>.</operator><name>shared</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_compressed</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>evicted_data</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>tag</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>tag</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>evicted_data</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>evicted_data</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>tag</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>shared</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>evicted_data</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <call><name>seq_buf_finalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>freeBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FREE_PAGE_IF_VALID</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>shared</name><operator>-&gt;</operator><name>pages</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FREE_PAGE_IF_VALID</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>shared</name><operator>-&gt;</operator><name>pages</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>evicted_data</name><operator>-&gt;</operator><name>nextChkp</name><operator>.</operator><name>tag</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>chkp_index</name></expr>]</index></name><operator>.</operator><name><name>shared</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>evicted_data</name><operator>-&gt;</operator><name>nextChkp</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <call><name>seq_buf_finalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>chkp_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FREE_PAGE_IF_VALID</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>chkp_index</name></expr>]</index></name><operator>.</operator><name><name>shared</name><operator>-&gt;</operator><name>pages</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FREE_PAGE_IF_VALID</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>chkp_index</name></expr>]</index></name><operator>.</operator><name><name>shared</name><operator>-&gt;</operator><name>pages</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>evicted_data</name><operator>-&gt;</operator><name>tmpBuf</name><operator>.</operator><name>tag</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>chkp_index</name></expr>]</index></name><operator>.</operator><name><name>shared</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>evicted_data</name><operator>-&gt;</operator><name>tmpBuf</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <call><name>seq_buf_finalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>chkp_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FREE_PAGE_IF_VALID</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>chkp_index</name></expr>]</index></name><operator>.</operator><name><name>shared</name><operator>-&gt;</operator><name>pages</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FREE_PAGE_IF_VALID</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>chkp_index</name></expr>]</index></name><operator>.</operator><name><name>shared</name><operator>-&gt;</operator><name>pages</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evict the tree, assuming rootPageBlkno page is locked.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>evict_btree</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>checkpoint_number</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>root_blkno</name> <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>rootPageBlkno</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>root_blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OrioleDBPageDesc</name> <modifier>*</modifier></type><name>root_desc</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name>root_blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeMetaPage</name> <modifier>*</modifier></type><name>metaPage</name> <init>= <expr><call><name>BTREE_GET_META</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CheckpointFileHeader</name></type> <name>file_header</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EvictedTreeData</name></type> <name>evicted_tree_data</name> <init>= <expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>new_downlink</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>,
				<decl><type ref="prev"/><name><name>img</name><index>[<expr><name>ORIOLEDB_BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>was_dirty</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>			<name>i</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ORootPageIsValid</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OMetaPageIsValid</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <call><name>O_PAGE_STATE_IS_LOCKED</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><call><name>O_PAGE_HEADER</name><argument_list>(<argument><expr><name>rootPageBlkno</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>state</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we check it before */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RightLinkIsValid</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_GET_RIGHTLINK</name><argument_list>(<argument><expr><name>rootPageBlkno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>was_dirty</name> <operator>=</operator> <call><name>IS_DIRTY</name><argument_list>(<argument><expr><name>root_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>was_dirty</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>not_used</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CLEAN_DIRTY</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>root_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Code above ensured there is no IO in progress */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root_desc</name><operator>-&gt;</operator><name>ionum</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root_desc</name><operator>-&gt;</operator><name>ionum</name></name> <operator>=</operator> <call><name>assign_io_num</name><argument_list>(<argument><expr><name>root_blkno</name></expr></argument>, <argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><name>rootPageBlkno</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>root_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>new_downlink</name> <operator>=</operator> <call><name>perform_page_io</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>root_blkno</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><name>checkpoint_number</name></expr></argument>,
									   <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>not_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DiskDownlinkIsValid</name><argument_list>(<argument><expr><name>new_downlink</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Can not evict rootPageBlkno page on disk."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>writeback_put_extent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>io_writeback</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>new_downlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlock_io</name><argument_list>(<argument><expr><name><name>root_desc</name><operator>-&gt;</operator><name>ionum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root_desc</name><operator>-&gt;</operator><name>ionum</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>new_downlink</name> <operator>=</operator> <call><name>MAKE_ON_DISK_DOWNLINK</name><argument_list>(<argument><expr><name><name>root_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>root_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>file_header</name><operator>.</operator><name>rootDownlink</name></name> <operator>=</operator> <name>new_downlink</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ppool_free_page</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>root_blkno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>file_header</name><operator>.</operator><name>datafileLength</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>datafileLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>file_header</name><operator>.</operator><name>leafPagesNum</name></name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>leafPagesNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>file_header</name><operator>.</operator><name>ctid</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>ctid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>file_header</name><operator>.</operator><name>numFreeBlocks</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>numFreeBlocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_SEQ_SCANS_ARRAY_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPage</name><operator>-&gt;</operator><name>numSeqScans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>evicted_tree_data</name><operator>.</operator><name>file_header</name></name> <operator>=</operator> <name>file_header</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Free all private seq buf pages and get their offsets
	 */</comment>
	<expr_stmt><expr><call><name>btree_finalize_private_seq_bufs</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>evicted_tree_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>get_eviction_filename</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>, <argument><expr><name>checkpoint_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_WRONLY</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not open eviction file: %s"</literal></expr></argument>,
							   <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OFileWrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>,
				   <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>evicted_tree_data</name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>evicted_tree_data</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				   <argument><expr><literal type="number">0</literal></expr></argument>,
				   <argument><expr><name>WAIT_EVENT_DATA_FILE_WRITE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>evicted_tree_data</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not write eviction data to file: %s"</literal></expr></argument>,
							   <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ppool_free_page</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>metaPageBlkno</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>metaPageBlkno</name></name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>perform_writeback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>io_writeback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Shared descr drops to signalize other backends that tree is evicted.
	 * Backends and workers can create a new SharedRootInfo* after this.
	 */</comment>
	<expr_stmt><expr><call><name>o_drop_shared_root_info</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>BTreeDescr</name> <modifier>*</modifier></type>
<name>index_oids_get_btree_descr</name><parameter_list>(<parameter><decl><type><name>ORelOids</name></type> <name>oids</name></decl></parameter>, <parameter><decl><type><name>OIndexType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>indexDescr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nested</name></decl>;</decl_stmt>

	<comment type="block">/* Check is this table is visible for us */</comment>
	<expr_stmt><expr><name>indexDescr</name> <operator>=</operator> <call><name>o_fetch_index_descr</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nested</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>indexDescr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>desc</name> <operator>=</operator> <operator>&amp;</operator><name><name>indexDescr</name><operator>-&gt;</operator><name>desc</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>o_btree_try_use_shmem</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>desc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Examine single page and evict it if possible.
 */</comment>
<function><type><name>OWalkPageResult</name></type>
<name>walk_page</name><parameter_list>(<parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>evict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OrioleDBPageDesc</name> <modifier>*</modifier></type><name>page_desc</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>parent_page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ORelOids</name></type>	<name>oids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>int_hdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>checkpoint_number</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>copy_blkno</name></decl>,
				<decl><type ref="prev"/><name>found</name></decl>,
				<decl><type ref="prev"/><name>merge_tried</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ionum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>img</name><index>[<expr><name>ORIOLEDB_BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_root</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>retry</name>:</label>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ORelOidsIsValid</name><argument_list>(<argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>page_desc</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>oIndexInvalid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>OWalkPageSkipped</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>evict</name> <operator>&amp;&amp;</operator> <call><name>PAGE_GET_N_ONDISK</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>OWalkPageSkipped</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>evict</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_DIRTY</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>OWalkPageSkipped</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>try_lock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>OWalkPageSkipped</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* page is locked once we get here */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ORelOidsIsValid</name><argument_list>(<argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>page_desc</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>oIndexInvalid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>OWalkPageSkipped</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>evict</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_DIRTY</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>OWalkPageSkipped</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>PRE_CLEANUP</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>OWalkPageSkipped</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* On concurrent IO, then wait for completion and retry */</comment>
	<expr_stmt><expr><name>ionum</name> <operator>=</operator> <name><name>page_desc</name><operator>-&gt;</operator><name>ionum</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ionum</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>wait_for_io_completion</name><argument_list>(<argument><expr><name>ionum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>retry</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>evict</name> <operator>&amp;&amp;</operator> <call><name>PAGE_GET_N_ONDISK</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>OWalkPageSkipped</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>evict</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>prepare_non_leaf_page</name><argument_list>(<argument><expr><name>img</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>OWalkPageSkipped</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RightLinkIsValid</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_GET_RIGHTLINK</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>OWalkPageSkipped</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>oids</name> <operator>=</operator> <name><name>page_desc</name><operator>-&gt;</operator><name>oids</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IS_SYS_TREE_OIDS</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>sys_tree_get_storage_type</name><argument_list>(<argument><expr><name><name>oids</name><operator>.</operator><name>relnode</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BTreeStorageInMemory</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>get_sys_tree</name><argument_list>(<argument><expr><name><name>oids</name><operator>.</operator><name>relnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>OWalkPageSkipped</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Check is this index is visible for us */</comment>
		<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>index_oids_get_btree_descr</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>desc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>OWalkPageSkipped</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Try to merge sparse page instead of eviction */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>merge_tried</name> <operator>&amp;&amp;</operator> <call><name>is_page_too_sparse</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>btree_try_merge_and_unlock</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Merge shouldn't leave us with locked pages. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>have_locked_pages</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>OWalkPageMerged</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>merge_tried</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<goto>goto <name>retry</name>;</goto>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>desc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ORootPageIsValid</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OMetaPageIsValid</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>is_root</name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name> <operator>==</operator> <name>blkno</name></expr>;</expr_stmt>

	<comment type="block">/* If page is rootPageBlkno, we don't need to search parent page. */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>desc</name></name> <operator>=</operator> <name>desc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_root</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>init_page_find_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>, <argument><expr><name>BTREE_PAGE_FIND_MODIFY</name>
							   <operator>|</operator> <name>BTREE_PAGE_FIND_TRY_LOCK</name>
							   <operator>|</operator> <name>BTREE_PAGE_FIND_DOWNLINK_LOCATION</name>
							   <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>evict</name></expr> ?</condition><then> <expr><name>BTREE_PAGE_FIND_NO_FIX_SPLIT</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>find_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyRightmost</name></expr></argument>, <argument><expr><call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>OTuple</name></type>		<name>hikey</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>find_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hikey</name></expr></argument>, <argument><expr><name>BTreeKeyPageHiKey</name></expr></argument>, <argument><expr><call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>have_locked_pages</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>OWalkPageSkipped</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>BTREE_PAGE_FIND_UNSET</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>TRY_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parent_page</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>int_hdr</name> <operator>=</operator> <operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>parent_page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DOWNLINK_IS_IN_MEMORY</name><argument_list>(<argument><expr><name><name>int_hdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>DOWNLINK_GET_IN_MEMORY_BLKNO</name><argument_list>(<argument><expr><name><name>int_hdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>blkno</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We didn't find downlink pointing to this page.  This could
			 * happend because of concurrent split.  Give up then...
			 */</comment>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>OWalkPageSkipped</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IS_SYS_TREE_OIDS</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>is_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>OWalkPageSkipped</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_checkpoint_number</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>checkpoint_number</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copy_blkno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_root</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>OWalkPageSkipped</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>evict</name> <operator>&amp;&amp;</operator> <name>is_root</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>recovery</name> <init>= <expr><call><name>is_recovery_in_progress</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>acquired</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>nested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recovery</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>acquired</name> <operator>=</operator> <call><name>o_tables_rel_try_lock_extended</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oids</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nested</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>acquired</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>acquired</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nested</name> <operator>&amp;&amp;</operator>
				<call><name>o_tables_rel_try_lock_extended</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oids</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nested</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nested</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Descriptor might be already invalidated.
					 */</comment>
					<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>index_oids_get_btree_descr</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>desc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
						<name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name> <operator>==</operator> <name>blkno</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>evict_btree</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>checkpoint_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>o_invalidate_oids</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recovery</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>o_tables_rel_unlock_extended</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oids</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>o_tables_rel_unlock_extended</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oids</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><ternary><condition><expr><name>result</name></expr> ?</condition><then> <expr><name>OWalkPageEvicted</name></expr> </then><else>: <expr><name>OWalkPageSkipped</name></expr></else></ternary></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recovery</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>o_tables_rel_unlock_extended</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oids</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>OWalkPageSkipped</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>STOPEVENT</name><argument_list>(<argument><expr><name>STOPEVENT_BEFORE_WRITE_PAGE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>write_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><name>checkpoint_number</name></expr></argument>, <argument><expr><name>evict</name></expr></argument>, <argument><expr><name>copy_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>STOPEVENT</name><argument_list>(<argument><expr><name>STOPEVENT_AFTER_WRITE_PAGE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><ternary><condition><expr><name>evict</name></expr> ?</condition><then> <expr><name>OWalkPageEvicted</name></expr> </then><else>: <expr><name>OWalkPageWritten</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>write_tree_pages_recursive</name><parameter_list>(<parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>changeCount</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>maxLevel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>evict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>level</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name><name>childPageNumbers</name><index>[<expr><name>BTREE_PAGE_MAX_CHUNK_ITEMS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name><name>childPageChangeCounts</name><index>[<expr><name>BTREE_PAGE_MAX_CHUNK_ITEMS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>childPagesCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OInMemoryBlknoIsValid</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>lock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_GET_CHANGE_COUNT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>changeCount</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>level</name> <operator>=</operator> <call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<macro><name>BTREE_PAGE_FOREACH_ITEMS</name><argument_list>(<argument>p</argument>, <argument>&amp;loc</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name> <init>= <expr><operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>DOWNLINK_IS_IN_MEMORY</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>childPageNumbers</name><index>[<expr><name>childPagesCount</name></expr>]</index></name> <operator>=</operator> <call><name>DOWNLINK_GET_IN_MEMORY_BLKNO</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>childPageChangeCounts</name><index>[<expr><name>childPagesCount</name></expr>]</index></name> <operator>=</operator> <call><name>DOWNLINK_GET_IN_MEMORY_CHANGECOUNT</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>childPagesCount</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>childPagesCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>write_tree_pages_recursive</name><argument_list>(<argument><expr><name><name>childPageNumbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										  <argument><expr><name><name>childPageChangeCounts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										  <argument><expr><name>maxLevel</name></expr></argument>,
										  <argument><expr><name>evict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&lt;=</operator> <name>maxLevel</name></expr>)</condition>
	<block>{<block_content>
		<while>while <condition>(<expr><name>true</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>reserve_undo_size</name><argument_list>(<argument><expr><name>UndoReserveTxn</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>O_MERGE_UNDO_IMAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walk_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>evict</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OWalkPageMerged</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>release_undo_size</name><argument_list>(<argument><expr><name>UndoReserveTxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_tree_pages</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxLevel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>evict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>write_tree_pages_recursive</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>,
									<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageChangeCount</name></name></expr></argument>,
									<argument><expr><name>maxLevel</name></expr></argument>, <argument><expr><name>evict</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>metaPageBlkno</name></name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageChangeCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>write_tree_pages_recursive</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>,
										  <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageChangeCount</name></name></expr></argument>,
										  <argument><expr><name>maxLevel</name></expr></argument>, <argument><expr><name>evict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_relation_pages</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxLevel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>evict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>td</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>treen</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>orioledb_check_shmem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rel</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation oid %u does not exists"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>treen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>treen</name> <operator>&lt;</operator> <name><name>descr</name><operator>-&gt;</operator><name>nIndices</name></name></expr>;</condition> <incr><expr><name>treen</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>td</name> <operator>=</operator> <operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>treen</name></expr>]</index></name><operator>-&gt;</operator><name>desc</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_tree_pages</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name>maxLevel</name></expr></argument>, <argument><expr><name>evict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>td</name> <operator>=</operator> <operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>toast</name><operator>-&gt;</operator><name>desc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>write_tree_pages</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name>maxLevel</name></expr></argument>, <argument><expr><name>evict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>orioledb_evict_pages</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxLevel</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>write_relation_pages</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>maxLevel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>orioledb_write_pages</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxLevel</name> <init>= <expr><name>ORIOLEDB_MAX_DEPTH</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>write_relation_pages</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>maxLevel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>tree_offsets_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TreeOffset</name></type>	<name>val1</name> <init>= <expr><operator>*</operator><operator>(</operator><name>TreeOffset</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TreeOffset</name></type>	<name>val2</name> <init>= <expr><operator>*</operator><operator>(</operator><name>TreeOffset</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>val1</name><operator>.</operator><name>datoid</name></name> <operator>!=</operator> <name><name>val2</name><operator>.</operator><name>datoid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>val1</name><operator>.</operator><name>datoid</name></name> <operator>&lt;</operator> <name><name>val2</name><operator>.</operator><name>datoid</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>val1</name><operator>.</operator><name>relnode</name></name> <operator>!=</operator> <name><name>val2</name><operator>.</operator><name>relnode</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>val1</name><operator>.</operator><name>relnode</name></name> <operator>&lt;</operator> <name><name>val2</name><operator>.</operator><name>relnode</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>val1</name><operator>.</operator><name>segno</name></name> <operator>!=</operator> <name><name>val2</name><operator>.</operator><name>segno</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>val1</name><operator>.</operator><name>segno</name></name> <operator>&lt;</operator> <name><name>val2</name><operator>.</operator><name>segno</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>val1</name><operator>.</operator><name>fileExtent</name><operator>.</operator><name>off</name></name> <operator>!=</operator> <name><name>val2</name><operator>.</operator><name>fileExtent</name><operator>.</operator><name>off</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><name><name>val1</name><operator>.</operator><name>fileExtent</name><operator>.</operator><name>off</name></name> <operator>&lt;</operator> <name><name>val2</name><operator>.</operator><name>fileExtent</name><operator>.</operator><name>off</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>val1</name><operator>.</operator><name>fileExtent</name><operator>.</operator><name>len</name></name> <operator>!=</operator> <name><name>val2</name><operator>.</operator><name>fileExtent</name><operator>.</operator><name>len</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * an extent with bigger length will be placed first, it helps to
		 * simplify process this case in perform_writeback()
		 */</comment>
		<return>return <expr><ternary><condition><expr><name><name>val1</name><operator>.</operator><name>fileExtent</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <name><name>val2</name><operator>.</operator><name>fileExtent</name><operator>.</operator><name>len</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>writeback_put_extent</name><parameter_list>(<parameter><decl><type><name>IOWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>, <parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>,
					 <parameter><decl><type><name>uint64</name></type> <name>downlink</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TreeOffset</name></type>	<name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>blcksz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>last_segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FileExtent</name></type>	<name>extent</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DOWNLINK_IS_ON_DISK</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extent</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>DOWNLINK_GET_DISK_LEN</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extent</name><operator>.</operator><name>off</name></name> <operator>=</operator> <call><name>DOWNLINK_GET_DISK_OFF</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ORelOidsIsValid</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>desc</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>oIndexInvalid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>extent</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>extent</name><operator>.</operator><name>len</name></name> <operator>&lt;=</operator> <operator>(</operator><name>ORIOLEDB_BLCKSZ</name> <operator>/</operator> <name>ORIOLEDB_COMP_BLCKSZ</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>offset</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>offset</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>offset</name><operator>.</operator><name>compressed</name></name> <operator>=</operator> <call><name>OCompressIsValid</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>blcksz</name> <operator>=</operator> <ternary><condition><expr><name><name>offset</name><operator>.</operator><name>compressed</name></name></expr> ?</condition><then> <expr><name>ORIOLEDB_COMP_BLCKSZ</name></expr> </then><else>: <expr><name>ORIOLEDB_BLCKSZ</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>offset</name><operator>.</operator><name>segno</name></name> <operator>=</operator> <name>blcksz</name> <operator>*</operator> <name><name>extent</name><operator>.</operator><name>off</name></name> <operator>/</operator> <name>ORIOLEDB_SEGMENT_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>last_segno</name> <operator>=</operator> <name>blcksz</name> <operator>*</operator> <operator>(</operator><name><name>extent</name><operator>.</operator><name>off</name></name> <operator>+</operator> <name><name>extent</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>ORIOLEDB_SEGMENT_SIZE</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name><name>offset</name><operator>.</operator><name>segno</name></name> <operator>&lt;=</operator> <name>last_segno</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>writeback</name><operator>-&gt;</operator><name>extents</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>writeback</name><operator>-&gt;</operator><name>extentsNumber</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>writeback</name><operator>-&gt;</operator><name>extentsAllocated</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>writeback</name><operator>-&gt;</operator><name>extents</name></name> <operator>=</operator> <operator>(</operator><name>TreeOffset</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
																   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeOffset</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>writeback</name><operator>-&gt;</operator><name>extentsAllocated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>writeback</name><operator>-&gt;</operator><name>extentsNumber</name></name> <operator>&gt;=</operator> <name><name>writeback</name><operator>-&gt;</operator><name>extentsAllocated</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>writeback</name><operator>-&gt;</operator><name>extentsAllocated</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>writeback</name><operator>-&gt;</operator><name>extents</name></name> <operator>=</operator> <operator>(</operator><name>TreeOffset</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>writeback</name><operator>-&gt;</operator><name>extents</name></name></expr></argument>,
														 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeOffset</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>writeback</name><operator>-&gt;</operator><name>extentsAllocated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>offset</name><operator>.</operator><name>fileExtent</name></name> <operator>=</operator> <name>extent</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>offset</name><operator>.</operator><name>segno</name></name> <operator>!=</operator> <name>last_segno</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>offset</name><operator>.</operator><name>fileExtent</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>ORIOLEDB_SEGMENT_SIZE</name> <operator>/</operator> <name>blcksz</name> <operator>-</operator> <name><name>extent</name><operator>.</operator><name>off</name></name> <operator>%</operator> <operator>(</operator><name>ORIOLEDB_SEGMENT_SIZE</name> <operator>/</operator> <name>blcksz</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>writeback</name><operator>-&gt;</operator><name>extents</name><index>[<expr><name><name>writeback</name><operator>-&gt;</operator><name>extentsNumber</name></name></expr>]</index></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>writeback</name><operator>-&gt;</operator><name>extentsNumber</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>offset</name><operator>.</operator><name>segno</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extent</name><operator>.</operator><name>off</name></name> <operator>+=</operator> <name><name>offset</name><operator>.</operator><name>fileExtent</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extent</name><operator>.</operator><name>len</name></name> <operator>-=</operator> <name><name>offset</name><operator>.</operator><name>fileExtent</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>perform_writeback</name><parameter_list>(<parameter><decl><type><name>IOWriteBack</name> <modifier>*</modifier></type><name>writeback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>flushAfter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>offset</name> <init>= <expr><name>InvalidFileExtentOff</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>blcksz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>filename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>datoid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>,
				<decl><type ref="prev"/><name>relnode</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>file</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>use_device</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>use_mmap</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>writeback</name><operator>-&gt;</operator><name>extentsNumber</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>flushAfter</name> <operator>=</operator> <ternary><condition><expr><name>IsBGWriter</name></expr> ?</condition><then> <expr><name>bgwriter_flush_after</name></expr> </then><else>: <expr><name>backend_flush_after</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>flushAfter</name> <operator>*=</operator> <name>BLCKSZ</name> <operator>/</operator> <name>ORIOLEDB_BLCKSZ</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>writeback</name><operator>-&gt;</operator><name>extentsNumber</name></name> <operator>&lt;</operator> <name>flushAfter</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pg_qsort</name><argument_list>(<argument><expr><name><name>writeback</name><operator>-&gt;</operator><name>extents</name></name></expr></argument>, <argument><expr><name><name>writeback</name><operator>-&gt;</operator><name>extentsNumber</name></name></expr></argument>,
			 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeOffset</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>tree_offsets_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>writeback</name><operator>-&gt;</operator><name>extentsNumber</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TreeOffset</name></type>	<name>cur</name> <init>= <expr><name><name>writeback</name><operator>-&gt;</operator><name>extents</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>datoid</name> <operator>!=</operator> <name><name>cur</name><operator>.</operator><name>datoid</name></name> <operator>||</operator> <name>relnode</name> <operator>!=</operator> <name><name>cur</name><operator>.</operator><name>relnode</name></name> <operator>||</operator> <name>segno</name> <operator>!=</operator> <name><name>cur</name><operator>.</operator><name>segno</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>use_mmap</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>msync</name><argument_list>(<argument><expr><name>mmap_data</name> <operator>+</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>segno</name> <operator>*</operator> <name>ORIOLEDB_SEGMENT_SIZE</name> <operator>+</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>offset</name> <operator>*</operator> <name>blcksz</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>len</name> <operator>*</operator> <name>blcksz</name></expr></argument>, <argument><expr><name>MS_ASYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>FileWriteback</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>offset</name> <operator>*</operator> <name>blcksz</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>len</name> <operator>*</operator> <name>blcksz</name></expr></argument>,
								  <argument><expr><name>WAIT_EVENT_DATA_FILE_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>file</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>blcksz</name> <operator>=</operator> <ternary><condition><expr><name><name>cur</name><operator>.</operator><name>compressed</name></name></expr> ?</condition><then> <expr><name>ORIOLEDB_COMP_BLCKSZ</name></expr> </then><else>: <expr><name>ORIOLEDB_BLCKSZ</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name>datoid</name> <operator>=</operator> <name><name>cur</name><operator>.</operator><name>datoid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>relnode</name> <operator>=</operator> <name><name>cur</name><operator>.</operator><name>relnode</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>segno</name> <operator>=</operator> <name><name>cur</name><operator>.</operator><name>segno</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_mmap</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>segno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>ORIOLEDB_DATA_DIR</name> <literal type="string">"/%u_%u"</literal></expr></argument>, <argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>relnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>ORIOLEDB_DATA_DIR</name> <literal type="string">"/%u_%u.%u"</literal></expr></argument>, <argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>relnode</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>cur</name><operator>.</operator><name>fileExtent</name><operator>.</operator><name>off</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>cur</name><operator>.</operator><name>fileExtent</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>.</operator><name>fileExtent</name><operator>.</operator><name>off</name></name> <operator>==</operator> <name>offset</name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>cur</name><operator>.</operator><name>fileExtent</name><operator>.</operator><name>off</name></name> <operator>==</operator> <name>offset</name> <operator>+</operator> <name>len</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>len</name> <operator>+=</operator> <name><name>cur</name><operator>.</operator><name>fileExtent</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>use_mmap</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>msync</name><argument_list>(<argument><expr><name>mmap_data</name> <operator>+</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>segno</name> <operator>*</operator> <name>ORIOLEDB_SEGMENT_SIZE</name> <operator>+</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>offset</name> <operator>*</operator> <name>blcksz</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>len</name> <operator>*</operator> <name>blcksz</name></expr></argument>, <argument><expr><name>MS_ASYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>FileWriteback</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>offset</name> <operator>*</operator> <name>blcksz</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>len</name> <operator>*</operator> <name>blcksz</name></expr></argument>,
								  <argument><expr><name>WAIT_EVENT_DATA_FILE_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>cur</name><operator>.</operator><name>fileExtent</name><operator>.</operator><name>off</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>cur</name><operator>.</operator><name>fileExtent</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blcksz</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>use_mmap</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>msync</name><argument_list>(<argument><expr><name>mmap_data</name> <operator>+</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>segno</name> <operator>*</operator> <name>ORIOLEDB_SEGMENT_SIZE</name> <operator>+</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>offset</name> <operator>*</operator> <name>blcksz</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>len</name> <operator>*</operator> <name>blcksz</name></expr></argument>, <argument><expr><name>MS_ASYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FileWriteback</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>offset</name> <operator>*</operator> <name>blcksz</name></expr></argument>,
						  <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>len</name> <operator>*</operator> <name>blcksz</name></expr></argument>,
						  <argument><expr><name>WAIT_EVENT_DATA_FILE_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_mmap</name> <operator>&amp;&amp;</operator> <name>file</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>writeback</name><operator>-&gt;</operator><name>extentsNumber</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>RelnodeFileCallback</name>) <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block">/*
 * Iterate all the files belonging to given (datoid, relnode) pair and call
 * the callback for each filename.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>iterate_relnode_files</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>datoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relnode</name></decl></parameter>, <parameter><decl><type><name>RelnodeFileCallback</name></type> <name>callback</name></decl></parameter>,
					  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>ext</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>segno</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name>ORIOLEDB_DATA_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><operator>(</operator><name>file</name> <operator>=</operator> <call><name>readdir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>file_datoid</name></decl>,
					<decl><type ref="prev"/><name>file_relnode</name></decl>,
					<decl><type ref="prev"/><name>file_chkp</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"%10u_%10u"</literal></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>file_datoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_relnode</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal> <operator>||</operator>
			<call><name>sscanf</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"%10u_%10u.%10u"</literal></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>file_datoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_relnode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>segno</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal> <operator>||</operator>
			<operator>(</operator><call><name>sscanf</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"%10u_%10u-%10u.%4s"</literal></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>file_datoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_relnode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_chkp</name></expr></argument>, <argument><expr><name>ext</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator>
			 <operator>(</operator><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"tmp"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"map"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>datoid</name> <operator>==</operator> <name>file_datoid</name> <operator>&amp;&amp;</operator> <name>relnode</name> <operator>==</operator> <name>file_relnode</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><name>ORIOLEDB_DATA_DIR</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>callback</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>unlink_callback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>cleanup_btree_files</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>datoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>iterate_relnode_files</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>relnode</name></expr></argument>, <argument><expr><name>unlink_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>fsync_callback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>fsync_fname</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>fsync_btree_files</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>datoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>iterate_relnode_files</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>relnode</name></expr></argument>, <argument><expr><name>fsync_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
