<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/btree/undo.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * undo.c
 *		Routines dealing with undo records of orioledb B-tree.
 *
 * Copyright (c) 2021-2022, Oriole DB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/btree/undo.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/find.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/merge.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/page_chunks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"recovery/recovery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tableam/descr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transam/oxid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transam/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/stopevent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/page_pool.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>

<comment type="block">/* Undo records */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>UndoStackItem</name></type> <name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeOperationType</name></type> <name>action</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ORelOids</name></type>	<name>oids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>pageChangeCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeLeafTuphdr</name></type> <name>tuphdr</name></decl>;</decl_stmt>
}</block></struct></type> <name>BTreeModifyUndoStackItem</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>OnCommitUndoStackItem</name></type> <name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>datoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldRelnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>oldNumTreeOids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>newRelnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>newNumTreeOids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fsync</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ORelOids</name></type>	<name><name>oids</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>RelnodeUndoStackItem</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clean_chain_has_locks_flag</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>,
									   <parameter><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>pageTuphdr</name></decl></parameter>,
									   <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Add page image to the undo log.
 */</comment>
<function><type><name>UndoLocation</name></type>
<name>page_add_item_to_undo</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>imageCsn</name></decl></parameter>,
					  <parameter><decl><type><name>OTuple</name> <modifier>*</modifier></type><name>splitKey</name></decl></parameter>, <parameter><decl><type><name>LocationIndex</name></type> <name>splitKeyLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoPageImageHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>undoLocation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>ptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>undoType</name></name> <operator>!=</operator> <name>UndoReserveNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>splitKey</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>get_undo_record</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>undoType</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>undoLocation</name></expr></argument>,
							  <argument><expr><call><name>O_SPLIT_UNDO_IMAGE_SIZE</name><argument_list>(<argument><expr><name>splitKeyLen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>get_undo_record</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>undoType</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>undoLocation</name></expr></argument>,
							  <argument><expr><name>O_COMPACT_UNDO_IMAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>UndoPageImageHeader</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>splitKey</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>UndoPageImageSplit</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>splitKeyFlags</name></name> <operator>=</operator> <name><name>splitKey</name><operator>-&gt;</operator><name>formatFlags</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>splitKeyLen</name></name> <operator>=</operator> <name>splitKeyLen</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>UndoPageImageCompact</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UndoPageImageHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>splitKey</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>ORIOLEDB_BLCKSZ</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>splitKey</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>splitKeyLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>undoLocation</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given page item modified by in-progress transaction.  Rollback changes
 * using undo chain.  Specify 'wholeChain' flag to revert all in-progress
 * changes from the chain.  Otherise, only last change item is reverted.
 *
 * Return true if page item still exists.
 *
 * 'nonLockTuphdrPtr' and 'nonLockUndoLocation' are a hint to the first
 * non-lock-only undo record in the chain.
 */</comment>
<function><type><name>bool</name></type>
<name>page_item_rollback</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>locator</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>wholeChain</name></decl></parameter>, <parameter><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>nonLockTuphdrPtr</name></decl></parameter>,
				   <parameter><decl><type><name>UndoLocation</name></type> <name>nonLockUndoLocation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl>,
				<decl><type ref="prev"/><name>nonLockTuphdr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuphdr</name> <operator>=</operator> <operator>(</operator><name>BTreeLeafTuphdr</name> <operator>*</operator><operator>)</operator> <name>item</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nonLockTuphdrPtr</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nonLockTuphdr</name> <operator>=</operator> <operator>*</operator><name>tuphdr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nonLockTuphdrPtr</name> <operator>=</operator> <operator>&amp;</operator><name>nonLockTuphdr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nonLockUndoLocation</name> <operator>=</operator> <call><name>find_non_lock_only_undo_record</name><argument_list>(<argument><expr><name>nonLockTuphdrPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<label><name>retry</name>:</label>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tuphdr</name><operator>-&gt;</operator><name>deleted</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>prev_tuple</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Revert deletion.  Assuming tuple is deleted, we shouldn't have any
		 * row-level lock on this tuple.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>nonLockUndoLocation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UNDO_REC_EXISTS</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>get_prev_leaf_header_from_undo</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTREE_PAGE_READ_TUPLE</name><argument_list>(<argument><expr><name>prev_tuple</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PAGE_SUB_N_VACATED</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
						   <argument><expr><name>BTreeLeafTuphdrSize</name> <operator>+</operator>
						   <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>prev_tuple</name></expr></argument>, <argument><expr><name>OTupleLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>nonLockUndoLocation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>nonLockTuphdrPtr</name> <operator>=</operator> <operator>*</operator><name>tuphdr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>wholeChain</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name><name>nonLockTuphdrPtr</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Current tuple is not deleted.  And there is a pointer to previous
		 * version in chain.  This must be update (or insert to previously
		 * deleted tuple).
		 */</comment>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>prev_tuplen</name></decl>,
					<decl><type ref="prev"/><name>tuplen</name></decl>,
					<decl><type ref="prev"/><name>itemlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTreeLeafTuphdr</name></type> <name>prev_header</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>prev_header</name> <operator>=</operator> <operator>*</operator><name>nonLockTuphdrPtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <call><name>BTREE_PAGE_GET_ITEM_FLAGS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>item</name> <operator>+</operator> <name>BTreeLeafTuphdrSize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev_tuplen</name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>OTupleLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tuplen</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>BTreeLeafTuphdrSize</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_prev_leaf_header_and_tuple_from_undo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prev_header</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>,
												 <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuplen</name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>OTupleLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemlen</name> <operator>=</operator> <name>BTreeLeafTuphdrSize</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemlen</name> <operator>&lt;=</operator> <call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name><name>prev_header</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PAGE_SUB_N_VACATED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call> <operator>-</operator>
							   <operator>(</operator><name>BTreeLeafTuphdrSize</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>prev_tuplen</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>page_locator_resize_item</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>, <argument><expr><name>itemlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>PAGE_ADD_N_VACATED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>prev_tuplen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PAGE_SUB_N_VACATED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>prev_header</name><operator>.</operator><name>deleted</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PAGE_ADD_N_VACATED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BTreeLeafTuphdrSize</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>nonLockUndoLocation</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>nonLockTuphdrPtr</name> <operator>=</operator> <operator>*</operator><name>tuphdr</name> <operator>=</operator> <name>prev_header</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>deleted</name></name> <operator>=</operator> <name><name>prev_header</name><operator>.</operator><name>deleted</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nonLockTuphdrPtr</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>=</operator> <name><name>prev_header</name><operator>.</operator><name>undoLocation</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nonLockTuphdrPtr</name><operator>-&gt;</operator><name>xactInfo</name></name> <operator>=</operator> <name><name>prev_header</name><operator>.</operator><name>xactInfo</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>update_leaf_header_in_undo</name><argument_list>(<argument><expr><name>nonLockTuphdrPtr</name></expr></argument>, <argument><expr><name>nonLockUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>BTREE_PAGE_SET_ITEM_FLAGS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>.</operator><name>formatFlags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Follow the row-level undo chain if needed */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>nonLockUndoLocation</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <operator>!</operator><call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name><name>prev_header</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <name>wholeChain</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Find the next item in the chain */</comment>
			<expr_stmt><expr><name>nonLockUndoLocation</name> <operator>=</operator> <call><name>find_non_lock_only_undo_record</name><argument_list>(<argument><expr><name>nonLockTuphdrPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name><name>nonLockTuphdrPtr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tuphdr</name> <operator>=</operator> <operator>(</operator><name>BTreeLeafTuphdr</name> <operator>*</operator><operator>)</operator> <name>item</name></expr>;</expr_stmt>
			<goto>goto <name>retry</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>prev_tuple</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Revert insertion of new tuple.  Assuming insertion is in-progress,
		 * we shouldn't have any row-level lock on this tuple.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>nonLockUndoLocation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>BTREE_PAGE_READ_TUPLE</name><argument_list>(<argument><expr><name>prev_tuple</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PAGE_SUB_N_VACATED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call> <operator>-</operator>
						   <operator>(</operator><name>BTreeLeafTuphdrSize</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>prev_tuple</name></expr></argument>, <argument><expr><name>OTupleLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>page_locator_delete_item</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Jsonb</name> <modifier>*</modifier></type>
<name>undo_record_key_stopevent_params</name><parameter_list>(<parameter><decl><type><name>BTreeOperationType</name></type> <name>action</name></decl></parameter>,
								 <parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>,
								 <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mctx</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>stopevents_cxt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>WJB_BEGIN_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BTreeOperationInsert</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>jsonb_push_string_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"action"</literal></expr></argument>, <argument><expr><literal type="string">"insert"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>action</name> <operator>==</operator> <name>BTreeOperationUpdate</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>jsonb_push_string_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"action"</literal></expr></argument>, <argument><expr><literal type="string">"update"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>action</name> <operator>==</operator> <name>BTreeOperationDelete</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>jsonb_push_string_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"action"</literal></expr></argument>, <argument><expr><literal type="string">"delete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>action</name> <operator>==</operator> <name>BTreeOperationLock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>jsonb_push_string_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"action"</literal></expr></argument>, <argument><expr><literal type="string">"lock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>jsonb_push_int8_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"oxid"</literal></expr></argument>, <argument><expr><name>oxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>btree_desc_stopevent_params_internal</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jsonb_push_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="string">"key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BTreeOperationUpdate</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>key</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>allocated</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>o_btree_tuple_make_key</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>allocated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>o_btree_key_to_jsonb</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>allocated</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>o_btree_key_to_jsonb</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>WJB_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Make undo record associated with give tuple and operation.
 */</comment>
<function><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type>
<name>make_undo_record</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_tuple</name></decl></parameter>,
				 <parameter><decl><type><name>BTreeOperationType</name></type> <name>action</name></decl></parameter>, <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>,
				 <parameter><decl><type><name>uint32</name></type> <name>pageChangeCount</name></decl></parameter>,
				 <parameter><decl><type><name>UndoLocation</name> <modifier>*</modifier></type><name>undoLocation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>tuplelen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeModifyUndoStackItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>size</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BTreeOperationUpdate</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>is_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuplelen</name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>OTupleLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>tuplelen</name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><ternary><condition><expr><name>is_tuple</name></expr> ?</condition><then> <expr><name>OTupleKeyLength</name></expr> </then><else>: <expr><name>OKeyLength</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTreeModifyUndoStackItem</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>tuplelen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>BTreeModifyUndoStackItem</name> <operator>*</operator><operator>)</operator> <call><name>get_undo_record</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>undoType</name></name></expr></argument>,
														<argument><expr><name>undoLocation</name></expr></argument>,
														<argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>itemSize</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BTreeOperationLock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>RowLockUndoItemType</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>ModifyUndoItemType</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>indexType</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>action</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>pageChangeCount</name></name> <operator>=</operator> <name>pageChangeCount</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>oids</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BTreeOperationUpdate</name> <operator>||</operator> <operator>!</operator><name>is_tuple</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>item</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTreeModifyUndoStackItem</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			   <argument><expr><name><name>tuple</name><operator>.</operator><name>data</name></name></expr></argument>,
			   <argument><expr><name>tuplelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>tuphdr</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>tuple</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>key_palloc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>key</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>item</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTreeModifyUndoStackItem</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tuplelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>o_btree_tuple_make_key</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
									 <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>item</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTreeModifyUndoStackItem</name></expr></argument>)</argument_list></sizeof></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key_palloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>tuphdr</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>key</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>key_palloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>add_new_undo_stack_item</name><argument_list>(<argument><expr><operator>*</operator><name>undoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>undoLocation</name> <operator>+=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>BTreeModifyUndoStackItem</name></expr></argument>, <argument><expr><name>tuphdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>tuphdr</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BTreeDescr</name> <modifier>*</modifier></type>
<name>get_tree_descr</name><parameter_list>(<parameter><decl><type><name>ORelOids</name></type> <name>oids</name></decl></parameter>, <parameter><decl><type><name>OIndexType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IS_SYS_TREE_OIDS</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>get_sys_tree</name><argument_list>(<argument><expr><name><name>oids</name><operator>.</operator><name>relnode</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>descr</name> <init>= <expr><call><name>o_fetch_index_descr</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>descr</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>desc</name></name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Callback for aborting B-tree record modification.
 */</comment>
<function><type><name>void</name></type>
<name>modify_undo_callback</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>UndoStackItem</name> <modifier>*</modifier></type><name>baseItem</name></decl></parameter>,
					 <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>abort</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>changeCountsValid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeModifyUndoStackItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>(</operator><name>BTreeModifyUndoStackItem</name> <operator>*</operator><operator>)</operator> <name>baseItem</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><call><name>get_tree_descr</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>indexType</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tupHdr</name></decl>,
				<decl><type ref="prev"/><name>nonLockTupHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>nonLockUndoLocation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeKeyType</name></type> <name>keyType</name> <init>= <expr><ternary><condition><expr><name><name>item</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>BTreeOperationUpdate</name></expr> ?</condition><then> <expr><name>BTreeKeyLeafTuple</name></expr> </then><else>: <expr><name>BTreeKeyNonLeafKey</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>abort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>desc</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>tuphdr</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>item</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTreeModifyUndoStackItem</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>STOPEVENTS_ENABLED</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>params</name> <init>= <expr><call><name>undo_record_key_stopevent_params</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>action</name></name></expr></argument>,
															  <argument><expr><name>desc</name></expr></argument>,
															  <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>STOPEVENT</name><argument_list>(<argument><expr><name>STOPEVENT_APPLY_UNDO</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_page_find_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>,
						   <argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>,
						   <argument><expr><name>BTREE_PAGE_FIND_MODIFY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>changeCountsValid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>pageChangeCount</name></name> <operator>=</operator> <name>InvalidOPageChangeCount</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>refind_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><name>keyType</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name><name>item</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>pageChangeCount</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * BTree can be already deleted and cleaned by
		 * btree_relnode_undo_callback().
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>&amp;</operator><name><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>leafTup</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tupHdr</name></expr></argument>, <argument><expr><name>leafTup</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><name>keyType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leafTup</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can't find the required key.  This might happend if operation
		 * was already "undone" earlier.
		 */</comment>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>nonLockTupHdr</name> <operator>=</operator> <operator>*</operator><name>tupHdr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nonLockUndoLocation</name> <operator>=</operator> <call><name>find_non_lock_only_undo_record</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nonLockTupHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XACT_INFO_OXID_EQ</name><argument_list>(<argument><expr><name><name>nonLockTupHdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The key is found, but it doesn't belong to our transaction.  Again,
		 * this might happend if operation was already "undone" earlier.
		 */</comment>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that undo chain item matches to the tuple item.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>nonLockTupHdr</name><operator>.</operator><name>undoLocation</name></name> <operator>==</operator> <name>location</name> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>BTreeModifyUndoStackItem</name></expr></argument>, <argument><expr><name>tuphdr</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>(</operator><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name><name>nonLockTupHdr</name><operator>.</operator><name>undoLocation</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>item</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>BTreeOperationInsert</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>page_item_rollback</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>nonLockTupHdr</name></expr></argument>, <argument><expr><name>nonLockUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MARK_DIRTY</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>!=</operator> <name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name> <operator>&amp;&amp;</operator> <call><name>is_page_too_sparse</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We can try to merge this page */</comment>
		<expr_stmt><expr><call><name>btree_try_merge_and_unlock</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>desc</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Callback for aborting B-tree tuple lock.
 */</comment>
<function><type><name>void</name></type>
<name>lock_undo_callback</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>UndoStackItem</name> <modifier>*</modifier></type><name>baseItem</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>abort</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>changeCountsValid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeModifyUndoStackItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>(</operator><name>BTreeModifyUndoStackItem</name> <operator>*</operator><operator>)</operator> <name>baseItem</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><call><name>get_tree_descr</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>indexType</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>page_tuphdr</name></decl>,
				<decl><type ref="prev"/><name>tuphdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>locptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>tuphdrUndoLocation</name></decl>,
				<decl><type ref="prev"/><name>lastLockOnlyUndoLocation</name> <init>= <expr><name>InvalidUndoLocation</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>abort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>desc</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>tuphdr</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>item</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTreeModifyUndoStackItem</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>STOPEVENTS_ENABLED</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>params</name> <init>= <expr><call><name>undo_record_key_stopevent_params</name><argument_list>(<argument><expr><name>BTreeOperationLock</name></expr></argument>,
															  <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>STOPEVENT</name><argument_list>(<argument><expr><name>STOPEVENT_APPLY_UNDO</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_page_find_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>, <argument><expr><name>BTREE_PAGE_FIND_MODIFY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>changeCountsValid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>pageChangeCount</name></name> <operator>=</operator> <name>InvalidOPageChangeCount</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>refind_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>pageChangeCount</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * BTree can be already deleted and cleaned by
		 * btree_relnode_undo_callback().
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>locptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locptr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>leafTup</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>BTREE_PAGE_READ_TUPLE</name><argument_list>(<argument><expr><name>leafTup</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>locptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leafTup</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Row already gone. Nothing to do. */</comment>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>page_tuphdr</name> <operator>=</operator> <operator>(</operator><name>BTreeLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuphdr</name> <operator>=</operator> <operator>*</operator><name>page_tuphdr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuphdrUndoLocation</name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>!</operator><call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>tuphdr</name><operator>.</operator><name>chainHasLocks</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>delete_record</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>UndoLocation</name></type> <name>undoLocation</name> <init>= <expr><name><name>tuphdr</name><operator>.</operator><name>undoLocation</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTreeLeafTuphdr</name></type> <name>prev_tuphdr</name> <init>= <expr><name>tuphdr</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>UNDO_REC_EXISTS</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_prev_leaf_header_from_undo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prev_tuphdr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>XACT_INFO_GET_OXID</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>oxid</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>tuphdr</name><operator>.</operator><name>undoLocation</name></name> <operator>==</operator> <name>location</name> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>BTreeModifyUndoStackItem</name></expr></argument>, <argument><expr><name>tuphdr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>delete_record</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>delete_record</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tuphdr</name><operator>.</operator><name>chainHasLocks</name></name> <operator>&amp;&amp;</operator>
				<call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>clean_chain_has_locks_flag</name><argument_list>(<argument><expr><name>lastLockOnlyUndoLocation</name></expr></argument>,
										   <argument><expr><name>page_tuphdr</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>tuphdrUndoLocation</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>page_tuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name> <operator>=</operator> <name><name>prev_tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>page_tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>=</operator> <name><name>prev_tuphdr</name><operator>.</operator><name>undoLocation</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>page_tuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name> <operator>=</operator> <name><name>prev_tuphdr</name><operator>.</operator><name>chainHasLocks</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tuphdr</name> <operator>=</operator> <operator>*</operator><name>page_tuphdr</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MARK_DIRTY</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name> <operator>=</operator> <name><name>prev_tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tuphdr</name><operator>.</operator><name>undoLocation</name></name> <operator>=</operator> <name><name>prev_tuphdr</name><operator>.</operator><name>undoLocation</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tuphdr</name><operator>.</operator><name>chainHasLocks</name></name> <operator>=</operator> <name><name>prev_tuphdr</name><operator>.</operator><name>chainHasLocks</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>update_leaf_header_in_undo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuphdr</name></expr></argument>, <argument><expr><name>tuphdrUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We should be able to find at CSN-record or invalid undo location
		 * before running out of undo records.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UNDO_REC_EXISTS</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lastLockOnlyUndoLocation</name> <operator>=</operator> <name>tuphdrUndoLocation</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tuphdr</name> <operator>=</operator> <name>prev_tuphdr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuphdrUndoLocation</name> <operator>=</operator> <name>undoLocation</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>undoLocation</name> <operator>=</operator> <name><name>tuphdr</name><operator>.</operator><name>undoLocation</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Change relnode of btree.
 */</comment>
<function><type><name>void</name></type>
<name>btree_relnode_undo_callback</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>UndoStackItem</name> <modifier>*</modifier></type><name>baseItem</name></decl></parameter>,
							<parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>abort</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>changeCountsValid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelnodeUndoStackItem</name> <modifier>*</modifier></type><name>relnode_item</name> <init>= <expr><operator>(</operator><name>RelnodeUndoStackItem</name> <operator>*</operator><operator>)</operator> <name>baseItem</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>datoid</name></decl>,
				<decl><type ref="prev"/><name>reloid</name></decl>,
				<decl><type ref="prev"/><name>dropRelnode</name></decl>,
				<decl><type ref="prev"/><name>remainRelnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dropNumTreeOids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ORelOids</name>   <modifier>*</modifier></type><name>dropTreeOids</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>datoid</name> <operator>=</operator> <name><name>relnode_item</name><operator>-&gt;</operator><name>datoid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>reloid</name> <operator>=</operator> <name><name>relnode_item</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>abort</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dropRelnode</name> <operator>=</operator> <name><name>relnode_item</name><operator>-&gt;</operator><name>oldRelnode</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>remainRelnode</name> <operator>=</operator> <name><name>relnode_item</name><operator>-&gt;</operator><name>newRelnode</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dropTreeOids</name> <operator>=</operator> <operator>&amp;</operator><name><name>relnode_item</name><operator>-&gt;</operator><name>oids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dropNumTreeOids</name> <operator>=</operator> <name><name>relnode_item</name><operator>-&gt;</operator><name>oldNumTreeOids</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>dropRelnode</name> <operator>=</operator> <name><name>relnode_item</name><operator>-&gt;</operator><name>newRelnode</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>remainRelnode</name> <operator>=</operator> <name><name>relnode_item</name><operator>-&gt;</operator><name>oldRelnode</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dropTreeOids</name> <operator>=</operator> <operator>&amp;</operator><name><name>relnode_item</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name><name>relnode_item</name><operator>-&gt;</operator><name>oldNumTreeOids</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dropNumTreeOids</name> <operator>=</operator> <name><name>relnode_item</name><operator>-&gt;</operator><name>newNumTreeOids</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Fsync new files if required */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>abort</name> <operator>&amp;&amp;</operator>
		<call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>relnode_item</name><operator>-&gt;</operator><name>newRelnode</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>relnode_item</name><operator>-&gt;</operator><name>fsync</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>numTreeOids</name> <init>= <expr><name><name>relnode_item</name><operator>-&gt;</operator><name>newNumTreeOids</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ORelOids</name>   <modifier>*</modifier></type><name>treeOids</name> <init>= <expr><operator>&amp;</operator><name><name>relnode_item</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name><name>relnode_item</name><operator>-&gt;</operator><name>oldNumTreeOids</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTreeOids</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fsync_btree_files</name><argument_list>(<argument><expr><name><name>treeOids</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>datoid</name></expr></argument>,
							  <argument><expr><name><name>treeOids</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>dropRelnode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>recovery</name> <init>= <expr><call><name>is_recovery_in_progress</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ORelOids</name></type>	<name>oids</name> <init>= <expr><block>{<expr><name>datoid</name></expr>, <expr><name>reloid</name></expr>, <expr><name>dropRelnode</name></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recovery</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>o_tables_rel_lock_extended</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oids</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>o_tables_rel_lock_extended</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oids</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CacheInvalidateRelcacheByDbidRelid</name><argument_list>(<argument><expr><name>datoid</name></expr></argument>, <argument><expr><name>reloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>o_invalidate_oids</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recovery</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>o_tables_rel_unlock_extended</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oids</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>o_tables_rel_unlock_extended</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oids</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dropNumTreeOids</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recovery</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>o_tables_rel_lock_extended</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dropTreeOids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>o_tables_rel_lock_extended</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dropTreeOids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>cleanup_btree</name><argument_list>(<argument><expr><name><name>dropTreeOids</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>datoid</name></expr></argument>, <argument><expr><name><name>dropTreeOids</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>o_invalidate_oids</name><argument_list>(<argument><expr><name><name>dropTreeOids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recovery</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>o_tables_rel_unlock_extended</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dropTreeOids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>o_tables_rel_unlock_extended</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dropTreeOids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>remainRelnode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ORelOids</name></type>	<name>oids</name> <init>= <expr><block>{<expr><name>datoid</name></expr>, <expr><name>reloid</name></expr>, <expr><name>remainRelnode</name></expr>}</block></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>o_invalidate_oids</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * oldTreeOids and newTreeOids should be allocated in CurTransactionContext.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>add_undo_relnode</name><parameter_list>(<parameter><decl><type><name>ORelOids</name></type> <name>oldOids</name></decl></parameter>, <parameter><decl><type><name>ORelOids</name> <modifier>*</modifier></type><name>oldTreeOids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>oldNumTreeOids</name></decl></parameter>,
				 <parameter><decl><type><name>ORelOids</name></type> <name>newOids</name></decl></parameter>, <parameter><decl><type><name>ORelOids</name> <modifier>*</modifier></type><name>newTreeOids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newNumTreeOids</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>fsync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>location</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelnodeUndoStackItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>RelnodeUndoStackItem</name></expr></argument>, <argument><expr><name>oids</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ORelOids</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>oldNumTreeOids</name> <operator>+</operator> <name>newNumTreeOids</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>RelnodeUndoStackItem</name> <operator>*</operator><operator>)</operator> <call><name>get_undo_record_unreserved</name><argument_list>(<argument><expr><name>UndoReserveTxn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>location</name></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>base</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>RelnodeUndoItemType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>base</name><operator>.</operator><name>itemSize</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>base</name><operator>.</operator><name>indexType</name></name> <operator>=</operator> <name>oIndexPrimary</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ORelOidsIsValid</name><argument_list>(<argument><expr><name>oldOids</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ORelOidsIsValid</name><argument_list>(<argument><expr><name>newOids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ORelOidsIsValid</name><argument_list>(<argument><expr><name>oldOids</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>datoid</name></name> <operator>=</operator> <name><name>oldOids</name><operator>.</operator><name>datoid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name><name>oldOids</name><operator>.</operator><name>reloid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>datoid</name></name> <operator>=</operator> <name><name>newOids</name><operator>.</operator><name>datoid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name><name>newOids</name><operator>.</operator><name>reloid</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>oldRelnode</name></name> <operator>=</operator> <name><name>oldOids</name><operator>.</operator><name>relnode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>oldNumTreeOids</name></name> <operator>=</operator> <name>oldNumTreeOids</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>newRelnode</name></name> <operator>=</operator> <name><name>newOids</name><operator>.</operator><name>relnode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>newNumTreeOids</name></name> <operator>=</operator> <name>newNumTreeOids</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>fsync</name></name> <operator>=</operator> <name>fsync</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldNumTreeOids</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oldTreeOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>,
			   <argument><expr><name>oldTreeOids</name></expr></argument>,
			   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ORelOids</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>oldNumTreeOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>newNumTreeOids</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newTreeOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>oldNumTreeOids</name></expr>]</index></name></expr></argument>,
			   <argument><expr><name>newTreeOids</name></expr></argument>,
			   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ORelOids</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>newNumTreeOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * This might happend before we accessed oxid.  So, ensure we've assigned
	 * it.
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_current_oxid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oxid_needs_wal_flush</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_new_undo_stack_item</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>release_undo_size</name><argument_list>(<argument><expr><name>UndoReserveTxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>add_undo_truncate_relnode</name><parameter_list>(<parameter><decl><type><name>ORelOids</name></type> <name>oldOids</name></decl></parameter>, <parameter><decl><type><name>ORelOids</name> <modifier>*</modifier></type><name>oldTreeOids</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>oldNumTreeOids</name></decl></parameter>,
						  <parameter><decl><type><name>ORelOids</name></type> <name>newOids</name></decl></parameter>, <parameter><decl><type><name>ORelOids</name> <modifier>*</modifier></type><name>newTreeOids</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>newNumTreeOids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ORelOidsIsValid</name><argument_list>(<argument><expr><name>oldOids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ORelOidsIsValid</name><argument_list>(<argument><expr><name>newOids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>oldOids</name><operator>.</operator><name>datoid</name></name> <operator>==</operator> <name><name>newOids</name><operator>.</operator><name>datoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>oldOids</name><operator>.</operator><name>reloid</name></name> <operator>==</operator> <name><name>newOids</name><operator>.</operator><name>reloid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>add_undo_relnode</name><argument_list>(<argument><expr><name>oldOids</name></expr></argument>, <argument><expr><name>oldTreeOids</name></expr></argument>, <argument><expr><name>oldNumTreeOids</name></expr></argument>,
					 <argument><expr><name>newOids</name></expr></argument>, <argument><expr><name>newTreeOids</name></expr></argument>, <argument><expr><name>newNumTreeOids</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>add_undo_drop_relnode</name><parameter_list>(<parameter><decl><type><name>ORelOids</name></type> <name>oids</name></decl></parameter>, <parameter><decl><type><name>ORelOids</name> <modifier>*</modifier></type><name>treeOids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTreeOids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ORelOids</name></type>	<name>invalid</name> <init>= <expr><block>{<expr><name>InvalidOid</name></expr>, <expr><name>InvalidOid</name></expr>, <expr><name>InvalidOid</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ORelOidsIsValid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_undo_relnode</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name>treeOids</name></expr></argument>, <argument><expr><name>numTreeOids</name></expr></argument>, <argument><expr><name>invalid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>add_undo_create_relnode</name><parameter_list>(<parameter><decl><type><name>ORelOids</name></type> <name>oids</name></decl></parameter>, <parameter><decl><type><name>ORelOids</name> <modifier>*</modifier></type><name>treeOids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTreeOids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ORelOids</name></type>	<name>invalid</name> <init>= <expr><block>{<expr><name>InvalidOid</name></expr>, <expr><name>InvalidOid</name></expr>, <expr><name>InvalidOid</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ORelOidsIsValid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_undo_relnode</name><argument_list>(<argument><expr><name>invalid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>oids</name></expr></argument>, <argument><expr><name>treeOids</name></expr></argument>, <argument><expr><name>numTreeOids</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>read_hikey_from_undo</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>LocationIndex</name> <modifier>*</modifier></type><name>loc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>undo_read</name><argument_list>(<argument><expr><name>location</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTreePageHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>loc</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTreePageHeader</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>undo_read</name><argument_list>(<argument><expr><name>location</name> <operator>+</operator> <operator>*</operator><name>loc</name></expr></argument>,
			  <argument><expr><operator>(</operator><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>dest</name><operator>)</operator><operator>-&gt;</operator><name>hikeysEnd</name> <operator>-</operator> <operator>*</operator><name>loc</name></expr></argument>,
			  <argument><expr><name>dest</name> <operator>+</operator> <operator>*</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>dest</name><operator>)</operator><operator>-&gt;</operator><name>hikeysEnd</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Finds page image in undoLocation.
 */</comment>
<function><type><name>void</name></type>
<name>get_page_from_undo</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name></type> <name>undoLocation</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>key</name></decl></parameter>,
				   <parameter><decl><type><name>BTreeKeyType</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>dest</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_left</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_right</name></decl></parameter>, <parameter><decl><type><name>OFixedKey</name> <modifier>*</modifier></type><name>lokey</name></decl></parameter>,
				   <parameter><decl><type><name>OFixedKey</name> <modifier>*</modifier></type><name>page_lokey</name></decl></parameter>, <parameter><decl><type><name>OTuple</name> <modifier>*</modifier></type><name>page_hikey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoPageImageHeader</name></type> <name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>,
				<decl><type ref="prev"/><name>cmp_expected</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>hikey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>left_loc</name></decl>,
				<decl><type ref="prev"/><name>right_loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>loc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>undo_read</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UndoPageImageHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>left_loc</name> <operator>=</operator> <name>undoLocation</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UndoPageImageHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_left</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>is_left</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_right</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>is_right</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* there is only one page, no need to choose */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>UndoPageImageSplit</name> <operator>||</operator>
		<name><name>header</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>UndoPageImageCompact</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_left</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>is_left</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_right</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>is_right</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>undo_read</name><argument_list>(<argument><expr><name>left_loc</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>page_lokey</name> <operator>&amp;&amp;</operator> <name><name>header</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>UndoPageImageSplit</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>set_page_lokey</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>page_hikey</name> <operator>||</operator> <call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><operator>*</operator><name>page_hikey</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>set_page_lokey</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OTuple</name></type>		<name>hikey</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>page_hikey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hikey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cmp</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>set_page_lokey</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>set_page_lokey</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>undo_read</name><argument_list>(<argument><expr><name>left_loc</name> <operator>+</operator> <name>ORIOLEDB_BLCKSZ</name></expr></argument>,
						  <argument><expr><name><name>header</name><operator>.</operator><name>splitKeyLen</name></name></expr></argument>,
						  <argument><expr><name><name>page_lokey</name><operator>-&gt;</operator><name>fixedData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>page_lokey</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>header</name><operator>.</operator><name>splitKeyFlags</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>page_lokey</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name><name>page_lokey</name><operator>-&gt;</operator><name>fixedData</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>right_loc</name> <operator>=</operator> <name>left_loc</name> <operator>+</operator> <name>ORIOLEDB_BLCKSZ</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * It's dual undo log page image. We should make decision which page (left
	 * or right) should be returned.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>header</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>UndoPageImageMerge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>kind</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BTreeKeyNone</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>is_left</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>is_left</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>undo_read</name><argument_list>(<argument><expr><name>left_loc</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>BTreeKeyRightmost</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>is_right</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>is_right</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>lokey</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>read_hikey_from_undo</name><argument_list>(<argument><expr><name>left_loc</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>copy_fixed_hikey</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>lokey</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>undo_read</name><argument_list>(<argument><expr><name>right_loc</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>BTreeKeyLeafTuple</name></expr>:</case>
		<case>case <expr><name>BTreeKeyNonLeafKey</name></expr>:</case>
		<case>case <expr><name>BTreeKeyBound</name></expr>:</case>
		<case>case <expr><name>BTreeKeyPageHiKey</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>read_hikey_from_undo</name><argument_list>(<argument><expr><name>left_loc</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>cmp_expected</name> <operator>=</operator> <ternary><condition><expr><name>kind</name> <operator>==</operator> <name>BTreeKeyPageHiKey</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name>kind</name> <operator>=</operator> <ternary><condition><expr><name>kind</name> <operator>==</operator> <name>BTreeKeyPageHiKey</name></expr> ?</condition><then> <expr><name>BTreeKeyNonLeafKey</name></expr> </then><else>: <expr><name>kind</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hikey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;=</operator> <name>cmp_expected</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>is_right</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>is_right</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>lokey</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>copy_fixed_hikey</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>lokey</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>undo_read</name><argument_list>(<argument><expr><name>right_loc</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>is_left</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>is_left</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>undo_read</name><argument_list>(<argument><expr><name>left_loc</name> <operator>+</operator> <name>loc</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name> <operator>-</operator> <name>loc</name></expr></argument>, <argument><expr><name>dest</name> <operator>+</operator> <name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Copy images of the left and the right pages into undo log.
 */</comment>
<function><type><name>UndoLocation</name></type>
<name>make_merge_undo_image</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>left</name></decl></parameter>,
					  <parameter><decl><type><name>Pointer</name></type> <name>right</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>imageCsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoPageImageHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>undoLocation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>undo_rec</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>undoType</name></name> <operator>!=</operator> <name>UndoReserveNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>undo_rec</name> <operator>=</operator> <call><name>get_undo_record</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>undoType</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>undoLocation</name></expr></argument>, <argument><expr><name>O_MERGE_UNDO_IMAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>UndoPageImageHeader</name> <operator>*</operator><operator>)</operator> <name>undo_rec</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>UndoPageImageMerge</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>undo_rec</name> <operator>=</operator> <name>undo_rec</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UndoPageImageHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>undo_rec</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>undo_rec</name> <operator>+</operator> <name>ORIOLEDB_BLCKSZ</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>undoLocation</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Clean `chainHasLocks` flag on given and previous undo locations.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>clean_chain_has_locks_flag</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>pageTuphdr</name></decl></parameter>,
						   <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeLeafTuphdr</name></type> <name>tuphdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>retainedUndoLocation</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_recovery_process</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>retainedUndoLocation</name> <operator>=</operator> <call><name>get_snapshot_retained_undo_location</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>retainedUndoLocation</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>undo_meta</name><operator>-&gt;</operator><name>checkpointRetainStartLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Invalid location means that we should update starting from the
	 * pageTuphdr. Clean `chainHasLocks` flag there if needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>location</name> <operator>&lt;</operator> <name>retainedUndoLocation</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pageTuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pageTuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>location</name> <operator>=</operator> <name><name>pageTuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Iteratively clean `chainHasLocks` flag in the rest of chain.
	 */</comment>
	<while>while <condition>(<expr><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>location</name> <operator>&gt;=</operator> <name>retainedUndoLocation</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UNDO_REC_EXISTS</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>undo_read</name><argument_list>(<argument><expr><name>location</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tuphdr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>tuphdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tuphdr</name><operator>.</operator><name>chainHasLocks</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>tuphdr</name><operator>.</operator><name>chainHasLocks</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>undo_write</name><argument_list>(<argument><expr><name>location</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tuphdr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>tuphdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>location</name> <operator>=</operator> <name><name>tuphdr</name><operator>.</operator><name>undoLocation</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * Check for row-level lock conflict
 *
 * Returns true if lock conflict.  On lock conflict places the conflicting undo
 * record info *conflictTuphdr.
 *
 * Otherwise, places the first csn undo record info *conflictTuphdr.
 * If there is no such undo records, then *conflictTuphdr is set to
 * *pageTuphdr.
 *
 * Lock-only undo records from committed and aborted transactions are removed.
 * Own lock-only undo records of the same or weaker level are removed.
 */</comment>
<function><type><name>bool</name></type>
<name>row_lock_conflicts</name><parameter_list>(<parameter><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>pageTuphdr</name></decl></parameter>,
				   <parameter><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>conflictTuphdr</name></decl></parameter>,
				   <parameter><decl><type><name>UndoLocation</name> <modifier>*</modifier></type><name>conflictUndoLocation</name></decl></parameter>,
				   <parameter><decl><type><name>RowLockMode</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>my_oxid</name></decl></parameter>, <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>,
				   <parameter><decl><type><name>UndoLocation</name></type> <name>savepointUndoLocation</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>redundant_row_locks</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>already_locked</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTupleXactInfo</name></type> <name>xactInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>xactIsfinished</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>undoLocation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>lastLockOnlyUndoLocation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeLeafTuphdr</name></type> <name>finishedTuphdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>finishedUndoLocation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>retainedUndoLocation</name> <init>= <expr><call><name>get_snapshot_retained_undo_location</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>foundFinished</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>finishedTuphdr</name> <operator>=</operator> <operator>*</operator><name>conflictTuphdr</name> <operator>=</operator> <operator>*</operator><name>pageTuphdr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>finishedUndoLocation</name> <operator>=</operator> <operator>*</operator><name>conflictUndoLocation</name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lastLockOnlyUndoLocation</name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>xactInfo</name> <operator>=</operator> <name><name>conflictTuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>xactIsfinished</name> <operator>=</operator> <call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>foundFinished</name> <operator>=</operator> <name>xactIsfinished</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>undoLocation</name> <operator>=</operator> <name><name>conflictTuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name><name>conflictTuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name> <operator>||</operator>
		   <call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <operator>!</operator><name>xactIsfinished</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>prevChainHasLocks</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>delete_record</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>XACT_INFO_GET_OXID</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>my_oxid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Check if there are redundant row-level locks */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_GET_LOCK_MODE</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>mode</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>savepointUndoLocation</name></expr></argument>)</argument_list></call> <operator>||</operator>
				 <operator>(</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				  <name>undoLocation</name> <operator>&gt;=</operator> <name>savepointUndoLocation</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>redundant_row_locks</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_GET_LOCK_MODE</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>mode</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>already_locked</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>ROW_LOCKS_CONFLICT</name><argument_list>(<argument><expr><call><name>XACT_INFO_GET_LOCK_MODE</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreeLeafTuphdr</name></type> <name>prev_tuphdr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name> <init>= <expr><call><name>XACT_INFO_GET_OXID</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>oxid</name> <operator>!=</operator> <name>my_oxid</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Row-level locks make sense only for in-progress
				 * transactions. We delete RLL for both committed and aborted
				 * transactions.
				 */</comment>
				<expr_stmt><expr><name>csn</name> <operator>=</operator> <call><name>oxid_get_csn</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>COMMITSEQNO_IS_ABORTED</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<call><name>COMMITSEQNO_IS_NORMAL</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<call><name>COMMITSEQNO_IS_FROZEN</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>delete_record</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>delete_record</name> <operator>&amp;&amp;</operator> <name>undoLocation</name> <operator>&gt;=</operator> <name>retainedUndoLocation</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UNDO_REC_EXISTS</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>prev_tuphdr</name> <operator>=</operator> <operator>*</operator><name>conflictTuphdr</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_prev_leaf_header_from_undo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prev_tuphdr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>conflictUndoLocation</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>pageTuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name> <operator>=</operator> <name><name>prev_tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>pageTuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>=</operator> <name><name>prev_tuphdr</name><operator>.</operator><name>undoLocation</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>pageTuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name> <operator>=</operator> <name><name>prev_tuphdr</name><operator>.</operator><name>chainHasLocks</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * Update chainHasLocks flag of the next undo records if
					 * needed.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name><name>conflictTuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						<operator>!</operator><name><name>conflictTuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>clean_chain_has_locks_flag</name><argument_list>(<argument><expr><name>lastLockOnlyUndoLocation</name></expr></argument>,
												   <argument><expr><name>pageTuphdr</name></expr></argument>,
												   <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>lastLockOnlyUndoLocation</name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name><name>conflictTuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name> <operator>=</operator> <name><name>prev_tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conflictTuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>=</operator> <name><name>prev_tuphdr</name><operator>.</operator><name>undoLocation</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conflictTuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name> <operator>=</operator> <name><name>prev_tuphdr</name><operator>.</operator><name>chainHasLocks</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>update_leaf_header_in_undo</name><argument_list>(<argument><expr><name>conflictTuphdr</name></expr></argument>,
											   <argument><expr><operator>*</operator><name>conflictUndoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name>xactIsfinished</name> <operator>&amp;&amp;</operator>
				 <call><name>ROW_LOCKS_CONFLICT</name><argument_list>(<argument><expr><call><name>XACT_INFO_GET_LOCK_MODE</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_GET_OXID</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>my_oxid</name> <operator>&amp;&amp;</operator>
				<call><name>XACT_INFO_GET_LOCK_MODE</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>mode</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>already_locked</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<name>undoLocation</name> <operator>&lt;</operator> <name>retainedUndoLocation</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We have reached the end of "in-progress" undo chain.  Fix tail
			 * "chainHasLocks" flag if needed.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>conflictTuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>clean_chain_has_locks_flag</name><argument_list>(<argument><expr><name>lastLockOnlyUndoLocation</name></expr></argument>,
										   <argument><expr><name>pageTuphdr</name></expr></argument>,
										   <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>lastLockOnlyUndoLocation</name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><operator>*</operator><name>conflictTuphdr</name> <operator>=</operator> <name>finishedTuphdr</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>conflictUndoLocation</name> <operator>=</operator> <name>finishedUndoLocation</name></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>delete_record</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We should be able to find a CSN-record or invalid undo location
			 * before running out of undo records.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UNDO_REC_EXISTS</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Update previous location of lock-only record.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>lastLockOnlyUndoLocation</name> <operator>=</operator> <name>undoLocation</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>prevChainHasLocks</name> <operator>=</operator> <name><name>conflictTuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_prev_leaf_header_from_undo</name><argument_list>(<argument><expr><name>conflictTuphdr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>conflictUndoLocation</name> <operator>=</operator> <name>undoLocation</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>xactInfo</name> <operator>=</operator> <name><name>conflictTuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>xactIsfinished</name> <operator>=</operator> <call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>undoLocation</name> <operator>=</operator> <name><name>conflictTuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>prevChainHasLocks</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>conflictTuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We have reached the end of "in-progress" undo chain.  Fix tail
			 * "chainHasLocks" flag if needed.
			 */</comment>
			<expr_stmt><expr><call><name>clean_chain_has_locks_flag</name><argument_list>(<argument><expr><name>lastLockOnlyUndoLocation</name></expr></argument>,
									   <argument><expr><name>pageTuphdr</name></expr></argument>,
									   <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lastLockOnlyUndoLocation</name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>foundFinished</name> <operator>&amp;&amp;</operator> <name>xactIsfinished</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>finishedTuphdr</name> <operator>=</operator> <operator>*</operator><name>conflictTuphdr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>finishedUndoLocation</name> <operator>=</operator> <operator>*</operator><name>conflictUndoLocation</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>foundFinished</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><operator>*</operator><name>conflictTuphdr</name> <operator>=</operator> <name>finishedTuphdr</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>conflictUndoLocation</name> <operator>=</operator> <name>finishedUndoLocation</name></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove redudant row-level locks.
 */</comment>
<function><type><name>void</name></type>
<name>remove_redundant_row_locks</name><parameter_list>(<parameter><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>pageTuphdr</name></decl></parameter>,
						   <parameter><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>conflictTuphdrPtr</name></decl></parameter>,
						   <parameter><decl><type><name>UndoLocation</name> <modifier>*</modifier></type><name>conflictTupHdrUndoLocation</name></decl></parameter>,
						   <parameter><decl><type><name>RowLockMode</name></type> <name>mode</name></decl></parameter>,
						   <parameter><decl><type><name>OXid</name></type> <name>my_oxid</name></decl></parameter>, <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>,
						   <parameter><decl><type><name>UndoLocation</name></type> <name>savepointUndoLocation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeLeafTuphdr</name></type> <name>tuphdr</name> <init>= <expr><operator>*</operator><name>pageTuphdr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTupleXactInfo</name></type> <name>xactInfo</name> <init>= <expr><name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>chainHasLocks</name> <init>= <expr><name><name>tuphdr</name><operator>.</operator><name>chainHasLocks</name></name></expr></init></decl>,
				<decl><type ref="prev"/><name>xactIsFinished</name> <init>= <expr><call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>undoLocation</name> <init>= <expr><name><name>tuphdr</name><operator>.</operator><name>undoLocation</name></name></expr></init></decl>,
				<decl><type ref="prev"/><name>prevUndoLoc</name> <init>= <expr><name>InvalidUndoLocation</name></expr></init></decl>,
				<decl><type ref="prev"/><name>lastLockOnlyUndoLocation</name> <init>= <expr><name>InvalidUndoLocation</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>retainedUndoLocation</name> <init>= <expr><call><name>get_snapshot_retained_undo_location</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>(</operator><operator>!</operator><name>xactIsFinished</name> <operator>||</operator> <name>chainHasLocks</name><operator>)</operator> <operator>&amp;&amp;</operator>
		   <name>undoLocation</name> <operator>&gt;=</operator> <name>retainedUndoLocation</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We should be able to find at CSN-record or invalid undo location
		 * before running out of undo records.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UNDO_REC_EXISTS</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>get_prev_leaf_header_from_undo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuphdr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>XACT_INFO_GET_OXID</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>my_oxid</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>delete_record</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>UNDO_REC_EXISTS</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_GET_LOCK_MODE</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>mode</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>savepointUndoLocation</name></expr></argument>)</argument_list></call> <operator>||</operator>
				 <operator>(</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				  <name>undoLocation</name> <operator>&gt;=</operator> <name>savepointUndoLocation</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>delete_record</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>delete_record</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>conflictTupHdrUndoLocation</name> <operator>==</operator> <name>undoLocation</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>conflictTuphdrPtr</name> <operator>=</operator> <name>tuphdr</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>conflictTupHdrUndoLocation</name> <operator>=</operator> <name>prevUndoLoc</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>prevUndoLoc</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>pageTuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name> <operator>=</operator> <name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>pageTuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>=</operator> <name><name>tuphdr</name><operator>.</operator><name>undoLocation</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * Update chainHasLocks flag of the next undo records if
					 * needed.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>chainHasLocks</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>clean_chain_has_locks_flag</name><argument_list>(<argument><expr><name>lastLockOnlyUndoLocation</name></expr></argument>,
												   <argument><expr><name>pageTuphdr</name></expr></argument>,
												   <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>update_leaf_header_in_undo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuphdr</name></expr></argument>, <argument><expr><name>prevUndoLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Update last location of lock-only record.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lastLockOnlyUndoLocation</name> <operator>=</operator> <name>prevUndoLoc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>prevUndoLoc</name> <operator>=</operator> <name>undoLocation</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>xactInfo</name> <operator>=</operator> <name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>xactIsFinished</name> <operator>=</operator> <call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>undoLocation</name> <operator>=</operator> <name><name>tuphdr</name><operator>.</operator><name>undoLocation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>chainHasLocks</name> <operator>=</operator> <name><name>tuphdr</name><operator>.</operator><name>chainHasLocks</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Finds first non-lock-only undo record and returns pointer to it.  Returns
 * NULL if such record is not found.
 */</comment>
<function><type><name>UndoLocation</name></type>
<name>find_non_lock_only_undo_record</name><parameter_list>(<parameter><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTupleXactInfo</name></type> <name>xactInfo</name> <init>= <expr><name><name>tuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>undoLocation</name> <init>= <expr><name>InvalidUndoLocation</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>undoLocation</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We should be able to find non lock-only undo location before
		 * running out of undo records.
		 */</comment>
		<expr_stmt><expr><name>undoLocation</name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>UNDO_REC_EXISTS</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>InvalidUndoLocation</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>get_prev_leaf_header_from_undo</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>xactInfo</name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>undoLocation</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>get_prev_leaf_header_from_undo</name><parameter_list>(<parameter><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeLeafTuphdr</name></type> <name>prevTuphdr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UNDO_REC_EXISTS</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>undo_read</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prevTuphdr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>prevTuphdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name>inPage</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>tuphdr</name> <operator>=</operator> <name>prevTuphdr</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name> <operator>=</operator> <name><name>prevTuphdr</name><operator>.</operator><name>xactInfo</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>=</operator> <name><name>prevTuphdr</name><operator>.</operator><name>undoLocation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name> <operator>=</operator> <name><name>prevTuphdr</name><operator>.</operator><name>chainHasLocks</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>get_prev_leaf_header_and_tuple_from_undo</name><parameter_list>(<parameter><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl></parameter>,
										 <parameter><decl><type><name>OTuple</name> <modifier>*</modifier></type><name>tuple</name></decl></parameter>,
										 <parameter><decl><type><name>LocationIndex</name></type> <name>sizeAvailable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeModifyUndoStackItem</name></type> <name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>tupleSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>undoLocation</name> <init>= <expr><name><name>tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>UNDO_REC_EXISTS</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>undo_read</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>BTreeModifyUndoStackItem</name></expr></argument>, <argument><expr><name>tuphdr</name></expr></argument>)</argument_list></call></expr></argument>,
			  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTreeModifyUndoStackItem</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>item</name><operator>.</operator><name>header</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>ModifyUndoItemType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>item</name><operator>.</operator><name>action</name></name> <operator>==</operator> <name>BTreeOperationUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>tuphdr</name> <operator>=</operator> <name><name>item</name><operator>.</operator><name>tuphdr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>formatFlags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupleSize</name> <operator>=</operator> <name><name>item</name><operator>.</operator><name>header</name><operator>.</operator><name>itemSize</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTreeModifyUndoStackItem</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>sizeAvailable</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>tupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sizeAvailable</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>sizeAvailable</name> <operator>&gt;=</operator> <name>tupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>undo_read</name><argument_list>(<argument><expr><name>undoLocation</name> <operator>+</operator> <name>BTreeLeafTuphdrSize</name></expr></argument>,
			  <argument><expr><name>tupleSize</name></expr></argument>,
			  <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>update_leaf_header_in_undo</name><parameter_list>(<parameter><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>UNDO_REC_EXISTS</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>undo_write</name><argument_list>(<argument><expr><name>location</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tuphdr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>tuphdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
