<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/btree/print.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * print.c
 *		Routines for printing orioledb B-tree structure and contents.
 *
 * Copyright (c) 2021-2022, Oriole DB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/btree/print.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/btree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/page_chunks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/print.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transam/oxid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transam/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/page_pool.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>BTreePrintOptions</name> <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
	<comment type="block">/* Page number in NLR tree traversal */</comment>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>NLRPageNumber</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>minCheckpointNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>minCsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>minUndoLoc</name></decl>;</decl_stmt>
	<comment type="block">/* Used for saving backend id number during NLR traversal. */</comment>
	<decl_stmt><decl><type><name>BackendId</name></type>	<name>backendIdInTraversal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasCsn</name></decl>;</decl_stmt>
	<comment type="block">/* hash mapping of the backend id with the number of   */</comment>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>backendIdHash</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * hash mapping of the page number in memory with number in the NLR tree
	 * traversal
	 */</comment>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>pageHash</name></decl>;</decl_stmt>
	<comment type="block">/* sorted list of unique undo locations in ascending order */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>undosList</name></decl>;</decl_stmt>
}</block></struct></type> <name>BTreePrintData</name>;</typedef>

<typedef>typedef <type><name>BackendId</name></type> <name>BackendIdHashKey</name>;</typedef>
<typedef>typedef <type><name>OInMemoryBlkno</name></type> <name>PageHashKey</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>BackendIdHashKey</name></type> <name>backendId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackendId</name></type>	<name>backendIdInTraversal</name></decl>;</decl_stmt>
}</block></struct></type> <name>BackendIdHashEntry</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>PageHashKey</name></type> <name>inMemoryPageNumber</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>NLRPageNumber</name></decl>;</decl_stmt>
}</block></struct></type> <name>PageHashEntry</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>print_page_contents_recursive</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>,
										  <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>,
										  <parameter><decl><type><name>PrintFunc</name></type> <name>keyPrintFunc</name></decl></parameter>,
										  <parameter><decl><type><name>PrintFunc</name></type> <name>tuplePrintFunc</name></decl></parameter>,
										  <parameter><decl><type><name>Pointer</name></type> <name>printArg</name></decl></parameter>,
										  <parameter><decl><type><name>BTreePrintData</name> <modifier>*</modifier></type><name>printData</name></decl></parameter>,
										  <parameter><decl><type><name>int</name></type> <name>depthLeft</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>outbuf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>btree_calculate_min_values</name><parameter_list>(<parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>,
									   <parameter><decl><type><name>BTreePrintData</name> <modifier>*</modifier></type><name>printData</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>btree_print_csn</name><parameter_list>(<parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>outbuf</name></decl></parameter>,
							<parameter><decl><type><name>BTreePrintData</name> <modifier>*</modifier></type><name>printData</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>addComma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>btree_print_backend_id</name><parameter_list>(<parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>outbuf</name></decl></parameter>,
								   <parameter><decl><type><name>BTreePrintData</name> <modifier>*</modifier></type><name>printData</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>lundo_location</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>btree_print_undo_location</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>undoLocation</name></decl></parameter>,
									  <parameter><decl><type><name>StringInfo</name></type> <name>outbuf</name></decl></parameter>,
									  <parameter><decl><type><name>BTreePrintData</name> <modifier>*</modifier></type><name>printData</name></decl></parameter>,
									  <parameter><decl><type><name>bool</name></type> <name>addComma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>btree_print_page_number</name><parameter_list>(<parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>outbuf</name></decl></parameter>,
									<parameter><decl><type><name>BTreePrintData</name> <modifier>*</modifier></type><name>printData</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>btree_print_orioledb_downlink</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>downlink</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>outbuf</name></decl></parameter>,
										  <parameter><decl><type><name>BTreePrintData</name> <modifier>*</modifier></type><name>printData</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>btree_print_rightlink</name><parameter_list>(<parameter><decl><type><name>OInMemoryBlkno</name></type> <name>rightlink</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>outbuf</name></decl></parameter>,
								  <parameter><decl><type><name>BTreePrintData</name> <modifier>*</modifier></type><name>printData</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pdata_set_min_csn</name><parameter_list>(<parameter><decl><type><name>BTreePrintData</name> <modifier>*</modifier></type><name>printData</name></decl></parameter>,
							  <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>ladd_unique_undo</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>,
							  <parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Recursively print contents of B-tree pages with given depth.  Uses
 * callbacks for printing keys and tuples.
 */</comment>
<function><type><name>void</name></type>
<name>o_print_btree_pages</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>outbuf</name></decl></parameter>,
					<parameter><decl><type><name>PrintFunc</name></type> <name>keyPrintFunc</name></decl></parameter>, <parameter><decl><type><name>PrintFunc</name></type> <name>tuplePrintFunc</name></decl></parameter>,
					<parameter><decl><type><name>Pointer</name></type> <name>printArg</name></decl></parameter>, <parameter><decl><type><name>BTreePrintOptions</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePrintData</name></type> <name>printData</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>undoLogLocationPrintType</name></name> <operator>!=</operator> <name>BTreeNotPrint</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>update_min_undo_locations</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OInMemoryBlknoIsValid</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <call><name>OInMemoryBlknoIsValid</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>metaPageBlkno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>printData</name><operator>.</operator><name>options</name></name> <operator>=</operator> <name>options</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BackendIdHashKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BackendIdHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>printData</name><operator>.</operator><name>backendIdHash</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"backend id hash"</literal></expr></argument>, <argument><expr><call><name>GetMaxBackends</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
										  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PageHashKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PageHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>printData</name><operator>.</operator><name>pageHash</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"page hash"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
									 <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* calculate minimal values only if one of the options set */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>printData</name><operator>.</operator><name>options</name><operator>-&gt;</operator><name>pagePrintType</name></name> <operator>==</operator> <name>BTreePrintRelative</name> <operator>||</operator>
		<name><name>printData</name><operator>.</operator><name>options</name><operator>-&gt;</operator><name>csnPrintType</name></name> <operator>==</operator> <name>BTreePrintRelative</name> <operator>||</operator>
		<name><name>printData</name><operator>.</operator><name>options</name><operator>-&gt;</operator><name>undoLogLocationPrintType</name></name> <operator>==</operator> <name>BTreePrintRelative</name> <operator>||</operator>
		<name><name>printData</name><operator>.</operator><name>options</name><operator>-&gt;</operator><name>backendIdPrintType</name></name> <operator>==</operator> <name>BTreePrintAbsolute</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>printData</name><operator>.</operator><name>minCheckpointNum</name></name> <operator>=</operator> <name>UINT32_MAX</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>printData</name><operator>.</operator><name>hasCsn</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>printData</name><operator>.</operator><name>minUndoLoc</name></name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>printData</name><operator>.</operator><name>backendIdInTraversal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>printData</name><operator>.</operator><name>NLRPageNumber</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>printData</name><operator>.</operator><name>undosList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>btree_calculate_min_values</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>printData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>printData</name><operator>.</operator><name>NLRPageNumber</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>print_page_contents_recursive</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>, <argument><expr><name>keyPrintFunc</name></expr></argument>, <argument><expr><name>tuplePrintFunc</name></expr></argument>,
								  <argument><expr><name>printArg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>printData</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>outbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name><name>printData</name><operator>.</operator><name>undosList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>printData</name><operator>.</operator><name>pageHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>printData</name><operator>.</operator><name>backendIdHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print contents of give B-tree page.  If non-leaf page is given, recursively
 * print childredn.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_page_contents_recursive</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>,
							  <parameter><decl><type><name>PrintFunc</name></type> <name>keyPrintFunc</name></decl></parameter>,
							  <parameter><decl><type><name>PrintFunc</name></type> <name>tuplePrintFunc</name></decl></parameter>,
							  <parameter><decl><type><name>Pointer</name></type> <name>printArg</name></decl></parameter>,
							  <parameter><decl><type><name>BTreePrintData</name> <modifier>*</modifier></type><name>printData</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>depthLeft</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>outbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OrioleDBPageDesc</name> <modifier>*</modifier></type><name>page_desc</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>depthLeft</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>btree_print_page_number</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>outbuf</name></expr></argument>, <argument><expr><name>printData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"level = %d, maxKeyLen = %d"</literal></expr></argument>,
					 <argument><expr><call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name><name>header</name><operator>-&gt;</operator><name>maxKeyLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>btree_print_csn</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>csn</name></name></expr></argument>, <argument><expr><name>outbuf</name></expr></argument>, <argument><expr><name>printData</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>btree_print_undo_location</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>, <argument><expr><name>outbuf</name></expr></argument>, <argument><expr><name>printData</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", nVacatedBytes = %u"</literal></expr></argument>, <argument><expr><call><name>PAGE_GET_N_VACATED</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>printData</name><operator>-&gt;</operator><name>options</name><operator>-&gt;</operator><name>printStateValue</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"state = %u"</literal></expr></argument>, <argument><expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><call><name>O_PAGE_HEADER</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>state</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>state</name> <init>= <expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><call><name>O_PAGE_HEADER</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>state</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_STATE_READ_IS_BLOCKED</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"state = modify"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>O_PAGE_STATE_IS_LOCKED</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"state = locked"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"state = free"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>printData</name><operator>-&gt;</operator><name>options</name><operator>-&gt;</operator><name>changeCountPrintType</name></name> <operator>==</operator> <name>BTreePrintAbsolute</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", pageChangeCount = %u"</literal></expr></argument>, <argument><expr><call><name>O_PAGE_HEADER</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pageChangeCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", datoid "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>printData</name><operator>-&gt;</operator><name>options</name><operator>-&gt;</operator><name>idsPrintType</name></name> <operator>==</operator> <name>BTreePrintRelative</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"%sequal"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>page_desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name> <operator>==</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"not "</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"= %u"</literal></expr></argument>, <argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", relnode "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>printData</name><operator>-&gt;</operator><name>options</name><operator>-&gt;</operator><name>idsPrintType</name></name> <operator>==</operator> <name>BTreePrintRelative</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"%sequal"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>page_desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name> <operator>==</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"not "</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"= %u"</literal></expr></argument>, <argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<switch>switch <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>oIndexInvalid</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", ix_type = invalid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>oIndexToast</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", ix_type = toast"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>oIndexPrimary</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", ix_type = primary"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>oIndexUnique</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", ix_type = unique"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>oIndexRegular</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", ix_type = regular"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", ix_type = wrong"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><call><name>OCompressIsValid</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", compression = %d"</literal></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_DIRTY</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_DIRTY_CONCURRENT</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", dirty, concurrent IO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", dirty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", clean"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>printData</name><operator>-&gt;</operator><name>options</name><operator>-&gt;</operator><name>printFileOffset</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>FileExtentIsValid</name><argument_list>(<argument><expr><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", fileOffset = %lu"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>unsigned</name><operator>)</operator> <name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name><operator>.</operator><name>off</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", fileOffset is invalid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>printData</name><operator>-&gt;</operator><name>options</name><operator>-&gt;</operator><name>checkpointNumPrintType</name></name> <operator>==</operator> <name>BTreePrintAbsolute</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", checkpointNum = %u"</literal></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>checkpointNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>printData</name><operator>-&gt;</operator><name>options</name><operator>-&gt;</operator><name>checkpointNumPrintType</name></name> <operator>==</operator> <name>BTreePrintRelative</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", checkpointNum = %u"</literal></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>checkpointNum</name></name> <operator>-</operator> <name><name>printData</name><operator>-&gt;</operator><name>minCheckpointNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEFTMOST</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"    Leftmost, "</literal></expr> </then><else>: <expr><literal type="string">"    "</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>hikey</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>btree_print_rightlink</name><argument_list>(<argument><expr><call><name>RIGHTLINK_GET_BLKNO</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>rightLink</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>outbuf</name></expr></argument>, <argument><expr><name>printData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"    Hikey: offset = %d, key = "</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>Pointer</name><operator>)</operator> <name><name>hikey</name><operator>.</operator><name>data</name></name> <operator>-</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>keyPrintFunc</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>outbuf</name></expr></argument>, <argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>printArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"Rightmost\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"  Chunk %i: offset = %u, location = %u, hikey location = %u"</literal></expr></argument>,
						 <argument><expr><name>j</name></expr></argument>,
						 <argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>offset</name></expr></argument>,
						 <argument><expr><call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>shortLocation</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>j</name> <operator>&lt;</operator> <name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OTuple</name></type>		<name>hikey</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>hikey</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>hikeyFlags</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hikey</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", hikey = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>keyPrintFunc</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>outbuf</name></expr></argument>, <argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>printArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>page_chunk_fill_locator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>loc</name><operator>.</operator><name>chunkItemsCount</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>loc</name><operator>.</operator><name>itemOffset</name></name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BTreeLeafTuphdr</name></type> <name>tuphdr</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>pageTuphdr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>inUndo</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>pageTuphdr</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tuphdr</name> <operator>=</operator> <operator>*</operator><name>pageTuphdr</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"    Item %i: "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<while>while <condition>(<expr><name>true</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type>		<name>needsComma</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>inUndo</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"      Undo item: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>needsComma</name> <operator>=</operator> <call><name>btree_print_csn</name><argument_list>(<argument><expr><call><name>XACT_INFO_MAP_CSN</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>outbuf</name></expr></argument>, <argument><expr><name>printData</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type>			<name>lockMode</name> <init>= <expr><call><name>XACT_INFO_GET_LOCK_MODE</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"lock only, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<switch>switch <condition>(<expr><name>lockMode</name></expr>)</condition>
						<block>{<block_content>
							<case>case <expr><name>RowLockKeyShare</name></expr>:</case>
								<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"mode = keyShare"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>
							<case>case <expr><name>RowLockShare</name></expr>:</case>
								<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"mode = share"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>
							<case>case <expr><name>RowLockNoKeyUpdate</name></expr>:</case>
								<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"mode = noKeyUpdate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>
							<case>case <expr><name>RowLockUpdate</name></expr>:</case>
								<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"mode = update"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>
							<default>default:</default>
								<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid lock mode: %u"</literal></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>
						</block_content>}</block></switch>
						<expr_stmt><expr><name>needsComma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>btree_print_backend_id</name><argument_list>(<argument><expr><call><name>XACT_INFO_GET_OXID</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>outbuf</name></expr></argument>, <argument><expr><name>printData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>tuphdr</name><operator>.</operator><name>deleted</name></name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>needsComma</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>needsComma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"deleted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>needsComma</name> <operator>|=</operator> <call><name>btree_print_undo_location</name><argument_list>(<argument><expr><operator>(</operator><name>UndoLocation</name><operator>)</operator> <name><name>tuphdr</name><operator>.</operator><name>undoLocation</name></name></expr></argument>, <argument><expr><name>outbuf</name></expr></argument>, <argument><expr><name>printData</name></expr></argument>, <argument><expr><name>needsComma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inUndo</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>needsComma</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>needsComma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"offset = %u"</literal></expr></argument>,
										 <argument><expr><call><name>BTREE_PAGE_GET_ITEM_OFFSET</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>tuphdr</name><operator>.</operator><name>chainHasLocks</name></name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>needsComma</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>needsComma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"chainHasLocks"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>needsComma</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>needsComma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"tuple = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>tuplePrintFunc</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>outbuf</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>printArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>tuphdr</name><operator>.</operator><name>chainHasLocks</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
						<call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>.</operator><name>undoLocation</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UNDO_REC_EXISTS</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>.</operator><name>undoLocation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>inUndo</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>tuple</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tuphdr</name><operator>.</operator><name>deleted</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>get_prev_leaf_header_and_tuple_from_undo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuphdr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<expr_stmt><expr><call><name>get_prev_leaf_header_from_undo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuphdr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
						<expr_stmt><expr><name>inUndo</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<break>break;</break>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></while>
				<if_stmt><if>if <condition>(<expr><name>inUndo</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>tuple</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>BTREE_PAGE_READ_INTERNAL_ITEM</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"    Item %i: "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"offset = %u"</literal></expr></argument>,
								 <argument><expr><call><name>BTREE_PAGE_GET_ITEM_OFFSET</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>DOWNLINK_IS_IN_MEMORY</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>btree_print_orioledb_downlink</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>, <argument><expr><name>outbuf</name></expr></argument>, <argument><expr><name>printData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>DOWNLINK_IS_IN_IO</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", in-progress (%u)"</literal></expr></argument>,
									 <argument><expr><call><name>DOWNLINK_GET_IO_LOCKNUM</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", downlink = on-disk (%lu, %u)"</literal></expr></argument>,
									 <argument><expr><call><name>DOWNLINK_GET_DISK_OFF</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>DOWNLINK_GET_DISK_LEN</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", key = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>keyPrintFunc</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>outbuf</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>printArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>printData</name><operator>-&gt;</operator><name>NLRPageNumber</name></name><operator>++</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<macro><name>BTREE_PAGE_FOREACH_ITEMS</name><argument_list>(<argument>p</argument>, <argument>&amp;loc</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Pointer</name></type>		<name>ptr</name> <init>= <expr><call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name> <init>= <expr><operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>DOWNLINK_IS_IN_MEMORY</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>print_page_contents_recursive</name><argument_list>(<argument><expr><name>desc</name></expr></argument>,
											  <argument><expr><call><name>DOWNLINK_GET_IN_MEMORY_BLKNO</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>keyPrintFunc</name></expr></argument>, <argument><expr><name>tuplePrintFunc</name></expr></argument>, <argument><expr><name>printArg</name></expr></argument>, <argument><expr><name>printData</name></expr></argument>,
											  <argument><expr><name>depthLeft</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>outbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>RIGHTLINK_GET_BLKNO</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_GET_RIGHTLINK</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OInMemoryBlknoIsValid</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>print_page_contents_recursive</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>keyPrintFunc</name></expr></argument>, <argument><expr><name>tuplePrintFunc</name></expr></argument>,
									  <argument><expr><name>printArg</name></expr></argument>, <argument><expr><name>printData</name></expr></argument>, <argument><expr><name>depthLeft</name></expr></argument>, <argument><expr><name>outbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate values needed for printing page positions in NLR traversal,
 * relative CSNs and Undo locations.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>btree_calculate_min_values</name><parameter_list>(<parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>BTreePrintData</name> <modifier>*</modifier></type><name>printData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PageHashEntry</name> <modifier>*</modifier></type><name>pageHashEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackendIdHashEntry</name> <modifier>*</modifier></type><name>backendIdHashEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>


	<comment type="block">/* if page number is not in hash, then add new value to hash */</comment>
	<expr_stmt><expr><name>pageHashEntry</name> <operator>=</operator> <operator>(</operator><name>PageHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>printData</name><operator>-&gt;</operator><name>pageHash</name></name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pageHashEntry</name><operator>-&gt;</operator><name>NLRPageNumber</name></name> <operator>=</operator> <name><name>printData</name><operator>-&gt;</operator><name>NLRPageNumber</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>printData</name><operator>-&gt;</operator><name>NLRPageNumber</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>printData</name><operator>-&gt;</operator><name>minCheckpointNum</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>printData</name><operator>-&gt;</operator><name>minCheckpointNum</name></name></expr></argument>,
									  <argument><expr><name><name>header</name><operator>-&gt;</operator><name>checkpointNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>printData</name><operator>-&gt;</operator><name>undosList</name></name> <operator>=</operator> <call><name>ladd_unique_undo</name><argument_list>(<argument><expr><name><name>printData</name><operator>-&gt;</operator><name>undosList</name></name></expr></argument>,
											<argument><expr><name><name>header</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Iterate over the child nodes */</comment>
	<macro><name>BTREE_PAGE_FOREACH_ITEMS</name><argument_list>(<argument>p</argument>, <argument>&amp;loc</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Pointer</name></type>		<name>ptr</name> <init>= <expr><call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreeLeafTuphdr</name></type> <name>tuphdr</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>BTreeLeafTuphdr</name> <operator>*</operator><operator>)</operator> <name>ptr</name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<while>while <condition>(<expr><name>true</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>printData</name><operator>-&gt;</operator><name>undosList</name></name> <operator>=</operator> <call><name>ladd_unique_undo</name><argument_list>(<argument><expr><name><name>printData</name><operator>-&gt;</operator><name>undosList</name></name></expr></argument>,
														<argument><expr><name><name>tuphdr</name><operator>.</operator><name>undoLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pdata_set_min_csn</name><argument_list>(<argument><expr><name>printData</name></expr></argument>, <argument><expr><call><name>XACT_INFO_MAP_CSN</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name> <init>= <expr><call><name>XACT_INFO_GET_OXID</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>uint32</name></type>		<name>procnum</name> <init>= <expr><call><name>oxid_get_procnum</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>backendIdHashEntry</name> <operator>=</operator> <operator>(</operator><name>BackendIdHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>printData</name><operator>-&gt;</operator><name>backendIdHash</name></name></expr></argument>,
																			<argument><expr><operator>&amp;</operator><name>procnum</name></expr></argument>,
																			<argument><expr><name>HASH_ENTER</name></expr></argument>,
																			<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * if backend id wasn't in hash that means it first
					 * appearence of backend saving id in traversal to hash
					 * needed
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>backendIdHashEntry</name><operator>-&gt;</operator><name>backendIdInTraversal</name></name> <operator>=</operator> <name><name>printData</name><operator>-&gt;</operator><name>backendIdInTraversal</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>printData</name><operator>-&gt;</operator><name>backendIdInTraversal</name></name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>tuphdr</name><operator>.</operator><name>chainHasLocks</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
					<call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>.</operator><name>undoLocation</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>get_prev_leaf_header_from_undo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuphdr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<break>break;</break></block_content></block></else></if_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name> <init>= <expr><operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* If tuple is downlink in memory */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>DOWNLINK_IS_IN_MEMORY</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* recursively traverse to every child */</comment>
				<expr_stmt><expr><call><name>btree_calculate_min_values</name><argument_list>(<argument><expr><call><name>DOWNLINK_GET_IN_MEMORY_BLKNO</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>printData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* If node has valid rightlink also traverse to it */</comment>
	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>RIGHTLINK_GET_BLKNO</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_GET_RIGHTLINK</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OInMemoryBlknoIsValid</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>btree_calculate_min_values</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>printData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print in memory downlink for child node
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>btree_print_csn</name><parameter_list>(<parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>outbuf</name></decl></parameter>, <parameter><decl><type><name>BTreePrintData</name> <modifier>*</modifier></type><name>printData</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>addComma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>printedCsn</name> <init>= <expr><name>csn</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* print csn if option has another value then BTreePrintAbsolute */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>printData</name><operator>-&gt;</operator><name>options</name><operator>-&gt;</operator><name>csnPrintType</name></name> <operator>!=</operator> <name>BTreeNotPrint</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>addComma</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"csn = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>COMMITSEQNO_IS_FROZEN</name><argument_list>(<argument><expr><name>printedCsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"FROZEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>COMMITSEQNO_IS_INPROGRESS</name><argument_list>(<argument><expr><name>printedCsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"INPROGRESS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * If relative csn option set, then substract min csn from
			 * absolute node csn
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>printData</name><operator>-&gt;</operator><name>options</name><operator>-&gt;</operator><name>csnPrintType</name></name> <operator>==</operator> <name>BTreePrintRelative</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>printedCsn</name> <operator>=</operator> <name>csn</name> <operator>-</operator> <name><name>printData</name><operator>-&gt;</operator><name>minCsn</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>printedCsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Print node backend id
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>btree_print_backend_id</name><parameter_list>(<parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>outbuf</name></decl></parameter>, <parameter><decl><type><name>BTreePrintData</name> <modifier>*</modifier></type><name>printData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BackendId</name></type>	<name>backendId</name> <init>= <expr><call><name>oxid_get_procnum</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackendIdHashEntry</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>printData</name><operator>-&gt;</operator><name>options</name><operator>-&gt;</operator><name>backendIdPrintType</name></name> <operator>!=</operator> <name>BTreeNotPrint</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* find backend id in traversal by backend id */</comment>
		<expr_stmt><expr><name>hentry</name> <operator>=</operator> <operator>(</operator><name>BackendIdHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>printData</name><operator>-&gt;</operator><name>backendIdHash</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>backendId</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", backend = %d"</literal></expr></argument>, <argument><expr><name><name>hentry</name><operator>-&gt;</operator><name>backendIdInTraversal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>lundo_location</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>list</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><operator>(</operator><name>UndoLocation</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>location</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>btree_print_undo_location</name><parameter_list>(<parameter><decl><type><name>UndoLocation</name></type> <name>undoLocation</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>outbuf</name></decl></parameter>,
						  <parameter><decl><type><name>BTreePrintData</name> <modifier>*</modifier></type><name>printData</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>addComma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>printedUndoLoc</name> <init>= <expr><name>undoLocation</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePrintOption</name></type> <name>printType</name> <init>= <expr><name><name>printData</name><operator>-&gt;</operator><name>options</name><operator>-&gt;</operator><name>undoLogLocationPrintType</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>printType</name> <operator>!=</operator> <name>BTreeNotPrint</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* print undo location only if it is valid */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><operator>(</operator><call><name>UNDO_REC_EXISTS</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>printType</name> <operator>==</operator> <name>BTreePrintAbsolute</name><operator>)</operator><operator>)</operator> <operator>||</operator>
			 <operator>(</operator><operator>(</operator><call><name>UNDO_REC_XACT_RETAIN</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>printType</name> <operator>==</operator> <name>BTreePrintRelative</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * if ascending number option set, then it gets number of undo
			 * location in sorted list
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>printData</name><operator>-&gt;</operator><name>options</name><operator>-&gt;</operator><name>undoLogLocationPrintType</name></name> <operator>==</operator>
				<name>BTreePrintRelative</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>printedUndoLoc</name> <operator>=</operator> <call><name>lundo_location</name><argument_list>(<argument><expr><name><name>printData</name><operator>-&gt;</operator><name>undosList</name></name></expr></argument>, <argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>printedUndoLoc</name> <operator>||</operator>
					   <name>printedUndoLoc</name> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>printData</name><operator>-&gt;</operator><name>undosList</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>addComma</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"undoLocation = "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>printedUndoLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Print page number for node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>btree_print_page_number</name><parameter_list>(<parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>outbuf</name></decl></parameter>, <parameter><decl><type><name>BTreePrintData</name> <modifier>*</modifier></type><name>printData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PageHashEntry</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>printedPageNumber</name> <init>= <expr><name>blkno</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* print page number in NLR traverse only if corresponding option set */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>printData</name><operator>-&gt;</operator><name>options</name><operator>-&gt;</operator><name>pagePrintType</name></name> <operator>==</operator> <name>BTreePrintRelative</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* find the corresponding page number in NLR traversal */</comment>
		<expr_stmt><expr><name>hentry</name> <operator>=</operator> <operator>(</operator><name>PageHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>printData</name><operator>-&gt;</operator><name>pageHash</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>printedPageNumber</name> <operator>=</operator> <name><name>hentry</name><operator>-&gt;</operator><name>NLRPageNumber</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"Page %u: "</literal></expr></argument>, <argument><expr><name>printedPageNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print in memory downlink for child node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>btree_print_orioledb_downlink</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>downlink</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>outbuf</name></decl></parameter>, <parameter><decl><type><name>BTreePrintData</name> <modifier>*</modifier></type><name>printData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PageHashEntry</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>printedPageNumber</name> <init>= <expr><call><name>DOWNLINK_GET_IN_MEMORY_BLKNO</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* print page number in NLR traverse only if corresponding option set */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>printData</name><operator>-&gt;</operator><name>options</name><operator>-&gt;</operator><name>pagePrintType</name></name> <operator>==</operator> <name>BTreePrintRelative</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* find the corresponding page number in NLR traversal */</comment>
		<expr_stmt><expr><name>hentry</name> <operator>=</operator> <operator>(</operator><name>PageHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>printData</name><operator>-&gt;</operator><name>pageHash</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>printedPageNumber</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>printedPageNumber</name> <operator>=</operator> <name><name>hentry</name><operator>-&gt;</operator><name>NLRPageNumber</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">", downlink = %u"</literal></expr></argument>, <argument><expr><name>printedPageNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>printData</name><operator>-&gt;</operator><name>options</name><operator>-&gt;</operator><name>changeCountPrintType</name></name> <operator>==</operator> <name>BTreePrintAbsolute</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">" (%u)"</literal></expr></argument>, <argument><expr><call><name>DOWNLINK_GET_IN_MEMORY_CHANGECOUNT</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print rightlink for node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>btree_print_rightlink</name><parameter_list>(<parameter><decl><type><name>OInMemoryBlkno</name></type> <name>rightlink</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>outbuf</name></decl></parameter>, <parameter><decl><type><name>BTreePrintData</name> <modifier>*</modifier></type><name>printData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PageHashEntry</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>printedPageNumber</name> <init>= <expr><name>rightlink</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * print rightlink page number in NLR traverse only if corresponding
	 * option set
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OInMemoryBlknoIsValid</name><argument_list>(<argument><expr><name>rightlink</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>printData</name><operator>-&gt;</operator><name>options</name><operator>-&gt;</operator><name>pagePrintType</name></name> <operator>==</operator> <name>BTreePrintRelative</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* find the corresponding page number in NLR traversal */</comment>
			<expr_stmt><expr><name>hentry</name> <operator>=</operator> <operator>(</operator><name>PageHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>printData</name><operator>-&gt;</operator><name>pageHash</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>printedPageNumber</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>printedPageNumber</name> <operator>=</operator> <name><name>hentry</name><operator>-&gt;</operator><name>NLRPageNumber</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"Rightlink = %u\n"</literal></expr></argument>, <argument><expr><name>printedPageNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><literal type="string">"Rightlink is invalid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pdata_set_min_csn</name><parameter_list>(<parameter><decl><type><name>BTreePrintData</name> <modifier>*</modifier></type><name>printData</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>COMMITSEQNO_IS_NORMAL</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>printData</name><operator>-&gt;</operator><name>hasCsn</name></name> <operator>||</operator> <name><name>printData</name><operator>-&gt;</operator><name>minCsn</name></name> <operator>&gt;</operator> <name>csn</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>printData</name><operator>-&gt;</operator><name>hasCsn</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>printData</name><operator>-&gt;</operator><name>minCsn</name></name> <operator>=</operator> <name>csn</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* adds unique undo location in ascending order */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ladd_unique_undo</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>lLoc</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>copyLoc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>insertAt</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>UNDO_REC_XACT_RETAIN</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>list</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>copyLoc</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UndoLocation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>copyLoc</name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

	<comment type="block">/* lappend_cell does not work with NIL list */</comment>
	<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>lappend</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>copyLoc</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>lLoc</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>UndoLocation</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>lLoc</name> <operator>&gt;</operator> <name>location</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>lcons</name><argument_list>(<argument><expr><name>copyLoc</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>list</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>lLoc</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>UndoLocation</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>lLoc</name> <operator>==</operator> <name>location</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>copyLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>list</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>lLoc</name> <operator>&gt;</operator> <name>location</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>insertAt</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>insertAt</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>list_insert_nth</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>insertAt</name></expr></argument>, <argument><expr><name>copyLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>
</unit>
