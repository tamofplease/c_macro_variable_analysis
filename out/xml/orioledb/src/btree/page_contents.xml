<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/btree/page_contents.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * page_contents.c
 *		Low-level routines for working with b-tree page contents.
 *
 * Copyright (c) 2021-2022, Oriole DB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/btree/page_contents.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/find.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/page_chunks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"recovery/recovery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tableam/descr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transam/oxid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transam/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/page_pool.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ucm.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proclist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/s_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memdebug.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Navigates and reads the page image from undo log according to `key` of
 * `keyType` and `csn`.  Saves lokey of the page to lokey if *lokey != NULL.
 */</comment>
<function><type><name>UndoLocation</name></type>
<name>read_page_from_undo</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>img</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name></type> <name>undo_loc</name></decl></parameter>,
					<parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>keyType</name></decl></parameter>,
					<parameter><decl><type><name>OFixedKey</name> <modifier>*</modifier></type><name>lokey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>page_csn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>rec_undo_location</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_left</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>undo_loc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Read page image from page-level undo item */</comment>
		<expr_stmt><expr><call><name>get_page_from_undo</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>undo_loc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keyType</name></expr></argument>, <argument><expr><name>img</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>is_left</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lokey</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>img</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>page_csn</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>csn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rec_undo_location</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>undoLocation</name></name></expr>;</expr_stmt>

		<comment type="block">/* Page-level undo item should be retained */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UNDO_REC_EXISTS</name><argument_list>(<argument><expr><name>undo_loc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Continue traversing undo chain if needed */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>COMMITSEQNO_IS_NORMAL</name><argument_list>(<argument><expr><name>page_csn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>page_csn</name> <operator>&gt;=</operator> <name>csn</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>undo_loc</name> <operator>=</operator> <name>rec_undo_location</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Page-level undo item should be retained */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UNDO_REC_EXISTS</name><argument_list>(<argument><expr><name>undo_loc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>O_UNDO_GET_IMAGE_LOCATION</name><argument_list>(<argument><expr><name>undo_loc</name></expr></argument>, <argument><expr><name>is_left</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try to copy consistent image of page with page number = blkno to dest.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ReadPageResult</name></type>
<name>try_copy_page</name><parameter_list>(<parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>pageChangeCount</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>dest</name></decl></parameter>,
			  <parameter><decl><type><name>PartialPageState</name> <modifier>*</modifier></type><name>partial</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name> <modifier>*</modifier></type><name>readCsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UsageCountMap</name> <modifier>*</modifier></type><name>ucm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>state1</name></decl>,
				<decl><type ref="prev"/><name>state2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>		<name>hiKeysEndOK</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>state1</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><call><name>O_PAGE_HEADER</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>state</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_STATE_READ_IS_BLOCKED</name><argument_list>(<argument><expr><name>state1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ReadPageResultFailed</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>partial</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LocationIndex</name></type> <name>hikeysEnd</name> <init>= <expr><name><name>header</name><operator>-&gt;</operator><name>hikeysEnd</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>hikeysEnd</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTreePageHeader</name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator> <name>hikeysEnd</name> <operator>&lt;</operator> <name>ORIOLEDB_BLCKSZ</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>hikeysEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>hiKeysEndOK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>partial</name><operator>-&gt;</operator><name>isPartial</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partial</name><operator>-&gt;</operator><name>src</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>partial</name><operator>-&gt;</operator><name>chunkIsLoaded</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>BTREE_PAGE_MAX_CHUNKS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>readCsn</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>readCsn</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextCommitSeqNo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>state2</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><call><name>O_PAGE_HEADER</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>state</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>state1</name> <operator>&amp;</operator> <name>PAGE_STATE_CHANGE_COUNT_MASK</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>state2</name> <operator>&amp;</operator> <name>PAGE_STATE_CHANGE_COUNT_MASK</name><operator>)</operator> <operator>||</operator>
		<call><name>O_PAGE_STATE_READ_IS_BLOCKED</name><argument_list>(<argument><expr><name>state2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ReadPageResultFailed</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pageChangeCount</name> <operator>!=</operator> <name>InvalidOPageChangeCount</name> <operator>&amp;&amp;</operator> <call><name>O_PAGE_GET_CHANGE_COUNT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>pageChangeCount</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ReadPageResultWrongPageChangeCount</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>hiKeysEndOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ucm</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><call><name>get_ppool_by_blkno</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ucm</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>page_inc_usage_count</name><argument_list>(<argument><expr><name>ucm</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>,
						 <argument><expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>OrioleDBPageHeader</name> <operator>*</operator><operator>)</operator> <name>dest</name><operator>)</operator><operator>-&gt;</operator><name>usageCount</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ReadPageResultOK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy consistent image of page with page number = blkno to dest.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>copy_page</name><parameter_list>(<parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>PartialPageState</name> <modifier>*</modifier></type><name>partial</name></decl></parameter>,
		  <parameter><decl><type><name>CommitSeqNo</name> <modifier>*</modifier></type><name>readCsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><call><name>try_copy_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>InvalidOPageChangeCount</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>,
						 <argument><expr><name>partial</name></expr></argument>, <argument><expr><name>readCsn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ReadPageResultOK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>page_wait_for_read_enable</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Read in-memory page number `blkno` into `img`.  Check expected
 * `pageChangeCount` until it is InvalidOPageChangeCount.  Lookup for undo
 * page according to `csn` when `key` of `keyType`.
 */</comment>
<function><type><name>bool</name></type>
<name>o_btree_read_page</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>,
				  <parameter><decl><type><name>uint32</name></type> <name>pageChangeCount</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>img</name></decl></parameter>,
				  <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>keyType</name></decl></parameter>,
				  <parameter><decl><type><name>OFixedKey</name> <modifier>*</modifier></type><name>lokey</name></decl></parameter>, <parameter><decl><type><name>PartialPageState</name> <modifier>*</modifier></type><name>partial</name></decl></parameter>,
				  <parameter><decl><type><name>UndoLocation</name> <modifier>*</modifier></type><name>undoLocation</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name> <modifier>*</modifier></type><name>readCsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>headerCsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>headerUndoLocation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>read_undo</name> <init>= <expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>EA_READ_INC</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*---
	 * Check if we need to load page image from undo?
	 *
	 * We do this check without holding a page lock or even usage of state
	 * protocol.  Istead we ensure correctenss of this check in a following
	 * way.
	 *
	 * 1. We read csn before undo location (ensured with memory barriers).
	 *    We write csn after undo location (also ensured with memory barriers).
	 *    Thus, undo location we read is probably more recent than csn.  That could
	 *    lead to traverse of extra step of undo chain, which is not a problem.
	 *    Also that could lead to miss the need of reading undo, but that would
	 *    be catched by subsequent check.
	 * 2. We check page change count after reading csn and undo location.  That
	 *    ensures page wasn't reused for something while reading csn and undo
	 *    location.  Note, that there is at least one memory barrier between
	 *    increasing page change count and reusing the page during page unlock.
	 */</comment>
	<expr_stmt><expr><name>headerCsn</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>csn</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>read_undo</name> <operator>&amp;&amp;</operator> <call><name>COMMITSEQNO_IS_NORMAL</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>headerCsn</name> <operator>&gt;=</operator> <name>csn</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>UndoLocation</name></type> <name>pageUndoLoc</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>headerUndoLocation</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>undoLocation</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pageChangeCount</name> <operator>!=</operator> <name>InvalidOPageChangeCount</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>o_header</name><operator>.</operator><name>pageChangeCount</name></name> <operator>!=</operator> <name>pageChangeCount</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>pageChangeCount</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>o_header</name><operator>.</operator><name>pageChangeCount</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>pageUndoLoc</name> <operator>=</operator> <call><name>read_page_from_undo</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><name>headerUndoLocation</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>,
										  <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keyType</name></expr></argument>, <argument><expr><name>lokey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>img</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>o_header</name><operator>.</operator><name>pageChangeCount</name></name> <operator>=</operator> <name>pageChangeCount</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>partial</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>partial</name><operator>-&gt;</operator><name>isPartial</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>undoLocation</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>undoLocation</name> <operator>=</operator> <name>pageUndoLoc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>readCsn</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>readCsn</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>csn</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>copy_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><name>partial</name></expr></argument>, <argument><expr><name>readCsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If that is the required page according to page change count */</comment>
	<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>img</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pageChangeCount</name> <operator>!=</operator> <name>InvalidOPageChangeCount</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>o_header</name><operator>.</operator><name>pageChangeCount</name></name> <operator>!=</operator> <name>pageChangeCount</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>pageChangeCount</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>o_header</name><operator>.</operator><name>pageChangeCount</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Re-try reading page-level undo item due to concurrent changes */</comment>
	<if_stmt><if>if <condition>(<expr><name>read_undo</name> <operator>&amp;&amp;</operator> <call><name>COMMITSEQNO_IS_NORMAL</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>header</name><operator>-&gt;</operator><name>csn</name></name> <operator>&gt;=</operator> <name>csn</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>UndoLocation</name></type> <name>pageUndoLoc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pageUndoLoc</name> <operator>=</operator> <call><name>read_page_from_undo</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>, <argument><expr><name>csn</name></expr></argument>,
										  <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keyType</name></expr></argument>, <argument><expr><name>lokey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>img</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>o_header</name><operator>.</operator><name>pageChangeCount</name></name> <operator>=</operator> <name>pageChangeCount</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>partial</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>partial</name><operator>-&gt;</operator><name>isPartial</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>undoLocation</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>undoLocation</name> <operator>=</operator> <name>pageUndoLoc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>readCsn</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>readCsn</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>csn</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>undoLocation</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>undoLocation</name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try to read page with concurrent changes.  Returns true on success.
 */</comment>
<function><type><name>ReadPageResult</name></type>
<name>o_btree_try_read_page</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>pageChangeCount</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>img</name></decl></parameter>,
					  <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>keyType</name></decl></parameter>,
					  <parameter><decl><type><name>PartialPageState</name> <modifier>*</modifier></type><name>partial</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name> <modifier>*</modifier></type><name>readCsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>tmpPageChangeCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>read_undo</name> <init>= <expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReadPageResult</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>EA_READ_INC</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check pointer to page-level undo item */</comment>
	<if_stmt><if>if <condition>(<expr><name>read_undo</name> <operator>&amp;&amp;</operator> <call><name>COMMITSEQNO_IS_NORMAL</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>header</name><operator>-&gt;</operator><name>csn</name></name> <operator>&gt;=</operator> <name>csn</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tmpPageChangeCount</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>o_header</name><operator>.</operator><name>pageChangeCount</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pageChangeCount</name> <operator>!=</operator> <name>InvalidOPageChangeCount</name> <operator>&amp;&amp;</operator> <name>tmpPageChangeCount</name> <operator>!=</operator> <name>pageChangeCount</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>ReadPageResultWrongPageChangeCount</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>read_page_from_undo</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>, <argument><expr><name>csn</name></expr></argument>,
							<argument><expr><name>key</name></expr></argument>, <argument><expr><name>keyType</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>img</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>o_header</name><operator>.</operator><name>pageChangeCount</name></name> <operator>=</operator> <name>tmpPageChangeCount</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>readCsn</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>readCsn</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>csn</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>ReadPageResultOK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>try_copy_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>pageChangeCount</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><name>partial</name></expr></argument>, <argument><expr><name>readCsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>ReadPageResultOK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Re-try reading page-level undo item due to concurrent changes */</comment>
	<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>img</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>read_undo</name> <operator>&amp;&amp;</operator> <call><name>COMMITSEQNO_IS_NORMAL</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>header</name><operator>-&gt;</operator><name>csn</name></name> <operator>&gt;=</operator> <name>csn</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tmpPageChangeCount</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>o_header</name><operator>.</operator><name>pageChangeCount</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pageChangeCount</name> <operator>==</operator> <name>InvalidOPageChangeCount</name> <operator>||</operator> <name>tmpPageChangeCount</name> <operator>==</operator> <name>pageChangeCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>read_page_from_undo</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>, <argument><expr><name>csn</name></expr></argument>,
							<argument><expr><name>key</name></expr></argument>, <argument><expr><name>keyType</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>img</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>o_header</name><operator>.</operator><name>pageChangeCount</name></name> <operator>=</operator> <name>tmpPageChangeCount</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>readCsn</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>readCsn</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>csn</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>ReadPageResultOK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>init_new_btree_page</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>flags</name></decl></parameter>,
					<parameter><decl><type><name>uint16</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>noLock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OrioleDBPageDesc</name> <modifier>*</modifier></type><name>page_desc</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>noLock</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>lock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>oids</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>InvalidFileExtentLen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name><operator>.</operator><name>off</name></name> <operator>=</operator> <name>InvalidFileExtentOff</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>O_BTREE_FLAG_LEAF</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>field1</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PAGE_SET_N_VACATED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>PAGE_SET_LEVEL</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PAGE_SET_N_ONDISK</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>rightLink</name></name> <operator>=</operator> <name>InvalidRightLink</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <name>COMMITSEQNO_FROZEN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>checkpointNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>itemsCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>prevInsertOffset</name></name> <operator>=</operator> <name>MaxOffsetNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>maxKeyLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>page_change_usage_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>ppool</name><operator>-&gt;</operator><name>ucm</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name><operator>-&gt;</operator><name>ucm</name><operator>.</operator><name>epoch</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>%</operator> <name>UCM_USAGE_LEVELS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>BTreePageHeader</name></expr></argument>, <argument><expr><name>chunkDesc</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><literal type="number">0</literal></expr></argument>,
		   <argument><expr><name>ORIOLEDB_BLCKSZ</name> <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>BTreePageHeader</name></expr></argument>, <argument><expr><name>chunkDesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>init_meta_page</name><parameter_list>(<parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>leafPagesNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OrioleDBPageDesc</name> <modifier>*</modifier></type><name>page_desc</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeMetaPage</name> <modifier>*</modifier></type><name>metaPageBlkno</name> <init>= <expr><operator>(</operator><name>BTreeMetaPage</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>O_PAGE_HEADER_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name> <operator>-</operator> <name>O_PAGE_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPageBlkno</name><operator>-&gt;</operator><name>leafPagesNum</name></name></expr></argument>, <argument><expr><name>leafPagesNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPageBlkno</name><operator>-&gt;</operator><name>numFreeBlocks</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPageBlkno</name><operator>-&gt;</operator><name>datafileLength</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPageBlkno</name><operator>-&gt;</operator><name>ctid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_SEQ_SCANS_ARRAY_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPageBlkno</name><operator>-&gt;</operator><name>numSeqScans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPageBlkno</name><operator>-&gt;</operator><name>copyBlknoLock</name></name></expr></argument>,
					 <argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>copyBlknoTrancheId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPageBlkno</name><operator>-&gt;</operator><name>metaLock</name></name></expr></argument>,
					 <argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oMetaTrancheId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>oIndexInvalid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>reloid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>InvalidFileExtentLen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name><operator>.</operator><name>off</name></name> <operator>=</operator> <name>InvalidFileExtentOff</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>metaPageBlkno</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>pages</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>metaPageBlkno</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>pages</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metaPageBlkno</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>pages</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate vacated space in the page.
 */</comment>
<function><type><name>LocationIndex</name></type>
<name>page_get_vacated_space</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>vacated_bytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>

	<macro><name>BTREE_PAGE_FOREACH_ITEMS</name><argument_list>(<argument>p</argument>, <argument>&amp;loc</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_FINISHED_FOR_EVERYBODY</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>deleted</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>COMMITSEQNO_IS_INPROGRESS</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>XACT_INFO_MAP_CSN</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>csn</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>vacated_bytes</name> <operator>+=</operator> <call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>vacated_bytes</name> <operator>+=</operator> <call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call> <operator>-</operator>
					<operator>(</operator><name>BTreeLeafTuphdrSize</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>OTupleLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>vacated_bytes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sets to 0 unused space on the page.
 */</comment>
<function><type><name>void</name></type>
<name>null_unused_bytes</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>img</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>img</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>img</name> <operator>+</operator> <name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		   <argument><expr><name>ORIOLEDB_BLCKSZ</name> <operator>-</operator> <name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>page_cut_first_key</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl>,
				<decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_FIRST</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>BTreeNonLeafTuphdrSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuphdr</name> <operator>=</operator> <operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>*</operator><name>tuphdr</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>page_locator_resize_item</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>, <argument><expr><name>BTreeNonLeafTuphdrSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuphdr</name> <operator>=</operator> <operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>tuphdr</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>put_page_image</name><parameter_list>(<parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>img</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name> <operator>+</operator> <name>O_PAGE_HEADER_SIZE</name></expr></argument>,
		   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>img</name> <operator>+</operator> <name>O_PAGE_HEADER_SIZE</name></expr></argument>,
		   <argument><expr><name>ORIOLEDB_BLCKSZ</name> <operator>-</operator> <name>O_PAGE_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Calculates number of vacated bytes for leaf pages and number of
 * disk downlinks for non-leaf pages.
 */</comment>
<function><type><name>void</name></type>
<name>o_btree_page_calculate_statistics</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nVacated</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<macro><name>BTREE_PAGE_FOREACH_ITEMS</name><argument_list>(<argument>p</argument>, <argument>&amp;loc</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tupHdr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tupHdr</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tupHdr</name><operator>-&gt;</operator><name>deleted</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nVacated</name> <operator>+=</operator> <call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>nVacated</name> <operator>+=</operator> <call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call> <operator>-</operator>
					<operator>(</operator><name>BTreeLeafTuphdrSize</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>OTupleLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PAGE_SET_N_VACATED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nVacated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nOnDisk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<macro><name>BTREE_PAGE_FOREACH_ITEMS</name><argument_list>(<argument>p</argument>, <argument>&amp;loc</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>tupHdr</name> <init>= <expr><operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>DOWNLINK_IS_ON_DISK</name><argument_list>(<argument><expr><name><name>tupHdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nOnDisk</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PAGE_SET_N_ONDISK</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nOnDisk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>copy_fixed_tuple</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OFixedTuple</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>tuplen</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>clear_fixed_tuple</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tuplen</name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>OTupleLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuplen</name> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>fixedData</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>src</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name><name>dst</name><operator>-&gt;</operator><name>fixedData</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>fixedData</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tuplen</name> <operator>!=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>fixedData</name><index>[<expr><name>tuplen</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>tuplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_fixed_key_with_len</name><parameter_list>(<parameter><decl><type><name>OFixedKey</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tuplen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>clear_fixed_key</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>src</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name><name>dst</name><operator>-&gt;</operator><name>fixedData</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>fixedData</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tuplen</name> <operator>!=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>fixedData</name><index>[<expr><name>tuplen</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>tuplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>copy_fixed_key</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OFixedKey</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>tuplen</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>clear_fixed_key</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tuplen</name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>OKeyLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuplen</name> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>fixedData</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>copy_fixed_key_with_len</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>copy_fixed_page_key</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OFixedKey</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>,
					<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>loc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>src</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>BTREE_PAGE_READ_TUPLE</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>copy_fixed_key</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>copy_fixed_hikey</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OFixedKey</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>src</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>copy_fixed_key</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>clear_fixed_tuple</name><parameter_list>(<parameter><decl><type><name>OFixedTuple</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>clear_fixed_key</name><parameter_list>(<parameter><decl><type><name>OFixedKey</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>copy_from_fixed_shmem_key</name><parameter_list>(<parameter><decl><type><name>OFixedKey</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>OFixedShmemKey</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>src</name><operator>-&gt;</operator><name>notNull</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>clear_fixed_key</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>fixedData</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fixedData</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name><name>dst</name><operator>-&gt;</operator><name>fixedData</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>formatFlags</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>copy_fixed_shmem_key</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OFixedShmemKey</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>clear_fixed_shmem_key</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>OKeyLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fixedData</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fixedData</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>dst</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>notNull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>src</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>copy_fixed_shmem_page_key</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OFixedShmemKey</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>,
						  <parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>loc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>src</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>BTREE_PAGE_READ_TUPLE</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>copy_fixed_shmem_key</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>copy_fixed_shmem_hikey</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OFixedShmemKey</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>src</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>copy_fixed_shmem_key</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>clear_fixed_shmem_key</name><parameter_list>(<parameter><decl><type><name>OFixedShmemKey</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>notNull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>OTuple</name></type>
<name>fixed_shmem_key_get_tuple</name><parameter_list>(<parameter><decl><type><name>OFixedShmemKey</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>notNull</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fixedData</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>formatFlags</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>OTuple</name></type>
<name>page_get_hikey</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageChunkDesc</name> <modifier>*</modifier></type><name>chunkDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>chunkDesc</name> <operator>=</operator> <operator>&amp;</operator><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>chunkDesc</name><operator>-&gt;</operator><name>hikeyFlags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>chunkDesc</name><operator>-&gt;</operator><name>hikeyShortLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>page_get_hikey_size</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageChunkDesc</name> <modifier>*</modifier></type><name>chunkDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>chunkDesc</name> <operator>=</operator> <operator>&amp;</operator><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name><name>header</name><operator>-&gt;</operator><name>hikeysEnd</name></name> <operator>-</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>chunkDesc</name><operator>-&gt;</operator><name>hikeyShortLocation</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>page_set_hikey_flags</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageChunkDesc</name> <modifier>*</modifier></type><name>chunkDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>chunkDesc</name> <operator>=</operator> <operator>&amp;</operator><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkDesc</name><operator>-&gt;</operator><name>hikeyFlags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>page_fits_hikey</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>LocationIndex</name></type> <name>newHikeySize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>dataShift</name></decl>,
				<decl><type ref="prev"/><name>hikeyLocation</name></decl>,
				<decl><type ref="prev"/><name>dataLocation</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newHikeySize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>newHikeySize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hikeyLocation</name> <operator>=</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dataLocation</name> <operator>=</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>shortLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hikeyLocation</name> <operator>+</operator> <name>newHikeySize</name> <operator>&lt;=</operator> <name>dataLocation</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>dataShift</name> <operator>=</operator> <name>hikeyLocation</name> <operator>+</operator> <name>newHikeySize</name> <operator>-</operator> <name>dataLocation</name></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name> <operator>+</operator> <name>dataShift</name> <operator>&lt;=</operator> <name>ORIOLEDB_BLCKSZ</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>page_resize_hikey</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>LocationIndex</name></type> <name>newHikeySize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>dataShift</name></decl>,
				<decl><type ref="prev"/><name>hikeyLocation</name></decl>,
				<decl><type ref="prev"/><name>dataLocation</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newHikeySize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>newHikeySize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hikeyLocation</name> <operator>=</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dataLocation</name> <operator>=</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>shortLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hikeyLocation</name> <operator>+</operator> <name>newHikeySize</name> <operator>&lt;=</operator> <name>dataLocation</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Fits */</comment>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>hikeysEnd</name></name> <operator>=</operator> <name>hikeyLocation</name> <operator>+</operator> <name>newHikeySize</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>dataShift</name> <operator>=</operator> <name>hikeyLocation</name> <operator>+</operator> <name>newHikeySize</name> <operator>-</operator> <name>dataLocation</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name> <operator>+</operator> <name>dataShift</name> <operator>&lt;=</operator> <name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <name>dataLocation</name> <operator>+</operator> <name>dataShift</name></expr></argument>,
			<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <name>dataLocation</name></expr></argument>,
			<argument><expr><name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name> <operator>-</operator> <name>dataLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>shortLocation</name> <operator>+=</operator> <call><name>LOCATION_GET_SHORT</name><argument_list>(<argument><expr><name>dataShift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>hikeysEnd</name></name> <operator>=</operator> <name>hikeyLocation</name> <operator>+</operator> <name>newHikeySize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name> <operator>+=</operator> <name>dataShift</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>btree_page_update_max_key_len</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>maxKeyLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>maxKeyLen</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_HIKEY_SIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>maxKeyLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>


	<macro><name>BTREE_PAGE_FOREACH_ITEMS</name><argument_list>(<argument>p</argument>, <argument>&amp;loc</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LocationIndex</name></type> <name>keyLen</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>keyLen</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call> <operator>-</operator>
				<name>BTreeNonLeafTuphdrSize</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>BTREE_PAGE_READ_TUPLE</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>keyLen</name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>OTupleKeyLengthNoVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>maxKeyLen</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>maxKeyLen</name></expr></argument>, <argument><expr><name>keyLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>maxKeyLen</name></name> <operator>=</operator> <name>maxKeyLen</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
