<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/btree/iterator.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * interator.c
 *		Implemetation of orioledb B-tree iterator.
 *
 * Copyright (c) 2021-2022, Oriole DB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/btree/interator.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/btree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/find.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/iterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/page_chunks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transam/oxid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transam/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/page_pool.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<comment type="block">/* Iterates through undo images */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
	<comment type="block">/* a current page image from undo log */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>image</name><index>[<expr><name>ORIOLEDB_BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>
	<comment type="block">/* a lokey of the image for backward scan */</comment>
	<decl_stmt><decl><type><name>OFixedKey</name></type>	<name>lokey</name></decl>;</decl_stmt>
	<comment type="block">/* a base undo location */</comment>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>baseLoc</name></decl>;</decl_stmt>
	<comment type="block">/* undo location of the image */</comment>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>imageUndoLoc</name></decl>;</decl_stmt>
	<comment type="block">/* is the image leftmost on the base location */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>leftmost</name></decl>;</decl_stmt>
	<comment type="block">/* is the image rightmost on the base location */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>rightmost</name></decl>;</decl_stmt>
}</block></struct></type> <name>UndoIterator</name>;</typedef>

<struct>struct <name>BTreeIterator</name>
<block>{
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoIterator</name></type> <name>undoIt</name></decl>;</decl_stmt>
	<comment type="block">/* scan direction of current iterator: forward or backward */</comment>
	<decl_stmt><decl><type><name>ScanDirection</name></type> <name>scanDir</name></decl>;</decl_stmt>
	<comment type="block">/* current tuple location in UndoIterator */</comment>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>undoLoc</name></decl>;</decl_stmt>
	<comment type="block">/* do we have to combine results from both current and undo pages? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>combinedResult</name></decl>;</decl_stmt>
	<comment type="block">/* do we need to combine results in the current page? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>combinedPage</name></decl>;</decl_stmt>
	<comment type="block">/* memory context for returned tuples */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tupleCxt</name></decl>;</decl_stmt>
	<comment type="block">/* callback for fetching tuple version */</comment>
	<decl_stmt><decl><type><name>TupleFetchCallback</name></type> <name>fetchCallback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>fetchCallbackArg</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<comment type="block">/* additional check for iteration order */</comment>
	<decl_stmt><decl><type><name>OFixedTuple</name></type> <name>prevTuple</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_next_combined_location</name><parameter_list>(<parameter><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>load_page_from_undo</name><parameter_list>(<parameter><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>kind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>btree_iterator_check_load_next_page</name><parameter_list>(<parameter><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>OTuple</name></type> <name>o_btree_iterator_fetch_internal</name><parameter_list>(<parameter><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>,
											  <parameter><decl><type><name>CommitSeqNo</name> <modifier>*</modifier></type><name>tupleCsn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>o_btree_interator_can_fetch_from_undo</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>can_fetch_from_undo</name><parameter_list>(<parameter><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>undo_it_create</name><parameter_list>(<parameter><decl><type><name>UndoIterator</name> <modifier>*</modifier></type><name>undoIt</name></decl></parameter>, <parameter><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>undo_it_init</name><parameter_list>(<parameter><decl><type><name>UndoIterator</name> <modifier>*</modifier></type><name>undoIt</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>kind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>undo_it_next_page</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>UndoIterator</name> <modifier>*</modifier></type><name>undoIt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>undo_it_switch</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>UndoIterator</name> <modifier>*</modifier></type><name>undoIt</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>undo_it_find_internal</name><parameter_list>(<parameter><decl><type><name>UndoIterator</name> <modifier>*</modifier></type><name>undoIt</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>kind</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IT_IS_BACKWARD</name><parameter_list>(<parameter><type><name>it</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((it)-&gt;scanDir == BackwardScanDirection)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IT_IS_FORWARD</name><parameter_list>(<parameter><type><name>it</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((it)-&gt;scanDir == ForwardScanDirection)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_LAST_PAGE</name><parameter_list>(<parameter><type><name>page</name></type></parameter>, <parameter><type><name>it</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((IT_IS_FORWARD((it)) &amp;&amp; O_PAGE_IS(page, RIGHTMOST)) \
								|| (IT_IS_BACKWARD((it)) &amp;&amp; O_PAGE_IS(page, LEFTMOST)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IT_NEXT_OFFSET</name><parameter_list>(<parameter><type><name>it</name></type></parameter>, <parameter><type><name>loc</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (IT_IS_FORWARD(it)) \
			BTREE_PAGE_LOCATOR_NEXT((it)-&gt;context.img, (loc)); \
		else if (IT_IS_BACKWARD(it)) \
			BTREE_PAGE_LOCATOR_PREV((it)-&gt;context.img, (loc)); \
	} while (0); \

#define UNDO_IT_NEXT_OFFSET(undoIt, loc) \
	do { \
		if (IT_IS_FORWARD(it)) \
			BTREE_PAGE_LOCATOR_NEXT((undoIt)-&gt;image, (loc)); \
		else if (IT_IS_BACKWARD(it)) \
			BTREE_PAGE_LOCATOR_PREV((undoIt)-&gt;image, (loc)); \
	} while (0);</cpp:value></cpp:define> \

<comment type="block">/*
 * Fetches tuple from the tree with given CSN snapshot.  Tuple is allocated
 * in the given context.  Leaf page is found using the given hint (if provided).
 * Given hint is adjusted with relevant leaf page.
 */</comment>
<function><type><name>OTuple</name></type>
<name>o_btree_find_tuple_by_key_cb</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
							 <parameter><decl><type><name>BTreeKeyType</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>readCsn</name></decl></parameter>,
							 <parameter><decl><type><name>CommitSeqNo</name> <modifier>*</modifier></type><name>outCsn</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>,
							 <parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>deleted</name></decl></parameter>,
							 <parameter><decl><type><name>TupleFetchCallback</name></type> <name>cb</name></decl></parameter>,
							 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>img</name> <init>= <expr><name><name>context</name><operator>.</operator><name>img</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>img</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>combinedResult</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>COMMITSEQNO_IS_NORMAL</name><argument_list>(<argument><expr><name>readCsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>combinedResult</name> <operator>=</operator> <operator>!</operator><call><name>have_current_undo</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>init_page_find_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>,
						   <argument><expr><ternary><condition><expr><name>combinedResult</name></expr> ?</condition><then> <expr><name>COMMITSEQNO_INPROGRESS</name></expr> </then><else>: <expr><name>readCsn</name></expr></else></ternary></expr></argument>, <argument><expr><name>BTREE_PAGE_FIND_FETCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Use page location hint if provided */</comment>
	<if_stmt><if>if <condition>(<expr><name>hint</name> <operator>&amp;&amp;</operator> <call><name>OInMemoryBlknoIsValid</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>refind_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>pageChangeCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>find_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>loc</name> <operator>=</operator> <name><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr>;</expr_stmt>

	<comment type="block">/* Adjust hint if given */</comment>
	<if_stmt><if>if <condition>(<expr><name>hint</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>pageChangeCount</name></name> <operator>=</operator> <name><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>pageChangeCount</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>combinedResult</name> <operator>&amp;&amp;</operator> <name><name>header</name><operator>-&gt;</operator><name>csn</name></name> <operator>&gt;=</operator> <name>readCsn</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tupHdr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OTuple</name></type>		<name>curTuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>result_size</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OTupleXactInfo</name></type> <name>xactInfo</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tupHdr</name></expr></argument>, <argument><expr><name>curTuple</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tupHdr</name> <operator>=</operator> <operator>(</operator><name>BTreeLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>xactInfo</name> <operator>=</operator> <name><name>tupHdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_OXID_IS_CURRENT</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>outCsn</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>outCsn</name> <operator>=</operator> <name>COMMITSEQNO_INPROGRESS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>deleted</name> <operator>=</operator> <name><name>tupHdr</name><operator>-&gt;</operator><name>deleted</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tupHdr</name><operator>-&gt;</operator><name>deleted</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>result_size</name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>curTuple</name></expr></argument>, <argument><expr><name>OTupleLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>result</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>mcxt</name></expr></argument>, <argument><expr><name>result_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>curTuple</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>result_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>result</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>curTuple</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>read_page_from_undo</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>, <argument><expr><name>readCsn</name></expr></argument>,
							<argument><expr><name>key</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>btree_page_search</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>page_locator_find_real_item</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tupHdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>curTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tupHdr</name></expr></argument>, <argument><expr><name>curTuple</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>curTuple</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>deleted</name> <operator>=</operator> <name><name>tupHdr</name><operator>-&gt;</operator><name>deleted</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>o_find_tuple_version</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>, <argument><expr><name>readCsn</name></expr></argument>, <argument><expr><name>outCsn</name></expr></argument>,
										<argument><expr><name>mcxt</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Tuple isn't found */</comment>
	<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>OTuple</name></type>
<name>o_btree_find_tuple_by_key</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>kind</name></decl></parameter>,
						  <parameter><decl><type><name>CommitSeqNo</name></type> <name>readCsn</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name> <modifier>*</modifier></type><name>outCsn</name></decl></parameter>,
						  <parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>, <parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>o_btree_find_tuple_by_key_cb</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>readCsn</name></expr></argument>, <argument><expr><name>outCsn</name></expr></argument>,
										<argument><expr><name>mcxt</name></expr></argument>, <argument><expr><name>hint</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Finds appropriate tuple version in the undo chain.
 */</comment>
<function><type><name>OTuple</name></type>
<name>o_find_tuple_version</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>loc</name></decl></parameter>,
					 <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name> <modifier>*</modifier></type><name>tupleCsn</name></decl></parameter>,
					 <parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>, <parameter><decl><type><name>TupleFetchCallback</name></type> <name>cb</name></decl></parameter>,
					 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeLeafTuphdr</name></type> <name>tupHdr</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tupHdrPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>curTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>undoLocation</name> <init>= <expr><name>InvalidUndoLocation</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>curTupleAllocated</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>prevMctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prevMctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tupHdrPtr</name></expr></argument>, <argument><expr><name>curTuple</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupHdr</name> <operator>=</operator> <operator>*</operator><name>tupHdrPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>find_non_lock_only_undo_record</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tupHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>COMMITSEQNO_IS_NORMAL</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>COMMITSEQNO_IS_INPROGRESS</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTupleXactInfo</name></type> <name>xactInfo</name> <init>= <expr><name><name>tupHdr</name><operator>.</operator><name>xactInfo</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>txIsFinished</name> <init>= <expr><call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>tupcsn</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tupcsn</name> <operator>=</operator> <call><name>XACT_INFO_MAP_CSN</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tupleCsn</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>COMMITSEQNO_IS_NORMAL</name><argument_list>(<argument><expr><name>tupcsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>tupleCsn</name> <operator>=</operator> <ternary><condition><expr><call><name>COMMITSEQNO_IS_NORMAL</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>Max</name><argument_list>(<argument><expr><name>csn</name></expr></argument>, <argument><expr><name>tupcsn</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>COMMITSEQNO_MAX_NORMAL</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>COMMITSEQNO_IS_FROZEN</name><argument_list>(<argument><expr><name>tupcsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>tupleCsn</name> <operator>=</operator> <ternary><condition><expr><call><name>COMMITSEQNO_IS_NORMAL</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>csn</name></expr> </then><else>: <expr><name>COMMITSEQNO_MAX_NORMAL</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>tupleCsn</name> <operator>=</operator> <name>COMMITSEQNO_INPROGRESS</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>cb</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TupleFetchCallbackResult</name></type> <name>cbResult</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>version_check</name> <init>= <expr><operator>!</operator><name>txIsFinished</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OXid</name></type>		<name>tupOxid</name> <init>= <expr><ternary><condition><expr><name>version_check</name></expr> ?</condition><then> <expr><call><name>XACT_INFO_GET_OXID</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>InvalidOXid</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleFetchCallbackCheckType</name></type> <name>check_type</name> <init>= <expr><ternary><condition><expr><name>version_check</name></expr> ?</condition><then>
			<expr><name>OTupleFetchCallbackVersionCheck</name></expr> </then><else>:
			<expr><name>OTupleFetchCallbackKeyCheck</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>cbResult</name> <operator>=</operator> <call><name>cb</name><argument_list>(<argument><expr><name>curTuple</name></expr></argument>, <argument><expr><name>tupOxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>check_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>cbResult</name> <operator>==</operator> <name>OTupleFetchMatch</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>cbResult</name> <operator>==</operator> <name>OTupleFetchNotMatch</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>prevMctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>result</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>txIsFinished</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cb</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>COMMITSEQNO_IS_INPROGRESS</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_GET_OXID</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>get_current_oxid_if_any</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
					<name>csn</name> <operator>!=</operator> <name>COMMITSEQNO_MAX_NORMAL</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>COMMITSEQNO_IS_INPROGRESS</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>COMMITSEQNO_IS_INPROGRESS</name><argument_list>(<argument><expr><name>tupcsn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>COMMITSEQNO_IS_ABORTED</name><argument_list>(<argument><expr><name>tupcsn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>tupcsn</name> <operator>&lt;</operator> <name>csn</name> <operator>||</operator> <call><name>COMMITSEQNO_IS_INPROGRESS</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>undoLocation</name> <operator>=</operator> <name><name>tupHdr</name><operator>.</operator><name>undoLocation</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>prevMctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tupHdr</name><operator>.</operator><name>deleted</name></name> <operator>||</operator> <call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name><name>tupHdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>get_prev_leaf_header_from_undo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tupHdr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>curTupleAllocated</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>curTuple</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>get_prev_leaf_header_and_tuple_from_undo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tupHdr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>curTuple</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>curTupleAllocated</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UNDO_REC_EXISTS</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><call><name>COMMITSEQNO_IS_NON_DELETED</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tupHdr</name><operator>.</operator><name>deleted</name></name> <operator>&amp;&amp;</operator> <call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name><name>tupHdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>prevMctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tupHdr</name><operator>.</operator><name>deleted</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>prevMctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>curTupleAllocated</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result_size</name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>curTuple</name></expr></argument>, <argument><expr><name>OTupleLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* TODO: check result tuple size */</comment>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>mcxt</name></expr></argument>, <argument><expr><name>result_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>curTuple</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>result_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>curTuple</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>curTuple</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>UNDO_REC_EXISTS</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>prevMctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BTreeIterator</name> <modifier>*</modifier></type>
<name>o_btree_iterator_create</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>kind</name></decl></parameter>,
						<parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>scanDir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>findFlags</name> <init>= <expr><name>BTREE_PAGE_FIND_IMAGE</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <operator>(</operator><name>BTreeIterator</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTreeIterator</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>combinedResult</name></name> <operator>=</operator> <operator>!</operator><call><name>have_current_undo</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>COMMITSEQNO_IS_NORMAL</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <name>csn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>scanDir</name></name> <operator>=</operator> <name>scanDir</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>tupleCxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>fetchCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>fetchCallbackArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_SET_INVALID</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>prevTuple</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>undo_it_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoIt</name></name></expr></argument>, <argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IT_IS_BACKWARD</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>findFlags</name> <operator>|=</operator> <name>BTREE_PAGE_FIND_KEEP_LOKEY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>init_page_find_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>desc</name></expr></argument>,
						   <argument><expr><ternary><condition><expr><name><name>it</name><operator>-&gt;</operator><name>combinedResult</name></name></expr> ?</condition><then> <expr><name>COMMITSEQNO_INPROGRESS</name></expr> </then><else>: <expr><name>csn</name></expr></else></ternary></expr></argument>, <argument><expr><name>findFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IT_IS_FORWARD</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>kind</name> <operator>=</operator> <name>BTreeKeyNone</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>kind</name> <operator>=</operator> <name>BTreeKeyRightmost</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>find_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>key</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>IT_IS_BACKWARD</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>loc</name> <init>= <expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>make_dec</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * From btree_page_binary_search(): "When nextkey is false (this
		 * case), we are looking for the first item &gt;= scankey."
		 *
		 * If it's next item than decrement item offset. In case item ==
		 * search key no need to do this.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>img</name></name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>img</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>img</name></name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>img</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>make_dec</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>OTuple</name></type>		<name>tup</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>BTREE_PAGE_READ_TUPLE</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>img</name></name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tup</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>make_dec</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>make_dec</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_PREV</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>img</name></name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>load_page_from_undo</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
						<argument><expr><ternary><condition><expr><name>kind</name> <operator>!=</operator> <name>BTreeKeyRightmost</name></expr> ?</condition><then> <expr><name>kind</name></expr> </then><else>: <expr><name>BTreeKeyNone</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>it</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>o_btree_iterator_set_tuple_ctx</name><parameter_list>(<parameter><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>tupleCxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>tupleCxt</name></name> <operator>=</operator> <name>tupleCxt</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>o_btree_iterator_set_callback</name><parameter_list>(<parameter><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>,
							  <parameter><decl><type><name>TupleFetchCallback</name></type> <name>callback</name></decl></parameter>,
							  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>fetchCallback</name></name> <operator>=</operator> <name>callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>fetchCallbackArg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>OTuple</name></type>
<name>o_btree_iterator_fetch</name><parameter_list>(<parameter><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name> <modifier>*</modifier></type><name>tupleCsn</name></decl></parameter>,
					   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>endType</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>endIsIncluded</name></decl></parameter>, <parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>desc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>o_btree_iterator_fetch_internal</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>tupleCsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>end</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name> <init>= <expr><call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>endType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IT_IS_BACKWARD</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cmp</name> <operator>*=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;=</operator> <operator>(</operator><ternary><condition><expr><name>endIsIncluded</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>prevTuple</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>prevTuple</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>IT_IS_FORWARD</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>copy_fixed_tuple</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>prevTuple</name></name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>hint</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>pageChangeCount</name></name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>pageChangeCount</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free resouces associated with iterator.
 */</comment>
<function><type><name>void</name></type>
<name>btree_iterator_free</name><parameter_list>(<parameter><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Load page from undo for combined result.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>load_page_from_undo</name><parameter_list>(<parameter><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>context</name> <init>= <expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name><name>context</name><operator>-&gt;</operator><name>img</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>desc</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>combinedResult</name></name> <operator>&amp;&amp;</operator> <name><name>header</name><operator>-&gt;</operator><name>csn</name></name> <operator>&gt;=</operator> <name><name>it</name><operator>-&gt;</operator><name>csn</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>undo_it_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoIt</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>key</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>btree_page_search</name><argument_list>(<argument><expr><name>desc</name></expr></argument>,
							  <argument><expr><name><name>it</name><operator>-&gt;</operator><name>undoIt</name><operator>.</operator><name>image</name></name></expr></argument>,
							  <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>page_locator_find_real_item</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>undoIt</name><operator>.</operator><name>image</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IT_IS_BACKWARD</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OTuple</name></type>		<name>founded</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>undoOffset</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>BTREE_PAGE_READ_TUPLE</name><argument_list>(<argument><expr><name>founded</name></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>undoIt</name><operator>.</operator><name>image</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * From btree_page_binary_search(): "When nextkey is false
				 * (this case), we are looking for the first item &gt;= scankey."
				 *
				 * If it's next item than decrement item offset. In case item
				 * == key bound no need to do this.
				 */</comment>
				<expr_stmt><expr><name>undoOffset</name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>undoIt</name><operator>.</operator><name>image</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>undoOffset</name> <operator>&lt;=</operator> <call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>undoIt</name><operator>.</operator><name>image</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>undoOffset</name> <operator>==</operator> <call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>undoIt</name><operator>.</operator><name>image</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
					<call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>founded</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_PREV</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>undoIt</name><operator>.</operator><name>image</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IT_IS_FORWARD</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_FIRST</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>undoIt</name><operator>.</operator><name>image</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_LAST</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>undoIt</name><operator>.</operator><name>image</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>combinedPage</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_next_combined_location</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>combinedPage</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find the next tuple location for result combination.  It should have
 * current oxid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_next_combined_location</name><parameter_list>(<parameter><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>context</name> <init>= <expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name> <init>= <expr><call><name>get_current_oxid_if_any</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>loc</name> <init>= <expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>context</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>img</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>img</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tupHdr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tupHdr</name> <operator>=</operator> <operator>(</operator><name>BTreeLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_OXID_EQ</name><argument_list>(<argument><expr><name><name>tupHdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>IT_NEXT_OFFSET</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch next tuple without checking for end condition.
 */</comment>
<function><type><specifier>static</specifier> <name>OTuple</name></type>
<name>o_btree_iterator_fetch_internal</name><parameter_list>(<parameter><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name> <modifier>*</modifier></type><name>tupleCsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>desc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>context</name> <init>= <expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBtreePageFindItem</name> <modifier>*</modifier></type><name>leaf_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>img</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>img</name></name></expr></init></decl>,
				<decl><type ref="prev"/><name>hImg</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>undoIt</name><operator>.</operator><name>image</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>result</name></decl>,
				<decl><type ref="prev"/><name>itup</name></decl>,
				<decl><type ref="prev"/><name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>btree_iterator_check_load_next_page</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>leaf_item</name> <operator>=</operator> <operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>context</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>combinedPage</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>hImg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cmp</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>leaf_item</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cmp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_TUPLE</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>leaf_item</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_TUPLE</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>hImg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>itup</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>htup</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>IT_IS_BACKWARD</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>cmp</name> <operator>*=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* mirror compare logic */</comment>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>o_find_tuple_version</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>img</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>leaf_item</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>,
											  <argument><expr><name><name>it</name><operator>-&gt;</operator><name>csn</name></name></expr></argument>, <argument><expr><name>tupleCsn</name></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>tupleCxt</name></name></expr></argument>,
											  <argument><expr><name><name>it</name><operator>-&gt;</operator><name>fetchCallback</name></name></expr></argument>,
											  <argument><expr><name><name>it</name><operator>-&gt;</operator><name>fetchCallbackArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>IT_NEXT_OFFSET</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>leaf_item</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>get_next_combined_location</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>UNDO_IT_NEXT_OFFSET</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoIt</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>o_find_tuple_version</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>hImg</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>,
											  <argument><expr><name><name>it</name><operator>-&gt;</operator><name>csn</name></name></expr></argument>, <argument><expr><name>tupleCsn</name></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>tupleCxt</name></name></expr></argument>,
											  <argument><expr><name><name>it</name><operator>-&gt;</operator><name>fetchCallback</name></name></expr></argument>,
											  <argument><expr><name><name>it</name><operator>-&gt;</operator><name>fetchCallbackArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>UNDO_IT_NEXT_OFFSET</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoIt</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>o_find_tuple_version</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>img</name></name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>leaf_item</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>,
										  <argument><expr><name><name>it</name><operator>-&gt;</operator><name>csn</name></name></expr></argument>, <argument><expr><name>tupleCsn</name></expr></argument>,
										  <argument><expr><name><name>it</name><operator>-&gt;</operator><name>tupleCxt</name></name></expr></argument>,
										  <argument><expr><name><name>it</name><operator>-&gt;</operator><name>fetchCallback</name></name></expr></argument>,
										  <argument><expr><name><name>it</name><operator>-&gt;</operator><name>fetchCallbackArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>IT_NEXT_OFFSET</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>leaf_item</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>				<comment type="block">/* unreachable */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Check and load the next tree page if needed.  Works with both normal and undo
 * pages.  Return true on success.  False means there is nothing more to read.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>btree_iterator_check_load_next_page</name><parameter_list>(<parameter><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>context</name> <init>= <expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>img</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>img</name></name></expr></init></decl>,
				<decl><type ref="prev"/><name>hImg</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>undoIt</name><operator>.</operator><name>image</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>img</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>desc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OFixedKey</name></type>	<name>key_buf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>o_btree_interator_can_fetch_from_undo</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><operator>!</operator><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>context</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>step_result</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_LAST_PAGE</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IT_IS_FORWARD</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>step_result</name> <operator>=</operator> <call><name>find_right_page</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>step_result</name> <operator>=</operator> <call><name>find_left_page</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>step_result</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>combinedResult</name></name> <operator>&amp;&amp;</operator> <name><name>header</name><operator>-&gt;</operator><name>csn</name></name> <operator>&gt;=</operator> <name><name>it</name><operator>-&gt;</operator><name>csn</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>reload</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>combinedPage</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>reload</name> <operator>=</operator> <operator>!</operator><call><name>o_btree_interator_can_fetch_from_undo</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>reload</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We can not to use current undo images iterator.
				 */</comment>

				<comment type="block">/* finds a tuple to resume */</comment>
				<expr_stmt><expr><call><name>undo_it_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoIt</name></name></expr></argument>,
							 <argument><expr><name><name>header</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>key_buf</name></expr></argument>,
							 <argument><expr><operator>(</operator><ternary><condition><expr><call><name>IT_IS_FORWARD</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>BTreeKeyNonLeafKey</name></expr> </then><else>: <expr><name>BTreeKeyPageHiKey</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>btree_page_search</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>hImg</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name><name>key_buf</name><operator>.</operator><name>tuple</name></name></expr></argument>,
								  <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>page_locator_find_real_item</name><argument_list>(<argument><expr><name>hImg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IT_IS_BACKWARD</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_PREV</name><argument_list>(<argument><expr><name>hImg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>get_next_combined_location</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>combinedPage</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>combinedPage</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>can_fetch_from_undo</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Can we fetch more pages form undo page image?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>o_btree_interator_can_fetch_from_undo</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>hImg</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>undoIt</name><operator>.</operator><name>image</name></name></expr></init></decl>,
				<decl><type ref="prev"/><name>img</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>img</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>img</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>hImg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>can_switch</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>combinedResult</name></name> <operator>&amp;&amp;</operator> <name><name>header</name><operator>-&gt;</operator><name>csn</name></name> <operator>&gt;=</operator> <name><name>it</name><operator>-&gt;</operator><name>csn</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* switch to next history page if we can */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>undo_it_next_page</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>desc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoIt</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>(</operator><name>can_switch</name> <operator>&amp;&amp;</operator> <call><name>undo_it_switch</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoIt</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IT_IS_FORWARD</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_FIRST</name><argument_list>(<argument><expr><name>hImg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_LAST</name><argument_list>(<argument><expr><name>hImg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>combinedPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>hImg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>can_fetch_from_undo</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if `historicalImg` still contains tuples corresponding to the `img`
 * key range.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>can_fetch_from_undo</name><parameter_list>(<parameter><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>desc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>context</name> <init>= <expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

	<comment type="block">/* False if no tuples to fetch */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>undoIt</name><operator>.</operator><name>image</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* True if `img` key range is inifity in the required direction */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_LAST_PAGE</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>img</name></name></expr></argument>, <argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Compare the next tuple with corresponding key range bound */</comment>
	<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_TUPLE</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>undoIt</name><operator>.</operator><name>image</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>undoLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IT_IS_FORWARD</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>hikey</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>hikey</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>img</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hikey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>htup</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else						<comment type="block">/* backward iterator case */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>lokey</name> <init>= <expr><call><name>btree_find_context_lokey</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lokey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>htup</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>cmp</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Iterate over leaf page tuples without considering undo log.  Deleted tuples
 * are reported as NULLs.  So, the separate `*end` flag indicates finish of
 * iterations.
 */</comment>
<function><type><name>OTuple</name></type>
<name>btree_iterate_raw</name><parameter_list>(<parameter><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>endKind</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>endInclude</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>scanEnd</name></decl></parameter>, <parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tupHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>context</name> <init>= <expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>img</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>img</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OFixedKey</name></type>	<name>key_buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>scanEnd</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>loc</name> <init>= <expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>context</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tupHdr</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>img</name></name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>IT_NEXT_OFFSET</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>end</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>endKind</name> <operator>!=</operator> <name>BTreeKeyNone</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>desc</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>endKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>cmp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>endInclude</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>scanEnd</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tupHdr</name><operator>-&gt;</operator><name>deleted</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>hint</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>pageChangeCount</name></name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>pageChangeCount</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><name>result</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>result</name></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_LAST_PAGE</name><argument_list>(<argument><expr><name>img</name></expr></argument>, <argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>scanEnd</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IT_IS_FORWARD</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>find_right_page</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>result</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>find_left_page</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>result</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>				<comment type="block">/* unreachable */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Fills basic fields of undo iterator
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>undo_it_create</name><parameter_list>(<parameter><decl><type><name>UndoIterator</name> <modifier>*</modifier></type><name>undoIt</name></decl></parameter>, <parameter><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>scanDir</name></name> <operator>!=</operator> <name>NoMovementScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>undoIt</name><operator>-&gt;</operator><name>it</name></name> <operator>=</operator> <name>it</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>undoIt</name><operator>-&gt;</operator><name>rightmost</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>undoIt</name><operator>-&gt;</operator><name>leftmost</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>undoIt</name><operator>-&gt;</operator><name>baseLoc</name></name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>undoIt</name><operator>-&gt;</operator><name>imageUndoLoc</name></name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initializes the undo iterator
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>undo_it_init</name><parameter_list>(<parameter><decl><type><name>UndoIterator</name> <modifier>*</modifier></type><name>undoIt</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>undoIt</name><operator>-&gt;</operator><name>baseLoc</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>undo_it_find_internal</name><argument_list>(<argument><expr><name>undoIt</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Tries to switch to next undo page from baseLoc
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>undo_it_next_page</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>UndoIterator</name> <modifier>*</modifier></type><name>undoIt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeKeyType</name></type> <name>kind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OFixedKey</name></type>	<name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>prevLoc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>baseLoc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Get bound key from the current undo page */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IT_IS_FORWARD</name><argument_list>(<argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>it</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>undoIt</name><operator>-&gt;</operator><name>rightmost</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* no more pages */</comment>
		<expr_stmt><expr><call><name>copy_fixed_hikey</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>image</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>kind</name> <operator>=</operator> <name>BTreeKeyNonLeafKey</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>undoIt</name><operator>-&gt;</operator><name>leftmost</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* no more pages */</comment>
		<expr_stmt><expr><call><name>copy_fixed_key</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>lokey</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>kind</name> <operator>=</operator> <name>BTreeKeyPageHiKey</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_LAST_PAGE</name><argument_list>(<argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>it</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>prevLoc</name> <operator>=</operator> <name><name>undoIt</name><operator>-&gt;</operator><name>imageUndoLoc</name></name></expr>;</expr_stmt>

	<comment type="block">/* Find undo page corresponding to the key from the undoIt-&gt;baseLoc */</comment>
	<expr_stmt><expr><call><name>undo_it_find_internal</name><argument_list>(<argument><expr><name>undoIt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>key</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Did we manage to find another page? */</comment>
	<if_stmt><if>if <condition>(<expr><name>prevLoc</name> <operator>!=</operator> <name><name>undoIt</name><operator>-&gt;</operator><name>imageUndoLoc</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>rightmost</name></name> <operator>||</operator> <name><name>undoIt</name><operator>-&gt;</operator><name>leftmost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Tries to switch to the next baseLoc
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>undo_it_switch</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>UndoIterator</name> <modifier>*</modifier></type><name>undoIt</name></decl></parameter>, <parameter><decl><type><name>UndoLocation</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_forward</name> <init>= <expr><call><name>IT_IS_FORWARD</name><argument_list>(<argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>it</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>baseLoc</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreeKeyType</name></type> <name>kind</name> <init>= <expr><ternary><condition><expr><name>is_forward</name></expr> ?</condition><then> <expr><name>BTreeKeyNone</name></expr> </then><else>: <expr><name>BTreeKeyRightmost</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="block">/* load of full undo */</comment>
		<expr_stmt><expr><name><name>undoIt</name><operator>-&gt;</operator><name>baseLoc</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>undo_it_find_internal</name><argument_list>(<argument><expr><name>undoIt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* else we must find next page in undo */</comment>

	<expr_stmt><expr><name><name>undoIt</name><operator>-&gt;</operator><name>baseLoc</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IS_LAST_PAGE</name><argument_list>(<argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>it</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* there is no more pages expected */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We need to find the page, which hikey moves to the required
		 * direction in comparison with previous undo page.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_forward</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>undo_it_find_internal</name><argument_list>(<argument><expr><name>undoIt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyRightmost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * we expect that a loaded rightmost page is equal to the
				 * previous
				 */</comment>
				<return>return <expr><call><name>undo_it_next_page</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>undoIt</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>OFixedKey</name></type>	<name>prev_hikey</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

			<comment type="block">/* copy the previous page hikey */</comment>
			<expr_stmt><expr><call><name>copy_fixed_hikey</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev_hikey</name></expr></argument>, <argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>image</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>undo_it_find_internal</name><argument_list>(<argument><expr><name>undoIt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prev_hikey</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>BTreeKeyPageHiKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>cmp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>OTuple</name></type>		<name>image_hikey</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>image_hikey</name></expr></argument>, <argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>image</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>image_hikey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>prev_hikey</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>undo_it_next_page</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>undoIt</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/* in forward case we must load next page */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_forward</name> <operator>||</operator> <name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* in backward case we must load previous page */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>is_forward</name> <operator>||</operator> <name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find in undo log page corresponding to the given key.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>undo_it_find_internal</name><parameter_list>(<parameter><decl><type><name>UndoIterator</name> <modifier>*</modifier></type><name>undoIt</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>rec_csn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>rec_undo_loc</name></decl>,
				<decl><type ref="prev"/><name>undoLocation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>left</name></decl>,
				<decl><type ref="prev"/><name>right</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>undoLocation</name> <operator>=</operator> <name><name>undoIt</name><operator>-&gt;</operator><name>baseLoc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>undoIt</name><operator>-&gt;</operator><name>leftmost</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>undoIt</name><operator>-&gt;</operator><name>rightmost</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Load the next page item from page-level undo item */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>undoIt</name><operator>-&gt;</operator><name>it</name><operator>-&gt;</operator><name>scanDir</name></name> <operator>==</operator> <name>ForwardScanDirection</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>get_page_from_undo</name><argument_list>(<argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>desc</name></name></expr></argument>, <argument><expr><name>undoLocation</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>,
							   <argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>get_page_from_undo</name><argument_list>(<argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>it</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>desc</name></name></expr></argument>, <argument><expr><name>undoLocation</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>,
							   <argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>undoIt</name><operator>-&gt;</operator><name>lokey</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>undoIt</name><operator>-&gt;</operator><name>rightmost</name></name> <operator>=</operator> <operator>(</operator><name><name>undoIt</name><operator>-&gt;</operator><name>rightmost</name></name> <operator>&amp;&amp;</operator> <name>right</name><operator>)</operator> <operator>||</operator> <call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>undoIt</name><operator>-&gt;</operator><name>leftmost</name></name> <operator>=</operator> <operator>(</operator><name><name>undoIt</name><operator>-&gt;</operator><name>leftmost</name></name> <operator>&amp;&amp;</operator> <name>left</name><operator>)</operator> <operator>||</operator> <call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><name>LEFTMOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>undoIt</name><operator>-&gt;</operator><name>imageUndoLoc</name></name> <operator>=</operator> <call><name>O_UNDO_GET_IMAGE_LOCATION</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UNDO_REC_EXISTS</name><argument_list>(<argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name><name>undoIt</name><operator>-&gt;</operator><name>image</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rec_csn</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>csn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rec_undo_loc</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>undoLocation</name></name></expr>;</expr_stmt>

		<comment type="block">/* Check if we need to visit next page-level undo item */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>COMMITSEQNO_IS_NORMAL</name><argument_list>(<argument><expr><name>rec_csn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>rec_csn</name> <operator>&gt;=</operator> <name><name>undoIt</name><operator>-&gt;</operator><name>it</name><operator>-&gt;</operator><name>csn</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>undoLocation</name> <operator>=</operator> <name>rec_undo_loc</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* if O_PAGE_IS(undoIt-&gt;image, RIGHTMOST) then undoIt-&gt;righmost == true */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>undoIt</name><operator>-&gt;</operator><name>rightmost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* if O_PAGE_IS(undoIt-&gt;image, LEFTMOST) then undoIt-&gt;leftmost == true */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name><name>undoIt</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><name>LEFTMOST</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>undoIt</name><operator>-&gt;</operator><name>leftmost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
