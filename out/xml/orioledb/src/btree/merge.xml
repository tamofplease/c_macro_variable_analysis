<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/btree/merge.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * merge.c
 *		Routines for implementation of B-tree pages merge.
 *
 * Copyright (c) 2021-2022, Oriole DB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/btree/merge.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/find.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/merge.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/page_chunks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"checkpoint/checkpoint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/page_pool.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transam/undo.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<comment type="block">/*
 * If the ratio of free to total space on a leaf page is greater than the value
 * then we will try to merge the node page.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>O_MERGE_LEAF_FREE_RATIO</name></cpp:macro> <cpp:value>(0.7)</cpp:value></cpp:define>
<comment type="block">/*
 * If the ratio of free to total space on a node page is greater than the value
 * then we will try to merge the node page.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>O_MERGE_NODE_FREE_RATIO</name></cpp:macro> <cpp:value>(0.7)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>can_be_merged</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>right</name></decl></parameter>,
						  <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>merge_pages</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>left_blkno</name></decl></parameter>,
						<parameter><decl><type><name>Page</name></type> <name>right</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Try to merge right page to the left page.  Returns true iff succeed.
 *
 * On success, all pages are unlocked.  On failure, all locks are held.
 */</comment>
<function><type><name>bool</name></type>
<name>btree_try_merge_pages</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>,
					  <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>parent_blkno</name></decl></parameter>, <parameter><decl><type><name>OFixedKey</name> <modifier>*</modifier></type><name>parent_hikey</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>merge_parent</name></decl></parameter>,
					  <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>left_blkno</name></decl></parameter>,
					  <parameter><decl><type><name>BTreePageItemLocator</name></type> <name>right_loc</name></decl></parameter>, <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>right_blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>parent</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>left</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>right</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>right_blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OrioleDBPageDesc</name> <modifier>*</modifier></type><name>right_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>left_header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>left</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FileExtent</name></type>	<name>right_extent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>undo_loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>checkpoint_number</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>copy_blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needsUndo</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RightLinkIsValid</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_GET_RIGHTLINK</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* concurrent split in progress */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_checkpoint_number</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>right_blkno</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>checkpoint_number</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copy_blkno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * page is concurrent to in progress checkpoint and can not be merged
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>needsUndo</name> <operator>=</operator> <call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>desc</name><operator>-&gt;</operator><name>undoType</name></name> <operator>!=</operator> <name>UndoReserveNone</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>needsUndo</name> <operator>&amp;&amp;</operator> <call><name>OXidIsValid</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>createOxid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>createOxid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>needsUndo</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>needsUndo</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>csn</name> <operator>=</operator> <call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextCommitSeqNo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>csn</name> <operator>=</operator> <name>COMMITSEQNO_INPROGRESS</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>can_be_merged</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* all checks are done, errors do not expected after this line */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* deletes downlink to right page from the parent node */</comment>
	<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>page_locator_delete_item</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right_loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MARK_DIRTY</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* unlocks the parent page */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>merge_parent</name> <operator>&amp;&amp;</operator> <call><name>is_page_too_sparse</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can try to merge thr parent page in the loop.  No undo is
		 * required for non-leaf pages.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>copy_fixed_hikey</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>parent_hikey</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name><name>parent_hikey</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* no need to merge parent page */</comment>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parent_blkno</name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>merge_parent</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Make a page-level undo item if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name>needsUndo</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>undo_loc</name> <operator>=</operator> <call><name>make_merge_undo_image</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name>undo_loc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Memory barrier between making undo image and setting the undo
		 * location.
		 */</comment>
		<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>undo_loc</name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Merge the pages and remove rightlink to the right page.
	 *
	 * It contains the required memory barrier between making undo image and
	 * setting the undo location.
	 */</comment>
	<expr_stmt><expr><call><name>merge_pages</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>left_blkno</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>btree_page_update_max_key_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MARK_DIRTY</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* the right page can not be found in B-Tree after this line */</comment>

	<expr_stmt><expr><name><name>left_header</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>=</operator> <name>undo_loc</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Memory barrier between write undo location and csn.  See comment in the
	 * o_btree_read_page() for details.
	 */</comment>
	<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>left_header</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <name>csn</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>left_blkno</name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>right_desc</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name>right_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>right_extent</name> <operator>=</operator> <name><name>right_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLEAN_DIRTY</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>right_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>O_PAGE_CHANGE_COUNT_INC</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ppool_free_page</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>right_blkno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_fetch_sub_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>BTREE_GET_META</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>leafPagesNum</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FileExtentIsValid</name><argument_list>(<argument><expr><name>right_extent</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free_extent_for_checkpoint</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right_extent</name></expr></argument>,
								   <argument><expr><name>checkpoint_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Returns true if page is successfully merged to the left or to the right.
 */</comment>
<function><type><name>bool</name></type>
<name>btree_try_merge_and_unlock</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>nested</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wait_io</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>target_loc</name></decl>,
				<decl><type ref="prev"/><name>left_loc</name></decl>,
				<decl><type ref="prev"/><name>right_loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>target</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>parent</name></decl>,
				<decl><type ref="prev"/><name>right</name></decl>,
				<decl><type ref="prev"/><name>left</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OFixedKey</name></type>	<name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>level</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name></type> <name>find_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>parent_blkno</name></decl>,
				<decl><type ref="prev"/><name>target_blkno</name> <init>= <expr><name>OInvalidInMemoryBlkno</name></expr></init></decl>,
				<decl><type ref="prev"/><name>right_blkno</name></decl>,
				<decl><type ref="prev"/><name>left_blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>parent_change_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>success</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needsUndo</name> <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>undoType</name></name> <operator>!=</operator> <name>UndoReserveNone</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Reserve the required undo size.  We are holding the page lock, so we
	 * can only do this with 'wait == false'.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>needsUndo</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>reserve_undo_size_extended</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>undoType</name></name></expr></argument>,
												 <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>O_MERGE_UNDO_IMAGE_SIZE</name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* unable to reserve undo location, no opportunity to resume */</comment>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>have_locked_pages</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Step 1: get all the information from the parent page */</comment>
	<expr_stmt><expr><name>level</name> <operator>=</operator> <call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>page_is_locked</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name> <operator>!=</operator> <name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>is_page_too_sparse</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>LEFTMOST</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RightLinkIsValid</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_GET_RIGHTLINK</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* copy hikey of current page */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>copy_fixed_hikey</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* unlock current page */</comment>
	<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Step 2: refind the parent.  We did release the target lock first: locks
	 * shouldn't go bottom-up.
	 */</comment>
	<expr_stmt><expr><call><name>init_page_find_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name>find_context</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>, <argument><expr><name>BTREE_PAGE_FIND_MODIFY</name> <operator>|</operator> <name>BTREE_PAGE_FIND_DOWNLINK_LOCATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get a full find context for parent page and lock it */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>find_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name>find_context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>key</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>BTreeKeyPageHiKey</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>find_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name>find_context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyRightmost</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>parent_blkno</name> <operator>=</operator> <name><name>find_context</name><operator>.</operator><name>items</name><index>[<expr><name><name>find_context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>parent_change_count</name> <operator>=</operator> <name><name>find_context</name><operator>.</operator><name>items</name><index>[<expr><name><name>find_context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>pageChangeCount</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>target_tuph</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>right_tuph</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>left_tuph</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>merge_parent</name></decl>,
					<decl><type ref="prev"/><name>merged</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>page_is_locked</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* refind parent page if needed */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>refind_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name>find_context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>key</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>BTreeKeyPageHiKey</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
							<argument><expr><name>parent_blkno</name></expr></argument>,
							<argument><expr><name>parent_change_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>refind_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name>find_context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyRightmost</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
							<argument><expr><name>parent_blkno</name></expr></argument>,
							<argument><expr><name>parent_change_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Step 3: do all the checks with parent and target */</comment>
		<expr_stmt><expr><name>parent_change_count</name> <operator>=</operator> <name><name>find_context</name><operator>.</operator><name>items</name><index>[<expr><name><name>find_context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>pageChangeCount</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parent_blkno</name> <operator>=</operator> <name><name>find_context</name><operator>.</operator><name>items</name><index>[<expr><name><name>find_context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>page_is_locked</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>target_loc</name> <operator>=</operator> <name><name>find_context</name><operator>.</operator><name>items</name><index>[<expr><name><name>find_context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>target_tuph</name> <operator>=</operator> <operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target_loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DOWNLINK_IS_IN_MEMORY</name><argument_list>(<argument><expr><name><name>target_tuph</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Page with O_BTREE_FLAG_UNDER_MERGE can not be evicted. But it
			 * can be split or merged and evicted.
			 */</comment>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>target_blkno</name> <operator>=</operator> <call><name>DOWNLINK_GET_IN_MEMORY_BLKNO</name><argument_list>(<argument><expr><name><name>target_tuph</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* all ok, lock target page */</comment>
		<expr_stmt><expr><call><name>lock_page</name><argument_list>(<argument><expr><name>target_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>target_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>level</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>==</operator> <call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator>
			<call><name>RightLinkIsValid</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_GET_RIGHTLINK</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The target page is a single child of parent node or concurrent
			 * split in progress.
			 */</comment>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>target_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>page_is_under_checkpoint</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call>
			<operator>||</operator> <operator>(</operator><name>level</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>page_is_under_checkpoint</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>target_blkno</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* pages merge is concurrent to in progress checkpoint */</comment>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>target_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>merge_parent</name> <operator>=</operator> <operator>(</operator><name>nested</name> <operator>&amp;&amp;</operator> <name><name>find_context</name><operator>.</operator><name>index</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Step 4: try to merge to the right.  On success, all page lock are
		 * released.  On failure, target and parent page locks are held.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target_loc</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator>
			<call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>right_loc</name> <operator>=</operator> <name>target_loc</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right_loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>right_tuph</name> <operator>=</operator> <operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right_loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>DOWNLINK_IS_IN_IO</name><argument_list>(<argument><expr><name><name>right_tuph</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>wait_io</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Wait till IO completion and retry */</comment>
				<decl_stmt><decl><type><name>uint32</name></type>		<name>io_num</name> <init>= <expr><call><name>DOWNLINK_GET_IO_LOCKNUM</name><argument_list>(<argument><expr><name><name>right_tuph</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>target_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>target_blkno</name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>wait_for_io_completion</name><argument_list>(<argument><expr><name>io_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>DOWNLINK_IS_IN_MEMORY</name><argument_list>(<argument><expr><name><name>right_tuph</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>io_num</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DOWNLINK_IS_IN_MEMORY</name><argument_list>(<argument><expr><name><name>right_tuph</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>right_blkno</name> <operator>=</operator> <call><name>DOWNLINK_GET_IN_MEMORY_BLKNO</name><argument_list>(<argument><expr><name><name>right_tuph</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>lock_page</name><argument_list>(<argument><expr><name>right_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>right</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>right_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>io_num</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name>right_blkno</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ionum</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>io_num</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>wait_io</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>target_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>right_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>target_blkno</name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>wait_for_io_completion</name><argument_list>(<argument><expr><name>io_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>PRE_CLEANUP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>RightLinkIsValid</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_GET_RIGHTLINK</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>page_is_under_checkpoint</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>right_blkno</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<name>io_num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>merged</name> <operator>=</operator> <call><name>btree_try_merge_pages</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>parent_blkno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>merge_parent</name></expr></argument>, <argument><expr><name>target_blkno</name></expr></argument>,
												   <argument><expr><name>right_loc</name></expr></argument>, <argument><expr><name>right_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>merged</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>right_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>merged</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>right_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Step 5: try to merge to the left.  On success, all page lock are
		 * released.  On failure, target and parent page locks are held.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>merged</name> <operator>&amp;&amp;</operator> <call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target_loc</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>left_loc</name> <operator>=</operator> <name>target_loc</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_PREV</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left_loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>left_tuph</name> <operator>=</operator> <operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left_loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>DOWNLINK_IS_IN_IO</name><argument_list>(<argument><expr><name><name>left_tuph</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>wait_io</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Wait till IO completion and retry */</comment>
				<decl_stmt><decl><type><name>uint32</name></type>		<name>io_num</name> <init>= <expr><call><name>DOWNLINK_GET_IO_LOCKNUM</name><argument_list>(<argument><expr><name><name>left_tuph</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>target_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>target_blkno</name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>wait_for_io_completion</name><argument_list>(<argument><expr><name>io_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>DOWNLINK_IS_IN_MEMORY</name><argument_list>(<argument><expr><name><name>left_tuph</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>io_num</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DOWNLINK_IS_IN_MEMORY</name><argument_list>(<argument><expr><name><name>left_tuph</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>left_blkno</name> <operator>=</operator> <call><name>DOWNLINK_GET_IN_MEMORY_BLKNO</name><argument_list>(<argument><expr><name><name>left_tuph</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>lock_page</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>left</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>io_num</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name>target_blkno</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ionum</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>io_num</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>wait_io</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>target_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>target_blkno</name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>wait_for_io_completion</name><argument_list>(<argument><expr><name>io_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>PRE_CLEANUP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>RightLinkIsValid</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_GET_RIGHTLINK</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>page_is_under_checkpoint</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<name>io_num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>merged</name> <operator>=</operator> <call><name>btree_try_merge_pages</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>parent_blkno</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>merge_parent</name></expr></argument>,
												   <argument><expr><name>left_blkno</name></expr></argument>,
												   <argument><expr><name>target_loc</name></expr></argument>, <argument><expr><name>target_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>merged</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>merged</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>merged</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>parent_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>target_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>success</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>merge_parent</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name>parent_blkno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>find_context</name><operator>.</operator><name>index</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>parent_blkno</name> <operator>=</operator> <name><name>find_context</name><operator>.</operator><name>items</name><index>[<expr><name><name>find_context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>parent_change_count</name> <operator>=</operator> <name><name>find_context</name><operator>.</operator><name>items</name><index>[<expr><name><name>find_context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>pageChangeCount</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>level</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* else we will try to merge the parent page in the loop */</comment>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>needsUndo</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>release_undo_size</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>undoType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>have_locked_pages</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Checks is pages can be merged.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>can_be_merged</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>right</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>space_free</name></decl>,
				<decl><type ref="prev"/><name>space_needed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_leaf</name> <init>= <expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>space_free</name> <operator>=</operator> <call><name>BTREE_PAGE_FREE_SPACE</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>space_needed</name> <operator>=</operator> <name>ORIOLEDB_BLCKSZ</name> <operator>-</operator> <call><name>BTREE_PAGE_FREE_SPACE</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we can not compact a node */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_leaf</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>space_free</name> <operator>&gt;=</operator> <name>space_needed</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* no need to compact page */</comment>
	<if_stmt><if>if <condition>(<expr><name>space_free</name> <operator>&gt;=</operator> <name>space_needed</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* we can merge pages after the pages compaction */</comment>
	<if_stmt><if>if <condition>(<expr><name>space_free</name> <operator>+</operator> <call><name>PAGE_GET_N_VACATED</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>+</operator>
		<call><name>PAGE_GET_N_VACATED</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>space_needed</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>space_free</name> <operator>+</operator> <call><name>page_get_vacated_space</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>)</argument_list></call> <operator>+</operator>
		<call><name>page_get_vacated_space</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>space_needed</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* we can not merge this pages */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Merges pages and writes result to the left page.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>merge_pages</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>left_blkno</name></decl></parameter>,
			<parameter><decl><type><name>Page</name></type> <name>right</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>left</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>left_header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>left</name></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>right_header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>right</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>leftHikey</name></decl>,
				<decl><type ref="prev"/><name>rightHikey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>leftHikeySize</name></decl>,
				<decl><type ref="prev"/><name>rightHikeySize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItem</name></type> <name><name>items</name><index>[<expr><name>BTREE_PAGE_MAX_CHUNK_ITEMS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>leaf</name> <init>= <expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>newItem</name><index>[<expr><call><name>Max</name><argument_list>(<argument><expr><name>BTreeLeafTuphdrSize</name></expr></argument>, <argument><expr><name>BTreeNonLeafTuphdrSize</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>O_BTREE_MAX_TUPLE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>leftHikeySize</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_HIKEY_SIZE</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>leftHikey</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rightHikeySize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>rightHikey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>rightHikeySize</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_HIKEY_SIZE</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>rightHikey</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>leaf</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>BTREE_PAGE_FOREACH_ITEMS</name><argument_list>(<argument>left</argument>, <argument>&amp;loc</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tupHdr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OTuple</name></type>		<name>tup</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>finished</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tupHdr</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>finished</name> <operator>=</operator> <call><name>XACT_INFO_FINISHED_FOR_EVERYBODY</name><argument_list>(<argument><expr><name><name>tupHdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>finished</name> <operator>&amp;&amp;</operator> <name><name>tupHdr</name><operator>-&gt;</operator><name>deleted</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>COMMITSEQNO_IS_INPROGRESS</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>XACT_INFO_MAP_CSN</name><argument_list>(<argument><expr><name><name>tupHdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>csn</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>tupHdr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name><name>tup</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <ternary><condition><expr><name>finished</name></expr> ?</condition><then> <expr><operator>(</operator><name>BTreeLeafTuphdrSize</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>OTupleLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr> </then><else>:
				<expr><call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>newItem</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<macro><name>BTREE_PAGE_FOREACH_ITEMS</name><argument_list>(<argument>left</argument>, <argument>&amp;loc</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_ITEM_FLAGS</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>newItem</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>leaf</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>BTREE_PAGE_FOREACH_ITEMS</name><argument_list>(<argument>right</argument>, <argument>&amp;loc</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tupHdr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OTuple</name></type>		<name>tup</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>finished</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tupHdr</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>finished</name> <operator>=</operator> <call><name>XACT_INFO_FINISHED_FOR_EVERYBODY</name><argument_list>(<argument><expr><name><name>tupHdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>finished</name> <operator>&amp;&amp;</operator> <name><name>tupHdr</name><operator>-&gt;</operator><name>deleted</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>COMMITSEQNO_IS_INPROGRESS</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>XACT_INFO_MAP_CSN</name><argument_list>(<argument><expr><name><name>tupHdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>csn</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>tupHdr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name><name>tup</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <ternary><condition><expr><name>finished</name></expr> ?</condition><then> <expr><operator>(</operator><name>BTreeLeafTuphdrSize</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>OTupleLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr> </then><else>:
				<expr><call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>newItem</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<macro><name>BTREE_PAGE_FOREACH_ITEMS</name><argument_list>(<argument>right</argument>, <argument>&amp;loc</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newItem</name></expr></argument>,
					   <argument><expr><call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>BTreeNonLeafTuphdrSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newItem</name><index>[<expr><name>BTreeNonLeafTuphdrSize</name></expr>]</index></name></expr></argument>,
					   <argument><expr><name><name>leftHikey</name><operator>.</operator><name>data</name></name></expr></argument>,
					   <argument><expr><name>leftHikeySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name> <operator>=</operator> <name>newItem</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name><name>leftHikey</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>BTreeNonLeafTuphdrSize</name> <operator>+</operator> <name>leftHikeySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>newItem</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_ITEM_FLAGS</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>newItem</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>left_header</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>left_header</name><operator>-&gt;</operator><name>flags</name></name> <operator>|</operator> <name><name>right_header</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>btree_page_reorg</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>items</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>rightHikeySize</name></expr></argument>, <argument><expr><name>rightHikey</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>o_btree_page_calculate_statistics</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>left_header</name><operator>-&gt;</operator><name>rightLink</name></name> <operator>=</operator> <name>InvalidRightLink</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>left_header</name><operator>-&gt;</operator><name>prevInsertOffset</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if page is too sparse and we can try to merge it.
 */</comment>
<function><type><name>bool</name></type>
<name>is_page_too_sparse</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>space_free</name></decl>;</decl_stmt>

	<comment type="block">/* we can not merge rootPageBlkno page */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEFTMOST</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* page should not be under split */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RightLinkIsValid</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_GET_RIGHTLINK</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if leaf have no items */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>space_free</name> <operator>=</operator> <call><name>BTREE_PAGE_FREE_SPACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>PAGE_GET_N_VACATED</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>space_free</name> <operator>/</operator> <name>ORIOLEDB_BLCKSZ</name><operator>)</operator> <operator>&lt;</operator> <name>O_MERGE_LEAF_FREE_RATIO</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>space_free</name> <operator>=</operator> <call><name>BTREE_PAGE_FREE_SPACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>page_get_vacated_space</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>space_free</name> <operator>/</operator> <name>ORIOLEDB_BLCKSZ</name><operator>)</operator> <operator>&gt;=</operator> <name>O_MERGE_LEAF_FREE_RATIO</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* if node have only one downlink */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_ITEMS_COUNT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>space_free</name> <operator>=</operator> <call><name>BTREE_PAGE_FREE_SPACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>space_free</name> <operator>/</operator> <name>ORIOLEDB_BLCKSZ</name><operator>)</operator> <operator>&gt;=</operator> <name>O_MERGE_NODE_FREE_RATIO</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
