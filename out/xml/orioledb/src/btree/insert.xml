<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/btree/insert.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * insert.c
 *		Routines for implementation of inserting new item into B-tree page.
 *
 * Copyright (c) 2021-2022, Oriole DB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/btree/insert.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/find.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/insert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/split.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/page_chunks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"checkpoint/checkpoint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"recovery/recovery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transam/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/page_pool.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/stopevent.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<comment type="block">/* In order to avoid use of the recursion in insert_leaf() we use context. */</comment>
<typedef>typedef <type><struct>struct <name>BTreeInsertStackItem</name>
<block>{
	<comment type="block">/* next item in the find context. next == NULL if it's last item. */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>BTreeInsertStackItem</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<comment type="block">/* current find context */</comment>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
	<comment type="block">/* if level == 0, tuple is BTreeTuple else it is BTreeKey */</comment>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * if level == 0, tupheader is BTreeLeafTuphdr else it is
	 * BTreeNonLeafTuphdr
	 */</comment>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>tupheader</name></decl>;</decl_stmt>
	<comment type="block">/* length of the tuple */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>tuplen</name></decl>;</decl_stmt>
	<comment type="block">/* current level of the insert */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>level</name></decl>;</decl_stmt>
	<comment type="block">/* blkno of the left page of incomplete split. */</comment>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>left_blkno</name></decl>;</decl_stmt>
	<comment type="block">/* is current item replace tuple */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>replace</name></decl>;</decl_stmt>
	<comment type="block">/* is refind_page must be called */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>refind</name></decl>;</decl_stmt>
}</block></struct></type> <name>BTreeInsertStackItem</name>;</typedef>

<comment type="block">/* Fills BTreeInsertStackItem as a downlink of current incomplete split. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>o_btree_split_fill_downlink_item</name><parameter_list>(<parameter><decl><type><name>BTreeInsertStackItem</name> <modifier>*</modifier></type><name>insert_item</name></decl></parameter>,
											 <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>left_blkno</name></decl></parameter>,
											 <parameter><decl><type><name>bool</name></type> <name>lock</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Finishes split of the rootPageBlkno page.
 * insert_item can be filled by o_btree_split_fill_downlink_item call.
 */</comment>
<function_decl><type><specifier>static</specifier> <name>OInMemoryBlkno</name></type> <name>o_btree_finish_root_split_internal</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>,
														 <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>left_blkno</name></decl></parameter>,
														 <parameter><decl><type><name>BTreeInsertStackItem</name> <modifier>*</modifier></type><name>insert_item</name></decl></parameter>,
														 <parameter><decl><type><name>int</name></type> <name>reserve_kind</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Adds a new fix split item to insert context. It modifies an insert_item.
 */</comment>
<function_decl><type><specifier>static</specifier> <name>BTreeInsertStackItem</name> <modifier>*</modifier></type><name>o_btree_insert_stack_push_split_item</name><parameter_list>(<parameter><decl><type><name>BTreeInsertStackItem</name> <modifier>*</modifier></type><name>insert_item</name></decl></parameter>,
																  <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>left_blkno</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>o_btree_insert_item</name><parameter_list>(<parameter><decl><type><name>BTreeInsertStackItem</name> <modifier>*</modifier></type><name>insert_item</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>reserve_kind</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Returns true if a current page is the left page of incomplete split.
 * Should be always call before insert a new tuple to page.
 */</comment>
<function><type><name>bool</name></type>
<name>o_btree_split_is_incomplete</name><parameter_list>(<parameter><decl><type><name>OInMemoryBlkno</name></type> <name>left_blkno</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>relocked</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RightLinkIsValid</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>rightLink</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BROKEN_SPLIT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* wait for split finish */</comment>
		<while>while <condition>(<expr><call><name>RightLinkIsValid</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>rightLink</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BROKEN_SPLIT</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>relock_page</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>relocked</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/* split should be broken or ok after this */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BROKEN_SPLIT</name></expr></argument>)</argument_list></call>
			   <operator>||</operator> <operator>!</operator><call><name>RightLinkIsValid</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>rightLink</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BROKEN_SPLIT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>o_btree_split_fill_downlink_item_with_key</name><parameter_list>(<parameter><decl><type><name>BTreeInsertStackItem</name> <modifier>*</modifier></type><name>insert_item</name></decl></parameter>,
										  <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>left_blkno</name></decl></parameter>,
										  <parameter><decl><type><name>bool</name></type> <name>lock</name></decl></parameter>,
										  <parameter><decl><type><name>OTuple</name></type> <name>key</name></decl></parameter>,
										  <parameter><decl><type><name>LocationIndex</name></type> <name>keylen</name></decl></parameter>,
										  <parameter><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>internal_header</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>right_blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>left_page</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>right_page</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>left_page</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>left_page</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RightLinkIsValid</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>rightLink</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>right_blkno</name> <operator>=</operator> <call><name>RIGHTLINK_GET_BLKNO</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>rightLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>lock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>lock_page</name><argument_list>(<argument><expr><name>right_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>right_page</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>right_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>O_PAGE_GET_CHANGE_COUNT</name><argument_list>(<argument><expr><name>right_page</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>RIGHTLINK_GET_CHANGECOUNT</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>rightLink</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tuplen</name></name> <operator>=</operator> <name>keylen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tuple</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>internal_header</name><operator>-&gt;</operator><name>downlink</name></name> <operator>=</operator> <call><name>MAKE_IN_MEMORY_DOWNLINK</name><argument_list>(<argument><expr><name>right_blkno</name></expr></argument>,
														<argument><expr><call><name>O_PAGE_GET_CHANGE_COUNT</name><argument_list>(<argument><expr><name>right_page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>lock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>right_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tupheader</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>internal_header</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>o_btree_split_fill_downlink_item</name><parameter_list>(<parameter><decl><type><name>BTreeInsertStackItem</name> <modifier>*</modifier></type><name>insert_item</name></decl></parameter>,
								 <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>left_blkno</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>left_page</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>hikey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>keylen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>internal_header</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTreeNonLeafTuphdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>keylen</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_HIKEY_SIZE</name><argument_list>(<argument><expr><name>left_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>left_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>hikey</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>hikey</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>o_btree_split_fill_downlink_item_with_key</name><argument_list>(<argument><expr><name>insert_item</name></expr></argument>, <argument><expr><name>left_blkno</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>,
											  <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>, <argument><expr><name>internal_header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OInMemoryBlkno</name></type>
<name>o_btree_finish_root_split_internal</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>,
								   <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>left_blkno</name></decl></parameter>,
								   <parameter><decl><type><name>BTreeInsertStackItem</name> <modifier>*</modifier></type><name>insert_item</name></decl></parameter>,
								   <parameter><decl><type><name>int</name></type> <name>reserve_kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name></type> <name>internal_header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OrioleDBPageDesc</name> <modifier>*</modifier></type><name>page_desc</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGEDESC</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>left_header</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>root_header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>left_page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FileExtent</name></type>	<name>root_extent</name> <init>= <expr><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_leaf</name> <init>= <expr><call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>left_page</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_new_btree_page</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>left_blkno</name></expr></argument>, <argument><expr><name>O_BTREE_FLAG_LEFTMOST</name></expr></argument>, <argument><expr><call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>left_page</name> <operator>+</operator> <name>O_PAGE_HEADER_SIZE</name></expr></argument>,
		   <argument><expr><name>p</name> <operator>+</operator> <name>O_PAGE_HEADER_SIZE</name></expr></argument>,
		   <argument><expr><name>ORIOLEDB_BLCKSZ</name> <operator>-</operator> <name>O_PAGE_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_new_btree_page</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>,
						<argument><expr><name>O_BTREE_FLAG_RIGHTMOST</name> <operator>|</operator> <name>O_BTREE_FLAG_LEFTMOST</name></expr></argument>,
						<argument><expr><call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>left_page</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_page_first_chunk</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* restore checkpoint number and file offset for the rootPageBlkno */</comment>
	<expr_stmt><expr><name>left_header</name> <operator>=</operator> <operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>left_page</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>root_header</name> <operator>=</operator> <operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root_header</name><operator>-&gt;</operator><name>checkpointNum</name></name> <operator>=</operator> <name><name>left_header</name><operator>-&gt;</operator><name>checkpointNum</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>left_header</name><operator>-&gt;</operator><name>checkpointNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>page_desc</name><operator>-&gt;</operator><name>fileExtent</name></name> <operator>=</operator> <name>root_extent</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>page_is_locked</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_FIRST</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>page_locator_insert_item</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>, <argument><expr><name>BTreeNonLeafTuphdrSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>page_locator_insert_item</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tuplen</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>BTreeNonLeafTuphdrSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tupheader</name></name></expr></argument>, <argument><expr><name>BTreeNonLeafTuphdrSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>BTreeNonLeafTuphdrSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tuplen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTREE_PAGE_SET_ITEM_FLAGS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>, <argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>formatFlags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>internal_header</name><operator>.</operator><name>downlink</name></name> <operator>=</operator> <call><name>MAKE_IN_MEMORY_DOWNLINK</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>,
													   <argument><expr><call><name>O_PAGE_GET_CHANGE_COUNT</name><argument_list>(<argument><expr><name>left_page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_FIRST</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>internal_header</name></expr></argument>, <argument><expr><name>BTreeNonLeafTuphdrSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MARK_DIRTY</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MARK_DIRTY</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>btree_split_mark_finished</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insert_item</name><operator>-&gt;</operator><name>left_blkno</name></name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>btree_page_update_max_key_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_leaf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_fetch_add_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>BTREE_GET_META</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>leafPagesNum</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>left_blkno</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fixes incomplete split of a non-rootPageBlkno page.
 * Left page must be locked.  Unlocks left page and all pages used internally.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>o_btree_fix_page_split</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>left_blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeInsertStackItem</name></type> <name>iitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OFixedKey</name></type>	<name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>level</name> <init>= <expr><call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BROKEN_SPLIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>left_blkno</name> <operator>!=</operator> <name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>iitem</name><operator>.</operator><name>context</name></name> <operator>=</operator> <operator>&amp;</operator><name>context</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>copy_fixed_hikey</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>O_BTREE_FLAG_BROKEN_SPLIT</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>btree_register_inprogress_split</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* FIXME: put O_BTREE_FLAG_BROKEN_SPLIT back on error */</comment>
	<expr_stmt><expr><call><name>ppool_reserve_pages</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>PPOOL_RESERVE_FIND</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_page_find_context</name><argument_list>(<argument><expr><name><name>iitem</name><operator>.</operator><name>context</name></name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>, <argument><expr><name>BTREE_PAGE_FIND_MODIFY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>find_page</name><argument_list>(<argument><expr><name><name>iitem</name><operator>.</operator><name>context</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>BTreeKeyPageHiKey</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iitem</name><operator>.</operator><name>left_blkno</name></name> <operator>=</operator> <name>left_blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iitem</name><operator>.</operator><name>replace</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iitem</name><operator>.</operator><name>refind</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iitem</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name>level</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iitem</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>o_btree_split_fill_downlink_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iitem</name></expr></argument>, <argument><expr><name>left_blkno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>o_btree_insert_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iitem</name></expr></argument>, <argument><expr><name>PPOOL_RESERVE_FIND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fixes incomplete split of a page.
 * Left page must be locked. Unlocks left page and all pages used internally.
 */</comment>
<function><type><name>void</name></type>
<name>o_btree_split_fix_and_unlock</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>left_blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>prev_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nested_call</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nested_call</name> <operator>=</operator> <name>CurrentMemoryContext</name> <operator>==</operator> <name>btree_insert_context</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nested_call</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>prev_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>btree_insert_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Root split can't be incomplete, because it's executed within a single
	 * critical section.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>left_blkno</name> <operator>!=</operator> <name><name>descr</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>o_btree_fix_page_split</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nested_call</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>prev_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextResetOnly</name><argument_list>(<argument><expr><name>btree_insert_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BTreeInsertStackItem</name> <modifier>*</modifier></type>
<name>o_btree_insert_stack_push_split_item</name><parameter_list>(<parameter><decl><type><name>BTreeInsertStackItem</name> <modifier>*</modifier></type><name>insert_item</name></decl></parameter>,
									 <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>left_blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeInsertStackItem</name> <modifier>*</modifier></type><name>new_item</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTreeInsertStackItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Should not be here. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>index</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The incomplete split found. We should fill a new insert item which will
	 * insert downlink to parent and push it to context.
	 */</comment>
	<expr_stmt><expr><name><name>new_item</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OBTreeFindPageContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>new_item</name><operator>-&gt;</operator><name>context</name></name><operator>)</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><name><name>insert_item</name><operator>-&gt;</operator><name>context</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_item</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>index</name></name><operator>--</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>new_item</name><operator>-&gt;</operator><name>replace</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_item</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name><name>insert_item</name><operator>-&gt;</operator><name>level</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_item</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>insert_item</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>o_btree_split_fill_downlink_item</name><argument_list>(<argument><expr><name>new_item</name></expr></argument>, <argument><expr><name>left_blkno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Removes broken flag and unlock page. */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>O_BTREE_FLAG_BROKEN_SPLIT</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>btree_register_inprogress_split</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>left_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insert_item</name><operator>-&gt;</operator><name>refind</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>new_item</name><operator>-&gt;</operator><name>left_blkno</name></name> <operator>=</operator> <name>left_blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_item</name><operator>-&gt;</operator><name>refind</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>new_item</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>o_btree_insert_item</name><parameter_list>(<parameter><decl><type><name>BTreeInsertStackItem</name> <modifier>*</modifier></type><name>insert_item</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reserve_kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>tupheaderlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeKeyType</name></type> <name>kind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>insert_item</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>desc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name> <init>= <expr><name>OInvalidInMemoryBlkno</name></expr></init></decl>,
				<decl><type ref="prev"/><name>right_blkno</name> <init>= <expr><name>OInvalidInMemoryBlkno</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>place_right</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>insert_item</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*--
	 * Guarantees that we never have recursive calls of o_btree_insert_item() such
	 * as:
	 * o_btree_insert_item()-&gt;refind_page()-&gt;find_page()
	 *							      -&gt;o_btree_fix_page_split()-&gt;o_btree_insert_item()
	 *
	 * Reasons:
	 *
	 * 1. o_btree_insert_item() algorithm fixes broken splits itself for pages
	 *    founded by refind_page().
	 * 2. Inner call of ppool_reserve_pages(kind, 2) with a same kind is
	 *    incorrect.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>insert_item</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BTREE_PAGE_FIND_FIX_LEAF_SPLIT</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>insert_item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreeItemPageFitType</name></type> <name>fit</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LocationIndex</name></type> <name>newItemSize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>curContext</name> <init>= <expr><name><name>insert_item</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>next</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>place_right</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>insert_item</name><operator>-&gt;</operator><name>level</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>kind</name> <operator>=</operator> <name>BTreeKeyNonLeafKey</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>kind</name> <operator>=</operator> <name>BTreeKeyLeafTuple</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>curContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>curContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>insert_item</name><operator>-&gt;</operator><name>level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * it can be called only from o_btree_insert_tuple_to_leaf()
			 * o_btree_insert_tuple_to_leaf() can be called only from
			 * o_btree_normal_modify()
			 */</comment>
			<comment type="block">/*
			 * we already make incomplete split checks in (re)find_page()
			 * inside o_btree_normal_modify().
			 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
			<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>page</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RightLinkIsValid</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>rightLink</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>refind</name></name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>relocked</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>insert_item</name><operator>-&gt;</operator><name>refind</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Re-find appropriate tree page.  It might happen that parent
				 * page is not available in context.  That may happen due to
				 * concurrent rootPageBlkno split or page location using hint.
				 * Then just find appropriate page from the rootPageBlkno.
				 */</comment>
				<expr_stmt><expr><call><name>BTREE_PAGE_FIND_UNSET</name><argument_list>(<argument><expr><name>curContext</name></expr></argument>, <argument><expr><name>IMAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>curContext</name><operator>-&gt;</operator><name>index</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>refind_page</name><argument_list>(<argument><expr><name>curContext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>insert_item</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>kind</name></expr></argument>,
								<argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>level</name></name></expr></argument>,
								<argument><expr><name><name>curContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>curContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr></argument>,
								<argument><expr><name><name>curContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>curContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>pageChangeCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>find_page</name><argument_list>(<argument><expr><name>curContext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>insert_item</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>kind</name></expr></argument>,
							  <argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name><name>insert_item</name><operator>-&gt;</operator><name>refind</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>curContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>curContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>o_btree_split_is_incomplete</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relocked</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* pushes fix split item to the insert context */</comment>
				<expr_stmt><expr><name>insert_item</name> <operator>=</operator> <call><name>o_btree_insert_stack_push_split_item</name><argument_list>(<argument><expr><name>insert_item</name></expr></argument>,
																   <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>relocked</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* page is changed, we should refind current tuple */</comment>
				<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>insert_item</name><operator>-&gt;</operator><name>refind</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>insert_item</name><operator>-&gt;</operator><name>level</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <name><name>curContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>curContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>tupheaderlen</name> <operator>=</operator> <name>BTreeNonLeafTuphdrSize</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <name><name>curContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>curContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>tupheaderlen</name> <operator>=</operator> <name>BTreeLeafTuphdrSize</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>newItemSize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tuplen</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>tupheaderlen</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Pass the current value of nextCommitSeqNo to
		 * page_locator_fits_item().  The result coult be somewhat
		 * pessimistic: it might happend that we could actually compact more
		 * due to advance of nextCommitSeqNo.
		 */</comment>
		<expr_stmt><expr><name>fit</name> <operator>=</operator> <call><name>page_locator_fits_item</name><argument_list>(<argument><expr><name>desc</name></expr></argument>,
									 <argument><expr><name>p</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>,
									 <argument><expr><name>newItemSize</name></expr></argument>,
									 <argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>replace</name></name></expr></argument>,
									 <argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextCommitSeqNo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>insert_item</name><operator>-&gt;</operator><name>level</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>page_is_under_checkpoint</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We change a node that is under checkpoint and must mark it as
			 * autonomous.
			 */</comment>
			<expr_stmt><expr><call><name>backend_set_autonomous_level</name><argument_list>(<argument><expr><name>checkpoint_state</name></expr></argument>, <argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>fit</name> <operator>!=</operator> <name>BTreeItemPageFitSplitRequired</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BTreeLeafTuphdr</name></type> <name>prev</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>prevItemSize</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>insert_item</name><operator>-&gt;</operator><name>replace</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>prev</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>BTreeLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>fit</name> <operator>==</operator> <name>BTreeItemPageFitCompactRequired</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>LocationIndex</name></type> <name>newItemLen</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Compact page might insert new item or resize existing item
				 * for us.
				 */</comment>
				<expr_stmt><expr><name>newItemLen</name> <operator>=</operator> <name>BTreeLeafTuphdrSize</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tuplen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>insert_item</name><operator>-&gt;</operator><name>replace</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>newItemLen</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>newItemLen</name></expr></argument>, <argument><expr><call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>perform_page_compaction</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>,
										<argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>,
										<argument><expr><name>newItemLen</name></expr></argument>,
										<argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>replace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>insert_item</name><operator>-&gt;</operator><name>replace</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>LocationIndex</name></type> <name>keyLen</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>fit</name> <operator>!=</operator> <name>BTreeItemPageFitCompactRequired</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>page_locator_insert_item</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>, <argument><expr><name>newItemSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>prevInsertOffset</name></name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>keyLen</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>OTupleKeyLengthNoVersion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>keyLen</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tuplen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>maxKeyLen</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>maxKeyLen</name></name></expr></argument>, <argument><expr><name>keyLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>prevItemSize</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>fit</name> <operator>!=</operator> <name>BTreeItemPageFitCompactRequired</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>prev</name><operator>.</operator><name>deleted</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>BTREE_PAGE_READ_TUPLE</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>PAGE_ADD_N_VACATED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BTreeLeafTuphdrSize</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>OTupleLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * If new tuple is less then previous one, don't resize
					 * page item immediately.  We want to be able to rollback
					 * this action without page splits.
					 *
					 * Page compaction will re-use unoccupied page space when
					 * needed.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>newItemSize</name> <operator>&gt;</operator> <name>prevItemSize</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>page_locator_resize_item</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>, <argument><expr><name>newItemSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>PAGE_SUB_N_VACATED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>prevItemSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>prevInsertOffset</name></name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<function_decl><type><name>OTuple</name>		<name>tuple</name></type> <name>pg_attribute_unused</name><parameter_list>()</parameter_list>;</function_decl>

						<expr_stmt><expr><call><name>BTREE_PAGE_READ_TUPLE</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>PAGE_SUB_N_VACATED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BTreeLeafTuphdrSize</name> <operator>+</operator>
										   <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tuplen</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>prevInsertOffset</name></name> <operator>=</operator> <name>MaxOffsetNumber</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * We replace tuples only in leafs.  Only inserts go to the
				 * non-leaf pages.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>level</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Copy new tuple and header */</comment>
			<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tupheader</name></name></expr></argument>, <argument><expr><name>tupheaderlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>tupheaderlen</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tuplen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BTREE_PAGE_SET_ITEM_FLAGS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>, <argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>formatFlags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>insert_item</name><operator>-&gt;</operator><name>left_blkno</name></name> <operator>!=</operator> <name>OInvalidInMemoryBlkno</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>btree_split_mark_finished</name><argument_list>(<argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>left_blkno</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>btree_unregister_inprogress_split</name><argument_list>(<argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>left_blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>insert_item</name><operator>-&gt;</operator><name>left_blkno</name></name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>page_split_chunk_if_needed</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MARK_DIRTY</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>next</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * No way to fit into the current page.  We have to split the
			 * page.
			 */</comment>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>left_count</name></decl>,
						<decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OTuple</name></type>		<name>split_key</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>LocationIndex</name></type> <name>split_key_len</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>internal_header</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>params</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>root_split_left_blkno</name> <init>= <expr><name>OInvalidInMemoryBlkno</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>UndoLocation</name></type> <name>undoLocation</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>needsUndo</name> <init>= <expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>desc</name><operator>-&gt;</operator><name>undoType</name></name> <operator>!=</operator> <name>UndoReserveNone</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>needsUndo</name> <operator>&amp;&amp;</operator> <call><name>OXidIsValid</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>createOxid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>desc</name><operator>-&gt;</operator><name>createOxid</name></name> <operator>==</operator> <call><name>get_current_oxid_if_any</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>needsUndo</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>STOPEVENTS_ENABLED</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>btree_page_stopevent_params</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Get CSN for undo item if needed */</comment>
			<if_stmt><if>if <condition>(<expr><name>needsUndo</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>csn</name> <operator>=</operator> <call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextCommitSeqNo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>csn</name> <operator>=</operator> <name>COMMITSEQNO_INPROGRESS</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>left_count</name> <operator>=</operator> <call><name>btree_get_split_left_count</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tuplen</name></name></expr></argument>,
													<argument><expr><name>offset</name></expr></argument>, <argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>replace</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>split_key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>split_key_len</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Make page-level undo item if needed */</comment>
			<if_stmt><if>if <condition>(<expr><name>needsUndo</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>undoLocation</name> <operator>=</operator> <call><name>page_add_item_to_undo</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>split_key</name></expr></argument>, <argument><expr><name>split_key_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>undoLocation</name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>internal_header</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTreeNonLeafTuphdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Move hikeyBlkno of split.  This change is atomic, no need to
			 * bother about change count.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>insert_item</name><operator>-&gt;</operator><name>level</name></name></expr>]</index></name><operator>.</operator><name>hikeyBlkno</name> <operator>==</operator> <name>blkno</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>insert_item</name><operator>-&gt;</operator><name>level</name></name></expr>]</index></name><operator>.</operator><name>hikeyBlkno</name> <operator>=</operator> <name>right_blkno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>root_split_left_blkno</name> <operator>=</operator> <call><name>ppool_get_page</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>reserve_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>right_blkno</name> <operator>=</operator> <call><name>ppool_get_page</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>reserve_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>perform_page_split</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>right_blkno</name></expr></argument>,
							   <argument><expr><name>left_count</name></expr></argument>, <argument><expr><name>split_key</name></expr></argument>, <argument><expr><name>split_key_len</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>place_right</name></expr></argument>,
							   <argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tupheader</name></name></expr></argument>,
							   <argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>tuplen</name></name></expr></argument>,
							   <argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>replace</name></name></expr></argument>,
							   <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>undoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>right_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>insert_item</name><operator>-&gt;</operator><name>left_blkno</name></name> <operator>!=</operator> <name>OInvalidInMemoryBlkno</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>btree_split_mark_finished</name><argument_list>(<argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>left_blkno</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>btree_unregister_inprogress_split</name><argument_list>(<argument><expr><name><name>insert_item</name><operator>-&gt;</operator><name>left_blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>insert_item</name><operator>-&gt;</operator><name>left_blkno</name></name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>insert_item</name><operator>-&gt;</operator><name>left_blkno</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>tupheaderlen</name> <operator>=</operator> <name>BTreeNonLeafTuphdrSize</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>o_btree_split_fill_downlink_item_with_key</name><argument_list>(<argument><expr><name>insert_item</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
													  <argument><expr><name>split_key</name></expr></argument>, <argument><expr><name>split_key_len</name></expr></argument>,
													  <argument><expr><name>internal_header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>curContext</name><operator>-&gt;</operator><name>index</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>o_btree_finish_root_split_internal</name><argument_list>(<argument><expr><name>desc</name></expr></argument>,
														   <argument><expr><name>root_split_left_blkno</name></expr></argument>,
														   <argument><expr><name>insert_item</name></expr></argument>, <argument><expr><name>reserve_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>next</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* node and leafs split */</comment>
				<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>btree_register_inprogress_split</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>insert_item</name><operator>-&gt;</operator><name>level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pg_atomic_fetch_add_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>BTREE_GET_META</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>leafPagesNum</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>curContext</name><operator>-&gt;</operator><name>index</name></name><operator>--</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>insert_item</name><operator>-&gt;</operator><name>refind</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>next</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>STOPEVENT_CONDITION</name><argument_list>(<argument><expr><name>STOPEVENT_SPLIT_FAIL</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Debug condition: page has been splitted."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>STOPEVENT</name><argument_list>(<argument><expr><name>STOPEVENT_PAGE_SPLIT</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>next</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Split non-rootPageBlkno case. Insert a downlink. */</comment>
				<expr_stmt><expr><name><name>insert_item</name><operator>-&gt;</operator><name>replace</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>insert_item</name><operator>-&gt;</operator><name>level</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>next</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>insert_item</name> <operator>=</operator> <name><name>insert_item</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>insert_item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ppool_reserve_pages</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>reserve_kind</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>ppool_release_reserved</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><call><name>PPOOL_KIND_GET_MASK</name><argument_list>(<argument><expr><name>reserve_kind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>o_btree_insert_tuple_to_leaf</name><parameter_list>(<parameter><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							 <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>LocationIndex</name></type> <name>tuplen</name></decl></parameter>,
							 <parameter><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>replace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeInsertStackItem</name></type> <name>insert_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>prev_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nested_call</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nested_call</name> <operator>=</operator> <name>CurrentMemoryContext</name> <operator>==</operator> <name>btree_insert_context</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nested_call</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>prev_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>btree_insert_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BTREE_PAGE_FIND_FIX_LEAF_SPLIT</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insert_item</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insert_item</name><operator>.</operator><name>context</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insert_item</name><operator>.</operator><name>tuple</name></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insert_item</name><operator>.</operator><name>tuplen</name></name> <operator>=</operator> <name>tuplen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insert_item</name><operator>.</operator><name>tupheader</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>tuphdr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insert_item</name><operator>.</operator><name>level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insert_item</name><operator>.</operator><name>replace</name></name> <operator>=</operator> <name>replace</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insert_item</name><operator>.</operator><name>left_blkno</name></name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insert_item</name><operator>.</operator><name>refind</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>o_btree_insert_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name>insert_item</name></expr></argument>, <argument><expr><name>PPOOL_RESERVE_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nested_call</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>prev_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextResetOnly</name><argument_list>(<argument><expr><name>btree_insert_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
