<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/btree/page_chunks.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * page_chunks.c
 *		Internals of OrioleDB page chunks: routines for working with chunks
 *		and their items.
 *
 * Copyright (c) 2021-2022, Oriole DB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/btree/page_chunks.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/find.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/insert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/page_chunks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"recovery/recovery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transam/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/page_pool.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ucm.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memdebug.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>reclaim_page_space</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>,
							   <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>location</name></decl></parameter>,
							   <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>LocationIndex</name></type> <name>tuplesize</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>replace</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Load chunk to the partial page.
 */</comment>
<function><type><name>bool</name></type>
<name>partial_load_chunk</name><parameter_list>(<parameter><decl><type><name>PartialPageState</name> <modifier>*</modifier></type><name>partial</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>img</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>chunkOffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>imgState</name></decl>,
				<decl><type ref="prev"/><name>srcState</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>src</name> <init>= <expr><name><name>partial</name><operator>-&gt;</operator><name>src</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>chunkBegin</name></decl>,
				<decl><type ref="prev"/><name>chunkEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>img</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>partial</name><operator>-&gt;</operator><name>isPartial</name></name> <operator>||</operator> <name><name>partial</name><operator>-&gt;</operator><name>chunkIsLoaded</name><index>[<expr><name>chunkOffset</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>chunkBegin</name> <operator>=</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>chunkOffset</name></expr>]</index></name><operator>.</operator><name>shortLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>chunkOffset</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>chunkEnd</name> <operator>=</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>chunkOffset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>shortLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>chunkEnd</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>chunkBegin</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>chunkBegin</name> <operator>&lt;=</operator> <name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>chunkEnd</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>chunkEnd</name> <operator>&lt;=</operator> <name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>img</name> <operator>+</operator> <name>chunkBegin</name></expr></argument>,
		   <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>src</name> <operator>+</operator> <name>chunkBegin</name></expr></argument>,
		   <argument><expr><name>chunkEnd</name> <operator>-</operator> <name>chunkBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>imgState</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><call><name>O_PAGE_HEADER</name><argument_list>(<argument><expr><name>img</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>state</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>srcState</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><call><name>O_PAGE_HEADER</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>state</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>imgState</name> <operator>&amp;</operator> <name>PAGE_STATE_CHANGE_COUNT_MASK</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>srcState</name> <operator>&amp;</operator> <name>PAGE_STATE_CHANGE_COUNT_MASK</name><operator>)</operator> <operator>||</operator>
		<call><name>O_PAGE_STATE_READ_IS_BLOCKED</name><argument_list>(<argument><expr><name>srcState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_GET_CHANGE_COUNT</name><argument_list>(<argument><expr><name>img</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>O_PAGE_GET_CHANGE_COUNT</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>partial</name><operator>-&gt;</operator><name>chunkIsLoaded</name><index>[<expr><name>chunkOffset</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BTreeItemPageFitType</name></type>
<name>page_locator_fits_item</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>locator</name></decl></parameter>,
					   <parameter><decl><type><name>LocationIndex</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>replace</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>freeSpace</name> <init>= <expr><call><name>BTREE_PAGE_FREE_SPACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>spaceNeeded</name> <init>= <expr><name>size</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>oldItemSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>spaceNeeded</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>spaceNeeded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>replace</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * During insert of new item, take into account extension of chunk
		 * items array.
		 */</comment>
		<expr_stmt><expr><name>spaceNeeded</name> <operator>+=</operator>
			<call><name>MAXALIGN</name><argument_list>(<argument><expr><operator>(</operator><name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>-</operator>
			<call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>oldItemSize</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We can replace tuple only on leafs */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>spaceNeeded</name> <operator>-=</operator> <name>oldItemSize</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>spaceNeeded</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>spaceNeeded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>freeSpace</name> <operator>&gt;=</operator> <name>spaceNeeded</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Already have enough of free space on the page */</comment>
		<return>return <expr><name>BTreeItemPageFitAsIs</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Start with optimistic estimate of free space after compaction */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>compactedFreeSpace</name> <init>= <expr><name>freeSpace</name> <operator>+</operator> <call><name>PAGE_GET_N_VACATED</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>replace</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tupHdr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tupHdr</name> <operator>=</operator> <operator>(</operator><name>BTreeLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tupHdr</name><operator>-&gt;</operator><name>deleted</name></name> <operator>&amp;&amp;</operator>
				<call><name>XACT_INFO_FINISHED_FOR_EVERYBODY</name><argument_list>(<argument><expr><name><name>tupHdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>COMMITSEQNO_IS_INPROGRESS</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call> <operator>||</operator>
					   <call><name>XACT_INFO_MAP_CSN</name><argument_list>(<argument><expr><name><name>tupHdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Evade double calculation of space occupied by item to be
				 * replace, which will go away after compaction.
				 */</comment>
				<expr_stmt><expr><name>compactedFreeSpace</name> <operator>-=</operator> <name>oldItemSize</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We have a chance to do a compation on leaf.  Check if at least
		 * optimistic esimate will work.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>compactedFreeSpace</name> <operator>&lt;</operator> <name>spaceNeeded</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>BTreeItemPageFitSplitRequired</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Switch to real estimate.  Real estimate is much slower, but there
		 * is a good chance to evade a page split.
		 */</comment>
		<expr_stmt><expr><name>compactedFreeSpace</name> <operator>-=</operator> <call><name>PAGE_GET_N_VACATED</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>page_get_vacated_space</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>compactedFreeSpace</name> <operator>&gt;=</operator> <name>spaceNeeded</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>BTreeItemPageFitCompactRequired</name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>BTreeItemPageFitSplitRequired</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>BTreeItemPageFitSplitRequired</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>perform_page_compaction</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl></parameter>,
						<parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>loc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>,
						<parameter><decl><type><name>LocationIndex</name></type> <name>tuplesize</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>replace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>undoLocation</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make a page-level undo item if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>undoType</name></name> <operator>!=</operator> <name>UndoReserveNone</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>csn</name> <operator>=</operator> <call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextCommitSeqNo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>undoLocation</name> <operator>=</operator> <call><name>page_add_item_to_undo</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Start page modification.  It contains the required memory barrier
		 * between making undo image and setting the undo location.
		 */</comment>
		<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update the old page meta-data */</comment>

		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>=</operator> <name>undoLocation</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>prevInsertOffset</name></name> <operator>=</operator> <name>MaxOffsetNumber</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Memory barrier between write undo location and csn.  See comment in
		 * the o_btree_read_page() for details.
		 */</comment>
		<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <name>csn</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>csn</name> <operator>=</operator> <name>COMMITSEQNO_INPROGRESS</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>reclaim_page_space</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tuplesize</name></expr></argument>, <argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name> <operator>&lt;=</operator> <name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reclaim page space occupied by deleted and/or resized items.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reclaim_page_space</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>,
				   <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>location</name></decl></parameter>,
				   <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>LocationIndex</name></type> <name>tuplesize</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>replace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItem</name></type> <name><name>items</name><index>[<expr><name>BTREE_PAGE_MAX_CHUNK_ITEMS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OFixedKey</name></type>	<name>hikey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>hikeySize</name></decl>,
				<decl><type ref="prev"/><name>nVacated</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>addedNewItem</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Iterate page items and check if they can be erased or truncated.
	 */</comment>
	<macro><name>BTREE_PAGE_FOREACH_ITEMS</name><argument_list>(<argument>p</argument>, <argument>&amp;loc</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tupHdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>tup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>finished</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addedNewItem</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name><name>loc</name><operator>.</operator><name>chunkOffset</name></name> <operator>==</operator> <name><name>location</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>&amp;&amp;</operator>
			  <name><name>loc</name><operator>.</operator><name>itemOffset</name></name> <operator>==</operator> <name><name>location</name><operator>-&gt;</operator><name>itemOffset</name></name><operator>)</operator> <operator>||</operator> <name><name>loc</name><operator>.</operator><name>chunkOffset</name></name> <operator>&gt;</operator> <name><name>location</name><operator>-&gt;</operator><name>chunkOffset</name></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name> <operator>=</operator> <name><name>tuple</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name><name>tuple</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <name>tuplesize</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>&lt;=</operator> <name>BTreeLeafTuphdrSize</name> <operator>+</operator> <name>O_BTREE_MAX_TUPLE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>newItem</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>addedNewItem</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>replace</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>loc</name><operator>.</operator><name>chunkOffset</name></name> <operator>==</operator> <name><name>location</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>&amp;&amp;</operator> <name><name>loc</name><operator>.</operator><name>itemOffset</name></name> <operator>==</operator> <name><name>location</name><operator>-&gt;</operator><name>itemOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tupHdr</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>finished</name> <operator>=</operator> <call><name>XACT_INFO_FINISHED_FOR_EVERYBODY</name><argument_list>(<argument><expr><name><name>tupHdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>finished</name> <operator>&amp;&amp;</operator> <name><name>tupHdr</name><operator>-&gt;</operator><name>deleted</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><call><name>COMMITSEQNO_IS_INPROGRESS</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>XACT_INFO_MAP_CSN</name><argument_list>(<argument><expr><name><name>tupHdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>csn</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>tupHdr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name><name>tup</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <ternary><condition><expr><name>finished</name></expr> ?</condition><then>
			<expr><operator>(</operator><name>BTreeLeafTuphdrSize</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>OTupleLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr> </then><else>:
			<expr><call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>&lt;=</operator> <name>BTreeLeafTuphdrSize</name> <operator>+</operator> <name>O_BTREE_MAX_TUPLE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>newItem</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tupHdr</name><operator>-&gt;</operator><name>deleted</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nVacated</name> <operator>+=</operator> <call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name>finished</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nVacated</name> <operator>+=</operator> <call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call> <operator>-</operator>
				<operator>(</operator><name>BTreeLeafTuphdrSize</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>OTupleLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addedNewItem</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name> <operator>=</operator> <name><name>tuple</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name><name>tuple</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <name>tuplesize</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>&lt;=</operator> <name>BTreeLeafTuphdrSize</name> <operator>+</operator> <name>O_BTREE_MAX_TUPLE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>newItem</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name><name>hikey</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hikeySize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>copy_fixed_hikey</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hikey</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hikeySize</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_HIKEY_SIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>btree_page_reorg</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>items</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>hikeySize</name></expr></argument>, <argument><expr><name><name>hikey</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PAGE_SET_N_VACATED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nVacated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>init_page_first_chunk</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>LocationIndex</name></type> <name>hikeySize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>hikeySize</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>hikeySize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>itemsCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>hikeysEnd</name></name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTreePageHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <name>hikeySize</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>hikeysEnd</name></name> <operator>&gt;</operator> <call><name>BTREE_PAGE_HIKEYS_END</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>hikeysEnd</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name> <operator>=</operator> <call><name>BTREE_PAGE_HIKEYS_END</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name> <operator>=</operator> <call><name>LOCATION_GET_SHORT</name><argument_list>(<argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTreePageHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>shortLocation</name> <operator>=</operator> <call><name>LOCATION_GET_SHORT</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hikeyFlags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>page_chunk_fill_locator</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>chunkOffset</name></decl></parameter>,
						<parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>locator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>chunkOffset</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>chunkOffset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>offset</name> <operator>-</operator>
			<name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>chunkOffset</name></expr>]</index></name><operator>.</operator><name>offset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>chunkSize</name></name> <operator>=</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>chunkOffset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>shortLocation</name></expr></argument>)</argument_list></call> <operator>-</operator>
			<call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>chunkOffset</name></expr>]</index></name><operator>.</operator><name>shortLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>itemsCount</name></name> <operator>-</operator>
			<name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>chunkOffset</name></expr>]</index></name><operator>.</operator><name>offset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>chunkSize</name></name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name> <operator>-</operator>
			<call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>chunkOffset</name></expr>]</index></name><operator>.</operator><name>shortLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>=</operator> <name>chunkOffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>chunk</name></name> <operator>=</operator> <operator>(</operator><name>BTreePageChunk</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>p</name> <operator>+</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>chunkOffset</name></expr>]</index></name><operator>.</operator><name>shortLocation</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>page_item_fill_locator</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>itemOffset</name></decl></parameter>,
					   <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>locator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>chunkOffset</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>chunkOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>chunkOffset</name> <operator>&lt;</operator> <name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
		   <name>itemOffset</name> <operator>&gt;=</operator> <name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>chunkOffset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>offset</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>chunkOffset</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<expr_stmt><expr><call><name>page_chunk_fill_locator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>chunkOffset</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>=</operator> <name>itemOffset</name> <operator>-</operator> <name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>chunkOffset</name></expr>]</index></name><operator>.</operator><name>offset</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>page_item_fill_locator_backwards</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>itemOffset</name></decl></parameter>,
								 <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>locator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>chunkOffset</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>chunkOffset</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>itemOffset</name> <operator>&lt;</operator> <name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>chunkOffset</name></expr>]</index></name><operator>.</operator><name>offset</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>chunkOffset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>chunkOffset</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>page_chunk_fill_locator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>chunkOffset</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>=</operator> <name>itemOffset</name> <operator>-</operator> <name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>chunkOffset</name></expr>]</index></name><operator>.</operator><name>offset</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Locate the next page item.
 */</comment>
<function><type><name>bool</name></type>
<name>page_locator_next_chunk</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>locator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>&gt;=</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>page_chunk_fill_locator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Locate the next page item.
 */</comment>
<function><type><name>bool</name></type>
<name>page_locator_prev_chunk</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>locator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<do>do
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>page_chunk_fill_locator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>chunk</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	while <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>;</do>
	<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>=</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Insert a new item of given size at the given location.
 */</comment>
<function><type><name>void</name></type>
<name>page_locator_insert_item</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>locator</name></decl></parameter>,
						 <parameter><decl><type><name>LocationIndex</name></type> <name>itemsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>itemsShift</name></decl>,
				<decl><type ref="prev"/><name>dataShift</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>firstItemPtr</name></decl>,
				<decl><type ref="prev"/><name>itemPtr</name></decl>,
				<decl><type ref="prev"/><name>endPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemsize</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>itemsize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Calculate the change of (maxaligned) item array size */</comment>
	<expr_stmt><expr><name>itemsShift</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>-</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Calculate the shift of the data after new item inserted */</comment>
	<expr_stmt><expr><name>dataShift</name> <operator>=</operator> <name>itemsShift</name> <operator>+</operator> <name>itemsize</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>firstItemPtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunk</name></name> <operator>+</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>&lt;</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>itemPtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunk</name></name> <operator>+</operator>
			<call><name>ITEM_GET_OFFSET</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>==</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemPtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunk</name></name> <operator>+</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkSize</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>endPtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name></expr>;</expr_stmt>

	<comment type="block">/* Data should still fit to the page */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>endPtr</name> <operator>+</operator> <name>dataShift</name> <operator>&lt;=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Shift the data after insert location */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemPtr</name> <operator>&lt;=</operator> <name>endPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>itemPtr</name> <operator>+</operator> <name>dataShift</name></expr></argument>, <argument><expr><name>itemPtr</name></expr></argument>, <argument><expr><name>endPtr</name> <operator>-</operator> <name>itemPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Adjust chunks parameters */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shortLocation</name> <operator>+=</operator> <call><name>LOCATION_GET_SHORT</name><argument_list>(<argument><expr><name>dataShift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>itemsCount</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name> <operator>+=</operator> <name>dataShift</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>itemsShift</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If items array size is changed, then we have to also move the items
		 * before insert location and adjust those locations in the items
		 * array.
		 */</comment>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>firstItemPtr</name> <operator>+</operator> <name>itemsShift</name></expr></argument>, <argument><expr><name>firstItemPtr</name></expr></argument>, <argument><expr><name>itemPtr</name> <operator>-</operator> <name>firstItemPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <name>itemsShift</name></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add new element to the items array  */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>dataShift</name></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>itemPtr</name> <operator>-</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunk</name></name> <operator>+</operator> <name>itemsShift</name></expr>;</expr_stmt>

	<comment type="block">/* Adjust the locator */</comment>
	<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>chunkSize</name></name> <operator>+=</operator> <name>dataShift</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>page_locator_fits_new_item</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>locator</name></decl></parameter>,
						   <parameter><decl><type><name>LocationIndex</name></type> <name>itemsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>sizeDiff</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sizeDiff</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>-</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sizeDiff</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>itemsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>BTREE_PAGE_FREE_SPACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>sizeDiff</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get size of the item at given location.
 */</comment>
<function><type><name>LocationIndex</name></type>
<name>page_locator_get_item_size</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>locator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>itemOffset</name></decl>,
				<decl><type ref="prev"/><name>nextItemOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Calculate offset form the beginning of the chunk */</comment>
	<expr_stmt><expr><name>itemOffset</name> <operator>=</operator> <call><name>ITEM_GET_OFFSET</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Next item is in the same chunk */</comment>
		<expr_stmt><expr><name>nextItemOffset</name> <operator>=</operator> <call><name>ITEM_GET_OFFSET</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Next item is in the next chunk. Recalculate offsets from the
		 * beginning of the page.
		 */</comment>
		<expr_stmt><expr><name>itemOffset</name> <operator>+=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunk</name></name> <operator>-</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nextItemOffset</name> <operator>=</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>shortLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>nextItemOffset</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><operator>(</operator><name>nextItemOffset</name> <operator>-</operator> <name>itemOffset</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Resizes page item under given locator.
 */</comment>
<function><type><name>void</name></type>
<name>page_locator_resize_item</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>locator</name></decl></parameter>,
						 <parameter><decl><type><name>LocationIndex</name></type> <name>newsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>dataShift</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>nextItemPtr</name></decl>,
				<decl><type ref="prev"/><name>endPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Calculate data shift */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newsize</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dataShift</name> <operator>=</operator> <name>newsize</name> <operator>-</operator> <call><name>page_locator_get_item_size</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dataShift</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>dataShift</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>dataShift</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>&lt;</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nextItemPtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunk</name></name> <operator>+</operator>
			<call><name>ITEM_GET_OFFSET</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>nextItemPtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunk</name></name> <operator>+</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkSize</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>endPtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>endPtr</name> <operator>+</operator> <name>dataShift</name> <operator>&lt;=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Shift the data after the item */</comment>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>nextItemPtr</name> <operator>+</operator> <name>dataShift</name></expr></argument>, <argument><expr><name>nextItemPtr</name></expr></argument>, <argument><expr><name>endPtr</name> <operator>-</operator> <name>nextItemPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Adjust chunk positions */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shortLocation</name> <operator>+=</operator> <call><name>LOCATION_GET_SHORT</name><argument_list>(<argument><expr><name>dataShift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name> <operator>+=</operator> <name>dataShift</name></expr>;</expr_stmt>

	<comment type="block">/* Adjust the items array */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <name>dataShift</name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Adjust the locator */</comment>
	<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>chunkSize</name></name> <operator>+=</operator> <name>dataShift</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Merge two chunks into one.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>page_merge_chunks</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name><name>tmpItems</name><index>[<expr><name>BTREE_PAGE_MAX_CHUNK_ITEMS</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name>hikeyShift</name></decl>,
				<decl><type ref="prev"/><name>hikeyShift2</name></decl>,
				<decl><type ref="prev"/><name>shift1</name></decl>,
				<decl><type ref="prev"/><name>shift2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
				<decl><type ref="prev"/><name>count1</name></decl>,
				<decl><type ref="prev"/><name>count2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc1</name></decl>,
				<decl><type ref="prev"/><name>loc2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>chunk1DataPtr</name></decl>,
				<decl><type ref="prev"/><name>chunk1EndPtr</name></decl>,
				<decl><type ref="prev"/><name>chunk2DataPtr</name></decl>,
				<decl><type ref="prev"/><name>endPtr</name></decl>,
				<decl><type ref="prev"/><name>p1_1</name></decl>,
				<decl><type ref="prev"/><name>p1_2</name></decl>,
				<decl><type ref="prev"/><name>p2_1</name></decl>,
				<decl><type ref="prev"/><name>p2_2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>index</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>page_chunk_fill_locator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>page_chunk_fill_locator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>count1</name> <operator>=</operator> <name><name>loc1</name><operator>.</operator><name>chunkItemsCount</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>count2</name> <operator>=</operator> <name><name>loc2</name><operator>.</operator><name>chunkItemsCount</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>chunk1DataPtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name><name>loc1</name><operator>.</operator><name>chunk</name></name> <operator>+</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>chunk1EndPtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name><name>loc1</name><operator>.</operator><name>chunk</name></name> <operator>+</operator> <name><name>loc1</name><operator>.</operator><name>chunkSize</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>chunk2DataPtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name><name>loc2</name><operator>.</operator><name>chunk</name></name> <operator>+</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>endPtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>shift1</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>count1</name> <operator>+</operator> <name>count2</name><operator>)</operator></expr></argument>)</argument_list></call> <operator>-</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>shift2</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count1</name></expr></argument>)</argument_list></call> <operator>+</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count2</name></expr></argument>)</argument_list></call> <operator>-</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>count1</name> <operator>+</operator> <name>count2</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count2</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tmpItems</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>loc2</name><operator>.</operator><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator>
			<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count2</name></expr></argument>)</argument_list></call> <operator>+</operator>
			<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>count1</name> <operator>+</operator> <name>count2</name><operator>)</operator></expr></argument>)</argument_list></call> <operator>+</operator>
			<operator>(</operator><name>chunk1EndPtr</name> <operator>-</operator> <name>chunk1DataPtr</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>shift1</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count1</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>loc1</name><operator>.</operator><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <name>shift1</name></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>chunk1DataPtr</name> <operator>+</operator> <name>shift1</name></expr></argument>,
				<argument><expr><name>chunk1DataPtr</name></expr></argument>,
				<argument><expr><name>chunk1EndPtr</name> <operator>-</operator> <name>chunk1DataPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>shift2</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>chunk2DataPtr</name> <operator>-</operator> <name>shift2</name></expr></argument>,
				<argument><expr><name>chunk2DataPtr</name></expr></argument>,
				<argument><expr><name>endPtr</name> <operator>-</operator> <name>chunk2DataPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name> <operator>-=</operator> <name>shift2</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name><name>loc1</name><operator>.</operator><name>chunk</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count1</name></expr></argument>,
		   <argument><expr><name>tmpItems</name></expr></argument>,
		   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hikeyShift</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>BTreePageHeader</name></expr></argument>, <argument><expr><name>chunkDesc</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTreePageChunkDesc</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name></expr></argument>)</argument_list></call> <operator>-</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>BTreePageHeader</name></expr></argument>, <argument><expr><name>chunkDesc</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTreePageChunkDesc</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hikeyShift2</name> <operator>=</operator> <name>hikeyShift</name> <operator>+</operator>
		<call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name></expr></argument>)</argument_list></call> <operator>-</operator>
		<call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>p1_1</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>hikeyShift</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>p1_2</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name></expr></argument>)</argument_list></call> <operator>-</operator>
		<call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>p2_1</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>hikeyShift</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>p2_2</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>hikeysEnd</name></name> <operator>-</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>hikeyFlags</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>hikeyFlags</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>index</name> <operator>+</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>hikeyFlags</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hikeyFlags</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name> <operator>-</operator> <call><name>LOCATION_GET_SHORT</name><argument_list>(<argument><expr><name>hikeyShift2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>shortLocation</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shortLocation</name> <operator>-</operator> <call><name>LOCATION_GET_SHORT</name><argument_list>(<argument><expr><name>shift2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>hikeyShift</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>index</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name> <operator>-</operator> <call><name>LOCATION_GET_SHORT</name><argument_list>(<argument><expr><name>hikeyShift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>hikeyShift</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p1_1</name></expr></argument>, <argument><expr><name>p1_2</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p2_1</name></expr></argument>, <argument><expr><name>p2_2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>hikeysEnd</name></name> <operator>-=</operator> <name>hikeyShift2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VALGRIND_CHECK_MEM_IS_DEFINED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deletes page item under given locator.
 */</comment>
<function><type><name>void</name></type>
<name>page_locator_delete_item</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>locator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>itemsShift</name></decl>,
				<decl><type ref="prev"/><name>dataShift</name></decl>,
				<decl><type ref="prev"/><name>itemsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>firstItemPtr</name></decl>,
				<decl><type ref="prev"/><name>itemPtr</name></decl>,
				<decl><type ref="prev"/><name>endPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Get item size */</comment>
	<expr_stmt><expr><name>itemsize</name> <operator>=</operator> <call><name>page_locator_get_item_size</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemsize</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>itemsize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>itemsShift</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr></argument>)</argument_list></call> <operator>-</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dataShift</name> <operator>=</operator> <name>itemsShift</name> <operator>+</operator> <name>itemsize</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>firstItemPtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunk</name></name> <operator>+</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>&lt;</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itemPtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunk</name></name> <operator>+</operator>
		<call><name>ITEM_GET_OFFSET</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>endPtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>endPtr</name> <operator>-</operator> <name>dataShift</name> <operator>&gt;=</operator> <name>itemPtr</name> <operator>-</operator> <name>itemsShift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Adjust the items array.  We should do this first to prevent it been
	 * overridden by the data when it's shorten.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name>dataShift</name></expr>;</expr_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name>itemsShift</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Shift the data before deleted item when items arrays is shorten. */</comment>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>firstItemPtr</name> <operator>-</operator> <name>itemsShift</name></expr></argument>, <argument><expr><name>firstItemPtr</name></expr></argument>, <argument><expr><name>itemPtr</name> <operator>-</operator> <name>firstItemPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Shift item pointers of those items */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-=</operator> <name>itemsShift</name></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Move the data after deleted item */</comment>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>itemPtr</name> <operator>-</operator> <name>itemsShift</name></expr></argument>, <argument><expr><name>itemPtr</name> <operator>+</operator> <name>itemsize</name></expr></argument>, <argument><expr><name>endPtr</name> <operator>-</operator> <name>itemPtr</name> <operator>-</operator> <name>itemsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Adjust position of following chunks */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shortLocation</name> <operator>-=</operator> <call><name>LOCATION_GET_SHORT</name><argument_list>(<argument><expr><name>dataShift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>itemsCount</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name> <operator>-=</operator> <name>dataShift</name></expr>;</expr_stmt>

	<comment type="block">/* Adjust the locator */</comment>
	<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>chunkSize</name></name> <operator>-=</operator> <name>dataShift</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>page_merge_chunks</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>page_chunk_fill_locator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>=</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>page_merge_chunks</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>page_chunk_fill_locator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Split the given page chunk into two.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>page_split_chunk</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>locator</name></decl></parameter>,
				 <parameter><decl><type><name>LocationIndex</name></type> <name>hikeysEnd</name></decl></parameter>, <parameter><decl><type><name>LocationIndex</name></type> <name>hikeySize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name><name>tmpItems</name><index>[<expr><name>BTREE_PAGE_MAX_CHUNK_ITEMS</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name>leftItemsShift</name></decl>,
				<decl><type ref="prev"/><name>rightItemsShift</name></decl>,
				<decl><type ref="prev"/><name>dataShift</name></decl>,
				<decl><type ref="prev"/><name>chunkDescShift</name></decl>,
				<decl><type ref="prev"/><name>hikeyShift</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>firstItemPtr</name></decl>,
				<decl><type ref="prev"/><name>itemPtr</name></decl>,
				<decl><type ref="prev"/><name>endPtr</name></decl>,
				<decl><type ref="prev"/><name>rightChunkPtr</name></decl>,
				<decl><type ref="prev"/><name>firstHikeyPtr</name></decl>,
				<decl><type ref="prev"/><name>hikeyPtr</name></decl>,
				<decl><type ref="prev"/><name>hikeyEndPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
				<decl><type ref="prev"/><name>leftItemsCount</name></decl>,
				<decl><type ref="prev"/><name>rightItemsCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>hikeySize</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>hikeySize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>leftItemsCount</name> <operator>=</operator> <name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightItemsCount</name> <operator>=</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name> <operator>-</operator> <name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>firstItemPtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunk</name></name> <operator>+</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itemPtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunk</name></name> <operator>+</operator>
		<call><name>ITEM_GET_OFFSET</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>endPtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>firstItemPtr</name> <operator>&gt;=</operator> <name>p</name> <operator>&amp;&amp;</operator> <name>itemPtr</name> <operator>&gt;=</operator> <name>firstItemPtr</name> <operator>&amp;&amp;</operator> <name>endPtr</name> <operator>&gt;=</operator> <name>itemPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>endPtr</name> <operator>&lt;=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Save positions of the items, which go to the right chunk.  We have to
	 * do this in order to make these items not overridden while data is
	 * moved. Position are counted from the beginning of the new chunk.
	 */</comment>
	<expr_stmt><expr><name>leftItemsShift</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr></argument>)</argument_list></call> <operator>-</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>leftItemsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightItemsShift</name> <operator>=</operator> <call><name>ITEM_GET_OFFSET</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>rightItemsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tmpItems</name><index>[<expr><name>i</name> <operator>-</operator> <name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name></expr>]</index></name> <operator>=</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name>rightItemsShift</name></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>VALGRIND_CHECK_MEM_IS_DEFINED</name><argument_list>(<argument><expr><name>tmpItems</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>tmpItems</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>rightItemsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Move the data items belong to the left chunk accordingly to new size of
	 * items array.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-=</operator> <name>leftItemsShift</name></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>firstItemPtr</name> <operator>-</operator> <name>leftItemsShift</name></expr></argument>,
			<argument><expr><name>firstItemPtr</name></expr></argument>,
			<argument><expr><name>itemPtr</name> <operator>-</operator> <name>firstItemPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>VALGRIND_CHECK_MEM_IS_DEFINED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Shift the data items belong to the right chunk */</comment>
	<expr_stmt><expr><name>dataShift</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>rightItemsCount</name></expr></argument>)</argument_list></call> <operator>+</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>leftItemsCount</name></expr></argument>)</argument_list></call> <operator>-</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemPtr</name> <operator>+</operator> <name>dataShift</name> <operator>+</operator> <operator>(</operator><name>endPtr</name> <operator>-</operator> <name>itemPtr</name><operator>)</operator> <operator>&lt;=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>itemPtr</name> <operator>+</operator> <name>dataShift</name></expr></argument>, <argument><expr><name>itemPtr</name></expr></argument>, <argument><expr><name>endPtr</name> <operator>-</operator> <name>itemPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>VALGRIND_CHECK_MEM_IS_DEFINED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Place the right chunk items array */</comment>
	<expr_stmt><expr><name>rightChunkPtr</name> <operator>=</operator> <name>itemPtr</name> <operator>-</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr></argument>)</argument_list></call> <operator>+</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>leftItemsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>rightChunkPtr</name></expr></argument>, <argument><expr><name>tmpItems</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>rightItemsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>VALGRIND_CHECK_MEM_IS_DEFINED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Calculate shift of hikeys before the new hikey */</comment>
	<expr_stmt><expr><name>chunkDescShift</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>BTreePageHeader</name></expr></argument>, <argument><expr><name>chunkDesc</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTreePageChunkDesc</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>-</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>BTreePageHeader</name></expr></argument>, <argument><expr><name>chunkDesc</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTreePageChunkDesc</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Calculate shift of hikeys after the new hikey */</comment>
	<expr_stmt><expr><name>hikeyShift</name> <operator>=</operator> <name>chunkDescShift</name> <operator>+</operator> <name>hikeySize</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>firstHikeyPtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hikeyPtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hikeyEndPtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <name><name>header</name><operator>-&gt;</operator><name>hikeysEnd</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>firstHikeyPtr</name> <operator>&gt;=</operator> <name>p</name> <operator>&amp;&amp;</operator> <name>hikeyPtr</name> <operator>&gt;=</operator> <name>firstHikeyPtr</name> <operator>&amp;&amp;</operator> <name>hikeyEndPtr</name> <operator>&gt;=</operator> <name>hikeyPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Move hikeys */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>hikeyEndPtr</name> <operator>+</operator> <name>hikeyShift</name> <operator>&lt;=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <name>hikeysEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>hikeyPtr</name> <operator>+</operator> <name>hikeyShift</name></expr></argument>, <argument><expr><name>hikeyPtr</name></expr></argument>, <argument><expr><name>hikeyEndPtr</name> <operator>-</operator> <name>hikeyPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>firstHikeyPtr</name> <operator>+</operator> <name>chunkDescShift</name></expr></argument>, <argument><expr><name>firstHikeyPtr</name></expr></argument>, <argument><expr><name>hikeyPtr</name> <operator>-</operator> <name>firstHikeyPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>VALGRIND_CHECK_MEM_IS_DEFINED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Adjust chunk descs */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name> <operator>+=</operator> <call><name>LOCATION_GET_SHORT</name><argument_list>(<argument><expr><name>chunkDescShift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name> <operator>+</operator> <call><name>LOCATION_GET_SHORT</name><argument_list>(<argument><expr><name>hikeyShift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hikeyFlags</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>hikeyFlags</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>offset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shortLocation</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>shortLocation</name> <operator>+</operator> <call><name>LOCATION_GET_SHORT</name><argument_list>(<argument><expr><name>dataShift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name> <operator>+</operator>
		<call><name>LOCATION_GET_SHORT</name><argument_list>(<argument><expr><name>hikeySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>offset</name> <operator>+</operator> <name>leftItemsCount</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shortLocation</name> <operator>=</operator> <call><name>LOCATION_GET_SHORT</name><argument_list>(<argument><expr><name>rightChunkPtr</name> <operator>-</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hikeyFlags</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>hikeyFlags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>hikeysEnd</name></name> <operator>+=</operator> <name>hikeyShift</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name> <operator>+=</operator> <name>dataShift</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>VALGRIND_CHECK_MEM_IS_DEFINED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>page_chunk_fill_locator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXALIGN_WASTE</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((MAXIMUM_ALIGNOF - 1) - ((s) + (MAXIMUM_ALIGNOF - 1)) % (MAXIMUM_ALIGNOF))</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name>page_split_chunk_if_needed</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>locator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
				<decl><type ref="prev"/><name>chunkOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>hikeysFreeSpace</name></decl>,
				<decl><type ref="prev"/><name>dataFreeSpace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bestOffset</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>bestScore</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>bestHiKeySize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>bestHiKeySizeUnaligned</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>hikeysEnd</name> <init>= <expr><call><name>BTREE_PAGE_HIKEYS_END</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OFixedKey</name></type>	<name>newHikey</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>VALGRIND_CHECK_MEM_IS_DEFINED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_DEFINED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>hikeysEnd</name></name> <operator>&gt;=</operator> <name>hikeysEnd</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>chunkOffset</name> <operator>=</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>float4</name><operator>)</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkSize</name></name> <operator>/</operator> <operator>(</operator><name>float4</name><operator>)</operator> <operator>(</operator><name>ORIOLEDB_BLCKSZ</name> <operator>-</operator> <name>hikeysEnd</name><operator>)</operator> <operator>&lt;</operator>
		<operator>(</operator><name>float4</name><operator>)</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>maxKeyLen</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">2.0f</literal> <operator>/</operator> <operator>(</operator><name>float4</name><operator>)</operator> <operator>(</operator><name>hikeysEnd</name> <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>BTreePageHeader</name></expr></argument>, <argument><expr><name>chunkDesc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>hikeysFreeSpace</name> <operator>=</operator> <name>hikeysEnd</name> <operator>-</operator> <name><name>header</name><operator>-&gt;</operator><name>hikeysEnd</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hikeysFreeSpace</name> <operator>-=</operator>
		<operator>(</operator><call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>BTreePageHeader</name></expr></argument>, <argument><expr><name>chunkDesc</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTreePageChunkDesc</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>-</operator>
		 <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>BTreePageHeader</name></expr></argument>, <argument><expr><name>chunkDesc</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTreePageChunkDesc</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>dataFreeSpace</name> <operator>=</operator> <name>ORIOLEDB_BLCKSZ</name> <operator>-</operator> <name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LocationIndex</name></type> <name>hikeySize</name></decl>,
					<decl><type ref="prev"/><name>hikeySizeUnaligned</name></decl>,
					<decl><type ref="prev"/><name>dataSize</name></decl>,
					<decl><type ref="prev"/><name>leftDataSize</name></decl>,
					<decl><type ref="prev"/><name>rightDataSize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>float4</name></type>		<name>score</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>data</name></name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>BTreeLeafTuphdrSize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <call><name>BTREE_PAGE_GET_ITEM_FLAGS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hikeySizeUnaligned</name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>OTupleKeyLengthNoVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hikeySize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>hikeySizeUnaligned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>hikeySize</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call> <operator>-</operator>
				<name>BTreeNonLeafTuphdrSize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>hikeySizeUnaligned</name> <operator>=</operator> <name>hikeySize</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>hikeySize</name> <operator>&gt;</operator> <name>hikeysFreeSpace</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>dataSize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>i</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
			<call><name>MAXALIGN</name><argument_list>(<argument><expr><operator>(</operator><name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name> <operator>-</operator> <name>i</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>-</operator>
			<call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>dataSize</name> <operator>&gt;</operator> <name>dataFreeSpace</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>leftDataSize</name> <operator>=</operator> <call><name>ITEM_GET_OFFSET</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rightDataSize</name> <operator>=</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkSize</name></name> <operator>-</operator> <name>leftDataSize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>leftDataSize</name> <operator>-=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>score</name> <operator>=</operator> <operator>(</operator><name>float4</name><operator>)</operator> <call><name>Min</name><argument_list>(<argument><expr><name>leftDataSize</name></expr></argument>, <argument><expr><name>rightDataSize</name></expr></argument>)</argument_list></call> <operator>/</operator> <operator>(</operator><name>float4</name><operator>)</operator> <name>hikeySize</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>score</name> <operator>&gt;</operator> <name>bestScore</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>bestOffset</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bestHiKeySize</name> <operator>=</operator> <name>hikeySize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bestHiKeySizeUnaligned</name> <operator>=</operator> <name>hikeySizeUnaligned</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bestScore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>bestOffset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>=</operator> <name>bestOffset</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>allocated</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>data</name></name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>BTreeLeafTuphdrSize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <call><name>BTREE_PAGE_GET_ITEM_FLAGS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newHikey</name><operator>.</operator><name>tuple</name></name> <operator>=</operator> <call><name>o_btree_tuple_make_key</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>newHikey</name><operator>.</operator><name>fixedData</name></name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>allocated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>bestHiKeySize</name> <operator>!=</operator> <name>bestHiKeySizeUnaligned</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>newHikey</name><operator>.</operator><name>fixedData</name></name> <operator>+</operator> <name>bestHiKeySizeUnaligned</name></expr></argument>,
				   <argument><expr><literal type="number">0</literal></expr></argument>,
				   <argument><expr><name>bestHiKeySize</name> <operator>-</operator> <name>bestHiKeySizeUnaligned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>allocated</name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VALGRIND_CHECK_MEM_IS_DEFINED</name><argument_list>(<argument><expr><name><name>newHikey</name><operator>.</operator><name>fixedData</name></name></expr></argument>, <argument><expr><name>bestHiKeySizeUnaligned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VALGRIND_CHECK_MEM_IS_DEFINED</name><argument_list>(<argument><expr><name><name>newHikey</name><operator>.</operator><name>fixedData</name></name></expr></argument>, <argument><expr><name>bestHiKeySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>key</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>data</name></name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>BTreeNonLeafTuphdrSize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <call><name>BTREE_PAGE_GET_ITEM_FLAGS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>copy_fixed_key</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newHikey</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VALGRIND_CHECK_MEM_IS_DEFINED</name><argument_list>(<argument><expr><name><name>newHikey</name><operator>.</operator><name>fixedData</name></name></expr></argument>, <argument><expr><name>bestHiKeySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>VALGRIND_CHECK_MEM_IS_DEFINED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>page_split_chunk</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>, <argument><expr><name>hikeysEnd</name></expr></argument>, <argument><expr><name>bestHiKeySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>VALGRIND_CHECK_MEM_IS_DEFINED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>chunkOffset</name></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>newHikey</name><operator>.</operator><name>fixedData</name></name></expr></argument>,
		   <argument><expr><name>bestHiKeySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>chunkOffset</name></expr>]</index></name><operator>.</operator><name>hikeyFlags</name> <operator>=</operator> <name><name>newHikey</name><operator>.</operator><name>tuple</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>VALGRIND_CHECK_MEM_IS_DEFINED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_page</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>prev</name></decl>,
				<decl><type ref="prev"/><name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeKeyType</name></type> <name>kind</name> <init>= <expr><ternary><condition><expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>BTreeTuple</name></expr> </then><else>: <expr><name>BTreeKey</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_FIRST</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>BTREE_PAGE_READ_TUPLE</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tup</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>loc</name><operator>.</operator><name>chunkOffset</name></name> <operator>&lt;</operator> <name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OTuple</name></type>		<name>chunkHikey</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>chunkHikey</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>p</name> <operator>+</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name><name>loc</name><operator>.</operator><name>chunkOffset</name></name></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>chunkHikey</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name><name>loc</name><operator>.</operator><name>chunkOffset</name></name></expr>]</index></name><operator>.</operator><name>hikeyFlags</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tup</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>chunkHikey</name></expr></argument>, <argument><expr><name>BTreeKey</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>tup</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>LocationIndex</name></type>
<name>item_get_key_size</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>leaf</name></decl></parameter>, <parameter><decl><type><name>BTreePageItem</name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>leaf</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>item</name><operator>-&gt;</operator><name>newItem</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>BTreeLeafTuphdrSize</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
		<return>return <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>OTupleKeyLengthNoVersion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>item</name><operator>-&gt;</operator><name>newItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>BTreeNonLeafTuphdrSize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
		<return>return <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>OKeyLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Split the page containing the single chunk into multiple chunks.
 */</comment>
<function><type><name>void</name></type>
<name>btree_page_reorg</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>BTreePageItem</name> <modifier>*</modifier></type><name>items</name></decl></parameter>,
				 <parameter><decl><type><name>OffsetNumber</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>LocationIndex</name></type> <name>hikeySize</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>hikey</name></decl></parameter>,
				 <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>newLoc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>chunksCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>totalDataSize</name></decl>,
				<decl><type ref="prev"/><name>itemHeaderSize</name> <init>= <expr><ternary><condition><expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>BTreeLeafTuphdrSize</name></expr> </then><else>: <expr><name>BTreeNonLeafTuphdrSize</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageChunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>ptr</name></decl>,
				<decl><type ref="prev"/><name>hikeysPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>chunkOffsets</name><index>[<expr><name>BTREE_PAGE_MAX_CHUNKS</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name><name>itemsArray</name><index>[<expr><name>BTREE_PAGE_MAX_CHUNK_ITEMS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>hikeysFreeSpace</name></decl>,
				<decl><type ref="prev"/><name>hikeysFreeSpaceLeft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>dataFreeSpace</name></decl>,
				<decl><type ref="prev"/><name>dataFreeSpaceLeft</name></decl>,
				<decl><type ref="prev"/><name>hikeysEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isRightmost</name> <init>= <expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>chunkDataSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>maxKeyLen</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>VALGRIND_CHECK_MEM_IS_DEFINED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_DEFINED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hikeysEnd</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_HIKEYS_END</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTreePageHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>hikeySize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>totalDataSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>totalDataSize</name> <operator>+=</operator> <name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name>hikeysFreeSpaceLeft</name> <operator>=</operator> <name>hikeysFreeSpace</name> <operator>=</operator> <name>hikeysEnd</name> <operator>-</operator> <operator>(</operator><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTreePageHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>hikeySize</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>dataFreeSpaceLeft</name> <operator>=</operator> <name>dataFreeSpace</name> <operator>=</operator> <operator>(</operator><name>ORIOLEDB_BLCKSZ</name> <operator>-</operator> <name>hikeysEnd</name><operator>)</operator> <operator>-</operator> <name>totalDataSize</name> <operator>-</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Calculate the chunks count to fit both chunks area and data area.
	 */</comment>
	<expr_stmt><expr><name>maxKeyLen</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>hikeySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Calculate chunks boundaries */</comment>
	<expr_stmt><expr><name><name>chunkOffsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>chunkDataSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>chunkDataSize</name> <operator>+=</operator> <name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>maxKeyLen</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>maxKeyLen</name></expr></argument>, <argument><expr><call><name>item_get_key_size</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LocationIndex</name></type> <name>nextKeySize</name></decl>,
					<decl><type ref="prev"/><name>hikeySizeDiff</name></decl>,
					<decl><type ref="prev"/><name>dataSpaceDiff</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>float4</name></type>		<name>dataSizeRatio</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nextKeySize</name> <operator>=</operator> <call><name>item_get_key_size</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxKeyLen</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>maxKeyLen</name></expr></argument>, <argument><expr><name>nextKeySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hikeySizeDiff</name> <operator>=</operator> <name>nextKeySize</name> <operator>+</operator>
			<operator>(</operator><call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>BTreePageHeader</name></expr></argument>, <argument><expr><name>chunkDesc</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTreePageChunkDesc</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>j</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>-</operator>
			 <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>BTreePageHeader</name></expr></argument>, <argument><expr><name>chunkDesc</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTreePageChunkDesc</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>j</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>dataSpaceDiff</name> <operator>=</operator> <call><name>MAXALIGN_WASTE</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>i</name> <operator>-</operator> <name><name>chunkOffsets</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>hikeySizeDiff</name> <operator>&gt;</operator> <name>hikeysFreeSpaceLeft</name> <operator>||</operator>
			<name>dataSpaceDiff</name> <operator>&gt;</operator> <name>dataFreeSpaceLeft</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>chunkDataSize</name> <operator>+=</operator> <name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>dataSizeRatio</name> <operator>=</operator> <operator>(</operator><name>float4</name><operator>)</operator> <name>chunkDataSize</name> <operator>/</operator> <operator>(</operator><name>float4</name><operator>)</operator> <name>totalDataSize</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dataSizeRatio</name> <operator>&gt;=</operator> <operator>(</operator><name>float4</name><operator>)</operator> <operator>(</operator><name>nextKeySize</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTreePageChunkDesc</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>/</operator> <operator>(</operator><name>float4</name><operator>)</operator> <name>hikeysFreeSpace</name> <operator>&amp;&amp;</operator>
			<name>dataSizeRatio</name> <operator>&gt;=</operator> <operator>(</operator><name>float4</name><operator>)</operator> <name>dataSpaceDiff</name> <operator>/</operator> <operator>(</operator><name>float4</name><operator>)</operator> <name>dataFreeSpace</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hikeysFreeSpaceLeft</name> <operator>-=</operator> <name>hikeySizeDiff</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dataFreeSpaceLeft</name> <operator>-=</operator> <name>dataSpaceDiff</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>chunkOffsets</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>chunkDataSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>chunkDataSize</name> <operator>+=</operator> <name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>j</name> <operator>&lt;=</operator> <name>BTREE_PAGE_MAX_CHUNKS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkOffsets</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>chunksCount</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

	<comment type="block">/* Calculate chunk items */</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <name>hikeysEnd</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>chunksCount</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>chunkItemsCount</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LocationIndex</name></type> <name>itemShift</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>chunkItemsCount</name> <operator>=</operator> <name><name>chunkOffsets</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>chunkOffsets</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemShift</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>chunkItemsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>chunkOffsets</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>chunkOffsets</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>itemsArray</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ITEM_SET_FLAGS</name><argument_list>(<argument><expr><name>itemShift</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>itemShift</name> <operator>+=</operator> <name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>itemShift</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>maxKeyLen</name></name> <operator>=</operator> <name>maxKeyLen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>dataSize</name></name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name> <operator>=</operator> <name>chunksCount</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Place the chunks data.  We need to do this backwards to be sure we only
	 * move the data forwards and not override.
	 */</comment>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>chunksCount</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>chunkItemsCount</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>chunkItemsCount</name> <operator>=</operator> <name><name>chunkOffsets</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>chunkOffsets</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>chunkOffsets</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <name><name>chunkOffsets</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>ptr</name> <operator>-=</operator> <name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name> <operator>&gt;=</operator> <name>p</name> <operator>&amp;&amp;</operator> <name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>data</name> <argument_list type="generic">&lt; <argument><expr><name>p</name> <operator>+</operator> <name>ORIOLEDB_BLCKSZ</name> <operator>&amp;&amp;</operator>
				<name>ptr</name></expr></argument> &gt;</argument_list></name> <name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>newItem</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>ptr</name> <operator>-=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>chunkItemsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Place chunks item arrays and fill chunk descs */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>==</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <name>hikeysEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hikeysPtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>BTreePageHeader</name></expr></argument>, <argument><expr><name>chunkDesc</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTreePageChunkDesc</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>chunksCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>chunksCount</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>chunkItemsCount</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>fillNewLoc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>chunkItemsCount</name> <operator>=</operator> <name><name>chunkOffsets</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>chunkOffsets</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>chunkOffsets</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>itemsArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>chunkItemsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>chunk</name> <operator>=</operator> <operator>(</operator><name>BTreePageChunk</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>shortLocation</name> <operator>=</operator> <call><name>LOCATION_GET_SHORT</name><argument_list>(<argument><expr><name>ptr</name> <operator>-</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <name><name>chunkOffsets</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocationIndex</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>chunkItemsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>chunkOffsets</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>chunkOffsets</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>newItem</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name> <operator>&gt;=</operator> <name>p</name> <operator>&amp;&amp;</operator> <name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name> <operator>&lt;</operator> <name>p</name> <operator>+</operator> <name>ORIOLEDB_BLCKSZ</name><operator>)</operator> <operator>||</operator>
					<name>ptr</name> <operator>&lt;</operator> <name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>newLoc</name><operator>-&gt;</operator><name>chunk</name></name> <operator>=</operator> <name>chunk</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newLoc</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newLoc</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>=</operator> <name>i</name> <operator>-</operator> <name><name>chunkOffsets</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newLoc</name><operator>-&gt;</operator><name>chunkItemsCount</name></name> <operator>=</operator> <name>chunkItemsCount</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>fillNewLoc</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>fillNewLoc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>newLoc</name><operator>-&gt;</operator><name>chunkSize</name></name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>chunk</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OTuple</name></type>		<name>chunkHikeyTuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>LocationIndex</name></type> <name>chunkHikeySize</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>items</name><index>[<expr><name><name>chunkOffsets</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>newItem</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>chunkHikeyTuple</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <call><name>ITEM_GET_FLAGS</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>chunkHikeyTuple</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>chunk</name> <operator>+</operator> <call><name>ITEM_GET_OFFSET</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>itemHeaderSize</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>chunkHikeyTuple</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>items</name><index>[<expr><name><name>chunkOffsets</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>flags</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>chunkHikeyTuple</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name><name>items</name><index>[<expr><name><name>chunkOffsets</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>data</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>shouldFree</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>chunkHikeyTuple</name> <operator>=</operator> <call><name>o_btree_tuple_make_key</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>chunkHikeyTuple</name></expr></argument>, <argument><expr><name>hikeysPtr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shouldFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunkHikeyTuple</name><operator>.</operator><name>data</name></name> <operator>==</operator> <name>hikeysPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>shouldFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>chunkHikeySize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>chunkHikeyTuple</name></expr></argument>, <argument><expr><name>OKeyLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>chunkHikeyTuple</name><operator>.</operator><name>data</name></name> <operator>!=</operator> <name>hikeysPtr</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>hikeysPtr</name></expr></argument>, <argument><expr><name><name>chunkHikeyTuple</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>chunkHikeySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>hikeyFlags</name> <operator>=</operator> <name><name>chunkHikeyTuple</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name> <operator>=</operator> <call><name>LOCATION_GET_SHORT</name><argument_list>(<argument><expr><name>hikeysPtr</name> <operator>-</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hikeysPtr</name> <operator>+=</operator> <name>chunkHikeySize</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>hikeysPtr</name> <operator>-</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name><operator>)</operator> <operator>&lt;=</operator> <name>hikeysEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Place page hikey */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isRightmost</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>hikeysPtr</name></expr></argument>, <argument><expr><name><name>hikey</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>hikeySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>hikeySize</name> <operator>!=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>hikeySize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>hikeysPtr</name> <operator>+</operator> <name>hikeySize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>hikeySize</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>hikeySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>hikeyFlags</name> <operator>=</operator> <name><name>hikey</name><operator>.</operator><name>formatFlags</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name> <operator>=</operator> <call><name>LOCATION_GET_SHORT</name><argument_list>(<argument><expr><name>hikeysPtr</name> <operator>-</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hikeysPtr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>hikeySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>hikeysPtr</name> <operator>-</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name><operator>)</operator> <operator>&lt;=</operator> <name>hikeysEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>hikeyFlags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name> <operator>=</operator> <call><name>LOCATION_GET_SHORT</name><argument_list>(<argument><expr><name>hikeysPtr</name> <operator>-</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>hikeysEnd</name></name> <operator>=</operator> <name>hikeysPtr</name> <operator>-</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>itemsCount</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VALGRIND_CHECK_MEM_IS_DEFINED</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>split_page_by_chunks</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItem</name></type> <name><name>items</name><index>[<expr><name>BTREE_PAGE_MAX_CHUNK_ITEMS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OFixedKey</name></type>	<name>hikey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocationIndex</name></type> <name>hikeySize</name></decl>;</decl_stmt>

	<macro><name>BTREE_PAGE_FOREACH_ITEMS</name><argument_list>(<argument>p</argument>, <argument>&amp;loc</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_ITEM_FLAGS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>newItem</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name><name>hikey</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hikeySize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>copy_fixed_hikey</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hikey</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hikeySize</name> <operator>=</operator> <call><name>BTREE_PAGE_GET_HIKEY_SIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>btree_page_reorg</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>items</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>hikeySize</name></expr></argument>, <argument><expr><name><name>hikey</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>page_locator_find_real_item</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>PartialPageState</name> <modifier>*</modifier></type><name>partial</name></decl></parameter>,
							<parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>locator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>&gt;=</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>&gt;=</operator> <name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>-</operator> <name><name>locator</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>partial</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>partial_load_chunk</name><argument_list>(<argument><expr><name>partial</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>page_chunk_fill_locator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>OffsetNumber</name></type>
<name>page_locator_get_offset</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>locator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name><name>locator</name><operator>-&gt;</operator><name>chunkOffset</name></name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>+</operator> <name><name>locator</name><operator>-&gt;</operator><name>itemOffset</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
