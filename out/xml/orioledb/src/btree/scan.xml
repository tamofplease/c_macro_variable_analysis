<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/btree/scan.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * scan.c
 *		Routines for sequential scan of orioledb B-tree
 *
 * Copyright (c) 2021-2022, Oriole DB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/btree/scan.c
 *
 * ALGORITHM
 *
 *		The big picture algorithm of sequential scan is following.
 *		1. Scan all the internal pages with level == 1. The total amount of
 *		   internal pages are expected to be small. So, it should be OK to
 *		   scan them in logical order.
 *		   1.1. Immediately scan children's leaves and return their contents.
 *		   1.2. Edge cases are handled using iterators. They are expected to
 *		   be very rare.
 *		   1.3. Collect on-disk downlinks into an array together with CSN at
 *		   the moment of the corresponding internal page read.
 *		2. Ascending sort array of downlinks providing as sequential access
 *		   pattern as possible.
 *		3. Scan sorted downlink and apply the corresponding CSN.
 *
 * PARALLEL SCAN
 *
 *		The parallel sequential scan is implemented as follows.
 *		1. Two internal page images (level == 1) are kept in shared memory.
 *		2. Workers are iterating the downlinks of these pages in parallel
 *		   one by one.
 *		3. Once the internal page is finished, one worker loads the next page in
 *		   its place.  Other workers continue to process the downlink of the
 *		   remaining page.
 *		4. Once internal page processing is finished, all workers publish
 *		   on-disk downlinks to the dsm.  The leader sorts on-disk downlinks.
 *		5. Workers process on-disk downlinks in parallel one by one.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/btree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/find.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/iterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/page_chunks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/scan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tuple/slot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sampling.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/stopevent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tableam/handler.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/wait_event.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><enum>enum
<block>{
	<decl><name>BTreeSeqScanInMemory</name></decl>,
	<decl><name>BTreeSeqScanDisk</name></decl>,
	<decl><name>BTreeSeqScanFinished</name></decl>
}</block></enum></type> <name>BTreeSeqScanStatus</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>uint64</name></type>		<name>downlink</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl>;</decl_stmt>
}</block></struct></type> <name>BTreeSeqScanDiskDownlink</name>;</typedef>

<struct>struct <name>BTreeSeqScan</name>
<block>{
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type>		<name><name>leafImg</name><index>[<expr><name>ORIOLEDB_BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>histImg</name><index>[<expr><name>ORIOLEDB_BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>snapshotCsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OFixedKey</name></type>	<name>prevHikey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeLocationHint</name></type> <name>hint</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>intLoc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The page offset we started with according to `prevHikey`;
	 */</comment>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>intStartOffset</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>leafLoc</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>haveHistImg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>histLoc</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>BTreeSeqScanStatus</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>BTreeSeqScanDiskDownlink</name> <modifier>*</modifier></type><name>diskDownlinks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>downlinksCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>downlinkIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>allocatedDownlinks</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>iterEnd</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Number of the last completed checkpoint when scan was started.  We need
	 * on-disk pages of this checkpoint to be not overriden until scan
	 * finishes.  This means we shouldn't start using free blocks of later
	 * checkpoints before this scan is finished.
	 */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>checkpointNumber</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>BTreeMetaPage</name> <modifier>*</modifier></type><name>metaPageBlkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_node</name></type>	<name>listNode</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>OFixedKey</name></type>	<name>nextKey</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>needSampling</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockSampler</name></type> <name>sampler</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>samplingNumber</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>samplingNext</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>BTreeSeqScanCallbacks</name> <modifier>*</modifier></type><name>cb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isSingleLeafPage</name></decl>;</decl_stmt>	<comment type="block">/* Scan couldn't read first internal page */</comment>
	<decl_stmt><decl><type><name>OFixedKey</name></type>	<name>keyRangeLow</name></decl>,
				<decl><type ref="prev"/><name>keyRangeHigh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>firstPageIsLoaded</name></decl>;</decl_stmt>

	<comment type="block">/* Private parallel worker info in a backend */</comment>
	<decl_stmt><decl><type><name>ParallelOScanDesc</name></type> <name>poscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isLeader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>workerNumber</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>dsmSeg</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>dlist_head</name></type> <name>listOfScans</name> <init>= <expr><call><name>DLIST_STATIC_INIT</name><argument_list>(<argument><expr><name>listOfScans</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>scan_make_iterator</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>startKey</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>keyRangeHigh</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_next_key</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>, <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>intLoc</name></decl></parameter>, <parameter><decl><type><name>OFixedKey</name> <modifier>*</modifier></type><name>nextKey</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>BTreeScanShmem</name> <modifier>*</modifier></type><name>btreeScanShmem</name></decl>;</decl_stmt>

<function><type><name>Size</name></type>
<name>btree_scan_shmem_needs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTreeScanShmem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>btree_scan_init_shmem</name><parameter_list>(<parameter><decl><type><name>Pointer</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>found</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>btreeScanShmem</name> <operator>=</operator> <operator>(</operator><name>BTreeScanShmem</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>btreeScanShmem</name><operator>-&gt;</operator><name>pageLoadTrancheId</name></name> <operator>=</operator> <call><name>LWLockNewTrancheId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>btreeScanShmem</name><operator>-&gt;</operator><name>downlinksSubscribeTrancheId</name></name> <operator>=</operator> <call><name>LWLockNewTrancheId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>btreeScanShmem</name><operator>-&gt;</operator><name>downlinksPublishTrancheId</name></name> <operator>=</operator> <call><name>LWLockNewTrancheId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name><name>btreeScanShmem</name><operator>-&gt;</operator><name>pageLoadTrancheId</name></name></expr></argument>,
						  <argument><expr><literal type="string">"OBTreeScanPageLoadTrancheId"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name><name>btreeScanShmem</name><operator>-&gt;</operator><name>downlinksSubscribeTrancheId</name></name></expr></argument>,
						  <argument><expr><literal type="string">"OBTreeScanDownlinksSubscribeTrancheId"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name><name>btreeScanShmem</name><operator>-&gt;</operator><name>downlinksPublishTrancheId</name></name></expr></argument>,
						  <argument><expr><literal type="string">"OBTreeScanDownlinksPublishTrancheId"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>load_first_historical_page</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>key</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeKeyType</name></type> <name>kind</name> <init>= <expr><name>BTreeKeyNone</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OFixedKey</name></type>	<name>lokey</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lokeyPtr</name> <init>= <expr><operator>&amp;</operator><name>lokey</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OFixedKey</name></type>	<name>hikey</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>haveHistImg</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>COMMITSEQNO_IS_NORMAL</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>snapshotCsn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>copy_fixed_hikey</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hikey</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name><name>hikey</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name><name>lokey</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>COMMITSEQNO_IS_NORMAL</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>csn</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <name><name>header</name><operator>-&gt;</operator><name>csn</name></name> <operator>&gt;=</operator> <name><name>scan</name><operator>-&gt;</operator><name>snapshotCsn</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UNDO_REC_EXISTS</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SNAPSHOT_TOO_OLD</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"snapshot too old"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_page_from_undo</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>,
								  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>lokeyPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hikey</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>copy_fixed_hikey</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hikey</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name><name>hikey</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>haveHistImg</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name><name>lokey</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>key</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name><name>lokey</name><operator>.</operator><name>tuple</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>kind</name> <operator>=</operator> <name>BTreeKeyNonLeafKey</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lokeyPtr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>haveHistImg</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name><name>lokey</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>btree_page_search</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>,
								 <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name><name>lokey</name><operator>.</operator><name>tuple</name></name></expr></argument>,
								 <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>histLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>page_locator_find_real_item</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>histLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_FIRST</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>histLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>load_next_historical_page</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OFixedKey</name></type>	<name>prevHikey</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>copy_fixed_hikey</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prevHikey</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>COMMITSEQNO_IS_NORMAL</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>csn</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <name><name>header</name><operator>-&gt;</operator><name>csn</name></name> <operator>&gt;=</operator> <name><name>scan</name><operator>-&gt;</operator><name>snapshotCsn</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UNDO_REC_EXISTS</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SNAPSHOT_TOO_OLD</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"snapshot too old"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_page_from_undo</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>,
								  <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name><name>prevHikey</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>,
								  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_FIRST</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>histLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Loads next internal page and. Outputs page, start locator and offset.
 *.
 * In case of parallel scan the caller should hold a lock preventing the other workers from modifying
 * a page in a shared state and updating prevHikey.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>load_next_internal_page</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>prevHikey</name></decl></parameter>,
						<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>,
						<parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>intLoc</name></decl></parameter>,
						<parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>startOffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_next</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"load_next_internal_page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>BTREE_PAGE_FIND_DOWNLINK_LOCATION</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>prevHikey</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>find_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prevHikey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>find_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* In case of parallel scan copy page image into shared state */</comment>
	<if_stmt><if>if <condition>(<expr><name>page</name> <operator>!=</operator> <name><name>scan</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>img</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>poscan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>poscan</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>O_PARALLEL_FIRST_PAGE_LOADED</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>img</name></name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>poscan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>firstPageIsLoaded</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Check if the left bound of the found keyrange corresponds to the
		 * previous hikey.  Otherwise, use iterator to correct the situation.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>intLoc</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>items</name><index>[<expr><name><name>scan</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>startOffset</name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>intLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>prevHikey</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OTuple</name></type>		<name>intTup</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>startOffset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>BTREE_PAGE_READ_INTERNAL_TUPLE</name><argument_list>(<argument><expr><name>intTup</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>intLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>intTup</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>lokey</name><operator>.</operator><name>tuple</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>o_btree_cmp</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>prevHikey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>intTup</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>get_next_key</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>intLoc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>keyRangeHigh</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"scan_make_iterator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>scan_make_iterator</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>prevHikey</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyRangeHigh</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>has_next</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_FIRST</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>leafLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>hint</name><operator>.</operator><name>blkno</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>hint</name><operator>.</operator><name>pageChangeCount</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pageChangeCount</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_SET_INVALID</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>intLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>nextKey</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>load_first_historical_page</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>has_next</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>has_next</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_on_disk_downlink</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>downlink</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>downlinksCount</name></name> <operator>&gt;=</operator> <name><name>scan</name><operator>-&gt;</operator><name>allocatedDownlinks</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>allocatedDownlinks</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>diskDownlinks</name></name> <operator>=</operator> <operator>(</operator><name>BTreeSeqScanDiskDownlink</name> <operator>*</operator><operator>)</operator> <call><name>repalloc_huge</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>diskDownlinks</name></name></expr></argument>,
																		 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>diskDownlinks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>scan</name><operator>-&gt;</operator><name>allocatedDownlinks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>diskDownlinks</name><index>[<expr><name><name>scan</name><operator>-&gt;</operator><name>downlinksCount</name></name></expr>]</index></name><operator>.</operator><name>downlink</name> <operator>=</operator> <name>downlink</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>diskDownlinks</name><index>[<expr><name><name>scan</name><operator>-&gt;</operator><name>downlinksCount</name></name></expr>]</index></name><operator>.</operator><name>csn</name> <operator>=</operator> <name>csn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>downlinksCount</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_downlinks</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>d1</name> <init>= <expr><operator>(</operator><operator>(</operator><name>BTreeSeqScanDiskDownlink</name> <operator>*</operator><operator>)</operator> <name>p1</name><operator>)</operator><operator>-&gt;</operator><name>downlink</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>d2</name> <init>= <expr><operator>(</operator><operator>(</operator><name>BTreeSeqScanDiskDownlink</name> <operator>*</operator><operator>)</operator> <name>p2</name><operator>)</operator><operator>-&gt;</operator><name>downlink</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>d1</name> <operator>&lt;</operator> <name>d2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>d1</name> <operator>==</operator> <name>d2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>switch_to_disk_scan</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelOScanDesc</name></type> <name>poscan</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>poscan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>diskLeader</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>BTreeSeqScanDisk</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_SET_INVALID</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>leafLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>poscan</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>diskDownlinks</name></name></expr></argument>,
			  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>downlinksCount</name></name></expr></argument>,
			  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>diskDownlinks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr><name>cmp_downlinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>		<name>workersReportedCount</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>workerBeginDisk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>poscan</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_PARALLEL_DISK_SCAN_STARTED</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>poscan</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>O_PARALLEL_DISK_SCAN_STARTED</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>diskLeader</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinksPublish</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinksSubscribe</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Publish the number of downlinks */</comment>
		<expr_stmt><expr><name><name>poscan</name><operator>-&gt;</operator><name>downlinksCount</name></name> <operator>+=</operator> <name><name>scan</name><operator>-&gt;</operator><name>downlinksCount</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>workersReportedCount</name> <operator>=</operator> <operator>++</operator><name><name>poscan</name><operator>-&gt;</operator><name>workersReportedCount</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>workerBeginDisk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>workersReportedCount</name> <operator>==</operator> <name><name>poscan</name><operator>-&gt;</operator><name>nworkers</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ConditionVariableBroadcast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinksCv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>diskLeader</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Wait until all workers publish their number of downlinks. */</comment>
			<while>while <condition>(<expr><name>true</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>workerBeginDisk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>poscan</name><operator>-&gt;</operator><name>workersReportedCount</name></name> <operator>&lt;=</operator> <name><name>poscan</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>poscan</name><operator>-&gt;</operator><name>workersReportedCount</name></name> <operator>==</operator> <name><name>poscan</name><operator>-&gt;</operator><name>nworkers</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>workerBeginDisk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>workerBeginDisk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ConditionVariableSleep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinksCv</name></name></expr></argument>, <argument><expr><name>WAIT_EVENT_PARALLEL_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>
			<expr_stmt><expr><call><name>ConditionVariableCancelSleep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>poscan</name><operator>-&gt;</operator><name>downlinksCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Create DSM segment and publish downlinks list first */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>poscan</name><operator>-&gt;</operator><name>dsmHandle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>dsmSeg</name></name> <operator>=</operator> <call><name>dsm_create</name><argument_list>(<argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>poscan</name><operator>-&gt;</operator><name>downlinksCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>diskDownlinks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>poscan</name><operator>-&gt;</operator><name>dsmHandle</name></name> <operator>=</operator> <call><name>dsm_segment_handle</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>dsmSeg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <call><name>dsm_segment_address</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>dsmSeg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>diskDownlinks</name></name></expr></argument>,
					   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>downlinksCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>diskDownlinks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinkIndex</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>downlinksCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinksPublish</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Wait until the other workers have published their downlinks
				 * lists
				 */</comment>
				<while>while <condition>(<expr><name>true</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinkIndex</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name><name>poscan</name><operator>-&gt;</operator><name>downlinksCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinkIndex</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>poscan</name><operator>-&gt;</operator><name>downlinksCount</name></name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>ConditionVariableSleep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinksCv</name></name></expr></argument>, <argument><expr><name>WAIT_EVENT_PARALLEL_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></while>
				<expr_stmt><expr><call><name>ConditionVariableCancelSleep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Make sure all workers released this lock */</comment>
				<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinksPublish</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinksPublish</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><call><name>dsm_segment_address</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>dsmSeg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>poscan</name><operator>-&gt;</operator><name>downlinksCount</name></name></expr></argument>,
					  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>diskDownlinks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmp_downlinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinksPublish</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinkIndex</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinksSubscribe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Now workers can get downlinks from shared sorted list */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint64</name></type>		<name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinksPublish</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>poscan</name><operator>-&gt;</operator><name>downlinksCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>poscan</name><operator>-&gt;</operator><name>dsmHandle</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>dsmSeg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>dsmSeg</name></name> <operator>=</operator> <call><name>dsm_attach</name><argument_list>(<argument><expr><name><name>poscan</name><operator>-&gt;</operator><name>dsmHandle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>downlinksCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinkIndex</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>downlinksCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <call><name>dsm_segment_address</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>dsmSeg</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>index</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>diskDownlinks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>,
						<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>diskDownlinks</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>downlinksCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>diskDownlinks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>index</name> <operator>+=</operator> <name><name>scan</name><operator>-&gt;</operator><name>downlinksCount</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinksPublish</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>downlinksCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>index</name> <operator>==</operator> <name><name>poscan</name><operator>-&gt;</operator><name>downlinksCount</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ConditionVariableBroadcast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinksCv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinksSubscribe</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Make an interator to read the key range from `startKey` to the next
 * downlink or hikey of internal page hikey if we're considering the last
 * downlink.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>scan_make_iterator</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>keyRangeLow</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>keyRangeHigh</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>mctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>keyRangeLow</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name> <operator>=</operator> <call><name>o_btree_iterator_create</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keyRangeLow</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>,
											 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>snapshotCsn</name></name></expr></argument>,
											 <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name> <operator>=</operator> <call><name>o_btree_iterator_create</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>,
											 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>snapshotCsn</name></name></expr></argument>,
											 <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_SET_INVALID</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>leafLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>haveHistImg</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>iterEnd</name></name> <operator>=</operator> <name>keyRangeHigh</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Output item downlink and key using provided page and current locator */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_current_downlink_key</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>,
						 <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>loc</name></decl></parameter>,
						 <parameter><decl><type><name>OffsetNumber</name></type> <name>startOffset</name></decl></parameter>,
						 <parameter><decl><type><name>OTuple</name></type> <name>prevHiKey</name></decl></parameter>,
						 <parameter><decl><type><name>OFixedKey</name> <modifier>*</modifier></type><name>curKey</name></decl></parameter>,
						 <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>downlink</name></decl></parameter>,
						 <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>STOPEVENT</name><argument_list>(<argument><expr><name>STOPEVENT_STEP_DOWN</name></expr></argument>, <argument><expr><call><name>btree_downlink_stopevent_params</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>,
																   <argument><expr><name>page</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BTREE_PAGE_READ_INTERNAL_ITEM</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>downlink</name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>downlink</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>startOffset</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>copy_fixed_key</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>curKey</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>LEFTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>prevHiKey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>copy_fixed_key</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>curKey</name></expr></argument>, <argument><expr><name>prevHiKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>prevHiKey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>clear_fixed_key</name><argument_list>(<argument><expr><name>curKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Output next key and locator on a provided internal page */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_next_key</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>, <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>intLoc</name></decl></parameter>, <parameter><decl><type><name>OFixedKey</name> <modifier>*</modifier></type><name>nextKey</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>intLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>intLoc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>copy_fixed_page_key</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>nextKey</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>intLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>copy_fixed_hikey</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>nextKey</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>clear_fixed_key</name><argument_list>(<argument><expr><name>nextKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Gets the next downlink with it's keyrange (low and high keys of the
 * keyrange).
 *
 * Returns true on success.  False result can be caused by one of three reasons:
 * 1) The rightmost internal page is processed;
 * 2) There is just single leaf page in the tree (and it's loaded into
 *    scan-&gt;context.img);
 * 3) There is scan-&gt;iter to be processed before we can get downlinks from the
 *    current internal page.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>get_next_downlink</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>downlink</name></decl></parameter>,
				  <parameter><decl><type><name>OFixedKey</name> <modifier>*</modifier></type><name>keyRangeLow</name></decl></parameter>, <parameter><decl><type><name>OFixedKey</name> <modifier>*</modifier></type><name>keyRangeHigh</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelOScanDesc</name></type> <name>poscan</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>poscan</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>poscan</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Non-parallel case */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>pageIsLoaded</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>firstPageIsLoaded</name></name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>true</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Try to load next internal page if needed */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pageIsLoaded</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>firstPageIsLoaded</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>img</name></name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>copy_fixed_hikey</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>prevHikey</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>img</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>load_next_internal_page</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>prevHikey</name><operator>.</operator><name>tuple</name></name></expr></argument>,
											 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>img</name></name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>intLoc</name></name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>intStartOffset</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* first page only */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>img</name></name></expr></argument>, <argument><expr><name>LEFTMOST</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>isSingleLeafPage</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>clear_fixed_key</name><argument_list>(<argument><expr><name>keyRangeLow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>clear_fixed_key</name><argument_list>(<argument><expr><name>keyRangeHigh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>img</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>intLoc</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>get_current_downlink_key</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>intLoc</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>intStartOffset</name></name></expr></argument>,
										 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>prevHikey</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>keyRangeLow</name></expr></argument>,
										 <argument><expr><name>downlink</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>img</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * construct fixed hikey of internal item and get next
				 * internal locator
				 */</comment>
				<expr_stmt><expr><call><name>get_next_key</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>intLoc</name></name></expr></argument>, <argument><expr><name>keyRangeHigh</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>img</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>img</name></name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>pageIsLoaded</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Parallel case */</comment>
		<while>while <condition>(<expr><name>true</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreeIntPageParallelData</name> <modifier>*</modifier></type><name>curPage</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BTreeIntPageParallelData</name> <modifier>*</modifier></type><name>nextPage</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>intpageAccess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>curPage</name> <operator>=</operator> <call><name>CUR_PAGE</name><argument_list>(<argument><expr><name>poscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nextPage</name> <operator>=</operator> <call><name>NEXT_PAGE</name><argument_list>(<argument><expr><name>poscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>poscan</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_PARALLEL_IS_SINGLE_LEAF_PAGE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>intpageAccess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>curPage</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>OParallelScanPageInvalid</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>loaded</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>poscan</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_PARALLEL_FIRST_PAGE_LOADED</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>nextPage</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>OParallelScanPageInvalid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>clear_fixed_shmem_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curPage</name><operator>-&gt;</operator><name>prevHikey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>nextPage</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>OParallelScanPageInProgress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name><name>nextPage</name><operator>-&gt;</operator><name>img</name></name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>intpageAccess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><name>false</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>copy_fixed_shmem_hikey</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>curPage</name><operator>-&gt;</operator><name>prevHikey</name></name></expr></argument>, <argument><expr><name><name>nextPage</name><operator>-&gt;</operator><name>img</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name><name>curPage</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>OParallelScanPageInProgress</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>intpageLoad</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>intpageAccess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>loaded</name> <operator>=</operator> <call><name>load_next_internal_page</name><argument_list>(<argument><expr><name>scan</name></expr></argument>,
												 <argument><expr><call><name>fixed_shmem_key_get_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curPage</name><operator>-&gt;</operator><name>prevHikey</name></name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name><name>curPage</name><operator>-&gt;</operator><name>img</name></name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name><name>curPage</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>loaded</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>poscan</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>O_PARALLEL_IS_SINGLE_LEAF_PAGE</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>clear_fixed_key</name><argument_list>(<argument><expr><name>keyRangeLow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>clear_fixed_key</name><argument_list>(<argument><expr><name>keyRangeHigh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>intpageLoad</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>curPage</name><operator>-&gt;</operator><name>imgReadCsn</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>imgReadCsn</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>curPage</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name><name>curPage</name><operator>-&gt;</operator><name>img</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>curPage</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>OParallelScanPageValid</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>intpageLoad</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>curPage</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>OParallelScanPageInProgress</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>intpageAccess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>LWLockAcquireOrWait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>intpageLoad</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>intpageLoad</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>nextPage</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>OParallelScanPageInvalid</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name><name>curPage</name><operator>-&gt;</operator><name>img</name></name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name>		<name>loaded</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>copy_fixed_shmem_hikey</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nextPage</name><operator>-&gt;</operator><name>prevHikey</name></name></expr></argument>, <argument><expr><name><name>curPage</name><operator>-&gt;</operator><name>img</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nextPage</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>OParallelScanPageInProgress</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>intpageLoad</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>intpageAccess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>loaded</name> <operator>=</operator> <call><name>load_next_internal_page</name><argument_list>(<argument><expr><name>scan</name></expr></argument>,
												 <argument><expr><call><name>fixed_shmem_key_get_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nextPage</name><operator>-&gt;</operator><name>prevHikey</name></name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name><name>nextPage</name><operator>-&gt;</operator><name>img</name></name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name><name>nextPage</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>loaded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>nextPage</name><operator>-&gt;</operator><name>imgReadCsn</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>imgReadCsn</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nextPage</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name><name>nextPage</name><operator>-&gt;</operator><name>img</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nextPage</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>OParallelScanPageValid</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>intpageLoad</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>BTREE_PAGE_OFFSET_GET_LOCATOR</name><argument_list>(<argument><expr><name><name>curPage</name><operator>-&gt;</operator><name>img</name></name></expr></argument>, <argument><expr><name><name>curPage</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name><name>curPage</name><operator>-&gt;</operator><name>img</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>)</condition>	<comment type="block">/* inside int page */</comment>
			<block>{<block_content>
				<expr_stmt><expr><call><name>get_current_downlink_key</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>, <argument><expr><name><name>curPage</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>,
										 <argument><expr><call><name>fixed_shmem_key_get_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curPage</name><operator>-&gt;</operator><name>prevHikey</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>keyRangeLow</name></expr></argument>, <argument><expr><name>downlink</name></expr></argument>, <argument><expr><name><name>curPage</name><operator>-&gt;</operator><name>img</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Get next internal page locator and next internal item hikey */</comment>
				<expr_stmt><expr><call><name>get_next_key</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>, <argument><expr><name>keyRangeHigh</name></expr></argument>, <argument><expr><name><name>curPage</name><operator>-&gt;</operator><name>img</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Push next internal item page offset into shared state */</comment>
				<expr_stmt><expr><name><name>curPage</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <call><name>BTREE_PAGE_LOCATOR_GET_OFFSET</name><argument_list>(<argument><expr><name><name>curPage</name><operator>-&gt;</operator><name>img</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>imgReadCsn</name></name> <operator>=</operator> <name><name>curPage</name><operator>-&gt;</operator><name>imgReadCsn</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>intpageAccess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>curPage</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>OParallelScanPageInvalid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>poscan</name><operator>-&gt;</operator><name>flags</name></name> <operator>^=</operator> <name>O_PARALLEL_CURRENT_PAGE</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>intpageAccess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Checks if loaded leaf page matches downlink of internal page.  Makes iterator
 * to read the considered key range if check failed.
 *
 * Hikey of leaf page should match to next downlink or internal page hikey if
 * we're considering the last downlink.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_in_memory_leaf_page</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>keyRangeLow</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>keyRangeHigh</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>leafHikey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>leafHikey</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>leafHikey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>keyRangeHigh</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>leafHikey</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>keyRangeHigh</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>leafHikey</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>o_btree_cmp</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>keyRangeHigh</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>leafHikey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"scan_make_iterator 2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>scan_make_iterator</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>keyRangeLow</name></expr></argument>, <argument><expr><name>keyRangeHigh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Interates the internal page till we either:
 *  - Successfully read the next in-memory leaf page;
 *  - Made an iterator to read key range, which belongs to current downlink;
 *  - Reached the end of internal page.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>iterate_internal_page</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>downlink</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>get_next_downlink</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>downlink</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>keyRangeLow</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>keyRangeHigh</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>valid_downlink</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>cb</name></name> <operator>&amp;&amp;</operator> <name><name>scan</name><operator>-&gt;</operator><name>cb</name><operator>-&gt;</operator><name>isRangeValid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>valid_downlink</name> <operator>=</operator> <call><name><name>scan</name><operator>-&gt;</operator><name>cb</name><operator>-&gt;</operator><name>isRangeValid</name></name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyRangeLow</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyRangeHigh</name><operator>.</operator><name>tuple</name></name></expr></argument>,
													<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>needSampling</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>samplingNumber</name></name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>samplingNext</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>valid_downlink</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>BlockSampler_HasMore</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>sampler</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>samplingNext</name></name> <operator>=</operator> <call><name>BlockSampler_Next</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>sampler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>samplingNext</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>samplingNumber</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>valid_downlink</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>DOWNLINK_IS_ON_DISK</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>add_on_disk_downlink</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>downlink</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>imgReadCsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>DOWNLINK_IS_IN_MEMORY</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ReadPageResult</name></type> <name>result</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>o_btree_try_read_page</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>,
											   <argument><expr><call><name>DOWNLINK_GET_IN_MEMORY_BLKNO</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><call><name>DOWNLINK_GET_IN_MEMORY_CHANGECOUNT</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>,
											   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>imgReadCsn</name></name></expr></argument>,
											   <argument><expr><name>NULL</name></expr></argument>,
											   <argument><expr><name>BTreeKeyNone</name></expr></argument>,
											   <argument><expr><name>NULL</name></expr></argument>,
											   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>ReadPageResultOK</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>check_in_memory_leaf_page</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyRangeLow</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyRangeHigh</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>hint</name><operator>.</operator><name>blkno</name></name> <operator>=</operator> <call><name>DOWNLINK_GET_IN_MEMORY_BLKNO</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>hint</name><operator>.</operator><name>pageChangeCount</name></name> <operator>=</operator> <call><name>DOWNLINK_GET_IN_MEMORY_CHANGECOUNT</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_FIRST</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>leafLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>nextKey</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>load_first_historical_page</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>scan_make_iterator</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyRangeLow</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyRangeHigh</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>DOWNLINK_IS_IN_IO</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Downlink has currently IO in-progress.  Wait for IO
				 * completion and refind this downlink.
				 */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>ionum</name> <init>= <expr><call><name>DOWNLINK_GET_IO_LOCKNUM</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>wait_for_io_completion</name><argument_list>(<argument><expr><name>ionum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"DOWNLINK_IS_IN_IO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>scan_make_iterator</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyRangeLow</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyRangeHigh</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"Worker %d iterate_internal_page complete"</literal></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>workerNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>load_next_disk_leaf_page</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileExtent</name></type>	<name>extent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>success</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeSeqScanDiskDownlink</name></type> <name>downlink</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParallelOScanDesc</name></type> <name>poscan</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>poscan</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>poscan</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>downlinkIndex</name></name> <operator>&gt;=</operator> <name><name>scan</name><operator>-&gt;</operator><name>downlinksCount</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>downlink</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>diskDownlinks</name><index>[<expr><name><name>scan</name><operator>-&gt;</operator><name>downlinkIndex</name></name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>index</name> <init>= <expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinkIndex</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name><name>poscan</name><operator>-&gt;</operator><name>downlinksCount</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinksSubscribe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>downlink</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>BTreeSeqScanDiskDownlink</name> <operator>*</operator><operator>)</operator> <call><name>dsm_segment_address</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>dsmSeg</name></name></expr></argument>)</argument_list></call><operator>)</operator><index>[<expr><name>index</name></expr>]</index></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>read_page_from_disk</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>,
								  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>,
								  <argument><expr><name><name>downlink</name><operator>.</operator><name>downlink</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>csn</name></name> <operator>&gt;=</operator> <name><name>downlink</name><operator>.</operator><name>csn</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>read_page_from_undo</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>,
							<argument><expr><name><name>downlink</name><operator>.</operator><name>csn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>STOPEVENT</name><argument_list>(<argument><expr><name>STOPEVENT_SCAN_DISK_PAGE</name></expr></argument>,
			  <argument><expr><call><name>btree_page_stopevent_params</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>,
										  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can not read leaf page from disk"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_FIRST</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>leafLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>downlinkIndex</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>hint</name><operator>.</operator><name>blkno</name></name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>hint</name><operator>.</operator><name>pageChangeCount</name></name> <operator>=</operator> <name>InvalidOPageChangeCount</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>nextKey</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>load_first_historical_page</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier>
<name>bool</name></type>
<name>single_leaf_page_rel</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>poscan</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name><name>scan</name><operator>-&gt;</operator><name>poscan</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_PARALLEL_IS_SINGLE_LEAF_PAGE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name><name>scan</name><operator>-&gt;</operator><name>isSingleLeafPage</name></name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BTreeSeqScan</name> <modifier>*</modifier></type>
<name>make_btree_seq_scan_internal</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>,
							 <parameter><decl><type><name>BTreeSeqScanCallbacks</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>,
							 <parameter><decl><type><name>BlockSampler</name></type> <name>sampler</name></decl></parameter>, <parameter><decl><type><name>ParallelOScanDesc</name></type> <name>poscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name> <init>= <expr><operator>(</operator><name>BTreeSeqScan</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>btree_seqscan_context</name></expr></argument>,
															 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTreeSeqScan</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>checkpointNumberBefore</name></decl>,
				<decl><type ref="prev"/><name>checkpointNumberAfter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>checkpointConcurrent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeMetaPage</name> <modifier>*</modifier></type><name>metaPageBlkno</name> <init>= <expr><call><name>BTREE_GET_META</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>poscan</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>workerStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name><name>scan</name><operator>-&gt;</operator><name>workerNumber</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>poscan</name><operator>-&gt;</operator><name>worker_active</name><index>[<expr><name><name>scan</name><operator>-&gt;</operator><name>workerNumber</name></name></expr>]</index></name> <operator>==</operator> <name>true</name></expr>;</condition> <incr><expr><name><name>scan</name><operator>-&gt;</operator><name>workerNumber</name></name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>poscan</name><operator>-&gt;</operator><name>worker_active</name><index>[<expr><name><name>scan</name><operator>-&gt;</operator><name>workerNumber</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>poscan</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>workerNumber</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<comment type="block">/* leader */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>workerNumber</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>poscan</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_PARALLEL_LEADER_STARTED</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>poscan</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>O_PARALLEL_LEADER_STARTED</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>isLeader</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>workerStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"make_btree_seq_scan_internal. %s %d started"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>poscan</name></expr> ?</condition><then> <expr><literal type="string">"Parallel worker"</literal></expr> </then><else>: <expr><literal type="string">"Worker"</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>workerNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>workerNumber</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>isLeader</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>poscan</name></name> <operator>=</operator> <name>poscan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name> <operator>=</operator> <name>desc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>snapshotCsn</name></name> <operator>=</operator> <name>csn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>BTreeSeqScanInMemory</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>allocatedDownlinks</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>downlinksCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>downlinkIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>diskDownlinks</name></name> <operator>=</operator> <operator>(</operator><name>BTreeSeqScanDiskDownlink</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>diskDownlinks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>scan</name><operator>-&gt;</operator><name>allocatedDownlinks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>mctx</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>cb</name></name> <operator>=</operator> <name>cb</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>firstPageIsLoaded</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>intStartOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>samplingNumber</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>sampler</name></name> <operator>=</operator> <name>sampler</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>dsmSeg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>sampler</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>needSampling</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BlockSampler_HasMore</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>sampler</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>samplingNext</name></name> <operator>=</operator> <call><name>BlockSampler_Next</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>sampler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>samplingNext</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>needSampling</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>samplingNext</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>nextKey</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name>listOfScans</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>listNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the checkpoint number for the scan.  There is race condition with
	 * concurrent switching tree to the next checkpoint.  So, we have to
	 * workaround this with recheck-retry loop,
	 */</comment>
	<expr_stmt><expr><name>checkpointNumberBefore</name> <operator>=</operator> <call><name>get_cur_checkpoint_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>,
													   <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>checkpointConcurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pg_atomic_fetch_add_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPageBlkno</name><operator>-&gt;</operator><name>numSeqScans</name><index>[<expr><name>checkpointNumberBefore</name> <operator>%</operator> <name>NUM_SEQ_SCANS_ARRAY_SIZE</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>checkpointNumberAfter</name> <operator>=</operator> <call><name>get_cur_checkpoint_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>,
														  <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>checkpointConcurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>checkpointNumberAfter</name> <operator>==</operator> <name>checkpointNumberBefore</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>checkpointNumber</name></name> <operator>=</operator> <name>checkpointNumberBefore</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pg_atomic_fetch_sub_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPageBlkno</name><operator>-&gt;</operator><name>numSeqScans</name><index>[<expr><name>checkpointNumberBefore</name> <operator>%</operator> <name>NUM_SEQ_SCANS_ARRAY_SIZE</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>checkpointNumberBefore</name> <operator>=</operator> <name>checkpointNumberAfter</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_page_find_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>BTREE_PAGE_FIND_IMAGE</name> <operator>|</operator>
						   <name>BTREE_PAGE_FIND_KEEP_LOKEY</name> <operator>|</operator>
						   <name>BTREE_PAGE_FIND_READ_CSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>clear_fixed_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>prevHikey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>clear_fixed_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>keyRangeHigh</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>clear_fixed_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>keyRangeLow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>isSingleLeafPage</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>iterate_internal_page</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>single_leaf_page_rel</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>switch_to_disk_scan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>load_next_disk_leaf_page</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>BTreeSeqScanFinished</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>scan</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BTreeSeqScan</name> <modifier>*</modifier></type>
<name>make_btree_seq_scan</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>poscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>make_btree_seq_scan_internal</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>poscan</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BTreeSeqScan</name> <modifier>*</modifier></type>
<name>make_btree_seq_scan_cb</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>,
					   <parameter><decl><type><name>BTreeSeqScanCallbacks</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>make_btree_seq_scan_internal</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BTreeSeqScan</name> <modifier>*</modifier></type>
<name>make_btree_sampling_scan</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>BlockSampler</name></type> <name>sampler</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>make_btree_seq_scan_internal</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sampler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OTuple</name></type>
<name>btree_seq_scan_get_tuple_from_iterator</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>,
									   <parameter><decl><type><name>CommitSeqNo</name> <modifier>*</modifier></type><name>tupleCsn</name></decl></parameter>,
									   <parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>iterEnd</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>o_btree_iterator_fetch</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>, <argument><expr><name>tupleCsn</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>iterEnd</name></name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>o_btree_iterator_fetch</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>, <argument><expr><name>tupleCsn</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>btree_iterator_free</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>adjust_location_with_next_key</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>,
							  <parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>loc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>key</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_TUPLE</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>nextKey</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>loc</name><operator>-&gt;</operator><name>chunkOffset</name></name> <operator>==</operator> <operator>(</operator><name><name>header</name><operator>-&gt;</operator><name>chunksCount</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name><name>loc</name><operator>-&gt;</operator><name>chunkOffset</name></name></expr>]</index></name><operator>.</operator><name>hikeyFlags</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>p</name> <operator>+</operator> <call><name>SHORT_GET_LOCATION</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>chunkDesc</name><index>[<expr><name><name>loc</name><operator>-&gt;</operator><name>chunkOffset</name></name></expr>]</index></name><operator>.</operator><name>hikeyShortLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>nextKey</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>loc</name><operator>-&gt;</operator><name>itemOffset</name></name> <operator>=</operator> <name><name>loc</name><operator>-&gt;</operator><name>chunkItemsCount</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>page_locator_next_chunk</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_SET_INVALID</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<while>while <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_TUPLE</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>nextKey</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>apply_next_key</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>leafLoc</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <operator>(</operator><name><name>scan</name><operator>-&gt;</operator><name>haveHistImg</name></name> <operator>&amp;&amp;</operator> <call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>histLoc</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>key</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>leafResult</name></decl>,
					<decl><type ref="prev"/><name>histResult</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>leafLoc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_TUPLE</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>leafLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>haveHistImg</name></name> <operator>&amp;&amp;</operator>
			<call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>histLoc</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_TUPLE</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>histLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>OTuple</name></type>		<name>histKey</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_TUPLE</name><argument_list>(<argument><expr><name>histKey</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>histLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>histKey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>key</name> <operator>=</operator> <name>histKey</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>nextKey</name><operator>.</operator><name>tuple</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name><name>scan</name><operator>-&gt;</operator><name>cb</name><operator>-&gt;</operator><name>getNextKey</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>nextKey</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_SET_INVALID</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>leafLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>leafResult</name> <operator>=</operator> <call><name>adjust_location_with_next_key</name><argument_list>(<argument><expr><name>scan</name></expr></argument>,
												   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>leafLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>haveHistImg</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>histResult</name> <operator>=</operator> <call><name>adjust_location_with_next_key</name><argument_list>(<argument><expr><name>scan</name></expr></argument>,
													   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>histLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>leafResult</name> <operator>||</operator> <name>histResult</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>leafResult</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>leafLoc</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><name><name>scan</name><operator>-&gt;</operator><name>haveHistImg</name></name> <operator>&amp;&amp;</operator>
			  <call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>histLoc</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OTuple</name></type>
<name>btree_seq_scan_getnext_internal</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>,
								<parameter><decl><type><name>CommitSeqNo</name> <modifier>*</modifier></type><name>tupleCsn</name></decl></parameter>, <parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>btree_seq_scan_get_tuple_from_iterator</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>tupleCsn</name></expr></argument>, <argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>tuple</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<while>while <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>haveHistImg</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OTuple</name></type>		<name>histTuple</name></decl>;</decl_stmt>

			<while>while <condition>(<expr><operator>!</operator><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>histLoc</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>haveHistImg</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>OTuple</name></type>		<name>leafHikey</name></decl>,
								<decl><type ref="prev"/><name>histHikey</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>leafHikey</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>histHikey</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>o_btree_cmp</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>histHikey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>leafHikey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>haveHistImg</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>load_next_historical_page</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>haveHistImg</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>cb</name></name> <operator>&amp;&amp;</operator> <name><name>scan</name><operator>-&gt;</operator><name>cb</name><operator>-&gt;</operator><name>getNextKey</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>apply_next_key</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>histLoc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_TUPLE</name><argument_list>(<argument><expr><name>histTuple</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>histLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>leafLoc</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OTuple</name></type>		<name>leafHikey</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>leafHikey</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>o_btree_cmp</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>histTuple</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>leafHikey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>haveHistImg</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>OTuple</name></type>		<name>leafTuple</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name>leafTuple</name></expr></argument>,
										  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>leafLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>histTuple</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>leafTuple</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_OXID_IS_CURRENT</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>histLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>leafLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>o_find_tuple_version</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>,
										 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>histLoc</name></name></expr></argument>,
										 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>snapshotCsn</name></name></expr></argument>,
										 <argument><expr><name>tupleCsn</name></expr></argument>,
										 <argument><expr><name>mctx</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>histImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>histLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>hint</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>hint</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>hint</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>tuple</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>

		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>cb</name></name> <operator>&amp;&amp;</operator> <name><name>scan</name><operator>-&gt;</operator><name>cb</name><operator>-&gt;</operator><name>getNextKey</name></name> <operator>&amp;&amp;</operator>
			<call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>leafLoc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>apply_next_key</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>leafLoc</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>BTreeSeqScanInMemory</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"load_next_in_memory_leaf_page START2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>iterate_internal_page</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>btree_seq_scan_get_tuple_from_iterator</name><argument_list>(<argument><expr><name>scan</name></expr></argument>,
																	   <argument><expr><name>tupleCsn</name></expr></argument>,
																	   <argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>tuple</name></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>switch_to_disk_scan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>BTreeSeqScanDisk</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>load_next_disk_leaf_page</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>BTreeSeqScanFinished</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>tuple</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>o_find_tuple_version</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>,
									 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>leafLoc</name></name></expr></argument>,
									 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>snapshotCsn</name></name></expr></argument>,
									 <argument><expr><name>tupleCsn</name></expr></argument>,
									 <argument><expr><name>mctx</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>leafLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>hint</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>hint</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>hint</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>tuple</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* keep compiler quiet */</comment>
	<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>OTuple</name></type>
<name>btree_seq_scan_getnext</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>,
					   <parameter><decl><type><name>CommitSeqNo</name> <modifier>*</modifier></type><name>tupleCsn</name></decl></parameter>, <parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>BTreeSeqScanInMemory</name> <operator>||</operator>
		<name><name>scan</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>BTreeSeqScanDisk</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>btree_seq_scan_getnext_internal</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>mctx</name></expr></argument>, <argument><expr><name>tupleCsn</name></expr></argument>, <argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>tuple</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>BTreeSeqScanFinished</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OTuple</name></type>
<name>btree_seq_scan_get_tuple_from_iterator_raw</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>,
										   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
										   <parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>iterEnd</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>btree_iterate_raw</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>iterEnd</name></name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>,
								   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>btree_iterate_raw</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>,
								   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>end</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>btree_iterator_free</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OTuple</name></type>
<name>btree_seq_scan_getnext_raw_internal</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>,
									<parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tupHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>end</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>btree_seq_scan_get_tuple_from_iterator_raw</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>end</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>tuple</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><operator>!</operator><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>leafLoc</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>BTreeSeqScanInMemory</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"load_next_in_memory_leaf_page START3"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>iterate_internal_page</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>iter</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type>		<name>end</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>btree_seq_scan_get_tuple_from_iterator_raw</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>end</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>tuple</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>switch_to_disk_scan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>BTreeSeqScanDisk</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>load_next_disk_leaf_page</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>BTreeSeqScanFinished</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>tuple</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tupHdr</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>leafLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>leafImg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>leafLoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tupHdr</name><operator>-&gt;</operator><name>deleted</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>hint</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>hint</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>hint</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>tuple</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>tuple</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>OTuple</name></type>
<name>btree_seq_scan_getnext_raw</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>BTreeSeqScanInMemory</name> <operator>||</operator>
		<name><name>scan</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>BTreeSeqScanDisk</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>btree_seq_scan_getnext_raw_internal</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>mctx</name></expr></argument>, <argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>BTreeSeqScanInMemory</name> <operator>||</operator>
			<name><name>scan</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>BTreeSeqScanDisk</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<return>return <expr><name>tuple</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>BTreeSeqScanFinished</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>O_TUPLE_SET_NULL</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>free_btree_seq_scan</name><parameter_list>(<parameter><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeMetaPage</name> <modifier>*</modifier></type><name>metaPageBlkno</name> <init>= <expr><call><name>BTREE_GET_META</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>listNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pg_atomic_fetch_sub_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPageBlkno</name><operator>-&gt;</operator><name>numSeqScans</name><index>[<expr><name><name>scan</name><operator>-&gt;</operator><name>checkpointNumber</name></name> <operator>%</operator> <name>NUM_SEQ_SCANS_ARRAY_SIZE</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>dsmSeg</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>dsmSeg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>diskDownlinks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Error cleanup for sequential scans.  No scans survives the error, but they
 * are't cleaned up individually.  Thus, we have to walk trough all the scans
 * and revert changes made to the metaPageBlkno-&gt;numSeqScans.
 */</comment>
<function><type><name>void</name></type>
<name>seq_scans_cleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>!</operator><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>listOfScans</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name> <init>= <expr><call><name>dlist_head_element</name><argument_list>(<argument><expr><name>BTreeSeqScan</name></expr></argument>, <argument><expr><name>listNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>listOfScans</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTreeMetaPage</name> <modifier>*</modifier></type><name>metaPageBlkno</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>poscan</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>metaPageBlkno</name> <operator>=</operator> <call><name>BTREE_GET_META</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pg_atomic_fetch_sub_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>metaPageBlkno</name><operator>-&gt;</operator><name>numSeqScans</name><index>[<expr><name><name>scan</name><operator>-&gt;</operator><name>checkpointNumber</name></name> <operator>%</operator> <name>NUM_SEQ_SCANS_ARRAY_SIZE</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>listNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>dsmSeg</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>dsmSeg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>listOfScans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
