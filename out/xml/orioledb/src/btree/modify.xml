<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/btree/modify.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * modify.c
 *		Routines for OrioleDB B-tree modification.
 *
 * Copyright (c) 2021-2022, Oriole DB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/btree/modify.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/find.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/insert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/merge.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/modify.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/page_chunks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/o_tables.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"recovery/recovery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"recovery/wal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transam/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transam/oxid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/page_pool.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/stopevent.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IsRelationTree</name><parameter_list>(<parameter><type><name>desc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(ORelOidsIsValid(desc-&gt;oids) &amp;&amp; !IS_SYS_TREE_OIDS(desc-&gt;oids))</cpp:value></cpp:define>

<comment type="block">/*
 * Context for o_btree_modify_internal()
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>pageFindContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeKeyType</name></type> <name>tupleType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeLeafTuphdr</name></type> <name>leafTuphdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeLeafTuphdr</name></type> <name>conflictTupHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>replace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>conflictUndoLocation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OXid</name></type>		<name>opOxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>opCsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RowLockMode</name></type> <name>lockMode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>hwLockTag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>hwLockMode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needsUndo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isAlreadyLocked</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>pagesAreReserved</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>undoIsReserved</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeOperationType</name></type> <name>action</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeKeyType</name></type> <name>keyType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>savepointUndoLocation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeModifyCallbackInfo</name> <modifier>*</modifier></type><name>callbackInfo</name></decl>;</decl_stmt>
}</block></struct></type> <name>BTreeModifyInternalContext</name>;</typedef>

<typedef>typedef <type><enum>enum <name>ConflictResolution</name>
<block>{
	<decl><name>ConflictResolutionOK</name></decl>,
	<decl><name>ConflictResolutionRetry</name></decl>,
	<decl><name>ConflictResolutionFound</name></decl>
}</block></enum></type> <name>ConflictResolution</name>;</typedef>

<decl_stmt><decl><type><name>BTreeModifyCallbackInfo</name></type> <name>nullCallbackInfo</name> <init>=
<expr><block>{
	<expr><operator>.</operator><name>waitCallback</name> <operator>=</operator> <name>NULL</name></expr>,
	<expr><operator>.</operator><name>modifyCallback</name> <operator>=</operator> <name>NULL</name></expr>,
	<expr><operator>.</operator><name>modifyDeletedCallback</name> <operator>=</operator> <name>NULL</name></expr>,
	<expr><operator>.</operator><name>needsUndoForSelfCreated</name> <operator>=</operator> <name>false</name></expr>,
	<expr><operator>.</operator><name>arg</name> <operator>=</operator> <name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>LOCKMODE</name></type> <name><name>hwLockModes</name><index>[]</index></name> <init>= <expr><block>{<expr><name>AccessShareLock</name></expr>, <expr><name>RowShareLock</name></expr>, <expr><name>ExclusiveLock</name></expr>, <expr><name>AccessExclusiveLock</name></expr>}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>unlock_release</name><parameter_list>(<parameter><decl><type><name>BTreeModifyInternalContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>unlock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ConflictResolution</name></type> <name>o_btree_modify_handle_conflicts</name><parameter_list>(<parameter><decl><type><name>BTreeModifyInternalContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>OBTreeModifyResult</name></type> <name>o_btree_modify_handle_tuple_not_found</name><parameter_list>(<parameter><decl><type><name>BTreeModifyInternalContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>o_btree_modify_item_rollback</name><parameter_list>(<parameter><decl><type><name>BTreeModifyInternalContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>o_btree_modify_insert_update</name><parameter_list>(<parameter><decl><type><name>BTreeModifyInternalContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>o_btree_modify_add_undo_record</name><parameter_list>(<parameter><decl><type><name>BTreeModifyInternalContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>OBTreeModifyResult</name></type> <name>o_btree_modify_delete</name><parameter_list>(<parameter><decl><type><name>BTreeModifyInternalContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>OBTreeModifyResult</name></type> <name>o_btree_modify_lock</name><parameter_list>(<parameter><decl><type><name>BTreeModifyInternalContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Jsonb</name> <modifier>*</modifier></type><name>prepare_modify_start_params</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>OBTreeModifyResult</name></type> <name>o_btree_normal_modify</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>,
												<parameter><decl><type><name>BTreeOperationType</name></type> <name>action</name></decl></parameter>,
												<parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>tupleType</name></decl></parameter>,
												<parameter><decl><type><name>Pointer</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>keyType</name></decl></parameter>,
												<parameter><decl><type><name>OXid</name></type> <name>opOxid</name></decl></parameter>,
												<parameter><decl><type><name>CommitSeqNo</name></type> <name>opCsn</name></decl></parameter>,
												<parameter><decl><type><name>RowLockMode</name></type> <name>lockMode</name></decl></parameter>,
												<parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>,
												<parameter><decl><type><name>BTreeModifyCallbackInfo</name> <modifier>*</modifier></type><name>callbackInfo</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Perform modification of btree leaf tuple, when page is alredy located
 * and locked, all reservations are done.
 */</comment>
<function><type><specifier>static</specifier> <name>OBTreeModifyResult</name></type>
<name>o_btree_modify_internal</name><parameter_list>(<parameter><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>pageFindContext</name></decl></parameter>,
						<parameter><decl><type><name>BTreeOperationType</name></type> <name>action</name></decl></parameter>,
						<parameter><decl><type><name>OTuple</name></type> <name>_tuple</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>tupleType</name></decl></parameter>,
						<parameter><decl><type><name>Pointer</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>keyType</name></decl></parameter>,
						<parameter><decl><type><name>OXid</name></type> <name>opOxid</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>opCsn</name></decl></parameter>,
						<parameter><decl><type><name>RowLockMode</name></type> <name>_lockMode</name></decl></parameter>,
						<parameter><decl><type><name>BTreeModifyCallbackInfo</name> <modifier>*</modifier></type><name>callbackInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>desc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeModifyResult</name></type> <name>result</name> <init>= <expr><name>OBTreeModifyResultInserted</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTupleXactInfo</name></type> <name>initXactInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>curTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeModifyInternalContext</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>tuple</name></name> <operator>=</operator> <name>_tuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>tupleType</name></name> <operator>=</operator> <name>tupleType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>pageFindContext</name></name> <operator>=</operator> <name>pageFindContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>replace</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>opOxid</name></name> <operator>=</operator> <name>opOxid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>opCsn</name></name> <operator>=</operator> <name>opCsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>lockMode</name></name> <operator>=</operator> <name>_lockMode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>hwLockMode</name></name> <operator>=</operator> <name>NoLock</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>isAlreadyLocked</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>action</name></name> <operator>=</operator> <name>action</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>keyType</name></name> <operator>=</operator> <name>keyType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>isAlreadyLocked</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>savepointUndoLocation</name></name> <operator>=</operator> <call><name>get_subxact_undo_location</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>callbackInfo</name></name> <operator>=</operator> <name>callbackInfo</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>callbackInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>action</name> <operator>!=</operator> <name>BTreeOperationInsert</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>tupleType</name> <operator>==</operator> <name>BTreeKeyLeafTuple</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>action</name> <operator>==</operator> <name>BTreeOperationLock</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>context</name><operator>.</operator><name>lockMode</name></name> <operator>&gt;=</operator> <name>RowLockNoKeyUpdate</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>pagesAreReserved</name></name> <operator>=</operator> <operator>(</operator><name>action</name> <operator>!=</operator> <name>BTreeOperationDelete</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>undoIsReserved</name></name> <operator>=</operator> <operator>(</operator><name><name>desc</name><operator>-&gt;</operator><name>undoType</name></name> <operator>!=</operator> <name>UndoReserveNone</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Undo should be reserved for transactional operations */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OXidIsValid</name><argument_list>(<argument><expr><name>opOxid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>context</name><operator>.</operator><name>undoIsReserved</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OXidIsValid</name><argument_list>(<argument><expr><name>opOxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>initXactInfo</name> <operator>=</operator> <call><name>OXID_GET_XACT_INFO</name><argument_list>(<argument><expr><name>opOxid</name></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>lockMode</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>initXactInfo</name> <operator>=</operator> <call><name>OXID_GET_XACT_INFO</name><argument_list>(<argument><expr><name>BootstrapTransactionId</name></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>lockMode</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<label><name>retry</name>:</label>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>needsUndo</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>callbackInfo</name> <operator>&amp;&amp;</operator> <name><name>callbackInfo</name><operator>-&gt;</operator><name>needsUndoForSelfCreated</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
		<call><name>OXidIsValid</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>createOxid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>desc</name><operator>-&gt;</operator><name>createOxid</name></name> <operator>==</operator> <name>opOxid</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>savepointUndoLocation</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>needsUndo</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>leafTuphdr</name><operator>.</operator><name>deleted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>leafTuphdr</name><operator>.</operator><name>undoLocation</name></name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>leafTuphdr</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>leafTuphdr</name><operator>.</operator><name>chainHasLocks</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>leafTuphdr</name><operator>.</operator><name>xactInfo</name></name> <operator>=</operator> <name>initXactInfo</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>loc</name> <operator>=</operator> <name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>page_is_locked</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>o_btree_modify_handle_tuple_not_found</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name>curTuple</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuphdr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>cmp</name></name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keyType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>curTuple</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>cmp</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ConflictResolution</name></type> <name>resolution</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>resolution</name> <operator>=</operator> <call><name>o_btree_modify_handle_conflicts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>resolution</name> <operator>==</operator> <name>ConflictResolutionFound</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>OBTreeModifyResultFound</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>resolution</name> <operator>==</operator> <name>ConflictResolutionRetry</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>page_is_locked</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>cmp</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>o_btree_modify_handle_tuple_not_found</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tuphdr</name><operator>-&gt;</operator><name>deleted</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Existing (non-deleted) tuple is found */</comment>
		<decl_stmt><decl><type><name>OBTreeModifyCallbackAction</name></type> <name>cbAction</name> <init>= <expr><name>OBTreeCallbackActionDoNothing</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RowLockMode</name></type> <name>prev_lock_mode</name> <init>= <expr><name><name>context</name><operator>.</operator><name>lockMode</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We should have set conflictTupHdr in the (cmp == 0) branch above.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>callbackInfo</name><operator>-&gt;</operator><name>modifyCallback</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTreeLocationHint</name></type> <name>cbHint</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>cbHint</name><operator>.</operator><name>blkno</name></name> <operator>=</operator> <name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cbHint</name><operator>.</operator><name>pageChangeCount</name></name> <operator>=</operator> <name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>pageChangeCount</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cbAction</name> <operator>=</operator> <call><name><name>callbackInfo</name><operator>-&gt;</operator><name>modifyCallback</name></name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>curTuple</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>opOxid</name></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>conflictTupHdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>,
													<argument><expr><name><name>context</name><operator>.</operator><name>conflictTupHdr</name><operator>.</operator><name>undoLocation</name></name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>lockMode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cbHint</name></expr></argument>, <argument><expr><name><name>callbackInfo</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>cbAction</name> <operator>==</operator> <name>OBTreeCallbackActionUndo</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>o_btree_modify_item_rollback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>retry</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>page_is_locked</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>callbackInfo</name><operator>-&gt;</operator><name>modifyCallback</name></name> <operator>||</operator> <operator>(</operator><name>action</name> <operator>==</operator> <name>BTreeOperationInsert</name> <operator>||</operator>
											 <name>action</name> <operator>==</operator> <name>BTreeOperationUpdate</name> <operator>||</operator>
											 <name>action</name> <operator>==</operator> <name>BTreeOperationLock</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>cbAction</name> <operator>==</operator> <name>OBTreeCallbackActionDoNothing</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>unlock_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>OBTreeModifyResultFound</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>lockMode</name></name> <operator>&gt;</operator> <name>prev_lock_mode</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>refind_page</name><argument_list>(<argument><expr><name>pageFindContext</name></expr></argument>,
								<argument><expr><name>key</name></expr></argument>,
								<argument><expr><name>keyType</name></expr></argument>,
								<argument><expr><literal type="number">0</literal></expr></argument>,
								<argument><expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr></argument>,
								<argument><expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>pageChangeCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>retry</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>cbAction</name> <operator>==</operator> <name>OBTreeCallbackActionUpdate</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tupleType</name> <operator>==</operator> <name>BTreeKeyLeafTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>context</name><operator>.</operator><name>replace</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>OBTreeModifyResultUpdated</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>cbAction</name> <operator>==</operator> <name>OBTreeCallbackActionLock</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>action</name> <operator>=</operator> <name>BTreeOperationLock</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cbAction</name> <operator>==</operator> <name>OBTreeCallbackActionDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>action</name> <operator>=</operator> <name>BTreeOperationDelete</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>action</name> <operator>==</operator> <name>BTreeOperationLock</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>context</name><operator>.</operator><name>lockMode</name></name> <operator>&gt;=</operator> <name>RowLockNoKeyUpdate</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BTreeOperationDelete</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>o_btree_modify_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>action</name> <operator>==</operator> <name>BTreeOperationLock</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>o_btree_modify_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tuphdr</name><operator>-&gt;</operator><name>deleted</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We should have set conflictTupHdr in the (cmp == 0) branch above.
		 */</comment>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BTreeOperationInsert</name> <operator>&amp;&amp;</operator> <name><name>callbackInfo</name><operator>-&gt;</operator><name>modifyDeletedCallback</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OBTreeModifyCallbackAction</name></type> <name>cbAction</name> <init>= <expr><name>OBTreeCallbackActionDoNothing</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BTreeLocationHint</name></type> <name>cbHint</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>cbHint</name><operator>.</operator><name>blkno</name></name> <operator>=</operator> <name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cbHint</name><operator>.</operator><name>pageChangeCount</name></name> <operator>=</operator> <name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>pageChangeCount</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cbAction</name> <operator>=</operator> <call><name><name>callbackInfo</name><operator>-&gt;</operator><name>modifyDeletedCallback</name></name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>curTuple</name></expr></argument>,
														   <argument><expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>opOxid</name></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>conflictTupHdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>,
														   <argument><expr><name><name>context</name><operator>.</operator><name>conflictTupHdr</name><operator>.</operator><name>undoLocation</name></name></expr></argument>,
														   <argument><expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>lockMode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cbHint</name></expr></argument>, <argument><expr><name><name>callbackInfo</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>cbAction</name> <operator>==</operator> <name>OBTreeCallbackActionUndo</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>o_btree_modify_item_rollback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>retry</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>cbAction</name> <operator>==</operator> <name>OBTreeCallbackActionDoNothing</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>unlock_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>OBTreeModifyResultNotFound</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cbAction</name> <operator>==</operator> <name>OBTreeCallbackActionUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Deleted tuple found, we only can handle insert at this point. This
		 * insert essentially becomes update.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BTreeOperationInsert</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>context</name><operator>.</operator><name>needsUndo</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If we don't need undo, just revert the deletion and then
				 * continue with normal insert (with undo).
				 */</comment>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>o_btree_modify_item_rollback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>context</name><operator>.</operator><name>needsUndo</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsRelationTree</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_MAP_CSN</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>conflictTupHdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>opCsn</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>context</name><operator>.</operator><name>replace</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>unlock_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>callbackInfo</name><operator>-&gt;</operator><name>modifyDeletedCallback</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name><name>callbackInfo</name><operator>-&gt;</operator><name>modifyDeletedCallback</name></name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>curTuple</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>opOxid</name></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>conflictTupHdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>,
													<argument><expr><name><name>context</name><operator>.</operator><name>conflictTupHdr</name><operator>.</operator><name>undoLocation</name></name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>lockMode</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
													<argument><expr><name><name>callbackInfo</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>OBTreeModifyResultNotFound</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tupleType</name> <operator>==</operator> <name>BTreeKeyLeafTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>o_btree_modify_insert_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlock_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>unlock_release</name><parameter_list>(<parameter><decl><type><name>BTreeModifyInternalContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>unlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>pageFindContext</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>pageFindContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>desc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>unlock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>undoIsReserved</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>release_undo_size</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>undoType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>pagesAreReserved</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ppool_release_reserved</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>PPOOL_RESERVE_INSERT_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>hwLockMode</name></name> <operator>!=</operator> <name>NoLock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>hwLockTag</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>hwLockMode</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>wait_for_tuple</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>RowLockMode</name></type> <name>lockMode</name></decl></parameter>,
			   <parameter><decl><type><name>LOCKTAG</name> <modifier>*</modifier></type><name>hwLockTag</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name> <modifier>*</modifier></type><name>hwLockMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hash</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>hwLockMode</name> <operator>==</operator> <name>NoLock</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>o_btree_hash</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SET_LOCKTAG_TUPLE</name><argument_list>(<argument><expr><operator>*</operator><name>hwLockTag</name></expr></argument>,
						  <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr></argument>,
						  <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>reloid</name></name></expr></argument>,
						  <argument><expr><name>hash</name></expr></argument>,
						  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>hwLockMode</name> <operator>=</operator> <name><name>hwLockModes</name><index>[<expr><name>lockMode</name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><name>hwLockTag</name></expr></argument>, <argument><expr><operator>*</operator><name>hwLockMode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>wait_for_oxid</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ConflictResolution</name></type>
<name>o_btree_modify_handle_conflicts</name><parameter_list>(<parameter><decl><type><name>BTreeModifyInternalContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>haveRedundantRowLocks</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>pageFindContext</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>pageFindContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>desc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>curTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>&amp;</operator><name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name>curTuple</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>row_lock_conflicts</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>conflictTupHdr</name></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>conflictUndoLocation</name></name></expr></argument>,
						   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>lockMode</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>opOxid</name></name></expr></argument>,
						   <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>savepointUndoLocation</name></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>haveRedundantRowLocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>isAlreadyLocked</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTupleXactInfo</name></type> <name>xactInfo</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>conflictTupHdr</name><operator>.</operator><name>xactInfo</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name> <init>= <expr><call><name>XACT_INFO_GET_OXID</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>oxid</name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>opOxid</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>BTreeOperationLock</name> <operator>||</operator>
				<operator>(</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>savepointUndoLocation</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <operator>(</operator><operator>!</operator><call><name>UndoLocationIsValid</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>conflictTupHdr</name><operator>.</operator><name>undoLocation</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				  <name><name>context</name><operator>-&gt;</operator><name>conflictTupHdr</name><operator>.</operator><name>undoLocation</name></name> <operator>&lt;</operator> <name><name>context</name><operator>-&gt;</operator><name>savepointUndoLocation</name></name><operator>)</operator><operator>)</operator> <operator>||</operator>
				<call><name>o_btree_needs_undo</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>action</name></name></expr></argument>, <argument><expr><name>curTuple</name></expr></argument>, <argument><expr><name>xactInfo</name></expr></argument>,
								   <argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>deleted</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>opOxid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>needsUndo</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_GET_LOCK_MODE</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>lockMode</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Upgrade our lock mode if we're going to replace our own
					 * undo item.
					 */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OXidIsValid</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>opOxid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>lockMode</name></name> <operator>=</operator> <call><name>XACT_INFO_GET_LOCK_MODE</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>leafTuphdr</name><operator>.</operator><name>xactInfo</name></name> <operator>=</operator> <call><name>OXID_GET_XACT_INFO</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>opOxid</name></name></expr></argument>,
																	  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>lockMode</name></name></expr></argument>,
																	  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>needsUndo</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>csn</name> <init>= <expr><call><name>oxid_get_csn</name><argument_list>(<argument><expr><name>oxid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>COMMITSEQNO_IS_ABORTED</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call> <operator>||</operator>
													 <call><name>COMMITSEQNO_IS_NORMAL</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call> <operator>||</operator>
													 <call><name>COMMITSEQNO_IS_FROZEN</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Normally row_lock_conflicts() should have lock-only records
				 * of committed and aborted transactions already removed from
				 * the undo chain.  But if locker transaction commit or abort
				 * concurrently, then retry.
				 */</comment>
				<return>return <expr><name>ConflictResolutionRetry</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>COMMITSEQNO_IS_ABORTED</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Transaction changes should be undone by the transaction
				 * owner.  But we rollback those changes ourself instead of
				 * waiting.
				 */</comment>
				<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>page_item_rollback</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>conflictTupHdr</name></name></expr></argument>,
										<argument><expr><name><name>context</name><operator>-&gt;</operator><name>conflictUndoLocation</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>cmp</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>MARK_DIRTY</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>COMMITSEQNO_IS_NORMAL</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>COMMITSEQNO_IS_FROZEN</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Check for serialization conflicts.
				 *
				 * TODO: check for such conflicts in page-level undo as well.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>csn</name> <operator>&gt;=</operator> <name><name>context</name><operator>-&gt;</operator><name>opCsn</name></name> <operator>&amp;&amp;</operator> <call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
					<call><name>IsRelationTree</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Conflicting transaction is in-progress.  If the callback is
				 * provided, ask it what to do.  Just wait otherwise.
				 */</comment>
				<decl_stmt><decl><type><name>OBTreeWaitCallbackAction</name></type> <name>cbAction</name> <init>= <expr><name>OBTreeCallbackActionXidWait</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>COMMITSEQNO_IS_INPROGRESS</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>callbackInfo</name><operator>-&gt;</operator><name>waitCallback</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>BTreeLocationHint</name></type> <name>cbHint</name></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>cbHint</name><operator>.</operator><name>blkno</name></name> <operator>=</operator> <name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cbHint</name><operator>.</operator><name>pageChangeCount</name></name> <operator>=</operator> <name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>pageChangeCount</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>cbAction</name> <operator>=</operator> <call><name><name>context</name><operator>-&gt;</operator><name>callbackInfo</name><operator>-&gt;</operator><name>waitCallback</name></name><argument_list>(<argument><expr><name>desc</name></expr></argument>,
																   <argument><expr><name>curTuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>,
																   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>conflictTupHdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>,
																   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>conflictTupHdr</name><operator>.</operator><name>undoLocation</name></name></expr></argument>,
																   <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>lockMode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cbHint</name></expr></argument>,
																   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>callbackInfo</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cbAction</name> <operator>&lt;=</operator> <name>OBTreeCallbackActionXidExit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>cbAction</name> <operator>==</operator> <name>OBTreeCallbackActionXidWait</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>wait_for_tuple</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>curTuple</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>,
								   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>lockMode</name></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>hwLockTag</name></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>hwLockMode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>cbAction</name> <operator>==</operator> <name>OBTreeCallbackActionXidExit</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>ConflictResolutionFound</name></expr>;</return></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cbAction</name> <operator>==</operator> <name>OBTreeCallbackActionXidNoWait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><call><name>refind_page</name><argument_list>(<argument><expr><name>pageFindContext</name></expr></argument>,
							<argument><expr><name><name>context</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,
							<argument><expr><name><name>context</name><operator>-&gt;</operator><name>keyType</name></name></expr></argument>,
							<argument><expr><literal type="number">0</literal></expr></argument>,
							<argument><expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr></argument>,
							<argument><expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>pageChangeCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>ConflictResolutionRetry</name></expr>;</return>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Update tuple and header pointer after page_item_rollback() */</comment>
			<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name>curTuple</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsRelationTree</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Check for serialization conflicts.
		 *
		 * TODO: check for such conflicts in page-level undo as well.
		 */</comment>
		<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>csn</name> <init>= <expr><call><name>XACT_INFO_MAP_CSN</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>conflictTupHdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>csn</name> <operator>&gt;=</operator> <name><name>context</name><operator>-&gt;</operator><name>opCsn</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Remove redundant row-level locks if any.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>haveRedundantRowLocks</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>remove_redundant_row_locks</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>conflictTupHdr</name></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>conflictUndoLocation</name></name></expr></argument>,
								   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>lockMode</name></name></expr></argument>,
								   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>opOxid</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>,
								   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>savepointUndoLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>needsUndo</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>leafTuphdr</name><operator>.</operator><name>undoLocation</name></name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>ConflictResolutionOK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OBTreeModifyResult</name></type>
<name>o_btree_modify_handle_tuple_not_found</name><parameter_list>(<parameter><decl><type><name>BTreeModifyInternalContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Matching tuple is not found.
	 *
	 * Ideally, for IsolationUsesXactSnapshot() we should also check
	 * page-level undo for conflicting tuples.  But it's not implemented so
	 * far.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>BTreeOperationUpdate</name> <operator>||</operator>
		<name><name>context</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>BTreeOperationDelete</name> <operator>||</operator>
		<name><name>context</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>BTreeOperationLock</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>unlock_release</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>OBTreeModifyResultNotFound</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>tupleType</name></name> <operator>==</operator> <name>BTreeKeyLeafTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>o_btree_modify_insert_update</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlock_release</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>OBTreeModifyResultInserted</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>o_btree_modify_item_rollback</name><parameter_list>(<parameter><decl><type><name>BTreeModifyInternalContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>pageFindContext</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>pageFindContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>desc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>applyResult</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>loc</name> <operator>=</operator> <name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>applyResult</name> <operator>=</operator> <call><name>page_item_rollback</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>conflictTupHdr</name></name></expr></argument>,
									 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>conflictUndoLocation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MARK_DIRTY</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>applyResult</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>btree_page_search</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,
						  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>keyType</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name> <operator>=</operator> <name>loc</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>applyResult</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>o_btree_modify_insert_update</name><parameter_list>(<parameter><decl><type><name>BTreeModifyInternalContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>pageFindContext</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>pageFindContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>desc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tuplen</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>undoIsReserved</name></name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>needsUndo</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>o_btree_modify_add_undo_record</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuplen</name> <operator>=</operator> <call><name>o_btree_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>OTupleLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuplen</name> <operator>&lt;=</operator> <name>O_BTREE_MAX_TUPLE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* no more sense in that */</comment>
	<expr_stmt><expr><call><name>BTREE_PAGE_FIND_UNSET</name><argument_list>(<argument><expr><name>pageFindContext</name></expr></argument>, <argument><expr><name>FIX_LEAF_SPLIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>o_btree_insert_tuple_to_leaf</name><argument_list>(<argument><expr><name>pageFindContext</name></expr></argument>,
								 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>tuplen</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>leafTuphdr</name></name></expr></argument>,
								 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>replace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>o_btree_modify_add_undo_record</name><parameter_list>(<parameter><decl><type><name>BTreeModifyInternalContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>pageFindContext</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>pageFindContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>desc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>undoLocation</name> <init>= <expr><name>InvalidUndoLocation</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>loc</name> <operator>=</operator> <name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>replace</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Make undo item and connect it with page tuple */</comment>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>curTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>leafTuphdr</name> <init>= <expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>leafTuphdr</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>prevTuphdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name>curTuple</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>prevTuphdr</name> <operator>=</operator> <call><name>make_undo_record</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>curTuple</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									  <argument><expr><name>BTreeOperationUpdate</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>,
									  <argument><expr><call><name>O_PAGE_GET_CHANGE_COUNT</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>undoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>leafTuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>=</operator> <name>undoLocation</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>leafTuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name> <operator>||</operator>
			<call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prevTuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prevTuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prevTuphdr</name><operator>-&gt;</operator><name>deleted</name></name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>deleted</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prevTuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Still need the undo item to deal with transaction rollback */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>make_undo_record</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								<argument><expr><name>BTreeOperationInsert</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>,
								<argument><expr><call><name>O_PAGE_GET_CHANGE_COUNT</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>undoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OBTreeModifyResult</name></type>
<name>o_btree_modify_delete</name><parameter_list>(<parameter><decl><type><name>BTreeModifyInternalContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>pageFindContext</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>pageFindContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>desc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>prev_tuphdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>pageChangeCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>undoLocation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>curTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>loc</name> <operator>=</operator> <name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name>curTuple</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>needsUndo</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>stillExists</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>stillExists</name> <operator>=</operator> <call><name>o_btree_modify_item_rollback</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>stillExists</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name>curTuple</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuphdr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>stillExists</name> <operator>=</operator> <operator>!</operator><name><name>tuphdr</name><operator>-&gt;</operator><name>deleted</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stillExists</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Already deleted */</comment>
			<expr_stmt><expr><call><name>unlock_release</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>OBTreeModifyResultDeleted</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We rollback our own changes to the version existed before.
			 * Thus, we need an undo record to modify it.
			 */</comment>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>needsUndo</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>undoIsReserved</name></name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>needsUndo</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>key</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>key_is_tuple</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>tupleType</name></name> <operator>==</operator> <name>BTreeKeyNonLeafKey</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>tuple</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>key_is_tuple</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>key</name> <operator>=</operator> <name>curTuple</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>key_is_tuple</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>pageChangeCount</name> <operator>=</operator> <call><name>O_PAGE_GET_CHANGE_COUNT</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev_tuphdr</name> <operator>=</operator> <call><name>make_undo_record</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_is_tuple</name></expr></argument>,
									   <argument><expr><name>BTreeOperationDelete</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>pageChangeCount</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>undoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prev_tuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prev_tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prev_tuphdr</name><operator>-&gt;</operator><name>deleted</name></name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>deleted</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prev_tuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>undoLocation</name> <operator>=</operator> <name>InvalidUndoLocation</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name> <operator>||</operator>
		<call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>=</operator> <name>undoLocation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>leafTuphdr</name><operator>.</operator><name>xactInfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>deleted</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PAGE_ADD_N_VACATED</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BTREE_PAGE_GET_ITEM_SIZE</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MARK_DIRTY</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OXidIsValid</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>opOxid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_page_too_sparse</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>btree_try_merge_and_unlock</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlock_release</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>unlock_release</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>OBTreeModifyResultDeleted</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OBTreeModifyResult</name></type>
<name>o_btree_modify_lock</name><parameter_list>(<parameter><decl><type><name>BTreeModifyInternalContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>pageFindContext</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>pageFindContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>desc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UndoLocation</name></type> <name>undoLocation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>prev_tuphdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>pageChangeCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>key_is_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>curTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>loc</name> <operator>=</operator> <name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name>curTuple</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>isAlreadyLocked</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>unlock_release</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>OBTreeModifyResultLocked</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>needsUndo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>undoIsReserved</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OXidIsValid</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>opOxid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>tupleType</name></name> <operator>==</operator> <name>BTreeKeyNonLeafKey</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>tuple</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>key_is_tuple</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>key</name> <operator>=</operator> <name>curTuple</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>key_is_tuple</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>pageChangeCount</name> <operator>=</operator> <call><name>O_PAGE_GET_CHANGE_COUNT</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_tuphdr</name> <operator>=</operator> <call><name>make_undo_record</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_is_tuple</name></expr></argument>,
								   <argument><expr><name>BTreeOperationLock</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>pageChangeCount</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>undoLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prev_tuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prev_tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prev_tuphdr</name><operator>-&gt;</operator><name>deleted</name></name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>deleted</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prev_tuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>page_block_reads</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name> <operator>=</operator> <name><name>tuphdr</name><operator>-&gt;</operator><name>chainHasLocks</name></name> <operator>||</operator>
		<call><name>XACT_INFO_IS_LOCK_ONLY</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name> <operator>=</operator> <name>undoLocation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>xactInfo</name></name> <operator>=</operator> <call><name>OXID_GET_XACT_INFO</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>opOxid</name></name></expr></argument>,
										  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>lockMode</name></name></expr></argument>,
										  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>deleted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MARK_DIRTY</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlock_release</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>OBTreeModifyResultLocked</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Jsonb</name> <modifier>*</modifier></type>
<name>prepare_modify_start_params</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mctx</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>stopevents_cxt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>WJB_BEGIN_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>btree_desc_stopevent_params_internal</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>WJB_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OBTreeModifyResult</name></type>
<name>o_btree_normal_modify</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>BTreeOperationType</name></type> <name>action</name></decl></parameter>,
					  <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>tupleType</name></decl></parameter>,
					  <parameter><decl><type><name>Pointer</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>keyType</name></decl></parameter>,
					  <parameter><decl><type><name>OXid</name></type> <name>opOxid</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>opCsn</name></decl></parameter>,
					  <parameter><decl><type><name>RowLockMode</name></type> <name>lockMode</name></decl></parameter>, <parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>,
					  <parameter><decl><type><name>BTreeModifyCallbackInfo</name> <modifier>*</modifier></type><name>callbackInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name></type> <name>pageFindContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>params</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>STOPEVENTS_ENABLED</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>prepare_modify_start_params</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>STOPEVENT</name><argument_list>(<argument><expr><name>STOPEVENT_MODIFY_START</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* No no key is separately given, use the tuple itself */</comment>
	<if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>key</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>tuple</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>keyType</name> <operator>=</operator> <name>tupleType</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>undoType</name></name> <operator>!=</operator> <name>UndoReserveNone</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>reserve_undo_size</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>undoType</name></name></expr></argument>, <argument><expr><name>O_MODIFY_UNDO_RESSERVE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>!=</operator> <name>BTreeOperationDelete</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ppool_reserve_pages</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>PPOOL_RESERVE_INSERT</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>init_page_find_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pageFindContext</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>,
						   <argument><expr><name>BTREE_PAGE_FIND_MODIFY</name> <operator>|</operator> <name>BTREE_PAGE_FIND_FIX_LEAF_SPLIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hint</name> <operator>&amp;&amp;</operator> <call><name>OInMemoryBlknoIsValid</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>refind_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pageFindContext</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keyType</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>pageChangeCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>find_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pageFindContext</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keyType</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><call><name>o_btree_modify_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pageFindContext</name></expr></argument>, <argument><expr><name>action</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupleType</name></expr></argument>,
								   <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keyType</name></expr></argument>, <argument><expr><name>opOxid</name></expr></argument>, <argument><expr><name>opCsn</name></expr></argument>,
								   <argument><expr><name>lockMode</name></expr></argument>, <argument><expr><name>callbackInfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>page_unique_check</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>locator</name></decl></parameter>,
				  <parameter><decl><type><name>Pointer</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>opOxid</name></decl></parameter>, <parameter><decl><type><name>OTupleXactInfo</name> <modifier>*</modifier></type><name>xactInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><call><name>BTREE_PAGE_LOCATOR_IS_VALID</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>pageTuphdr</name></decl>,
					<decl><type ref="prev"/><name>tuphdr</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>pageTuphdr</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>,
						  <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BTreeKeyUniqueUpperBound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tuphdr</name> <operator>=</operator> <operator>*</operator><name>pageTuphdr</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>find_non_lock_only_undo_record</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuphdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_OXID_EQ</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>, <argument><expr><name>opOxid</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>tuphdr</name><operator>.</operator><name>deleted</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>BTREE_PAGE_LOCATOR_NEXT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>xactInfo</name> <operator>=</operator> <name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>xactInfo</name> <operator>=</operator> <name><name>tuphdr</name><operator>.</operator><name>xactInfo</name></name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></while>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>slowpath_unique_check</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OBTreeFindPageContext</name> <modifier>*</modifier></type><name>pageFindContext</name></decl></parameter>,
					  <parameter><decl><type><name>Pointer</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>opOxid</name></decl></parameter>, <parameter><decl><type><name>OTupleXactInfo</name> <modifier>*</modifier></type><name>xactInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OFixedKey</name></type>	<name>hikey_buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>btree_find_context_from_modify_to_read</name><argument_list>(<argument><expr><name>pageFindContext</name></expr></argument>,
										   <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BTreeKeyUniqueLowerBound</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pageFindContext</name><operator>-&gt;</operator><name>img</name></name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>hikey</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>page_unique_check</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr></argument>,
							  <argument><expr><name>key</name></expr></argument>, <argument><expr><name>opOxid</name></expr></argument>, <argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hikey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>,
						  <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BTreeKeyUniqueUpperBound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>find_right_page</name><argument_list>(<argument><expr><name>pageFindContext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hikey_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Due to concurrent merges, some tuples might be lower than the
		 * unique key.  So, we can't just start from the beginning, but have
		 * to find the right position on the page.
		 */</comment>
		<expr_stmt><expr><call><name>btree_page_search</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BTreeKeyUniqueLowerBound</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pageFindContext</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>OBTreeModifyResult</name></type>
<name>o_btree_insert_unique</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>tupleType</name></decl></parameter>,
					  <parameter><decl><type><name>Pointer</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>keyType</name></decl></parameter>,
					  <parameter><decl><type><name>OXid</name></type> <name>opOxid</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>opCsn</name></decl></parameter>,
					  <parameter><decl><type><name>RowLockMode</name></type> <name>lockMode</name></decl></parameter>, <parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>,
					  <parameter><decl><type><name>BTreeModifyCallbackInfo</name> <modifier>*</modifier></type><name>callbackInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OBTreeFindPageContext</name></type> <name>pageFindContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fastpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OInMemoryBlkno</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>pageChangeCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>uniqueLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeModifyResult</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>params</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>STOPEVENTS_ENABLED</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>prepare_modify_start_params</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>STOPEVENT</name><argument_list>(<argument><expr><name>STOPEVENT_MODIFY_START</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>key</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>keyType</name> <operator>==</operator> <name>BTreeKeyBound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>undoType</name></name> <operator>!=</operator> <name>UndoReserveNone</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>reserve_undo_size</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>undoType</name></name></expr></argument>, <argument><expr><name>O_MODIFY_UNDO_RESSERVE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ppool_reserve_pages</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name></expr></argument>, <argument><expr><name>PPOOL_RESERVE_INSERT</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_page_find_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pageFindContext</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>,
						   <argument><expr><name>BTREE_PAGE_FIND_MODIFY</name> <operator>|</operator>
						   <name>BTREE_PAGE_FIND_IMAGE</name> <operator>|</operator>
						   <name>BTREE_PAGE_FIND_FIX_LEAF_SPLIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hint</name> <operator>&amp;&amp;</operator> <call><name>OInMemoryBlknoIsValid</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>refind_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pageFindContext</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BTreeKeyUniqueLowerBound</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>pageChangeCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>find_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pageFindContext</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BTreeKeyUniqueLowerBound</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<label><name>retry</name>:</label>

	<expr_stmt><expr><name>fastpath</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>pageFindContext</name><operator>.</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pageChangeCount</name> <operator>=</operator> <name><name>pageFindContext</name><operator>.</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>pageChangeCount</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fastpath</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>hikey</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fastpath</name> <operator>=</operator> <operator>(</operator><call><name>o_btree_cmp</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hikey</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>,
								<argument><expr><name>key</name></expr></argument>, <argument><expr><name>BTreeKeyUniqueUpperBound</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>uniqueLock</name> <operator>=</operator> <operator>&amp;</operator><name><name>unique_locks</name><index>[<expr><call><name>o_btree_unique_hash</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call> <operator>%</operator> <name>num_unique_locks</name></expr>]</index></name><operator>.</operator><name>lock</name></expr>;</expr_stmt>

	<comment type="block">/*---
	 * We can do fast path unique check if we know that the required key range
	 * resides the single page, and we managed to take a unique lwlock
	 * simultaneusly.
	 *
	 * It might seem that we don't need unique lwlock as soon as we see all the
	 * key range in the locked page.  However, consider the following example.
	 *
	 * s1: Unique lwlock acquire
	 * s1: Slow path check
	 * Page merge
	 * s2: Fast patch check
	 * s2: Insert
	 * s1: Insert
	 *
	 * Due to page merge, we might end up with double insert.  This even fast
	 * path check requires unique lwlock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fastpath</name> <operator>&amp;&amp;</operator> <call><name>LWLockConditionalAcquire</name><argument_list>(<argument><expr><name>uniqueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTupleXactInfo</name></type> <name>xactInfo</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>page_unique_check</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pageFindContext</name><operator>.</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr></argument>,
							  <argument><expr><name>key</name></expr></argument>, <argument><expr><name>opOxid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xactInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OTuple</name></type>		<name>curTuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BTreeLocationHint</name></type> <name>cbHint</name> <init>= <expr><block>{<expr><name><name>pageFindContext</name><operator>.</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>, <expr><name><name>pageFindContext</name><operator>.</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>pageChangeCount</name></expr>}</block></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name>curTuple</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pageFindContext</name><operator>.</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_OXID_EQ</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>, <argument><expr><name>opOxid</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OBTreeModifyCallbackAction</name> <name>cbAction</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>callbackInfo</name><operator>-&gt;</operator><name>modifyCallback</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>cbAction</name> <operator>=</operator> <call><name><name>callbackInfo</name><operator>-&gt;</operator><name>modifyCallback</name></name><argument_list>(<argument><expr><name>desc</name></expr></argument>,
															<argument><expr><name>curTuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><name>opOxid</name></expr></argument>,
															<argument><expr><name>xactInfo</name></expr></argument>, <argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>lockMode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cbHint</name></expr></argument>, <argument><expr><name><name>callbackInfo</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * We could support other callback actions, but it's not
					 * yet needed.
					 */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cbAction</name> <operator>==</operator> <name>OBTreeCallbackActionDoNothing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>uniqueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>OBTreeModifyResultFound</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>OBTreeWaitCallbackAction</name></type> <name>cbAction</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>uniqueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>callbackInfo</name><operator>-&gt;</operator><name>waitCallback</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>cbAction</name> <operator>=</operator> <call><name><name>callbackInfo</name><operator>-&gt;</operator><name>waitCallback</name></name><argument_list>(<argument><expr><name>desc</name></expr></argument>,
														  <argument><expr><name>curTuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><call><name>XACT_INFO_GET_OXID</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr></argument>,
														  <argument><expr><name>xactInfo</name></expr></argument>, <argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>lockMode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cbHint</name></expr></argument>, <argument><expr><name><name>callbackInfo</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cbAction</name> <operator>!=</operator> <name>OBTreeCallbackActionXidNoWait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>cbAction</name> <operator>==</operator> <name>OBTreeCallbackActionXidExit</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><name>OBTreeModifyResultFound</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>wait_for_oxid</name><argument_list>(<argument><expr><call><name>XACT_INFO_GET_OXID</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>refind_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pageFindContext</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BTreeKeyUniqueLowerBound</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							<argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>pageChangeCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>retry</name>;</goto>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We've to find approprivate offset for the new tuple.  It should
			 * be within the page, but can not match current offset, because
			 * we've searched for BTreeUniqueMinBound.
			 */</comment>
			<expr_stmt><expr><call><name>btree_page_search</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BTreeKeyBound</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pageFindContext</name><operator>.</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTupleXactInfo</name></type> <name>xactInfo</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Evade deadlock: unlock the page before taking an unique lwlock.
		 */</comment>
		<expr_stmt><expr><call><name>unlock_page</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>uniqueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>slowpath_unique_check</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pageFindContext</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
								  <argument><expr><name>opOxid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xactInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>		<name>p</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BTreePageItemLocator</name> <modifier>*</modifier></type><name>loc</name> <init>= <expr><operator>&amp;</operator><name><name>pageFindContext</name><operator>.</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>locator</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OTuple</name></type>		<name>curTuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BTreeLocationHint</name></type> <name>cbHint</name> <init>= <expr><block>{<expr><name><name>pageFindContext</name><operator>.</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>, <expr><name><name>pageFindContext</name><operator>.</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>pageChangeCount</name></expr>}</block></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BTreeLeafTuphdr</name> <modifier>*</modifier></type><name>tuphdr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name><name>pageFindContext</name><operator>.</operator><name>items</name><index>[<expr><name><name>pageFindContext</name><operator>.</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BTREE_PAGE_READ_LEAF_ITEM</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name>curTuple</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>XACT_INFO_OXID_EQ</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>, <argument><expr><name>opOxid</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>XACT_INFO_IS_FINISHED</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OBTreeModifyCallbackAction</name> <name>cbAction</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>callbackInfo</name><operator>-&gt;</operator><name>modifyCallback</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>cbAction</name> <operator>=</operator> <call><name><name>callbackInfo</name><operator>-&gt;</operator><name>modifyCallback</name></name><argument_list>(<argument><expr><name>desc</name></expr></argument>,
															<argument><expr><name>curTuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><name>opOxid</name></expr></argument>,
															<argument><expr><name>xactInfo</name></expr></argument>, <argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>lockMode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cbHint</name></expr></argument>, <argument><expr><name><name>callbackInfo</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * We could support other callback actions, but it's not
					 * yet needed.
					 */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cbAction</name> <operator>==</operator> <name>OBTreeCallbackActionDoNothing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>uniqueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>OBTreeModifyResultFound</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>OBTreeWaitCallbackAction</name></type> <name>cbAction</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>uniqueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>callbackInfo</name><operator>-&gt;</operator><name>waitCallback</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>cbAction</name> <operator>=</operator> <call><name><name>callbackInfo</name><operator>-&gt;</operator><name>waitCallback</name></name><argument_list>(<argument><expr><name>desc</name></expr></argument>,
														  <argument><expr><name>curTuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><call><name>XACT_INFO_GET_OXID</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr></argument>,
														  <argument><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>undoLocation</name></name></expr></argument>,
														  <argument><expr><name>xactInfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lockMode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cbHint</name></expr></argument>, <argument><expr><name><name>callbackInfo</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cbAction</name> <operator>!=</operator> <name>OBTreeCallbackActionXidNoWait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>cbAction</name> <operator>==</operator> <name>OBTreeCallbackActionXidExit</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>OBTreeModifyResultFound</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>wait_for_oxid</name><argument_list>(<argument><expr><call><name>XACT_INFO_GET_OXID</name><argument_list>(<argument><expr><name>xactInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>BTREE_PAGE_FIND_SET</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pageFindContext</name></expr></argument>, <argument><expr><name>MODIFY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>refind_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pageFindContext</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BTreeKeyUniqueLowerBound</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							<argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>pageChangeCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>retry</name>;</goto>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>BTREE_PAGE_FIND_SET</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pageFindContext</name></expr></argument>, <argument><expr><name>MODIFY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>find_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pageFindContext</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BTreeKeyBound</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>o_btree_modify_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pageFindContext</name></expr></argument>, <argument><expr><name>BTreeOperationInsert</name></expr></argument>,
									 <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupleType</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
									 <argument><expr><name>keyType</name></expr></argument>, <argument><expr><name>opOxid</name></expr></argument>, <argument><expr><name>opCsn</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>,
									 <argument><expr><name>callbackInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>uniqueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>OBTreeModifyResult</name></type>
<name>o_btree_modify</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>BTreeOperationType</name></type> <name>action</name></decl></parameter>,
			   <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>tupleType</name></decl></parameter>,
			   <parameter><decl><type><name>Pointer</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>keyType</name></decl></parameter>,
			   <parameter><decl><type><name>OXid</name></type> <name>oxid</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>, <parameter><decl><type><name>RowLockMode</name></type> <name>lockMode</name></decl></parameter>,
			   <parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>BTreeModifyCallbackInfo</name> <modifier>*</modifier></type><name>callbackInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OBTreeModifyResult</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>o_btree_normal_modify</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>action</name></expr></argument>,
								   <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupleType</name></expr></argument>,
								   <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keyType</name></expr></argument>,
								   <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>,
								   <argument><expr><name>hint</name></expr></argument>, <argument><expr><name>callbackInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>o_btree_autonomous_insert</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OAutonomousTxState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeModifyResult</name></type> <name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>storageType</name></name> <operator>==</operator> <name>BTreeStoragePersistence</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>start_autonomous_transaction</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>o_btree_normal_modify</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>BTreeOperationInsert</name></expr></argument>,
										   <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>,
										   <argument><expr><call><name>get_current_oxid</name><argument_list>()</argument_list></call></expr></argument>,
										   <argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>,
										   <argument><expr><name>RowLockUpdate</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nullCallbackInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>o_wal_insert</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><call><name>abort_autonomous_transaction</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>finish_autonomous_transaction</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>o_btree_normal_modify</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>BTreeOperationInsert</name></expr></argument>,
									   <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>,
									   <argument><expr><name>InvalidOXid</name></expr></argument>,
									   <argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>,
									   <argument><expr><name>RowLockUpdate</name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nullCallbackInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><operator>(</operator><name>result</name> <operator>==</operator> <name>OBTreeModifyResultInserted</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>o_btree_autonomous_delete</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>tupleType</name></decl></parameter>,
						  <parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OAutonomousTxState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeModifyResult</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tupleType</name> <operator>==</operator> <name>BTreeKeyLeafTuple</name> <operator>||</operator> <name>tupleType</name> <operator>==</operator> <name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>storageType</name></name> <operator>==</operator> <name>BTreeStoragePersistence</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>start_autonomous_transaction</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>o_btree_normal_modify</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>BTreeOperationDelete</name></expr></argument>,
										   <argument><expr><name>key</name></expr></argument>, <argument><expr><name>tupleType</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>,
										   <argument><expr><call><name>get_current_oxid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>,
										   <argument><expr><name>RowLockUpdate</name></expr></argument>,
										   <argument><expr><name>hint</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nullCallbackInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>tupleType</name> <operator>==</operator> <name>BTreeKeyLeafTuple</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>o_wal_delete</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>tupleType</name> <operator>==</operator> <name>BTreeKeyNonLeafKey</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>o_wal_delete_key</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><call><name>abort_autonomous_transaction</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>finish_autonomous_transaction</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>o_btree_normal_modify</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>BTreeOperationDelete</name></expr></argument>,
									   <argument><expr><name>key</name></expr></argument>, <argument><expr><name>tupleType</name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>,
									   <argument><expr><name>InvalidOXid</name></expr></argument>, <argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>,
									   <argument><expr><name>RowLockUpdate</name></expr></argument>,
									   <argument><expr><name>hint</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nullCallbackInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><operator>(</operator><name>result</name> <operator>==</operator> <name>OBTreeModifyResultDeleted</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
