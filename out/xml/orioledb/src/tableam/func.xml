<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/tableam/func.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * func.c
 *		SQL functions implementation for orioledb module.
 *
 * Copyright (c) 2021-2022, Oriole DB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/tableam/func.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/btree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/check.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/iterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/page_chunks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indices.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tableam/toast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tuple/format.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/compress.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>orioledb_tbl_structure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>orioledb_idx_structure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>orioledb_tbl_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>orioledb_compression_max_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>orioledb_tbl_compression_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>orioledb_tbl_indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>orioledb_relation_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>orioledb_tbl_are_indices_equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>orioledb_table_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>log_btree</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>o_tuple_print</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>, <parameter><decl><type><name>OTupleFixedFormatSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>,
			  <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>outputFns</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tup</name></decl></parameter>,
			  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>printVersion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>atti</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>printVersion</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(%u) "</literal></expr></argument>, <argument><expr><call><name>o_tuple_get_version</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>o_fastgetattr</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>spec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>atti</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>atti</name><operator>-&gt;</operator><name>attbyval</name></name> <operator>&amp;&amp;</operator> <name><name>atti</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Pointer</name></type>		<name>p</name> <init>= <expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IS_TOAST_POINTER</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"TOASTed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"'%s'"</literal></expr></argument>,
							 <argument><expr><call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>outputFns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>idx_key_print</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TuplePrintOpaque</name> <modifier>*</modifier></type><name>opaque</name> <init>= <expr><operator>(</operator><name>TuplePrintOpaque</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>o_tuple_print</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>keyDesc</name></name></expr></argument>, <argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>keySpec</name></name></expr></argument>, <argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>keyOutputFns</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>,
				  <argument><expr><name>tup</name></expr></argument>, <argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>idx_tup_print</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TuplePrintOpaque</name> <modifier>*</modifier></type><name>opaque</name> <init>= <expr><operator>(</operator><name>TuplePrintOpaque</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>o_tuple_print</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>spec</name></name></expr></argument>, <argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>outputFns</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>,
				  <argument><expr><name>tup</name></expr></argument>, <argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>, <argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>printRowVersion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>init_print_options</name><parameter_list>(<parameter><decl><type><name>BTreePrintOptions</name> <modifier>*</modifier></type><name>printOptions</name></decl></parameter>, <parameter><decl><type><name>VarChar</name> <modifier>*</modifier></type><name>optionsArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>optionsSize</name> <init>= <expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>optionsArg</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>options</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>optionsArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* parse options argument and update options */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>optionsSize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'n'</literal></expr>:</case>
				<expr_stmt><expr><name><name>printOptions</name><operator>-&gt;</operator><name>pagePrintType</name></name> <operator>=</operator> <name>BTreePrintRelative</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'C'</literal></expr>:</case>
				<expr_stmt><expr><name><name>printOptions</name><operator>-&gt;</operator><name>csnPrintType</name></name> <operator>=</operator> <name>BTreePrintAbsolute</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'c'</literal></expr>:</case>
				<expr_stmt><expr><name><name>printOptions</name><operator>-&gt;</operator><name>csnPrintType</name></name> <operator>=</operator> <name>BTreePrintRelative</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'b'</literal></expr>:</case>
				<expr_stmt><expr><name><name>printOptions</name><operator>-&gt;</operator><name>backendIdPrintType</name></name> <operator>=</operator> <name>BTreePrintAbsolute</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'U'</literal></expr>:</case>
				<expr_stmt><expr><name><name>printOptions</name><operator>-&gt;</operator><name>undoLogLocationPrintType</name></name> <operator>=</operator> <name>BTreePrintAbsolute</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'u'</literal></expr>:</case>
				<expr_stmt><expr><name><name>printOptions</name><operator>-&gt;</operator><name>undoLogLocationPrintType</name></name> <operator>=</operator> <name>BTreePrintRelative</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'e'</literal></expr>:</case>
				<expr_stmt><expr><name><name>printOptions</name><operator>-&gt;</operator><name>idsPrintType</name></name> <operator>=</operator> <name>BTreePrintRelative</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'i'</literal></expr>:</case>
				<expr_stmt><expr><name><name>printOptions</name><operator>-&gt;</operator><name>changeCountPrintType</name></name> <operator>=</operator> <name>BTreePrintAbsolute</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'K'</literal></expr>:</case>
				<expr_stmt><expr><name><name>printOptions</name><operator>-&gt;</operator><name>checkpointNumPrintType</name></name> <operator>=</operator> <name>BTreePrintAbsolute</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'k'</literal></expr>:</case>
				<expr_stmt><expr><name><name>printOptions</name><operator>-&gt;</operator><name>checkpointNumPrintType</name></name> <operator>=</operator> <name>BTreePrintRelative</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'S'</literal></expr>:</case>
				<expr_stmt><expr><name><name>printOptions</name><operator>-&gt;</operator><name>printStateValue</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'v'</literal></expr>:</case>
				<expr_stmt><expr><name><name>printOptions</name><operator>-&gt;</operator><name>printRowVersion</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'o'</literal></expr>:</case>
				<expr_stmt><expr><name><name>printOptions</name><operator>-&gt;</operator><name>printFileOffset</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
								<operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid option '%c'"</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_unloaded_tree</name><parameter_list>(<parameter><decl><type><name>StringInfoData</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>td</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>treeName</name></decl></parameter>,
					<parameter><decl><type><name>BTreePrintOptions</name> <modifier>*</modifier></type><name>printOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prev_chkp_fname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>prev_chkp_file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CheckpointFileHeader</name></type> <name>file_header</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SeqBufTag</name></type>	<name>prev_chkp_tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EvictedTreeData</name> <modifier>*</modifier></type><name>evicted_data</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prev_chkp_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prev_chkp_tag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prev_chkp_tag</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>td</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prev_chkp_tag</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name><name>td</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prev_chkp_tag</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>td</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prev_chkp_tag</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prev_chkp_tag</name><operator>.</operator><name>type</name></name> <operator>=</operator> <literal type="char">'m'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>evicted_data</name> <operator>=</operator> <call><name>read_evicted_data</name><argument_list>(<argument><expr><name><name>td</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>,
									 <argument><expr><name><name>checkpoint_state</name><operator>-&gt;</operator><name>lastCheckpointNumber</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If found in eviction hash then use cached file_header to initialize
	 * tree
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>evicted_data</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>file_header</name> <operator>=</operator> <name><name>evicted_data</name><operator>-&gt;</operator><name>file_header</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>evicted_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>prev_chkp_fname</name> <operator>=</operator> <call><name>get_seq_buf_filename</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prev_chkp_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev_chkp_file</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>prev_chkp_fname</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>prev_chkp_file</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>OFileRead</name><argument_list>(<argument><expr><name>prev_chkp_file</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>file_header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>file_header</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_SLRU_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>prev_chkp_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>file_header</name><operator>.</operator><name>rootDownlink</name></name> <operator>=</operator> <name>InvalidDiskDownlink</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"Index %s: not loaded"</literal></expr></argument>, <argument><expr><name>treeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>printOptions</name><operator>-&gt;</operator><name>idsPrintType</name></name> <operator>==</operator> <name>BTreePrintAbsolute</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"datoid = %d, relnode = %d, "</literal></expr></argument>,
						 <argument><expr><name><name>td</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr></argument>, <argument><expr><name><name>td</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>DiskDownlinkIsValid</name><argument_list>(<argument><expr><name><name>file_header</name><operator>.</operator><name>rootDownlink</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"rootOffset = "</literal> <name>UINT64_FORMAT</name> <literal type="string">", %u"</literal></expr></argument>,
							 <argument><expr><call><name>DOWNLINK_GET_DISK_OFF</name><argument_list>(<argument><expr><name><name>file_header</name><operator>.</operator><name>rootDownlink</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>DOWNLINK_GET_DISK_LEN</name><argument_list>(<argument><expr><name><name>file_header</name><operator>.</operator><name>rootDownlink</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"rootOffset is invalid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tree_structure</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>,
			   <parameter><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>id</name></decl></parameter>,
			   <parameter><decl><type><name>BTreePrintOptions</name></type> <name>printOptions</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TuplePrintOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedRootInfoKey</name></type> <name>key</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedRootInfo</name> <modifier>*</modifier></type><name>sharedRootInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>td</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>treeName</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>opaque</name><operator>.</operator><name>desc</name></name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>leafTupdesc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>.</operator><name>spec</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>leafSpec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>.</operator><name>keyDesc</name></name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>nonLeafTupdesc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>.</operator><name>keySpec</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>nonLeafSpec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>.</operator><name>values</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>opaque</name><operator>.</operator><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>.</operator><name>nulls</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>opaque</name><operator>.</operator><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>.</operator><name>outputFns</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>opaque</name><operator>.</operator><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>.</operator><name>keyOutputFns</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>opaque</name><operator>.</operator><name>keyDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>.</operator><name>printRowVersion</name></name> <operator>=</operator> <name><name>printOptions</name><operator>.</operator><name>printRowVersion</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>opaque</name><operator>.</operator><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>output</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>varlena</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>opaque</name><operator>.</operator><name>desc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>atttypid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opaque</name><operator>.</operator><name>outputFns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>opaque</name><operator>.</operator><name>keyDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>output</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>varlena</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>opaque</name><operator>.</operator><name>keyDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>atttypid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opaque</name><operator>.</operator><name>keyOutputFns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>td</name> <operator>=</operator> <operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>desc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>treeName</name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name><name>td</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>td</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sharedRootInfo</name> <operator>=</operator> <call><name>o_find_shared_root_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>sharedRootInfo</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"Index %s contents\n"</literal></expr></argument>, <argument><expr><name>treeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>td</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>oIndexToast</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>o_print_btree_pages</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>idx_key_print</name></expr></argument>, <argument><expr><name>idx_tup_print</name></expr></argument>,
								<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>opaque</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>printOptions</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>o_print_btree_pages</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>o_toast_key_print</name></expr></argument>, <argument><expr><name>o_toast_tup_print</name></expr></argument>,
								<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>opaque</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>printOptions</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>print_unloaded_tree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>td</name></expr></argument>, <argument><expr><name>treeName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>printOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>orioledb_tbl_structure</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarChar</name>    <modifier>*</modifier></type><name>optionsArg</name> <init>= <expr><operator>(</operator><name>VarChar</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_VARCHAR_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>depth</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>treen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePrintOptions</name></type> <name>printOptions</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>orioledb_check_shmem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rel</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation oid %u does not exists"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>descr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation oid %u is not orioledb"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_print_options</name><argument_list>(<argument><expr><operator>&amp;</operator><name>printOptions</name></expr></argument>, <argument><expr><name>optionsArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* index trees + toast tree */</comment>
	<for>for <control>(<init><expr><name>treen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>treen</name> <operator>&lt;</operator> <name><name>descr</name><operator>-&gt;</operator><name>nIndices</name></name></expr>;</condition> <incr><expr><name>treen</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tree_structure</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>descr</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>treen</name></expr>]</index></name></expr></argument>, <argument><expr><name>printOptions</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>tree_structure</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>descr</name><operator>-&gt;</operator><name>toast</name></name></expr></argument>, <argument><expr><name>printOptions</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>orioledb_idx_structure</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>treeName</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarChar</name>    <modifier>*</modifier></type><name>optionsArg</name> <init>= <expr><operator>(</operator><name>VarChar</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_VARCHAR_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>depth</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>treen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePrintOptions</name></type> <name>printOptions</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>orioledb_check_shmem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>descr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation oid %u is not orioledb"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_print_options</name><argument_list>(<argument><expr><operator>&amp;</operator><name>printOptions</name></expr></argument>, <argument><expr><name>optionsArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* index trees + toast tree */</comment>
	<for>for <control>(<init><expr><name>treen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>treen</name> <operator>&lt;</operator> <name><name>descr</name><operator>-&gt;</operator><name>nIndices</name></name></expr>;</condition> <incr><expr><name>treen</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>treeName</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>treen</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>tree_structure</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>descr</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>treen</name></expr>]</index></name></expr></argument>, <argument><expr><name>printOptions</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>treeName</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>descr</name><operator>-&gt;</operator><name>toast</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tree_structure</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>descr</name><operator>-&gt;</operator><name>toast</name></name></expr></argument>, <argument><expr><name>printOptions</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>log_btree</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreePrintOptions</name></type> <name>printOptions</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>pagePrintType</name> <operator>=</operator> <name>BTreePrintAbsolute</name></expr>,
		<expr><operator>.</operator><name>csnPrintType</name> <operator>=</operator> <name>BTreePrintAbsolute</name></expr>,
		<expr><operator>.</operator><name>undoLogLocationPrintType</name> <operator>=</operator> <name>BTreePrintAbsolute</name></expr>,
		<expr><operator>.</operator><name>idsPrintType</name> <operator>=</operator> <name>BTreePrintAbsolute</name></expr>,
		<expr><operator>.</operator><name>changeCountPrintType</name> <operator>=</operator> <name>BTreePrintAbsolute</name></expr>,
		<expr><operator>.</operator><name>checkpointNumPrintType</name> <operator>=</operator> <name>BTreePrintAbsolute</name></expr>,
		<expr><operator>.</operator><name>printRowVersion</name> <operator>=</operator> <name>true</name></expr>,
		<expr><operator>.</operator><name>printStateValue</name> <operator>=</operator> <name>true</name></expr>,
		<expr><operator>.</operator><name>printFileOffset</name> <operator>=</operator> <name>true</name></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name><name>typeoids</name><index>[]</index></name> <init>= <expr><block>{<expr><name>TIDOID</name></expr>, <expr><name>TEXTOID</name></expr>, <expr><name>INT4OID</name></expr>, <expr><name>INT2OID</name></expr>, <expr><name>BYTEAOID</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name><name>outoids</name><index>[]</index></name> <init>= <expr><block>{<expr><name>F_TIDOUT</name></expr>, <expr><name>F_TEXTOUT</name></expr>, <expr><name>F_INT4OUT</name></expr>, <expr><name>F_INT2OUT</name></expr>, <expr><name>F_BYTEAOUT</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_SYS_TREE_OIDS</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>id</name> <init>= <expr><operator>(</operator><name>OIndexDescr</name> <operator>*</operator><operator>)</operator> <name><name>desc</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TuplePrintOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
					<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>opaque</name><operator>.</operator><name>desc</name></name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>leafTupdesc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opaque</name><operator>.</operator><name>spec</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>leafSpec</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opaque</name><operator>.</operator><name>keyDesc</name></name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>nonLeafTupdesc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opaque</name><operator>.</operator><name>keySpec</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>nonLeafSpec</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opaque</name><operator>.</operator><name>values</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>opaque</name><operator>.</operator><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opaque</name><operator>.</operator><name>nulls</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>opaque</name><operator>.</operator><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opaque</name><operator>.</operator><name>outputFns</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>opaque</name><operator>.</operator><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opaque</name><operator>.</operator><name>keyOutputFns</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>opaque</name><operator>.</operator><name>keyDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opaque</name><operator>.</operator><name>printRowVersion</name></name> <operator>=</operator> <name><name>printOptions</name><operator>.</operator><name>printRowVersion</name></name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>opaque</name><operator>.</operator><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>output</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>varlena</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>typeoids</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>typeoids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<if_stmt><if>if <condition>(<expr><name><name>typeoids</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name><name>opaque</name><operator>.</operator><name>desc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>atttypid</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>output</name> <operator>=</operator> <name><name>outoids</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

			<if_stmt><if>if <condition>(<expr><name>output</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>opaque</name><operator>.</operator><name>desc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>atttypid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opaque</name><operator>.</operator><name>outputFns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>opaque</name><operator>.</operator><name>keyDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>output</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>varlena</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>typeoids</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>typeoids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<if_stmt><if>if <condition>(<expr><name><name>typeoids</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name><name>opaque</name><operator>.</operator><name>keyDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>atttypid</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>output</name> <operator>=</operator> <name><name>outoids</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

			<if_stmt><if>if <condition>(<expr><name>output</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>opaque</name><operator>.</operator><name>keyDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>atttypid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opaque</name><operator>.</operator><name>keyOutputFns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>o_print_btree_pages</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>idx_key_print</name></expr></argument>, <argument><expr><name>idx_tup_print</name></expr></argument>,
							<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>opaque</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>printOptions</name></expr></argument>, <argument><expr><name>ORIOLEDB_MAX_DEPTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>num</name> <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>o_print_btree_pages</name><argument_list>(<argument><expr><call><name>get_sys_tree</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							<argument><expr><call><name>sys_tree_key_print</name><argument_list>(<argument><expr><call><name>get_sys_tree</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>sys_tree_tup_print</name><argument_list>(<argument><expr><call><name>get_sys_tree</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>printOptions</name></expr></argument>,
							<argument><expr><name>ORIOLEDB_MAX_DEPTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>table_pages_walk_page</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>,
					  <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>p</name> <init>= <expr><call><name>O_GET_IN_MEMORY_PAGE</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageHeader</name> <modifier>*</modifier></type><name>pageHdr</name> <init>= <expr><operator>(</operator><name>BTreePageHeader</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreePageItemLocator</name></type> <name>loc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><call><name>PAGE_GET_LEVEL</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OInMemoryBlknoIsValid</name><argument_list>(<argument><expr><name><name>pageHdr</name><operator>-&gt;</operator><name>rightLink</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>pageHdr</name><operator>-&gt;</operator><name>rightLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RIGHTMOST</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>jsval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>hikey</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>BTREE_PAGE_GET_HIKEY</name><argument_list>(<argument><expr><name>hikey</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>jsval</name> <operator>=</operator> <call><name>o_btree_key_to_jsonb</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>hikey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>O_PAGE_IS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LEAF</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<macro><name>BTREE_PAGE_FOREACH_ITEMS</name><argument_list>(<argument>p</argument>, <argument>&amp;loc</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreeNonLeafTuphdr</name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>BTreeNonLeafTuphdr</name> <operator>*</operator><operator>)</operator> <call><name>BTREE_PAGE_LOCATOR_GET_ITEM</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>DOWNLINK_IS_IN_MEMORY</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>table_pages_walk_page</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><call><name>DOWNLINK_GET_IN_MEMORY_BLKNO</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>orioledb_table_pages</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>randomAccess</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>treen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>

	<comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* The tupdesc and tuplestore must be created in ecxt_per_query_memory */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><literal type="string">"blkno"</literal></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><literal type="string">"level"</literal></expr></argument>, <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><literal type="string">"rightlink"</literal></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><literal type="string">"hikey"</literal></expr></argument>, <argument><expr><name>JSONBOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>randomAccess</name> <operator>=</operator> <operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Random</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>randomAccess</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><empty_stmt>;</empty_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>descr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation oid %u is not orioledb"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>treen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>treen</name> <operator>&lt;</operator> <name><name>descr</name><operator>-&gt;</operator><name>nIndices</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>treen</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>td</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SharedRootInfoKey</name></type> <name>key</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SharedRootInfo</name> <modifier>*</modifier></type><name>sharedRootInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>treen</name> <operator>&lt;</operator> <name><name>descr</name><operator>-&gt;</operator><name>nIndices</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>td</name> <operator>=</operator> <operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>treen</name></expr>]</index></name><operator>-&gt;</operator><name>desc</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>td</name> <operator>=</operator> <operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>toast</name><operator>-&gt;</operator><name>desc</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name><name>td</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>td</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>relnode</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sharedRootInfo</name> <operator>=</operator> <call><name>o_find_shared_root_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>sharedRootInfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_pages_walk_page</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name><name>td</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>orioledb_tbl_are_indices_equal</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>idx_oid1</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>idx_oid2</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>descr2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>idx1</name></decl>,
				<decl><type ref="prev"/><name>idx2</name></decl>,
				<decl><type ref="prev"/><name>tbl1</name></decl>,
				<decl><type ref="prev"/><name>tbl2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>are_equal</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>td1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>td2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeIterator</name> <modifier>*</modifier></type><name>iter1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>iter2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexNumber</name></type> <name>ix_num1</name></decl>,
				<decl><type ref="prev"/><name>ix_num2</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>orioledb_check_shmem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>idx1</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>idx_oid1</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>idx2</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>idx_oid2</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tbl1</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>idx1</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tbl2</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>idx2</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>descr1</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name>tbl1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>descr2</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name>tbl2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><empty_stmt>;</empty_stmt>

	<expr_stmt><expr><name>ix_num1</name> <operator>=</operator> <call><name>o_find_ix_num_by_name</name><argument_list>(<argument><expr><name>descr1</name></expr></argument>, <argument><expr><name><name>idx1</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ix_num2</name> <operator>=</operator> <call><name>o_find_ix_num_by_name</name><argument_list>(<argument><expr><name>descr2</name></expr></argument>, <argument><expr><name><name>idx2</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>tbl1</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>tbl2</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>idx1</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>idx2</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ix_num1</name> <operator>==</operator> <name>InvalidIndexNumber</name> <operator>||</operator> <name>ix_num2</name> <operator>==</operator> <name>InvalidIndexNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid indexes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>td1</name> <operator>=</operator> <name><name>descr1</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>ix_num1</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>td2</name> <operator>=</operator> <name><name>descr2</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>ix_num2</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>td1</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>td2</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>are_equal</name> <operator>=</operator> <name><name>td1</name><operator>-&gt;</operator><name>leafTupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator> <name><name>td2</name><operator>-&gt;</operator><name>leafTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>are_equal</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>td1</name><operator>-&gt;</operator><name>leafTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>are_equal</name> <operator>=</operator> <name><name>td1</name><operator>-&gt;</operator><name>leafTupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>atttypid</name> <operator>==</operator>
			<name><name>td2</name><operator>-&gt;</operator><name>leafTupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>atttypid</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>are_equal</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>iter1</name> <operator>=</operator> <call><name>o_btree_iterator_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>td1</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>,
										<argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>iter2</name> <operator>=</operator> <call><name>o_btree_iterator_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>td2</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>,
										<argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>are_equal</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple1</name></decl>,
						<decl><type ref="prev"/><name>tuple2</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tuple1</name> <operator>=</operator> <call><name>o_btree_iterator_fetch</name><argument_list>(<argument><expr><name>iter1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tuple2</name> <operator>=</operator> <call><name>o_btree_iterator_fetch</name><argument_list>(<argument><expr><name>iter2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BTreeKeyNone</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tuple1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tuple2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>are_equal</name> <operator>=</operator> <operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tuple1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tuple2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>o_btree_cmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>td1</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>tuple1</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>tuple2</name></expr></argument>, <argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tuple1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>tuple1</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tuple2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>tuple2</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>btree_iterator_free</name><argument_list>(<argument><expr><name>iter1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>btree_iterator_free</name><argument_list>(<argument><expr><name>iter2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>are_equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>orioledb_tbl_check</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>force_map_check</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>orioledb_check_shmem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * ExclusiveLock helps to avoid changes in map/tmp files and concurrent
	 * eviction by bgwriter
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>descr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation oid %u is not orioledb"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>descr</name><operator>-&gt;</operator><name>nIndices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>check_btree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>desc</name></expr></argument>, <argument><expr><name>force_map_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>orioledb_compression_max_level</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_lvl</name> <init>= <expr><call><name>o_compress_max_lvl</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT16</name><argument_list>(<argument><expr><name>max_lvl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>orioledb_tbl_compression_check</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTreeCompressStats</name></type> <name>stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>compression_lvl</name> <init>= <expr><call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>narray</name></decl>,
				<decl><type ref="prev"/><name>next_from</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* checks compression lvl arg */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>compression_lvl</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>compression_lvl</name></expr></argument> &gt;</argument_list></name> <call><name>o_compress_max_lvl</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Compression level must be between 0 and %d"</literal></expr></argument>, <argument><expr><call><name>o_compress_max_lvl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* checks relation arg */</comment>
	<expr_stmt><expr><call><name>orioledb_check_shmem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>descr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"orioledb relation not found."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* checks range array arg */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ranges array must be not NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>array_contains_nulls</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ranges array must not contain nulls"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>narray</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fills stats */</comment>
	<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>errors</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>oversize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>totalSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>totalCompressedSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>nranges</name></name> <operator>=</operator> <name>narray</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>ranges</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTreeCompressRange</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>stats</name><operator>.</operator><name>nranges</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fills ranges */</comment>
	<expr_stmt><expr><name>next_from</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>narray</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>values</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>values</name> <operator>&gt;=</operator> <name>ORIOLEDB_BLCKSZ</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"range value must be between %d and %d"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>values</name> <operator>&lt;=</operator> <name>next_from</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"range array must be sorted ascending"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>ranges</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>from</name> <operator>=</operator> <name>next_from</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>next_from</name> <operator>=</operator> <operator>*</operator><name>values</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>ranges</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>to</name> <operator>=</operator> <name>next_from</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>ranges</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>leaf_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>ranges</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>node_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>ranges</name><index>[<expr><name>narray</name></expr>]</index></name><operator>.</operator><name>from</name> <operator>=</operator> <name>next_from</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>ranges</name><index>[<expr><name>narray</name></expr>]</index></name><operator>.</operator><name>to</name> <operator>=</operator> <name>ORIOLEDB_BLCKSZ</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>ranges</name><index>[<expr><name>narray</name></expr>]</index></name><operator>.</operator><name>leaf_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>ranges</name><index>[<expr><name>narray</name></expr>]</index></name><operator>.</operator><name>node_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* collect stats for each BTree loop */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>descr</name><operator>-&gt;</operator><name>nIndices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>td</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>treeName</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>descr</name><operator>-&gt;</operator><name>nIndices</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>td</name> <operator>=</operator> <operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>desc</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>treeName</name> <operator>=</operator> <name><name>descr</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>name</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>td</name> <operator>=</operator> <operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>toast</name><operator>-&gt;</operator><name>desc</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>treeName</name> <operator>=</operator> <literal type="string">"toast"</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>check_btree_compression</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stats</name></expr></argument>, <argument><expr><name>compression_lvl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"Compression check for index %s\n"</literal></expr></argument>, <argument><expr><name>treeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"Errors %d, oversize %d\n"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>errors</name></name></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>oversize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"Total size = "</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>totalSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"Total compressed size = "</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>totalCompressedSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"Ratio = %lf\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>stats</name><operator>.</operator><name>totalCompressedSize</name></name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>stats</name><operator>.</operator><name>totalSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* nodes */</comment>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"\nCompressed pages size for nodes:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>stats</name><operator>.</operator><name>nranges</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"%4d - %4d = %d nodes\n"</literal></expr></argument>,
							 <argument><expr><name><name>stats</name><operator>.</operator><name>ranges</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>from</name></expr></argument>,
							 <argument><expr><name><name>stats</name><operator>.</operator><name>ranges</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>to</name></expr></argument>,
							 <argument><expr><name><name>stats</name><operator>.</operator><name>ranges</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>node_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* leafs */</comment>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"\nCompressed pages size for leafs:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>stats</name><operator>.</operator><name>nranges</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"%4d - %4d = %d leafs\n"</literal></expr></argument>,
							 <argument><expr><name><name>stats</name><operator>.</operator><name>ranges</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>from</name></expr></argument>,
							 <argument><expr><name><name>stats</name><operator>.</operator><name>ranges</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>to</name></expr></argument>,
							 <argument><expr><name><name>stats</name><operator>.</operator><name>ranges</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>leaf_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* summary */</comment>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"\nCompressed pages size summary:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>stats</name><operator>.</operator><name>nranges</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"%4d - %4d = %d pages\n"</literal></expr></argument>,
							 <argument><expr><name><name>stats</name><operator>.</operator><name>ranges</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>from</name></expr></argument>,
							 <argument><expr><name><name>stats</name><operator>.</operator><name>ranges</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>to</name></expr></argument>,
							 <argument><expr><name><name>stats</name><operator>.</operator><name>ranges</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>node_count</name> <operator>+</operator> <name><name>stats</name><operator>.</operator><name>ranges</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>leaf_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* reset stats before next BTree */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>stats</name><operator>.</operator><name>nranges</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>ranges</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>leaf_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>ranges</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>node_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>oversize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>errors</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>totalSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>totalCompressedSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>ranges</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>orioledb_tbl_indices</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>orioledb_check_shmem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>descr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"orioledb relation not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>descr</name><operator>-&gt;</operator><name>nIndices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><name><name>descr</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nonLeafSize</name> <init>= <expr><name><name>ct</name><operator>-&gt;</operator><name>nonLeafTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>leafSize</name> <init>= <expr><name><name>ct</name><operator>-&gt;</operator><name>leafTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>primary</name> <init>= <expr><name>i</name> <operator>==</operator> <name>PrimaryIndexNumber</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"Index %s\n"</literal></expr></argument>, <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    Index type: %s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>primary</name></expr> ?</condition><then> <expr><literal type="string">"primary"</literal></expr> </then><else>: <expr><literal type="string">"secondary"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>ct</name><operator>-&gt;</operator><name>unique</name></name></expr> ?</condition><then> <expr><literal type="string">", unique"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OCompressIsValid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", compression = %d"</literal></expr></argument>, <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>primary</name> <operator>&amp;&amp;</operator> <name><name>ct</name><operator>-&gt;</operator><name>primaryIsCtid</name></name></expr> ?</condition><then> <expr><literal type="string">", ctid"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>predicate</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    Predicate: %s\n"</literal></expr></argument>, <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>predicate_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    Leaf tuple size: %d, non-leaf tuple size: %d\n"</literal></expr></argument>,
						 <argument><expr><name>leafSize</name></expr></argument>, <argument><expr><name>nonLeafSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    Non-leaf tuple fields: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nonLeafSize</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>nonLeafTupdesc</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>attname</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal> <operator>!=</operator> <name>nonLeafSize</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>desc</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>oIndexPrimary</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    Leaf tuple fields: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>leafSize</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>leafTupdesc</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>attname</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal> <operator>!=</operator> <name>nonLeafSize</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>orioledb_relation_size</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>td</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>orioledb_check_shmem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><empty_stmt>;</empty_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>descr</name><operator>-&gt;</operator><name>nIndices</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>td</name> <operator>=</operator> <ternary><condition><expr><name>i</name> <operator>!=</operator> <name><name>descr</name><operator>-&gt;</operator><name>nIndices</name></name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>desc</name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>descr</name><operator>-&gt;</operator><name>toast</name><operator>-&gt;</operator><name>desc</name></name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>+=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>TREE_NUM_LEAF_PAGES</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call> <operator>*</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>ORIOLEDB_BLCKSZ</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
