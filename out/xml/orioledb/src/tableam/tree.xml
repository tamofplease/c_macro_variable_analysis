<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/tableam/tree.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * tree.c
 *		Implementation BTree interface methods for OrioleDB tables and
 *		related routines.
 *
 * Copyright (c) 2021-2022, Oriole DB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/tableam/tree.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/btree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/o_sys_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/sys_trees.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"recovery/recovery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tableam/toast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tableam/tree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tuple/toast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/stopevent.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>o_idx_hash</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>kind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>o_toast_hash</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>kind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>o_idx_unique_hash</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>o_idx_len</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>OLengthType</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>JsonbValue</name> <modifier>*</modifier></type><name>o_key_to_jsonb</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>key</name></decl></parameter>,
								  <parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier><modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>OTuple</name></type> <name>o_sidx_tuple_make_key</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tupl</name></decl></parameter>,
									<parameter><decl><type><name>Pointer</name></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>keep_version</name></decl></parameter>,
									<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>allocated</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>OTuple</name></type> <name>o_tuple_make_key</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>,
							   <parameter><decl><type><name>Pointer</name></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>keep_version</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>allocated</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>OTuple</name></type> <name>o_create_key_tuple</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>,
								 <parameter><decl><type><name>Pointer</name></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>OIndexType</name></type> <name>type</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>keep_version</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pk_needs_undo</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>BTreeOperationType</name></type> <name>action</name></decl></parameter>,
						  <parameter><decl><type><name>OTuple</name></type> <name>oldTuple</name></decl></parameter>, <parameter><decl><type><name>OTupleXactInfo</name></type> <name>oldXactInfo</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>oldDeleted</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>newTuple</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>newOxid</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>BTreeOps</name></type> <name>primaryOps</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>len</name> <operator>=</operator> <name>o_idx_len</name></expr>,
	<expr><operator>.</operator><name>key_to_jsonb</name> <operator>=</operator> <name>o_key_to_jsonb</name></expr>,
	<expr><operator>.</operator><name>tuple_make_key</name> <operator>=</operator> <name>o_tuple_make_key</name></expr>,
	<expr><operator>.</operator><name>needs_undo</name> <operator>=</operator> <name>pk_needs_undo</name></expr>,
	<expr><operator>.</operator><name>cmp</name> <operator>=</operator> <name>o_idx_cmp</name></expr>,
	<expr><operator>.</operator><name>hash</name> <operator>=</operator> <name>o_idx_hash</name></expr>,
	<expr><operator>.</operator><name>unique_hash</name> <operator>=</operator> <name>o_idx_unique_hash</name></expr>
}</block></expr></init></decl>,

			<decl><type ref="prev"/><name>secondaryOps</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>len</name> <operator>=</operator> <name>o_idx_len</name></expr>,
	<expr><operator>.</operator><name>key_to_jsonb</name> <operator>=</operator> <name>o_key_to_jsonb</name></expr>,
	<expr><operator>.</operator><name>tuple_make_key</name> <operator>=</operator> <name>o_sidx_tuple_make_key</name></expr>,
	<expr><operator>.</operator><name>needs_undo</name> <operator>=</operator> <name>NULL</name></expr>,
	<expr><operator>.</operator><name>cmp</name> <operator>=</operator> <name>o_idx_cmp</name></expr>,
	<expr><operator>.</operator><name>hash</name> <operator>=</operator> <name>o_idx_hash</name></expr>,
	<expr><operator>.</operator><name>unique_hash</name> <operator>=</operator> <name>o_idx_unique_hash</name></expr>
}</block></expr></init></decl>,

			<decl><type ref="prev"/><name>toastOps</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>len</name> <operator>=</operator> <name>o_idx_len</name></expr>,
	<expr><operator>.</operator><name>key_to_jsonb</name> <operator>=</operator> <name>o_key_to_jsonb</name></expr>,
	<expr><operator>.</operator><name>tuple_make_key</name> <operator>=</operator> <name>o_sidx_tuple_make_key</name></expr>,
	<expr><operator>.</operator><name>needs_undo</name> <operator>=</operator> <name>o_toast_needs_undo</name></expr>,
	<expr><operator>.</operator><name>cmp</name> <operator>=</operator> <name>o_toast_cmp</name></expr>,
	<expr><operator>.</operator><name>hash</name> <operator>=</operator> <name>o_toast_hash</name></expr>,
	<expr><operator>.</operator><name>unique_hash</name> <operator>=</operator> <name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>


<function><type><name>void</name></type>
<name>index_btree_desc_init</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OCompress</name></type> <name>compress</name></decl></parameter>, <parameter><decl><type><name>ORelOids</name></type> <name>oids</name></decl></parameter>,
					  <parameter><decl><type><name>OIndexType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>createOxid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>oIndexPrimary</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>ops</name></name> <operator>=</operator> <operator>&amp;</operator><name>primaryOps</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>oIndexToast</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>ops</name></name> <operator>=</operator> <operator>&amp;</operator><name>toastOps</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>ops</name></name> <operator>=</operator> <operator>&amp;</operator><name>secondaryOps</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name></name> <operator>=</operator> <name>oids</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>compress</name></name> <operator>=</operator> <name>compress</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageBlkno</name></name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>metaPageBlkno</name></name> <operator>=</operator> <name>OInvalidInMemoryBlkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>rootInfo</name><operator>.</operator><name>rootPageChangeCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>files</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>smgr</name><operator>.</operator><name>filesAllocated</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>freeBuf</name><operator>.</operator><name>file</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>file</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>nextChkp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>file</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>file</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>tmpBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>file</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>ppool</name></name> <operator>=</operator> <call><name>get_ppool</name><argument_list>(<argument><expr><name>OPagePoolMain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>storageType</name></name> <operator>=</operator> <name>BTreeStoragePersistence</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>undoType</name></name> <operator>=</operator> <name>UndoReserveTxn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>createOxid</name></name> <operator>=</operator> <name>createOxid</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>OIndexDescr</name> <modifier>*</modifier></type>
<name>o_get_tree_def</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>desc</name><operator>-&gt;</operator><name>arg</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>o_get_key_len</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>OIndexType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>keepVersion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>id</name> <init>= <expr><call><name>o_get_tree_def</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>id</name><operator>-&gt;</operator><name>nonLeafTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>type</name> <operator>==</operator> <name>oIndexPrimary</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>id</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tableAttnum</name></expr> </then><else>: <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>o_fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>id</name><operator>-&gt;</operator><name>leafTupdesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>leafSpec</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>o_new_tuple_size</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>nonLeafTupdesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>nonLeafSpec</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						   <argument><expr><ternary><condition><expr><name>keepVersion</name></expr> ?</condition><then> <expr><call><name>o_tuple_get_version</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
						   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>o_idx_len</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>OLengthType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>id</name> <init>= <expr><operator>(</operator><name>OIndexDescr</name> <operator>*</operator><operator>)</operator> <name><name>desc</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>OTupleLength</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>o_tuple_size</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>leafSpec</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>OKeyLength</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>o_tuple_size</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>nonLeafSpec</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>type</name> <operator>==</operator> <name>OTupleKeyLength</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>OTupleKeyLengthNoVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>o_get_key_len</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
							 <argument><expr><operator>(</operator><name>type</name> <operator>==</operator> <name>OTupleKeyLength</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* creates index tuple from current index tuple */</comment>
<function><type><specifier>static</specifier> <name>OTuple</name></type>
<name>o_create_key_tuple</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>data</name></decl></parameter>,
				   <parameter><decl><type><name>OIndexType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>keep_version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>id</name> <init>= <expr><call><name>o_get_tree_def</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>key</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>version</name> <init>= <expr><ternary><condition><expr><name>keep_version</name></expr> ?</condition><then> <expr><call><name>o_tuple_get_version</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>type</name> <operator>==</operator> <name>oIndexPrimary</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>oIndexRegular</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>id</name><operator>-&gt;</operator><name>nonLeafTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>type</name> <operator>==</operator> <name>oIndexPrimary</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>id</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tableAttnum</name></expr> </then><else>: <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>o_fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>id</name><operator>-&gt;</operator><name>leafTupdesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>leafSpec</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>o_new_tuple_size</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>nonLeafTupdesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>nonLeafSpec</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>version</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>o_tuple_fill</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>nonLeafTupdesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>nonLeafSpec</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>version</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_INITIAL</name></cpp:macro> <cpp:value>(0x9e3779b9)</cpp:value></cpp:define>

<comment type="block">/*
 * Useful links:
 *
 * http://burtleburtle.net/bob/hash/index.html
 * http://burtleburtle.net/bob/hash/doobs.html
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint32</name></type>
<name>hash_combine_mix</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>key</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WORDS_BIGENDIAN</name></cpp:ifdef>
			<expr_stmt><expr><name>hash</name> <operator>=</operator> <operator>(</operator><name>hash</name> <operator>&lt;&lt;</operator> <literal type="number">28</literal><operator>)</operator> <operator>^</operator> <operator>(</operator><name>hash</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>^</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name><name>key</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>hash</name> <operator>=</operator> <operator>(</operator><name>hash</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>^</operator> <operator>(</operator><name>hash</name> <operator>&gt;&gt;</operator> <literal type="number">28</literal><operator>)</operator> <operator>^</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name><name>key</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * else helps us to get the same values for a key tuple without
		 * fetching datums from the tuple, see o_hash_key()
		 */</comment>
	</block_content>}</block></for>

	<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint32</name></type>
<name>hash_final</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WORDS_BIGENDIAN</name></cpp:ifdef>
	<return>return <expr><operator>(</operator><name>hash</name> <operator>^</operator> <operator>(</operator><name>hash</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>^</operator> <operator>(</operator><name>hash</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator><operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><operator>(</operator><name>hash</name> <operator>^</operator> <operator>(</operator><name>hash</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>^</operator> <operator>(</operator><name>hash</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * It's ok with inline and hash variable declaration as:
 *
 * register uint32 hash;
 *
 * Checked with gcc -O2
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint32</name></type>
<name>hash_combine_mix_field</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>OTupleFixedFormatSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>,
					   <parameter><decl><type><name>OTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>val_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><operator>(</operator><name>tupdesc</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>attnum</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>val_ptr</name> <operator>=</operator> <call><name>o_fastgetattr_ptr</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>val_ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>hash</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine_mix</name><argument_list>(<argument><expr><name>val_ptr</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine_mix</name><argument_list>(<argument><expr><name>val_ptr</name></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>val_ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine_mix</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>val_ptr</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>val_ptr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>o_hash_key</name><parameter_list>(<parameter><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>idx</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>uint32</name></type> <name>hash</name> <init>= <expr><name>HASH_INITIAL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>data</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>o_tuple_get_data</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>idx</name><operator>-&gt;</operator><name>nonLeafSpec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine_mix</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_final</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>o_hash_key_from_tuple</name><parameter_list>(<parameter><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>idx</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>uint32</name></type> <name>hash</name> <init>= <expr><name>HASH_INITIAL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><name><name>idx</name><operator>-&gt;</operator><name>leafTupdesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTupleFixedFormatSpec</name> <modifier>*</modifier></type><name>spec</name> <init>= <expr><operator>&amp;</operator><name><name>idx</name><operator>-&gt;</operator><name>leafSpec</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>idx</name><operator>-&gt;</operator><name>nonLeafTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>idx</name><operator>-&gt;</operator><name>desc</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>oIndexPrimary</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>idx</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tableAttnum</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine_mix_field</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>spec</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_final</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>o_hash_key_from_toast_tuple</name><parameter_list>(<parameter><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>toast</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>uint32</name></type> <name>hash</name> <init>= <expr><name>HASH_INITIAL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><name><name>toast</name><operator>-&gt;</operator><name>leafTupdesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTupleFixedFormatSpec</name> <modifier>*</modifier></type><name>spec</name> <init>= <expr><operator>&amp;</operator><name><name>toast</name><operator>-&gt;</operator><name>leafSpec</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>,
				<decl><type ref="prev"/><name>natts</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>toast</name><operator>-&gt;</operator><name>nonLeafTupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>-</operator> <name>TOAST_NON_LEAF_FIELDS_NUM</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine_mix_field</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>spec</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_final</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>o_hash_key_from_toast_key</name><parameter_list>(<parameter><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>toast</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>uint32</name></type> <name>hash</name> <init>= <expr><name>HASH_INITIAL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><name><name>toast</name><operator>-&gt;</operator><name>nonLeafTupdesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTupleFixedFormatSpec</name> <modifier>*</modifier></type><name>spec</name> <init>= <expr><operator>&amp;</operator><name><name>toast</name><operator>-&gt;</operator><name>nonLeafSpec</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>,
				<decl><type ref="prev"/><name>natts</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>-</operator> <name>TOAST_NON_LEAF_FIELDS_NUM</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine_mix_field</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>spec</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_final</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>o_idx_hash</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>kind</name> <operator>==</operator> <name>BTreeKeyLeafTuple</name> <operator>||</operator> <name>kind</name> <operator>==</operator> <name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>BTreeKeyLeafTuple</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>o_hash_key_from_tuple</name><argument_list>(<argument><expr><operator>(</operator><name>OIndexDescr</name> <operator>*</operator><operator>)</operator> <name><name>desc</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>kind</name> <operator>==</operator> <name>BTreeKeyNonLeafKey</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>o_hash_key</name><argument_list>(<argument><expr><operator>(</operator><name>OIndexDescr</name> <operator>*</operator><operator>)</operator> <name><name>desc</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>o_toast_hash</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>kind</name> <operator>==</operator> <name>BTreeKeyLeafTuple</name> <operator>||</operator> <name>kind</name> <operator>==</operator> <name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>BTreeKeyLeafTuple</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>o_hash_key_from_toast_tuple</name><argument_list>(<argument><expr><operator>(</operator><name>OIndexDescr</name> <operator>*</operator><operator>)</operator> <name><name>desc</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>kind</name> <operator>==</operator> <name>BTreeKeyNonLeafKey</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>o_hash_key_from_toast_key</name><argument_list>(<argument><expr><operator>(</operator><name>OIndexDescr</name> <operator>*</operator><operator>)</operator> <name><name>desc</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Provide hash for unique index insert.  It mixes tree oids with unique
 * fields.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>o_idx_unique_hash</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>idx</name> <init>= <expr><call><name>o_get_tree_def</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>uint32</name></type> <name>hash</name> <init>= <expr><name>HASH_INITIAL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><name><name>idx</name><operator>-&gt;</operator><name>leafTupdesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTupleFixedFormatSpec</name> <modifier>*</modifier></type><name>spec</name> <init>= <expr><operator>&amp;</operator><name><name>idx</name><operator>-&gt;</operator><name>leafSpec</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>attnum</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine_mix</name><argument_list>(<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>idx</name><operator>-&gt;</operator><name>nFields</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>OIndexKeyAttnumToTupleAttnum</name><argument_list>(<argument><expr><name>BTreeKeyLeafTuple</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine_mix_field</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>spec</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_final</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* creates index tuple from table tuple for primary index */</comment>
<function><type><specifier>static</specifier> <name>OTuple</name></type>
<name>o_tuple_make_key</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>data</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>keep_version</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>allocated</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>allocated</name> <operator>=</operator> <operator>(</operator><name>data</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
	<return>return <expr><call><name>o_create_key_tuple</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>oIndexPrimary</name></expr></argument>, <argument><expr><name>keep_version</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OTuple</name></type>
<name>o_sidx_tuple_make_key</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>data</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>keep_version</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>allocated</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>allocated</name> <operator>=</operator> <operator>(</operator><name>data</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
	<return>return <expr><call><name>o_create_key_tuple</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>oIndexRegular</name></expr></argument>, <argument><expr><name>keep_version</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>o_bound_is_coercible</name><parameter_list>(<parameter><decl><type><name>OBTreeValueBound</name> <modifier>*</modifier></type><name>bound</name></decl></parameter>, <parameter><decl><type><name>OIndexField</name> <modifier>*</modifier></type><name>field</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name><name>bound</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_COERCIBLE</name><operator>)</operator> <operator>||</operator>
		<call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name><name>bound</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>field</name><operator>-&gt;</operator><name>inputtype</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* fills key bound from tuple or index tuple that belongs to current BTree */</comment>
<function><type><name>void</name></type>
<name>o_fill_key_bound</name><parameter_list>(<parameter><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>,
				 <parameter><decl><type><name>BTreeKeyType</name></type> <name>keyType</name></decl></parameter>, <parameter><decl><type><name>OBTreeKeyBound</name> <modifier>*</modifier></type><name>bound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTupleFixedFormatSpec</name> <modifier>*</modifier></type><name>spec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>keyType</name> <operator>==</operator> <name>BTreeKeyLeafTuple</name> <operator>||</operator> <name>keyType</name> <operator>==</operator> <name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>nonLeafTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>keyType</name> <operator>==</operator> <name>BTreeKeyLeafTuple</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>leafTupdesc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>spec</name> <operator>=</operator> <operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>leafSpec</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>nonLeafTupdesc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>spec</name> <operator>=</operator> <operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>nonLeafSpec</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>id</name><operator>-&gt;</operator><name>nonLeafTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>OIndexKeyAttnumToTupleAttnum</name><argument_list>(<argument><expr><name>keyType</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>o_fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>spec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>atttypid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name>O_VALUE_BOUND_PLAIN_VALUE</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>|=</operator> <name>O_VALUE_BOUND_NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>comparator</name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>comparator</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* fills secondary index key bound from primary index tuple */</comment>
<function><type><name>void</name></type>
<name>o_fill_secondary_key_bound</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>primary</name></decl></parameter>,
						   <parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>secondary</name></decl></parameter>,
						   <parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>OBTreeKeyBound</name> <modifier>*</modifier></type><name>bound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>o_get_tree_def</name><argument_list>(<argument><expr><name>primary</name></expr></argument>)</argument_list></call></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>st</name> <init>= <expr><call><name>o_get_tree_def</name><argument_list>(<argument><expr><name>secondary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>nonLeafTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>st</name><operator>-&gt;</operator><name>nonLeafTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tableAttnum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>o_fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>pt</name><operator>-&gt;</operator><name>leafTupdesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pt</name><operator>-&gt;</operator><name>leafSpec</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>leafTupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>atttypid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name>O_VALUE_BOUND_PLAIN_VALUE</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>|=</operator> <name>O_VALUE_BOUND_NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>comparator</name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>comparator</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* fills primary index key bound from tuple that belongs secondary index */</comment>
<function><type><name>void</name></type>
<name>o_fill_pindex_tuple_key_bound</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>,
							  <parameter><decl><type><name>OTuple</name></type> <name>tup</name></decl></parameter>,
							  <parameter><decl><type><name>OBTreeKeyBound</name> <modifier>*</modifier></type><name>bound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>id</name> <init>= <expr><call><name>o_get_tree_def</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pk_from</name> <init>= <expr><name><name>id</name><operator>-&gt;</operator><name>nFields</name></name> <operator>-</operator> <name><name>id</name><operator>-&gt;</operator><name>nPrimaryFields</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>nPrimaryFields</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>id</name><operator>-&gt;</operator><name>nPrimaryFields</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name> <init>= <expr><name><name>id</name><operator>-&gt;</operator><name>primaryFieldsAttnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>o_fastgetattr</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>id</name><operator>-&gt;</operator><name>leafTupdesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>leafSpec</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>leafTupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>pk_from</name> <operator>+</operator> <name>i</name></expr>]</index></name><operator>.</operator><name>atttypid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name>O_VALUE_BOUND_PLAIN_VALUE</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>|=</operator> <name>O_VALUE_BOUND_NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>comparator</name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name>pk_from</name> <operator>+</operator> <name>i</name></expr>]</index></name><operator>.</operator><name>comparator</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_inclusive</name><parameter_list>(<parameter><decl><type><name>uint8</name></type> <name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <name>O_VALUE_BOUND_LOWER</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <name>O_VALUE_BOUND_INCLUSIVE</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <name>O_VALUE_BOUND_UPPER</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <name>O_VALUE_BOUND_INCLUSIVE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_inclusive2</name><parameter_list>(<parameter><decl><type><name>uint8</name></type> <name>f1</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>f2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp1</name> <init>= <expr><call><name>cmp_inclusive</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>cmp2</name> <init>= <expr><call><name>cmp_inclusive</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>cmp1</name> <operator>-</operator> <name>cmp2</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>o_idx_cmp_range_key_to_value</name><parameter_list>(<parameter><decl><type><name>OBTreeValueBound</name> <modifier>*</modifier></type><name>bound1</name></decl></parameter>, <parameter><decl><type><name>OIndexField</name> <modifier>*</modifier></type><name>field</name></decl></parameter>,
							 <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_UNBOUNDED</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_COERCIBLE</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>bound1</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>value</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cmp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>o_bound_is_coercible</name><argument_list>(<argument><expr><name>bound1</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_call_comparator</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>comparator</name></name></expr></argument>, <argument><expr><name><name>bound1</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_call_comparator</name><argument_list>(<argument><expr><name><name>bound1</name><operator>-&gt;</operator><name>comparator</name></name></expr></argument>, <argument><expr><name><name>bound1</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>field</name><operator>-&gt;</operator><name>ascending</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cmp</name> <operator>=</operator> <operator>-</operator><name>cmp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_INCLUSIVE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>cmp_inclusive</name><argument_list>(<argument><expr><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>cmp</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_NULL</name><operator>)</operator> <operator>||</operator> <name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_INCLUSIVE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>cmp_inclusive</name><argument_list>(<argument><expr><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><ternary><condition><expr><name><name>field</name><operator>-&gt;</operator><name>nullfirst</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>o_idx_cmp_tuples</name><parameter_list>(<parameter><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>id</name></decl></parameter>,
				 <parameter><decl><type><name>OTuple</name> <modifier>*</modifier></type><name>tuple1</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>keyType1</name></decl></parameter>,
				 <parameter><decl><type><name>OTuple</name> <modifier>*</modifier></type><name>tuple2</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>keyType2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc1</name></decl>,
				<decl><type ref="prev"/><name>tupdesc2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTupleFixedFormatSpec</name> <modifier>*</modifier></type><name>spec1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>spec2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>n</name></decl>,
				<decl><type ref="prev"/><name>attnum1</name></decl>,
				<decl><type ref="prev"/><name>attnum2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>value1</name></decl>,
				<decl><type ref="prev"/><name>value2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull1</name></decl>,
				<decl><type ref="prev"/><name>isnull2</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>keyType1</name> <operator>==</operator> <name>BTreeKeyLeafTuple</name> <operator>||</operator> <name>keyType1</name> <operator>==</operator> <name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>keyType1</name> <operator>==</operator> <name>BTreeKeyLeafTuple</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tupdesc1</name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>leafTupdesc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>spec1</name> <operator>=</operator> <operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>leafSpec</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>tupdesc1</name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>nonLeafTupdesc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>spec1</name> <operator>=</operator> <operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>nonLeafSpec</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>keyType2</name> <operator>==</operator> <name>BTreeKeyLeafTuple</name> <operator>||</operator> <name>keyType2</name> <operator>==</operator> <name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>keyType2</name> <operator>==</operator> <name>BTreeKeyLeafTuple</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tupdesc2</name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>leafTupdesc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>spec2</name> <operator>=</operator> <operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>leafSpec</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>tupdesc2</name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>nonLeafTupdesc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>spec2</name> <operator>=</operator> <operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>nonLeafSpec</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>nonLeafTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OIndexField</name> <modifier>*</modifier></type><name>field</name> <init>= <expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>attnum1</name> <operator>=</operator> <call><name>OIndexKeyAttnumToTupleAttnum</name><argument_list>(<argument><expr><name>keyType1</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>value1</name> <operator>=</operator> <call><name>o_fastgetattr</name><argument_list>(<argument><expr><operator>*</operator><name>tuple1</name></expr></argument>, <argument><expr><name>attnum1</name></expr></argument>, <argument><expr><name>tupdesc1</name></expr></argument>, <argument><expr><name>spec1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attnum2</name> <operator>=</operator> <call><name>OIndexKeyAttnumToTupleAttnum</name><argument_list>(<argument><expr><name>keyType2</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>value2</name> <operator>=</operator> <call><name>o_fastgetattr</name><argument_list>(<argument><expr><operator>*</operator><name>tuple2</name></expr></argument>, <argument><expr><name>attnum2</name></expr></argument>, <argument><expr><name>tupdesc2</name></expr></argument>, <argument><expr><name>spec2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull1</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isnull2</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_call_comparator</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>comparator</name></name></expr></argument>, <argument><expr><name>value1</name></expr></argument>, <argument><expr><name>value2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>field</name><operator>-&gt;</operator><name>ascending</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cmp</name> <operator>=</operator> <operator>-</operator><name>cmp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>isnull1</name> <operator>&amp;&amp;</operator> <name>isnull2</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cmp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>isnull1</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cmp</name> <operator>=</operator> <ternary><condition><expr><name><name>field</name><operator>-&gt;</operator><name>nullfirst</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>isnull2</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cmp</name> <operator>=</operator> <ternary><condition><expr><name><name>field</name><operator>-&gt;</operator><name>nullfirst</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>cmp</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>o_idx_cmp_key_bound_to_tuple</name><parameter_list>(<parameter><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>id</name></decl></parameter>,
							 <parameter><decl><type><name>OBTreeKeyBound</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>keyType1</name></decl></parameter>,
							 <parameter><decl><type><name>OTuple</name> <modifier>*</modifier></type><name>tuple2</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>keyType2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTupleFixedFormatSpec</name> <modifier>*</modifier></type><name>spec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>n</name></decl>,
				<decl><type ref="prev"/><name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>keyType2</name> <operator>==</operator> <name>BTreeKeyLeafTuple</name> <operator>||</operator> <name>keyType2</name> <operator>==</operator> <name>BTreeKeyNonLeafKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>keyType2</name> <operator>==</operator> <name>BTreeKeyLeafTuple</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>leafTupdesc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>spec</name> <operator>=</operator> <operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>leafSpec</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>nonLeafTupdesc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>spec</name> <operator>=</operator> <operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>nonLeafSpec</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>keyType1</name> <operator>==</operator> <name>BTreeKeyBound</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>nonLeafTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>nUniqueFields</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint8</name></type>		<name>flags</name> <init>= <expr><name><name>key1</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>O_VALUE_BOUND_UNBOUNDED</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>O_VALUE_BOUND_LOWER</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>OIndexKeyAttnumToTupleAttnum</name><argument_list>(<argument><expr><name>keyType2</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>o_fastgetattr</name><argument_list>(<argument><expr><operator>*</operator><name>tuple2</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>spec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_idx_cmp_range_key_to_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key1</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										   <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>cmp</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>keyType1</name> <operator>==</operator> <name>BTreeKeyUniqueLowerBound</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>keyType1</name> <operator>==</operator> <name>BTreeKeyUniqueUpperBound</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>o_idx_cmp_value_bounds</name><parameter_list>(<parameter><decl><type><name>OBTreeValueBound</name> <modifier>*</modifier></type><name>bound1</name></decl></parameter>,
					   <parameter><decl><type><name>OBTreeValueBound</name> <modifier>*</modifier></type><name>bound2</name></decl></parameter>,
					   <parameter><decl><type><name>OIndexField</name> <modifier>*</modifier></type><name>field</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>equal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Keep clang analyzer quiet */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__clang_analyzer__</name></cpp:ifndef>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>equal</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>equal</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_NO_VALUE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>bound2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_NO_VALUE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Handle normal values */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name><name>bound2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_COERCIBLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<name><name>bound1</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name><name>bound2</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>coercible1</name> <init>= <expr><call><name>o_bound_is_coercible</name><argument_list>(<argument><expr><name>bound1</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>coercible2</name> <init>= <expr><call><name>o_bound_is_coercible</name><argument_list>(<argument><expr><name>bound2</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>coercible1</name> <operator>&amp;&amp;</operator> <name>coercible2</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>o_call_comparator</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>comparator</name></name></expr></argument>, <argument><expr><name><name>bound1</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,
										<argument><expr><name><name>bound2</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>coercible1</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>-</operator><call><name>o_call_comparator</name><argument_list>(<argument><expr><name><name>bound2</name><operator>-&gt;</operator><name>comparator</name></name></expr></argument>, <argument><expr><name><name>bound2</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,
										 <argument><expr><name><name>bound1</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>coercible2</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>o_call_comparator</name><argument_list>(<argument><expr><name><name>bound1</name><operator>-&gt;</operator><name>comparator</name></name></expr></argument>, <argument><expr><name><name>bound1</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,
										<argument><expr><name><name>bound2</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>o_call_comparator</name><argument_list>(<argument><expr><call><name>o_find_comparator</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>opfamily</name></name></expr></argument>,
														  <argument><expr><name><name>bound1</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
														  <argument><expr><name><name>bound2</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
														  <argument><expr><name><name>field</name><operator>-&gt;</operator><name>collation</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name><name>bound1</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,
										<argument><expr><name><name>bound2</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>field</name><operator>-&gt;</operator><name>ascending</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>-</operator><name>res</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>cmp_inclusive2</name><argument_list>(<argument><expr><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>bound2</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>equal</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_INCLUSIVE</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>bound2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_INCLUSIVE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>equal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_UNBOUNDED</name><operator>)</operator> <operator>||</operator>
			 <operator>(</operator><name><name>bound2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_UNBOUNDED</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Handle infinities */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_UNBOUNDED</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>bound2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_UNBOUNDED</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_DIRECTIONS</name><operator>)</operator> <operator>==</operator>
				<operator>(</operator><name><name>bound2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_DIRECTIONS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_LOWER</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_UNBOUNDED</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_LOWER</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>bound2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_LOWER</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></else></if_stmt>

	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_NULL</name><operator>)</operator> <operator>||</operator>
			 <operator>(</operator><name><name>bound2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_NULL</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Handle nulls */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_NULL</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>bound2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>cmp_inclusive2</name><argument_list>(<argument><expr><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>bound2</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>bound1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>O_VALUE_BOUND_NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><name><name>field</name><operator>-&gt;</operator><name>nullfirst</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><name><name>field</name><operator>-&gt;</operator><name>nullfirst</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>o_idx_cmp</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>,
		  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>keyType1</name></decl></parameter>,
		  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>, <parameter><decl><type><name>BTreeKeyType</name></type> <name>keyType2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Keep clang analyzer quiet */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__clang_analyzer__</name></cpp:ifndef>
	<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>id</name> <init>= <expr><call><name>o_get_tree_def</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeKeyBound</name> <modifier>*</modifier></type><name>key1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>key2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>o_sys_cache_search_datoid</name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>oids</name><operator>.</operator><name>datoid</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_BOUND_KEY_TYPE</name><argument_list>(<argument><expr><name>keyType1</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>IS_BOUND_KEY_TYPE</name><argument_list>(<argument><expr><name>keyType2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IS_BOUND_KEY_TYPE</name><argument_list>(<argument><expr><name>keyType1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>o_idx_cmp_key_bound_to_tuple</name><argument_list>(<argument><expr><name>id</name></expr></argument>,
												<argument><expr><operator>(</operator><name>OBTreeKeyBound</name> <operator>*</operator><operator>)</operator> <name>p1</name></expr></argument>,
												<argument><expr><name>keyType1</name></expr></argument>,
												<argument><expr><operator>(</operator><name>OTuple</name> <operator>*</operator><operator>)</operator> <name>p2</name></expr></argument>,
												<argument><expr><name>keyType2</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IS_BOUND_KEY_TYPE</name><argument_list>(<argument><expr><name>keyType2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><call><name>o_idx_cmp_key_bound_to_tuple</name><argument_list>(<argument><expr><name>id</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>OBTreeKeyBound</name> <operator>*</operator><operator>)</operator> <name>p2</name></expr></argument>,
												 <argument><expr><name>keyType2</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>OTuple</name> <operator>*</operator><operator>)</operator> <name>p1</name></expr></argument>,
												 <argument><expr><name>keyType1</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><call><name>o_idx_cmp_tuples</name><argument_list>(<argument><expr><name>id</name></expr></argument>,
								<argument><expr><operator>(</operator><name>OTuple</name> <operator>*</operator><operator>)</operator> <name>p1</name></expr></argument>,
								<argument><expr><name>keyType1</name></expr></argument>,
								<argument><expr><operator>(</operator><name>OTuple</name> <operator>*</operator><operator>)</operator> <name>p2</name></expr></argument>,
								<argument><expr><name>keyType2</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>key1</name> <operator>=</operator> <operator>(</operator><name>OBTreeKeyBound</name> <operator>*</operator><operator>)</operator> <name>p1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>key2</name> <operator>=</operator> <operator>(</operator><name>OBTreeKeyBound</name> <operator>*</operator><operator>)</operator> <name>p2</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key1</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>==</operator> <name><name>id</name><operator>-&gt;</operator><name>nonLeafTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key2</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>==</operator> <name><name>id</name><operator>-&gt;</operator><name>nonLeafTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>keyType1</name> <operator>!=</operator> <name>BTreeKeyBound</name> <operator>||</operator> <name>keyType2</name> <operator>!=</operator> <name>BTreeKeyBound</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>nUniqueFields</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>key1</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>o_idx_cmp_value_bounds</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key1</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>key2</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmp</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>cmp</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>keyType1</name> <operator>!=</operator> <name>keyType2</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>keyType1</name> <operator>==</operator> <name>BTreeKeyUniqueLowerBound</name> <operator>||</operator> <name>keyType2</name> <operator>==</operator> <name>BTreeKeyUniqueUpperBound</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>keyType1</name> <operator>==</operator> <name>BTreeKeyUniqueUpperBound</name> <operator>||</operator> <name>keyType2</name> <operator>==</operator> <name>BTreeKeyUniqueLowerBound</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pk_needs_undo</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>BTreeOperationType</name></type> <name>action</name></decl></parameter>,
			  <parameter><decl><type><name>OTuple</name></type> <name>oldTuple</name></decl></parameter>, <parameter><decl><type><name>OTupleXactInfo</name></type> <name>oldXactInfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>oldDeleted</name></decl></parameter>,
			  <parameter><decl><type><name>OTuple</name></type> <name>newTuple</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>newOxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BTreeOperationDelete</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XACT_INFO_OXID_EQ</name><argument_list>(<argument><expr><name>oldXactInfo</name></expr></argument>, <argument><expr><name>newOxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldDeleted</name> <operator>&amp;&amp;</operator> <call><name>o_tuple_get_version</name><argument_list>(<argument><expr><name>oldTuple</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <call><name>o_tuple_get_version</name><argument_list>(<argument><expr><name>newTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>newTuple</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_recovery_process</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>o_tuple_get_version</name><argument_list>(<argument><expr><name>oldTuple</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>o_tuple_get_version</name><argument_list>(<argument><expr><name>newTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>o_key_to_jsonb_internal</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>, <parameter><decl><type><name>OTupleFixedFormatSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier><modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>jval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemPointer</name></type> <name>iptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>jsonb_push_key</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>attname</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>o_fastgetattr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>spec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>jval</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>jbvNull</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_VALUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<switch>switch <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>TEXTOID</name></expr>:</case>
				<expr_stmt><expr><name><name>jval</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>jbvString</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>jval</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>jval</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_VALUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>TIDOID</name></expr>:</case>
				<expr_stmt><expr><name>iptr</name> <operator>=</operator> <call><name>DatumGetItemPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumberNoCheck</name><argument_list>(<argument><expr><name>iptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumberNoCheck</name><argument_list>(<argument><expr><name>iptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>jval</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>jbvNumeric</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_BEGIN_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>jval</name><operator>.</operator><name>val</name><operator>.</operator><name>numeric</name></name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>blkno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_ELEM</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>jval</name><operator>.</operator><name>val</name><operator>.</operator><name>numeric</name></name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_ELEM</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_END_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>INT2OID</name></expr>:</case>
				<expr_stmt><expr><name><name>jval</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>jbvNumeric</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>jval</name><operator>.</operator><name>val</name><operator>.</operator><name>numeric</name></name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int2_numeric</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_VALUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>INT4OID</name></expr>:</case>
				<expr_stmt><expr><name><name>jval</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>jbvNumeric</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>jval</name><operator>.</operator><name>val</name><operator>.</operator><name>numeric</name></name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int4_numeric</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_VALUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>INT8OID</name></expr>:</case>
				<expr_stmt><expr><name><name>jval</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>jbvNumeric</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>jval</name><operator>.</operator><name>val</name><operator>.</operator><name>numeric</name></name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_VALUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>FLOAT4OID</name></expr>:</case>
				<expr_stmt><expr><name><name>jval</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>jbvNumeric</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>jval</name><operator>.</operator><name>val</name><operator>.</operator><name>numeric</name></name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>float4_numeric</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_VALUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>FLOAT8OID</name></expr>:</case>
				<expr_stmt><expr><name><name>jval</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>jbvNumeric</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>jval</name><operator>.</operator><name>val</name><operator>.</operator><name>numeric</name></name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>float8_numeric</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_VALUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><name><name>jval</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>jbvNull</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_VALUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>JsonbValue</name> <modifier>*</modifier></type>
<name>o_key_to_jsonb</name><parameter_list>(<parameter><decl><type><name>BTreeDescr</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>OTuple</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier><modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>id</name> <init>= <expr><call><name>o_get_tree_def</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_BEGIN_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>o_key_to_jsonb_internal</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>nonLeafTupdesc</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>nonLeafSpec</name></name></expr></argument>,
							<argument><expr><name><name>id</name><operator>-&gt;</operator><name>nonLeafTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
							<argument><expr><name>key</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
