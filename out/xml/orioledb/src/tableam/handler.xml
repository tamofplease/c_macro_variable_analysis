<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/orioledb/src/tableam/handler.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * handler.c
 *		Implementation of table access method handler
 *
 * Copyright (c) 2021-2022, Oriole DB Inc.
 *
 * IDENTIFICATION
 *	  contrib/orioledb/src/tableam/handler.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orioledb.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/btree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/iterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/scan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indices.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/o_indices.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/o_tables.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/o_sys_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tableam/descr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tableam/handler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tableam/operations.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tableam/tree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transam/oxid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tuple/slot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/stopevent.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/progress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/plancat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/backend_progress.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sampling.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <name>OScanDescData</name>
<block>{
	<decl_stmt><decl><type><name>TableScanDescData</name></type> <name>rs_base</name></decl>;</decl_stmt>	<comment type="block">/* AM independent part of the descriptor */</comment>
	<decl_stmt><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>iptr</name></decl>;</decl_stmt>
}</block></struct></type> <name>OScanDescData</name>;</typedef>
<typedef>typedef <type><name>OScanDescData</name> <modifier>*</modifier></type><name>OScanDesc</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>conflictIxOid</name></decl>;</decl_stmt>
}</block></struct></type> <name>OFDWState</name>;</typedef>

<comment type="block">/*
 * Operation with indices. It does not update TOAST BTree. Implementations
 * are in tableam_handler.c.
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_keys_from_rowid</name><parameter_list>(<parameter><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>pkDatum</name></decl></parameter>, <parameter><decl><type><name>OBTreeKeyBound</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
								<parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name> <modifier>*</modifier></type><name>csn</name></decl></parameter>,
								<parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>version</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ------------------------------------------------------------------------
 * Slot related callbacks for heap AM
 * ------------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type>
<name>orioledb_slot_callbacks</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* TODO: Create own TupleTableSlotOps */</comment>
	<return>return <expr><operator>&amp;</operator><name>TTSOpsOrioleDB</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------------------
 * Index Scan Callbacks for heap AM
 * ------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Returns NULL to prevent index scan from inside of standard_planner
 * for greater and lower where clauses.
 */</comment>
<function><type><specifier>static</specifier> <name>IndexFetchTableData</name> <modifier>*</modifier></type>
<name>orioledb_index_fetch_begin</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_index_fetch_reset</name><parameter_list>(<parameter><decl><type><name>IndexFetchTableData</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented: %s"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_index_fetch_end</name><parameter_list>(<parameter><decl><type><name>IndexFetchTableData</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented: %s"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>orioledb_index_fetch_tuple</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>IndexFetchTableData</name></name> <modifier>*</modifier></type><name>scan</name></decl></parameter>,
						   <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>,
						   <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
						   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>call_again</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>all_dead</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented: %s"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ------------------------------------------------------------------------
 * Callbacks for non-modifying operations on individual tuples for heap AM
 * ------------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>orioledb_tableam_fetch_row_version</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
								   <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>,
								   <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
								   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented: %s"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleFetchCallbackResult</name></type>
<name>fetch_row_version_callback</name><parameter_list>(<parameter><decl><type><name>OTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>OXid</name></type> <name>tupOxid</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl></parameter>,
						   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>TupleFetchCallbackCheckType</name></type> <name>check_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>version</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>check_type</name> <operator>!=</operator> <name>OTupleFetchCallbackVersionCheck</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>OTupleFetchNext</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>COMMITSEQNO_IS_INPROGRESS</name><argument_list>(<argument><expr><name>csn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>tupOxid</name> <operator>==</operator> <call><name>get_current_oxid_if_any</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>OTupleFetchNext</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>o_tuple_get_version</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>version</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>OTupleFetchMatch</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>OTupleFetchNext</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Fetches last committed row version for given tupleid.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>orioledb_fetch_row_version</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
						   <parameter><decl><type><name>Datum</name></type> <name>tupleid</name></decl></parameter>,
						   <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
						   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OBTreeKeyBound</name></type> <name>pkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeLocationHint</name></type> <name>hint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>tupleCsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>version</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>deleted</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>descr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>primaryIsCtid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>get_keys_from_rowid</name><argument_list>(<argument><expr><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pkey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>csn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>o_btree_find_tuple_by_key_cb</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>desc</name></expr></argument>,
										 <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>pkey</name></expr></argument>,
										 <argument><expr><name>BTreeKeyBound</name></expr></argument>,
										 <argument><expr><name>csn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupleCsn</name></expr></argument>,
										 <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>deleted</name></expr></argument>,
										 <argument><expr><name>fetch_row_version_callback</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>deleted</name> <operator>&amp;&amp;</operator> <call><name>COMMITSEQNO_IS_INPROGRESS</name><argument_list>(<argument><expr><name>tupleCsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>tts_orioledb_store_tuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>, <argument><expr><name>tupleCsn</name></expr></argument>,
							 <argument><expr><name>PrimaryIndexNumber</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Refetches row version in given slot.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>orioledb_refetch_row_version</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OBTreeKeyBound</name></type> <name>pkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>tupleCsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeLocationHint</name></type> <name>hint</name> <init>= <expr><block>{<expr><name>OInvalidInMemoryBlkno</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>descr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>primaryIsCtid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>tts_orioledb_fill_key_bound</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>pkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>o_btree_find_tuple_by_key</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>desc</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <operator>&amp;</operator><name>pkey</name></expr></argument>,
									  <argument><expr><name>BTreeKeyBound</name></expr></argument>,
									  <argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupleCsn</name></expr></argument>,
									  <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>tts_orioledb_store_tuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>, <argument><expr><name>tupleCsn</name></expr></argument>,
							 <argument><expr><name>PrimaryIndexNumber</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>orioledb_tuple_tid_valid</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented: %s"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>orioledb_tuple_satisfies_snapshot</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
								  <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------------------
 *  Functions for manipulations of physical tuples for heap AM.
 * ----------------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>RowRefType</name></type>
<name>orioledb_get_row_ref_type</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>descr</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * It happens during relation creation.  Should be safe to assume
		 * we've TID identifiers at this point.
		 */</comment>
		<return>return <expr><name>ROW_REF_TID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Always use rowid identifieds.  If even we use ctid as primary key, we
	 * still prepend it with page location hint.
	 */</comment>
	<return>return <expr><name>ROW_REF_ROWID</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_tuple_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
					  <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fill_current_oxid_csn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oxid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>o_tbl_insert</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_tableam_tuple_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
							  <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>,
							  <parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented: %s"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_tuple_insert_speculative</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
								  <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>,
								  <parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>specToken</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented: %s"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_tuple_complete_speculative</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
									<parameter><decl><type><name>uint32</name></type> <name>specToken</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>succeeded</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented: %s"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TM_Result</name></type>
<name>orioledb_tableam_tuple_delete</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>,
							  <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>crosscheck</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>,
							  <parameter><decl><type><name>TM_FailureData</name> <modifier>*</modifier></type><name>tmfd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>changingPart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented: %s"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>TM_Ok</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OIndexNumber</name></type>
<name>get_ix_num_by_oid</name><parameter_list>(<parameter><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ixOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OIndexNumber</name></type> <name>ixNum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>ixOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidIndexNumber</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>ixNum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ixNum</name> <operator>&lt;</operator> <name><name>descr</name><operator>-&gt;</operator><name>nIndices</name></name></expr>;</condition> <incr><expr><name>ixNum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>descr</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>ixNum</name></expr>]</index></name><operator>-&gt;</operator><name><name>oids</name><operator>.</operator><name>reloid</name></name> <operator>==</operator> <name>ixOid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>ixNum</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>InvalidIndexNumber</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>orioledb_tuple_insert_on_conflict</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mstate</name></decl></parameter>,
								  <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
								  <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>,
								  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>rinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OnConflictAction</name></type> <name>on_conflict</name> <init>= <expr><operator>(</operator><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>mstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>onConflictAction</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OFDWState</name>  <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>OFDWState</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>ri_FdwState</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>o_check_constraints</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>id</name><operator>-&gt;</operator><name>primaryIsCtid</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name> <operator>=</operator> <call><name>btree_ctid_get_and_inc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>tts_orioledb_toast</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>tts_orioledb_form_tuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>o_btree_check_size_of_tuple</name><argument_list>(<argument><expr><call><name>o_tuple_size</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>leafSpec</name></name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>o_tbl_insert_on_conflict</name><argument_list>(<argument><expr><name>mstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>,
									<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
									<argument><expr><name>on_conflict</name></expr></argument>,
									<argument><expr><call><name>get_ix_num_by_oid</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>conflictIxOid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TM_Result</name></type>
<name>orioledb_tuple_delete</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mstate</name></decl></parameter>,
					  <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>,
					  <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					  <parameter><decl><type><name>Datum</name></type> <name>tupleid</name></decl></parameter>,
					  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>returningSlot</name></decl></parameter>,
					  <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>,
					  <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>crosscheck</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>,
					  <parameter><decl><type><name>TM_FailureData</name> <modifier>*</modifier></type><name>tmfd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>changingPart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OModifyCallbackArg</name></type> <name>marg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTableModifyResult</name></type> <name>mres</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeKeyBound</name></type> <name>pkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeLocationHint</name></type> <name>hint</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>descr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>primaryIsCtid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oxid</name> <operator>=</operator> <call><name>get_current_oxid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>marg</name><operator>.</operator><name>descr</name></name> <operator>=</operator> <name>descr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>marg</name><operator>.</operator><name>oxid</name></name> <operator>=</operator> <name>oxid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>marg</name><operator>.</operator><name>csn</name></name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>snapshotcsn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>marg</name><operator>.</operator><name>rinfo</name></name> <operator>=</operator> <name>rinfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>marg</name><operator>.</operator><name>epqstate</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>mstate</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>marg</name><operator>.</operator><name>scanSlot</name></name> <operator>=</operator> <ternary><condition><expr><name>returningSlot</name></expr> ?</condition><then> <expr><name>returningSlot</name></expr> </then><else>: <expr><name><name>descr</name><operator>-&gt;</operator><name>oldTuple</name></name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>marg</name><operator>.</operator><name>rowLockMode</name></name> <operator>=</operator> <name>RowLockUpdate</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>get_keys_from_rowid</name><argument_list>(<argument><expr><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pkey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>mres</name> <operator>=</operator> <call><name>o_tbl_delete</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pkey</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>snapshotcsn</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>marg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>mres</name><operator>.</operator><name>success</name></name> <operator>&amp;&amp;</operator> <name><name>mres</name><operator>.</operator><name>action</name></name> <operator>==</operator> <name>BTreeOperationLock</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>epqslot</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>epqslot</name> <operator>=</operator> <call><name>EvalPlanQualNext</name><argument_list>(<argument><expr><name><name>marg</name><operator>.</operator><name>epqstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>epqslot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* Tuple not passing quals anymore, exiting... */</comment>
			<return>return <expr><name>TM_Deleted</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>tts_orioledb_fill_key_bound</name><argument_list>(<argument><expr><name><name>mres</name><operator>.</operator><name>oldTuple</name></name></expr></argument>, <argument><expr><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>pkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>mres</name> <operator>=</operator> <call><name>o_tbl_delete</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pkey</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name><name>marg</name><operator>.</operator><name>csn</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>marg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mres</name><operator>.</operator><name>action</name></name> <operator>!=</operator> <name>BTreeOperationLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* ExecClearTuple(mres.oldTuple); */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>o_check_tbl_delete_mres</name><argument_list>(<argument><expr><name>mres</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>mres</name><operator>.</operator><name>self_modified</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>cmax</name></name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>cmax</name></name> <operator>=</operator> <name>InvalidCommandId</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>mres</name><operator>.</operator><name>success</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mres</name><operator>.</operator><name>oldTuple</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>returningSlot</name> <operator>&amp;&amp;</operator> <name><name>mres</name><operator>.</operator><name>oldTuple</name></name> <operator>!=</operator> <name>returningSlot</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name>returningSlot</name></expr></argument>, <argument><expr><name><name>mres</name><operator>.</operator><name>oldTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><ternary><condition><expr><name><name>mres</name><operator>.</operator><name>self_modified</name></name></expr> ?</condition><then> <expr><name>TM_SelfModified</name></expr> </then><else>: <expr><name>TM_Ok</name></expr></else></ternary></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><ternary><condition><expr><name><name>mres</name><operator>.</operator><name>self_modified</name></name></expr> ?</condition><then> <expr><name>TM_SelfModified</name></expr> </then><else>: <expr><name>TM_Deleted</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TM_Result</name></type>
<name>orioledb_tableam_tuple_update</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>otid</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
							  <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>crosscheck</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>, <parameter><decl><type><name>TM_FailureData</name> <modifier>*</modifier></type><name>tmfd</name></decl></parameter>,
							  <parameter><decl><type><name>LockTupleMode</name> <modifier>*</modifier></type><name>lockmode</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>update_indexes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented: %s"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>TM_Ok</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TM_Result</name></type>
<name>orioledb_tuple_update</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mstate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>,
					  <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					  <parameter><decl><type><name>Datum</name></type> <name>tupleid</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
					  <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>crosscheck</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>, <parameter><decl><type><name>TM_FailureData</name> <modifier>*</modifier></type><name>tmfd</name></decl></parameter>,
					  <parameter><decl><type><name>LockTupleMode</name> <modifier>*</modifier></type><name>lockmode</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>update_indexes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTableModifyResult</name></type> <name>mres</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OModifyCallbackArg</name></type> <name>marg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>updatedAttrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>keyAttrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeKeyBound</name></type> <name>old_pkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeLocationHint</name></type> <name>hint</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>descr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>primaryIsCtid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>o_check_constraints</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>mstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>update_indexes</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oxid</name> <operator>=</operator> <call><name>get_current_oxid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>get_keys_from_rowid</name><argument_list>(<argument><expr><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_pkey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>,
						<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>marg</name><operator>.</operator><name>descr</name></name> <operator>=</operator> <name>descr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>marg</name><operator>.</operator><name>oxid</name></name> <operator>=</operator> <name>oxid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>marg</name><operator>.</operator><name>csn</name></name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>snapshotcsn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>marg</name><operator>.</operator><name>rinfo</name></name> <operator>=</operator> <name>rinfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>marg</name><operator>.</operator><name>epqstate</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>mstate</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>marg</name><operator>.</operator><name>scanSlot</name></name> <operator>=</operator> <name><name>descr</name><operator>-&gt;</operator><name>oldTuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>marg</name><operator>.</operator><name>newSlot</name></name> <operator>=</operator> <operator>(</operator><name>OTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get appropriate row lock mode.
	 *
	 * We don't have current version of tuple at hands and it appears to be
	 * difficult for postgres executor to bring it to us.  Fetching previous
	 * version of tuple to get row lock mode would require additional
	 * roundtrip. So, instead of getting row lock mode from actually updated
	 * columns, we get it from SET clause of UPDATE command.  In the majority
	 * of cases result should be the same.
	 */</comment>
	<expr_stmt><expr><name>keyAttrs</name> <operator>=</operator> <call><name>RelationGetIndexAttrBitmap</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
										  <argument><expr><name>INDEX_ATTR_BITMAP_KEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>exec_rt_fetch</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></argument>, <argument><expr><name><name>mstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>updatedAttrs</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>updatedCols</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>keyAttrs</name></expr></argument>, <argument><expr><name>updatedAttrs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>marg</name><operator>.</operator><name>rowLockMode</name></name> <operator>=</operator> <name>RowLockNoKeyUpdate</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>marg</name><operator>.</operator><name>rowLockMode</name></name> <operator>=</operator> <name>RowLockUpdate</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>mres</name> <operator>=</operator> <call><name>o_tbl_update</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_pkey</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
						<argument><expr><name>oxid</name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>snapshotcsn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>marg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>mres</name><operator>.</operator><name>success</name></name> <operator>&amp;&amp;</operator> <name><name>mres</name><operator>.</operator><name>action</name></name> <operator>==</operator> <name>BTreeOperationLock</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>epqslot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>partition_constraint_failed</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>epqslot</name> <operator>=</operator> <call><name>EvalPlanQualNext</name><argument_list>(<argument><expr><name><name>marg</name><operator>.</operator><name>epqstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>epqslot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* Tuple not passing quals anymore, exiting... */</comment>
			<return>return <expr><name>TM_Deleted</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>ExecGetUpdateNewTuple</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>,
									 <argument><expr><name>epqslot</name></expr></argument>,
									 <argument><expr><name><name>mres</name><operator>.</operator><name>oldTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecFilterJunk</name><argument_list>(<argument><expr><name><name>mstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_result_relation_info</name><operator>-&gt;</operator><name>ri_junkFilter</name></name></expr></argument>,
							  <argument><expr><name>epqslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><name>partition_constraint_failed</name> <operator>=</operator>
			<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>ExecPartitionCheck</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>partition_constraint_failed</name> <operator>&amp;&amp;</operator>
			<name><name>rinfo</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * ExecWithCheckOptions() will skip any WCOs which are not of the
			 * kind we are looking for at this point.
			 */</comment>
			<expr_stmt><expr><call><name>ExecWithCheckOptions</name><argument_list>(<argument><expr><name>WCO_RLS_UPDATE_CHECK</name></expr></argument>,
								 <argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>partition_constraint_failed</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>TM_Updated</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecConstraints</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>tts_orioledb_fill_key_bound</name><argument_list>(<argument><expr><name><name>mres</name><operator>.</operator><name>oldTuple</name></name></expr></argument>, <argument><expr><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_pkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>mres</name> <operator>=</operator> <call><name>o_tbl_update</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_pkey</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
							<argument><expr><name>oxid</name></expr></argument>, <argument><expr><name><name>marg</name><operator>.</operator><name>csn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>marg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mres</name><operator>.</operator><name>action</name></name> <operator>!=</operator> <name>BTreeOperationLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* ExecClearTuple(mres.oldTuple); */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>mres</name><operator>.</operator><name>self_modified</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>cmax</name></name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TM_SelfModified</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>cmax</name></name> <operator>=</operator> <name>InvalidCommandId</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>o_check_tbl_update_mres</name><argument_list>(<argument><expr><name>mres</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mres</name><operator>.</operator><name>success</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><ternary><condition><expr><name><name>mres</name><operator>.</operator><name>oldTuple</name></name></expr> ?</condition><then> <expr><name>TM_Ok</name></expr> </then><else>: <expr><name>TM_Deleted</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TM_Result</name></type>
<name>orioledb_tableam_tuple_lock</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
							<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>LockTupleMode</name></type> <name>mode</name></decl></parameter>,
							<parameter><decl><type><name>LockWaitPolicy</name></type> <name>wait_policy</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>flags</name></decl></parameter>,
							<parameter><decl><type><name>TM_FailureData</name> <modifier>*</modifier></type><name>tmfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented: %s"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>TM_Ok</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TM_Result</name></type>
<name>orioledb_tuple_lock</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>tupleid</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
					<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>LockTupleMode</name></type> <name>mode</name></decl></parameter>,
					<parameter><decl><type><name>LockWaitPolicy</name></type> <name>wait_policy</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>flags</name></decl></parameter>,
					<parameter><decl><type><name>TM_FailureData</name> <modifier>*</modifier></type><name>tmfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OLockCallbackArg</name></type> <name>larg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeModifyResult</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OBTreeKeyBound</name></type> <name>pkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeLocationHint</name></type> <name>hint</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>descr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oxid</name> <operator>=</operator> <call><name>get_current_oxid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>larg</name><operator>.</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>larg</name><operator>.</operator><name>descr</name></name> <operator>=</operator> <name>descr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>larg</name><operator>.</operator><name>oxid</name></name> <operator>=</operator> <name>oxid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>larg</name><operator>.</operator><name>csn</name></name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>snapshotcsn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>larg</name><operator>.</operator><name>epqstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>larg</name><operator>.</operator><name>scanSlot</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>larg</name><operator>.</operator><name>waitPolicy</name></name> <operator>=</operator> <name>wait_policy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>larg</name><operator>.</operator><name>wouldBlock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>larg</name><operator>.</operator><name>modified</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>larg</name><operator>.</operator><name>selfModified</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>get_keys_from_rowid</name><argument_list>(<argument><expr><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pkey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>o_tbl_lock</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pkey</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>larg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>larg</name><operator>.</operator><name>modified</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>traversed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>traversed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>larg</name><operator>.</operator><name>selfModified</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>cmax</name></name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TM_SelfModified</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>cmax</name></name> <operator>=</operator> <name>InvalidCommandId</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>larg</name><operator>.</operator><name>wouldBlock</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>TM_WouldBlock</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>OBTreeModifyResultNotFound</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>TM_Deleted</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <name>OBTreeModifyResultLocked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>TM_Ok</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_finish_bulk_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Do nothing here */</comment>
</block_content>}</block></function>


<comment type="block">/* ------------------------------------------------------------------------
 * DDL related callbacks for heap AM.
 * ------------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_relation_set_new_filenode</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>RelFileNode</name> <modifier>*</modifier></type><name>newrnode</name></decl></parameter>,
								   <parameter><decl><type><name>char</name></type> <name>persistence</name></decl></parameter>,
								   <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>freezeXid</name></decl></parameter>,
								   <parameter><decl><type><name>MultiXactId</name> <modifier>*</modifier></type><name>minmulti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>srel</name></decl>;</decl_stmt>

	<comment type="block">/* TRUNCATE case */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>oid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_TOASTVALUE</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>is_in_indexes_rebuild</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTable</name>	   <modifier>*</modifier></type><name>o_table</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>csn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>oldTreeOidsNum</name></decl>,
					<decl><type ref="prev"/><name>newTreeOidsNum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ORelOids</name></type>	<name>oldOids</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>oldTreeOids</name></decl>,
					<decl><type ref="prev"/><name>newOids</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>newTreeOids</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>oldOids</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oldOids</name><operator>.</operator><name>reloid</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oldOids</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>fill_current_oxid_csn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oxid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>o_table</name> <operator>=</operator> <call><name>o_tables_get</name><argument_list>(<argument><expr><name>oldOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>o_table</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldTreeOids</name> <operator>=</operator> <call><name>o_table_make_index_oids</name><argument_list>(<argument><expr><name>o_table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldTreeOidsNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>o_table_fill_oids</name><argument_list>(<argument><expr><name>o_table</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>newrnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newOids</name> <operator>=</operator> <name><name>o_table</name><operator>-&gt;</operator><name>oids</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newTreeOids</name> <operator>=</operator> <call><name>o_table_make_index_oids</name><argument_list>(<argument><expr><name>o_table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newTreeOidsNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oTablesAddLock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>o_tables_drop_by_oids</name><argument_list>(<argument><expr><name>oldOids</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>o_tables_add</name><argument_list>(<argument><expr><name>o_table</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oTablesAddLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>o_table_free</name><argument_list>(<argument><expr><name>o_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>orioledb_free_rd_amcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>o_fetch_table_descr</name><argument_list>(<argument><expr><name>newOids</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_undo_truncate_relnode</name><argument_list>(<argument><expr><name>oldOids</name></expr></argument>, <argument><expr><name>oldTreeOids</name></expr></argument>, <argument><expr><name>oldTreeOidsNum</name></expr></argument>,
								  <argument><expr><name>newOids</name></expr></argument>, <argument><expr><name>newTreeOids</name></expr></argument>, <argument><expr><name>newTreeOidsNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oldTreeOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newTreeOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>freezeXid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>minmulti</name> <operator>=</operator> <name>InvalidMultiXactId</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">150000</literal></expr></cpp:if>
	<expr_stmt><expr><name>srel</name> <operator>=</operator> <call><name>RelationCreateStorage</name><argument_list>(<argument><expr><operator>*</operator><name>newrnode</name></expr></argument>, <argument><expr><name>persistence</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>srel</name> <operator>=</operator> <call><name>RelationCreateStorage</name><argument_list>(<argument><expr><operator>*</operator><name>newrnode</name></expr></argument>, <argument><expr><name>persistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>srel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_relation_nontransactional_truncate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ORelOids</name></type>	<name>oids</name> <init>= <expr><block>{<expr><name>MyDatabaseId</name></expr>, <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>oid</name></name></expr>,
	<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr>}</block></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>treeOids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTable</name>	   <modifier>*</modifier></type><name>o_table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>treeOidsNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>invalidatedTable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>oid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_TOASTVALUE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>o_tables_rel_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oids</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>o_table</name> <operator>=</operator> <call><name>o_tables_get</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>o_table</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>treeOids</name> <operator>=</operator> <call><name>o_table_make_index_oids</name><argument_list>(<argument><expr><name>o_table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>treeOidsNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>treeOidsNum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>o_tables_rel_lock_extended</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>treeOids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>o_tables_rel_lock_extended</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>treeOids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>cleanup_btree</name><argument_list>(<argument><expr><name><name>treeOids</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>datoid</name></expr></argument>, <argument><expr><name><name>treeOids</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>o_invalidate_oids</name><argument_list>(<argument><expr><name><name>treeOids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ORelOidsIsEqual</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name><name>treeOids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>invalidatedTable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>o_tables_rel_unlock_extended</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>treeOids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>o_tables_rel_unlock_extended</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>treeOids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>invalidatedTable</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>o_invalidate_oids</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>o_tables_rel_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oids</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>treeOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_relation_copy_data</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RelFileNode</name> <modifier>*</modifier></type><name>newrnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented: %s"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_relation_copy_for_cluster</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>OldHeap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>NewHeap</name></decl></parameter>,
								   <parameter><decl><type><name>Relation</name></type> <name>OldIndex</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_sort</name></decl></parameter>,
								   <parameter><decl><type><name>TransactionId</name></type> <name>OldestXmin</name></decl></parameter>,
								   <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xid_cutoff</name></decl></parameter>,
								   <parameter><decl><type><name>MultiXactId</name> <modifier>*</modifier></type><name>multi_cutoff</name></decl></parameter>,
								   <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>num_tuples</name></decl></parameter>,
								   <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>tups_vacuumed</name></decl></parameter>,
								   <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>tups_recently_dead</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented: %s"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>orioledb_scan_analyze_next_block</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blockno</name></decl></parameter>,
								 <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>bstrategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OScanDesc</name></type>	<name>oscan</name> <init>= <expr><operator>(</operator><name>OScanDesc</name><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ItemPointerSetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oscan</name><operator>-&gt;</operator><name>iptr</name></name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oscan</name><operator>-&gt;</operator><name>iptr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_TUPLES_PER_BLOCK</name></cpp:macro>	<cpp:value>128</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>orioledb_scan_analyze_next_tuple</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>OldestXmin</name></decl></parameter>,
								 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>liverows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>deadrows</name></decl></parameter>,
								 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OScanDesc</name></type>	<name>oscan</name> <init>= <expr><operator>(</operator><name>OScanDesc</name><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeLocationHint</name></type> <name>hint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>end</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>btree_seq_scan_getnext_raw</name><argument_list>(<argument><expr><name><name>oscan</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>end</name> <operator>||</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oscan</name><operator>-&gt;</operator><name>iptr</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>NUM_TUPLES_PER_BLOCK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>tts_orioledb_store_tuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>, <argument><expr><name><name>oscan</name><operator>-&gt;</operator><name>csn</name></name></expr></argument>,
									 <argument><expr><name>PrimaryIndexNumber</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>liverows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ItemPointerSetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>, <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oscan</name><operator>-&gt;</operator><name>iptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ItemPointerSetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>, <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oscan</name><operator>-&gt;</operator><name>iptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ItemPointerSetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oscan</name><operator>-&gt;</operator><name>iptr</name></name></expr></argument>, <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oscan</name><operator>-&gt;</operator><name>iptr</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>deadrows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>orioledb_index_build_range_scan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
								<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
								<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>allow_sync</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>anyvisible</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>progress</name></decl></parameter>,
								<parameter><decl><type><name>BlockNumber</name></type> <name>start_blockno</name></decl></parameter>,
								<parameter><decl><type><name>BlockNumber</name></type> <name>numblocks</name></decl></parameter>,
								<parameter><decl><type><name>IndexBuildCallback</name></type> <name>callback</name></decl></parameter>,
								<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_state</name></decl></parameter>,
								<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * used for index creation
	 */</comment>
	<return>return <expr><literal type="number">0.0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_index_validate_scan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
							 <parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
							 <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
							 <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
							 <parameter><decl><type><name>ValidateIndexState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented: %s"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ------------------------------------------------------------------------
 * Miscellaneous callbacks for the heap AM
 * ------------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>orioledb_relation_size</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>descr</name> <operator>&amp;&amp;</operator> <call><name>tbl_data_exists</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>oids</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>uint64</name><operator>)</operator> <call><name>TREE_NUM_LEAF_PAGES</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>desc</name></expr></argument>)</argument_list></call> <operator>*</operator>
			<name>ORIOLEDB_BLCKSZ</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>orioledb_relation_needs_toast_table</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>orioledb_relation_toast_am</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>HEAP_TABLE_AM_OID</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ------------------------------------------------------------------------
 * Planner related callbacks for the heap AM
 * ------------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_estimate_rel_size</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>attr_widths</name></decl></parameter>,
						   <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>pages</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>tuples</name></decl></parameter>,
						   <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>allvisfrac</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>curpages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>relpages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>reltuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>relallvisible</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>density</name></decl>;</decl_stmt>

	<comment type="block">/* it has storage, ok to call the smgr */</comment>
	<expr_stmt><expr><name>curpages</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* coerce values in pg_class to more desirable types */</comment>
	<expr_stmt><expr><name>relpages</name> <operator>=</operator> <operator>(</operator><name>BlockNumber</name><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>reltuples</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>relallvisible</name> <operator>=</operator> <operator>(</operator><name>BlockNumber</name><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relallvisible</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * HACK: if the relation has never yet been vacuumed, use a minimum size
	 * estimate of 10 pages.  The idea here is to avoid assuming a
	 * newly-created table is really small, even if it currently is, because
	 * that may not be true once some data gets loaded into it.  Once a vacuum
	 * or analyze cycle has been done on it, it's more reasonable to believe
	 * the size is somewhat stable.
	 *
	 * (Note that this is only an issue if the plan gets cached and used again
	 * after the table has been filled.  What we're trying to avoid is using a
	 * nestloop-type plan on a table that has grown substantially since the
	 * plan was made.  Normally, autovacuum/autoanalyze will occur once enough
	 * inserts have happened and cause cached-plan invalidation; but that
	 * doesn't happen instantaneously, and it won't happen at all for cases
	 * such as temporary tables.)
	 *
	 * We approximate "never vacuumed" by "has relpages = 0", which means this
	 * will also fire on genuinely empty relations.  Not great, but
	 * fortunately that's a seldom-seen case in the real world, and it
	 * shouldn't degrade the quality of the plan too much anyway to err in
	 * this direction.
	 *
	 * If the table has inheritance children, we don't apply this heuristic.
	 * Totally empty parent tables are quite common, so we should be willing
	 * to believe that they are empty.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>curpages</name> <operator>&lt;</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator>
		<name>relpages</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhassubclass</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>curpages</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* report estimated # pages */</comment>
	<expr_stmt><expr><operator>*</operator><name>pages</name> <operator>=</operator> <name>curpages</name></expr>;</expr_stmt>
	<comment type="block">/* quick exit if rel is clearly empty */</comment>
	<if_stmt><if>if <condition>(<expr><name>curpages</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>tuples</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>allvisfrac</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* estimate number of tuples from previous tuple density */</comment>
	<if_stmt><if>if <condition>(<expr><name>relpages</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>density</name> <operator>=</operator> <name>reltuples</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>relpages</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>tuples</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>density</name> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>curpages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * When we have no data because the relation was truncated, estimate
		 * tuple width from attribute datatypes.  We assume here that the
		 * pages are completely full, which is OK for tables (since they've
		 * presumably not been VACUUMed yet) but is probably an overestimate
		 * for indexes.  Fortunately get_relation_info() can clamp the
		 * overestimate to the parent table's size.
		 *
		 * Note: this code intentionally disregards alignment considerations,
		 * because (a) that would be gilding the lily considering how crude
		 * the estimate is, and (b) it creates platform dependencies in the
		 * default plans which are kind of a headache for regression testing.
		 */</comment>
		<decl_stmt><decl><type><name>int32</name></type>		<name>tuple_width</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple_width</name> <operator>=</operator> <call><name>get_rel_data_width</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attr_widths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuple_width</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeOfOTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* note: integer division is intentional here */</comment>
		<expr_stmt><expr><name>density</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>ORIOLEDB_BLCKSZ</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>tuple_width</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>tuples</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>density</name> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>curpages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We use relallvisible as-is, rather than scaling it up like we do for
	 * the pages and tuples counts, on the theory that any pages added since
	 * the last VACUUM are most likely not marked all-visible.  But costsize.c
	 * wants it converted to a fraction.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relallvisible</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>curpages</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>allvisfrac</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>double</name><operator>)</operator> <name>relallvisible</name> <operator>&gt;=</operator> <name>curpages</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>allvisfrac</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>allvisfrac</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>relallvisible</name> <operator>/</operator> <name>curpages</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ------------------------------------------------------------------------
 * Executor related callbacks for the heap AM
 * ------------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>orioledb_scan_bitmap_next_block</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>,
								<parameter><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>tbmres</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented: %s"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>orioledb_scan_bitmap_next_tuple</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>,
								<parameter><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>tbmres</name></decl></parameter>,
								<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented: %s"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>orioledb_scan_sample_next_block</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>SampleScanState</name> <modifier>*</modifier></type><name>scanstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented: %s"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>orioledb_scan_sample_next_tuple</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>SampleScanState</name> <modifier>*</modifier></type><name>scanstate</name></decl></parameter>,
								<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented: %s"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Size</name></type>
<name>orioledb_parallelscan_estimate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_orioledb_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a orioledb table"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelOScanDescData</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Modified copy of table_block_parallelscan_initialize */</comment>
<function><type><name>Size</name></type>
<name>orioledb_parallelscan_initialize</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ParallelTableScanDesc</name></type> <name>pscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelOScanDesc</name></type> <name>poscan</name> <init>= <expr><operator>(</operator><name>ParallelOScanDesc</name><operator>)</operator> <name>pscan</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_orioledb_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a orioledb table"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>poscan</name><operator>-&gt;</operator><name>phs_base</name><operator>.</operator><name>phs_relid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poscan</name><operator>-&gt;</operator><name>phs_base</name><operator>.</operator><name>phs_syncscan</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>intpageAccess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>workerStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>workerBeginDisk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ConditionVariableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinksCv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>intpageLoad</name></name></expr></argument>, <argument><expr><name><name>btreeScanShmem</name><operator>-&gt;</operator><name>pageLoadTrancheId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinksSubscribe</name></name></expr></argument>, <argument><expr><name><name>btreeScanShmem</name><operator>-&gt;</operator><name>downlinksSubscribeTrancheId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinksPublish</name></name></expr></argument>, <argument><expr><name><name>btreeScanShmem</name><operator>-&gt;</operator><name>downlinksPublishTrancheId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>clear_fixed_shmem_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>intPage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>prevHikey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>clear_fixed_shmem_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>intPage</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>prevHikey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>poscan</name><operator>-&gt;</operator><name>intPage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>img</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>poscan</name><operator>-&gt;</operator><name>intPage</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>img</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ORIOLEDB_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poscan</name><operator>-&gt;</operator><name>intPage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>status</name> <operator>=</operator> <name>OParallelScanPageInvalid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poscan</name><operator>-&gt;</operator><name>intPage</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>status</name> <operator>=</operator> <name>OParallelScanPageInvalid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poscan</name><operator>-&gt;</operator><name>intPage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>startOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poscan</name><operator>-&gt;</operator><name>intPage</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>startOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poscan</name><operator>-&gt;</operator><name>intPage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poscan</name><operator>-&gt;</operator><name>intPage</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poscan</name><operator>-&gt;</operator><name>downlinksCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poscan</name><operator>-&gt;</operator><name>downlinkIndex</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poscan</name><operator>-&gt;</operator><name>workersReportedCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poscan</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poscan</name><operator>-&gt;</operator><name>cur_int_pageno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poscan</name><operator>-&gt;</operator><name>dsmHandle</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>poscan</name><operator>-&gt;</operator><name>worker_active</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>poscan</name><operator>-&gt;</operator><name>worker_active</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelOScanDescData</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>orioledb_parallelscan_reinitialize</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ParallelTableScanDesc</name></type> <name>pscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>is_orioledb_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented: %s"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>TableScanDesc</name></type>
<name>orioledb_beginscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>,
				   <parameter><decl><type><name>ParallelTableScanDesc</name></type> <name>parallel_scan</name></decl></parameter>,
				   <parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OScanDesc</name></type>	<name>scan</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * allocate and initialize scan descriptor
	 */</comment>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <operator>(</operator><name>OScanDesc</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OScanDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_snapshot</name></name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_nkeys</name></name> <operator>=</operator> <name>nkeys</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name> <operator>=</operator> <name>parallel_scan</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nkeys</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_key</name></name> <operator>=</operator> <operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_key</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_key</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;</operator> <name>SO_TYPE_ANALYZE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <name>COMMITSEQNO_INPROGRESS</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>csn</name></name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>snapshotcsn</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ItemPointerSetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>iptr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>iptr</name></name></expr></argument>, <argument><expr><name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>descr</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>scan</name></name> <operator>=</operator> <call><name>make_btree_seq_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>desc</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>csn</name></name></expr></argument>, <argument><expr><name>parallel_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_rescan</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>sscan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>set_params</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>allow_strat</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_sync</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_pagemode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OScanDesc</name></type>	<name>scan</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <operator>(</operator><name>OScanDesc</name><operator>)</operator> <name>sscan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_key</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
		   <name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_nkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>scan</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free_btree_seq_scan</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>scan</name></name> <operator>=</operator> <call><name>make_btree_seq_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>desc</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>csn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_endscan</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>sscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OScanDesc</name></type>	<name>scan</name> <init>= <expr><operator>(</operator><name>OScanDesc</name><operator>)</operator> <name>sscan</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>STOPEVENT</name><argument_list>(<argument><expr><name>STOPEVENT_SCAN_END</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;</operator> <name>SO_TEMP_SNAPSHOT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>scan</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free_btree_seq_scan</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>slot_keytest</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>keys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type>		<name>key</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>test</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>key</name> <operator>=</operator> <name>keys</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>sk_func</name></name></expr></argument>,
								 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>,
								 <argument><expr><name>val</name></expr></argument>,
								 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>orioledb_getnextslot</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>sscan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OScanDesc</name></type>	<name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTreeLocationHint</name></type> <name>hint</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CommitSeqNo</name></type> <name>tupleCsn</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>scan</name> <operator>=</operator> <operator>(</operator><name>OScanDesc</name><operator>)</operator> <name>sscan</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>descr</name> <operator>=</operator> <call><name>relation_get_descr</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>btree_seq_scan_getnext</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>tupleCsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>tts_orioledb_store_tuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>, <argument><expr><name>tupleCsn</name></expr></argument>,
								 <argument><expr><name>PrimaryIndexNumber</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>slot_keytest</name><argument_list>(<argument><expr><name>slot</name></expr></argument>,
							  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_nkeys</name></name></expr></argument>,
							  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	while <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>;</do>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_tableam_multi_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>slots</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>ntuples</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented: %s"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_multi_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>slots</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ntuples</name></decl></parameter>,
					  <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					  <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>orioledb_tuple_insert</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>,
							  <argument><expr><name>cid</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_get_latest_tid</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>sscan</name></decl></parameter>,
						<parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented: %s"</literal></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_vacuum_rel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
					<parameter><decl><type><name>BufferAccessStrategy</name></type> <name>bstrategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* nothing to do */</comment>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>
<function><type><specifier>static</specifier> <name>TransactionId</name></type>
<name>orioledb_index_delete_tuples</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>TM_IndexDeleteOp</name> <modifier>*</modifier></type><name>delstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>TransactionId</name></type>
<name>orioledb_compute_xid_horizon_for_tuples</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
										<parameter><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>tids</name></decl></parameter>,
										<parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_init_modify</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mstate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name> <init>= <expr><call><name>relation_get_descr</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>mstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OFDWState</name>  <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>OFDWState</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OFDWState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>ri_FdwState</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>conflictIxOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>mstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator>
		<name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>!=</operator> <name>ONCONFLICT_NONE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>arbiterIndexes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>arbiterOid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>arbiterIndexes</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>ri_onConflictArbiterIndexes</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>arbiterIndexes</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>conflictIxOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>arbiterOid</name> <operator>=</operator> <call><name>list_nth_oid</name><argument_list>(<argument><expr><name>arbiterIndexes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>descr</name><operator>-&gt;</operator><name>nIndices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>descr</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>oids</name><operator>.</operator><name>reloid</name></name> <operator>==</operator> <name>arbiterOid</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>conflictIxOid</name></name> <operator>=</operator> <name>arbiterOid</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>conflictIxOid</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Arbiter index isn't matched"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>orioledb_attr_to_field</name><parameter_list>(<parameter><decl><type><name>OTableField</name> <modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>typid</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>typmod</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>typlen</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>ndims</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attndims</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>byval</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>align</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attalign</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attstorage</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>
	<expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>compression</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attcompression</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>droped</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>notnull</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>hasmissing</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atthasmissing</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>hasdef</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atthasdef</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>orioledb_rewrite_table</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>oldDesc</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>old_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>			<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ORelOids</name></type>		<name>oids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTable</name>		   <modifier>*</modifier></type><name>old_o_table</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>o_table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTableDescr</name>	   <modifier>*</modifier></type><name>old_descr</name></decl>,
					<decl><type ref="prev"/><name>tmp_descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>		<name>newDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>old_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>oids</name><operator>.</operator><name>datoid</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oids</name><operator>.</operator><name>reloid</name></name> <operator>=</operator> <name><name>old_rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oids</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>old_rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>o_table</name> <operator>=</operator> <call><name>o_tables_get</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>o_table</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* it does not exist */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"orioledb table \"%s\" not found"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>old_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>old_o_table</name> <operator>=</operator> <name>o_table</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>o_table</name> <operator>=</operator> <call><name>o_tables_get</name><argument_list>(<argument><expr><name><name>o_table</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>o_table</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* it does not exist */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"orioledb table \"%s\" not found"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>old_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>assign_new_oids</name><argument_list>(<argument><expr><name>o_table</name></expr></argument>, <argument><expr><name>old_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>o_table</name><operator>-&gt;</operator><name>primary_init_nfields</name></name> <operator>=</operator> <name><name>o_table</name><operator>-&gt;</operator><name>nfields</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>oldDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>&lt;</operator> <name><name>newDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>o_table</name><operator>-&gt;</operator><name>has_primary</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>o_table</name><operator>-&gt;</operator><name>primary_init_nfields</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oTablesAddLock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_descr</name> <operator>=</operator> <call><name>o_fetch_table_descr</name><argument_list>(<argument><expr><name><name>old_o_table</name><operator>-&gt;</operator><name>oids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>o_fill_tmp_table_descr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_descr</name></expr></argument>, <argument><expr><name>o_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>rebuild_indices</name><argument_list>(<argument><expr><name>old_o_table</name></expr></argument>, <argument><expr><name>old_descr</name></expr></argument>, <argument><expr><name>o_table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>o_free_tmp_table_descr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recreate_o_table</name><argument_list>(<argument><expr><name>old_o_table</name></expr></argument>, <argument><expr><name>o_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>o_table_free</name><argument_list>(<argument><expr><name>old_o_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>o_table_free</name><argument_list>(<argument><expr><name>o_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>checkpoint_state</name><operator>-&gt;</operator><name>oTablesAddLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_change_not_null</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>new_val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTable</name>	   <modifier>*</modifier></type><name>o_table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTableField</name> <modifier>*</modifier></type><name>o_field</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ORelOids</name></type>	<name>oids</name> <init>= <expr><block>{<expr><name>MyDatabaseId</name></expr>, <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>oid</name></name></expr>, <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>o_table</name> <operator>=</operator> <call><name>o_tables_get</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>o_table</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* table does not exist */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"orioledb table \"%s\" not found"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>o_field</name> <operator>=</operator> <call><name>o_table_field_by_name</name><argument_list>(<argument><expr><name>o_table</name></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>o_field</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>o_field</name><operator>-&gt;</operator><name>notnull</name></name> <operator>!=</operator> <name>new_val</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CommitSeqNo</name></type>	<name>csn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>o_field</name><operator>-&gt;</operator><name>notnull</name></name> <operator>=</operator> <name>new_val</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>fill_current_oxid_csn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oxid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>o_tables_update</name><argument_list>(<argument><expr><name>o_table</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>o_tables_after_update</name><argument_list>(<argument><expr><name>o_table</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>o_table_free</name><argument_list>(<argument><expr><name>o_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>orioledb_alter_column_type</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>def</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTable</name>		   <modifier>*</modifier></type><name>o_table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTableField</name>	   <modifier>*</modifier></type><name>o_field</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ORelOids</name></type>		<name>oids</name> <init>= <expr><block>{<expr><name>MyDatabaseId</name></expr>,
							<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>oid</name></name></expr>,
							<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>type</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>o_table</name> <operator>=</operator> <call><name>o_tables_get</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>o_table</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* table does not exist */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"orioledb table \"%s\" not found"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>o_field</name> <operator>=</operator> <call><name>o_table_field_by_name</name><argument_list>(<argument><expr><name>o_table</name></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't support rewriting the relation for now.  So, we
	 * can only change the type if new type is binary coersible
	 * with the old one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>o_field</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name><name>o_field</name><operator>-&gt;</operator><name>typid</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not change the column type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>,
					<argument><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Column \"%s\" of OrioleDB table \"%s\" "</literal>
							  <literal type="string">"has type \"%s\". Can't change to \"%s\", "</literal>
							  <literal type="string">"because it's not binary coersible."</literal></expr></argument>,
							  <argument><expr><name>colName</name></expr></argument>,
							  <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>o_field</name><operator>-&gt;</operator><name>typid</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>o_table</name><operator>-&gt;</operator><name>nindices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTableIndex</name> <modifier>*</modifier></type><name>index</name> <init>= <expr><operator>&amp;</operator><name><name>o_table</name><operator>-&gt;</operator><name>indices</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>index</name><operator>-&gt;</operator><name>nfields</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OTableField</name> <modifier>*</modifier></type><name>field</name> <init>= <expr><operator>&amp;</operator><name><name>o_table</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name><name>index</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>attnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>collClause</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>	<name>collid</name> <init>= <expr><call><name>get_collation_oid</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>collClause</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>collid</name> <operator>!=</operator> <name><name>field</name><operator>-&gt;</operator><name>collation</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not change the column "</literal>
									   <literal type="string">"collation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>,
							<argument><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Column \"%s\" of OrioleDB table \"%s\" "</literal>
									  <literal type="string">"id used in \"%s\" index definition."</literal></expr></argument>,
										<argument><expr><name>colName</name></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>field</name><operator>-&gt;</operator><name>collation</name></name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not change the column collation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>,
						<argument><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Column \"%s\" of OrioleDB table \"%s\" "</literal>
								  <literal type="string">"id used in \"%s\" index definition."</literal></expr></argument>,
									<argument><expr><name>colName</name></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>o_field</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>collClause</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>collname</name> <init>= <expr><name><name>def</name><operator>-&gt;</operator><name>collClause</name><operator>-&gt;</operator><name>collname</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>collid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>collid</name> <operator>=</operator> <call><name>get_collation_oid</name><argument_list>(<argument><expr><name>collname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>o_field</name><operator>-&gt;</operator><name>collation</name></name> <operator>!=</operator> <name>collid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>o_field</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name>collid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>o_field</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>o_field</name><operator>-&gt;</operator><name>typid</name></name> <operator>!=</operator> <name>type</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CommitSeqNo</name></type>	<name>csn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OXid</name></type>		<name>oxid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>o_field</name><operator>-&gt;</operator><name>typid</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>fill_current_oxid_csn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oxid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>o_tables_update</name><argument_list>(<argument><expr><name>o_table</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>o_tables_after_update</name><argument_list>(<argument><expr><name>o_table</name></expr></argument>, <argument><expr><name>oxid</name></expr></argument>, <argument><expr><name>csn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>o_table_free</name><argument_list>(<argument><expr><name>o_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>orioledb_define_index_validate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
							   <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>o_define_index_validate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><operator>(</operator><name>ODefineIndexContext</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>orioledb_define_index</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ObjectAddress</name></type> <name>address</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>o_define_index</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>address</name></expr></argument>, <argument><expr><operator>(</operator><name>ODefineIndexContext</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>orioledb_free_rd_amcache</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>table_descr_dec_refcnt</name><argument_list>(<argument><expr><operator>(</operator><name>OTableDescr</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>orioledb_acquire_sample_rows</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
							 <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>,
							 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totalrows</name></decl></parameter>,
							 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totaldeadrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name> <init>= <expr><call><name>relation_get_descr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>pk</name> <init>= <expr><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTreeSeqScan</name> <modifier>*</modifier></type><name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReservoirStateData</name></type> <name>rstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>scanEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>descr</name><operator>-&gt;</operator><name>newTuple</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numrows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* # rows now in reservoir */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>samplerows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* total # rows collected */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>liverows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* # live rows seen */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>deadrows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* # dead rows seen */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>rowstoskip</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* -1 means not set yet */</comment>
	<decl_stmt><decl><type><name>BlockSamplerData</name></type> <name>bs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>totalblocks</name> <init>= <expr><call><name>TREE_NUM_LEAF_PAGES</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pk</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>nblocks</name> <operator>=</operator> <call><name>BlockSampler_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bs</name></expr></argument>, <argument><expr><name>totalblocks</name></expr></argument>,
								<argument><expr><name>targrows</name></expr></argument>, <argument><expr><call><name>random</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>make_btree_sampling_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pk</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Report sampling block numbers */</comment>
	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_ANALYZE_BLOCKS_TOTAL</name></expr></argument>,
								 <argument><expr><name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare for sampling rows */</comment>
	<expr_stmt><expr><call><name>reservoir_init_selection_state</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rstate</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>btree_seq_scan_getnext_raw</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>scanEnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>!</operator><name>scanEnd</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>btree_seq_scan_getnext_raw</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>scanEnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>O_TUPLE_IS_NULL</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>tts_orioledb_store_tuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>, <argument><expr><name>COMMITSEQNO_INPROGRESS</name></expr></argument>,
									 <argument><expr><name>PrimaryIndexNumber</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>liverows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>numrows</name> <operator>&lt;</operator> <name>targrows</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>rows</name><index>[<expr><name>numrows</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ExecCopySlotHeapTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * t in Vitter's paper is the number of records already
				 * processed.  If we need to compute a new S value, we must
				 * use the not-yet-incremented value of samplerows as t.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>rowstoskip</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rowstoskip</name> <operator>=</operator> <call><name>reservoir_get_next_S</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rstate</name></expr></argument>, <argument><expr><name>samplerows</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>rowstoskip</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Found a suitable tuple, so save it, replacing one old
					 * tuple at random
					 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">150000</literal></expr></cpp:if>
					<decl_stmt><decl><type><name>int</name></type>			<name>k</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>targrows</name> <operator>*</operator> <call><name>sampler_random_fract</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rstate</name><operator>.</operator><name>randstate</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
					<decl_stmt><decl><type><name>int</name></type>			<name>k</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>targrows</name> <operator>*</operator> <call><name>sampler_random_fract</name><argument_list>(<argument><expr><name><name>rstate</name><operator>.</operator><name>randstate</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>k</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;</operator> <name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>rows</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rows</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <call><name>ExecCopySlotHeapTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>rowstoskip</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>samplerows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>deadrows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>free_btree_seq_scan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Estimate total numbers of live and dead rows in relation, extrapolating
	 * on the assumption that the average tuple density in pages we didn't
	 * scan is the same as in the pages we did scan.  Since what we scanned is
	 * a random sample of the pages in the relation, this should be a good
	 * assumption.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>bs</name><operator>.</operator><name>m</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>totalrows</name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><operator>(</operator><name>liverows</name> <operator>/</operator> <name><name>bs</name><operator>.</operator><name>m</name></name><operator>)</operator> <operator>*</operator> <name>totalblocks</name> <operator>+</operator> <literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>totaldeadrows</name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><operator>(</operator><name>deadrows</name> <operator>/</operator> <name><name>bs</name><operator>.</operator><name>m</name></name><operator>)</operator> <operator>*</operator> <name>totalblocks</name> <operator>+</operator> <literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>totalrows</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>totaldeadrows</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Emit some interesting relation info
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\": scanned %d of %u pages, "</literal>
					<literal type="string">"containing %.0f live rows and %.0f dead rows; "</literal>
					<literal type="string">"%d rows in sample, %.0f estimated total rows"</literal></expr></argument>,
					<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name><name>bs</name><operator>.</operator><name>m</name></name></expr></argument>, <argument><expr><name>totalblocks</name></expr></argument>,
					<argument><expr><name>liverows</name></expr></argument>, <argument><expr><name>deadrows</name></expr></argument>,
					<argument><expr><name>numrows</name></expr></argument>, <argument><expr><operator>*</operator><name>totalrows</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>numrows</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>orioledb_analyze_table</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
					   <parameter><decl><type><name>AcquireSampleRowsFunc</name> <modifier>*</modifier></type><name>func</name></decl></parameter>,
					   <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>totalpages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>descr</name> <init>= <expr><call><name>relation_get_descr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>pk</name> <init>= <expr><call><name>GET_PRIMARY</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>o_btree_load_shmem</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pk</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>orioledb_acquire_sample_rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>totalpages</name> <operator>=</operator> <call><name>TREE_NUM_LEAF_PAGES</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pk</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ------------------------------------------------------------------------
 * Definition of the orioledb table access method.
 * ------------------------------------------------------------------------
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ExtendedTableAmRoutine</name></type> <name>orioledb_am_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>tableam</name> <operator>=</operator> <block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_ExtendedTableAmRoutine</name></expr>,
		<expr><operator>.</operator><name>slot_callbacks</name> <operator>=</operator> <name>orioledb_slot_callbacks</name></expr>,

		<expr><operator>.</operator><name>scan_begin</name> <operator>=</operator> <name>orioledb_beginscan</name></expr>,
		<expr><operator>.</operator><name>scan_end</name> <operator>=</operator> <name>orioledb_endscan</name></expr>,
		<expr><operator>.</operator><name>scan_rescan</name> <operator>=</operator> <name>orioledb_rescan</name></expr>,
		<expr><operator>.</operator><name>scan_getnextslot</name> <operator>=</operator> <name>orioledb_getnextslot</name></expr>,

		<expr><operator>.</operator><name>parallelscan_estimate</name> <operator>=</operator> <name>orioledb_parallelscan_estimate</name></expr>,
		<expr><operator>.</operator><name>parallelscan_initialize</name> <operator>=</operator> <name>orioledb_parallelscan_initialize</name></expr>,
		<expr><operator>.</operator><name>parallelscan_reinitialize</name> <operator>=</operator> <name>orioledb_parallelscan_reinitialize</name></expr>,

		<expr><operator>.</operator><name>index_fetch_begin</name> <operator>=</operator> <name>orioledb_index_fetch_begin</name></expr>,
		<expr><operator>.</operator><name>index_fetch_reset</name> <operator>=</operator> <name>orioledb_index_fetch_reset</name></expr>,
		<expr><operator>.</operator><name>index_fetch_end</name> <operator>=</operator> <name>orioledb_index_fetch_end</name></expr>,
		<expr><operator>.</operator><name>index_fetch_tuple</name> <operator>=</operator> <name>orioledb_index_fetch_tuple</name></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>
		<expr><operator>.</operator><name>index_delete_tuples</name> <operator>=</operator> <name>orioledb_index_delete_tuples</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr><operator>.</operator><name>tuple_insert</name> <operator>=</operator> <name>orioledb_tableam_tuple_insert</name></expr>,
		<expr><operator>.</operator><name>tuple_insert_speculative</name> <operator>=</operator> <name>orioledb_tuple_insert_speculative</name></expr>,
		<expr><operator>.</operator><name>tuple_complete_speculative</name> <operator>=</operator> <name>orioledb_tuple_complete_speculative</name></expr>,
		<expr><operator>.</operator><name>multi_insert</name> <operator>=</operator> <name>orioledb_tableam_multi_insert</name></expr>,
		<expr><operator>.</operator><name>tuple_delete</name> <operator>=</operator> <name>orioledb_tableam_tuple_delete</name></expr>,
		<expr><operator>.</operator><name>tuple_update</name> <operator>=</operator> <name>orioledb_tableam_tuple_update</name></expr>,
		<expr><operator>.</operator><name>tuple_lock</name> <operator>=</operator> <name>orioledb_tableam_tuple_lock</name></expr>,
		<expr><operator>.</operator><name>finish_bulk_insert</name> <operator>=</operator> <name>orioledb_finish_bulk_insert</name></expr>,

		<expr><operator>.</operator><name>tuple_fetch_row_version</name> <operator>=</operator> <name>orioledb_tableam_fetch_row_version</name></expr>,
		<expr><operator>.</operator><name>tuple_get_latest_tid</name> <operator>=</operator> <name>orioledb_get_latest_tid</name></expr>,
		<expr><operator>.</operator><name>tuple_tid_valid</name> <operator>=</operator> <name>orioledb_tuple_tid_valid</name></expr>,
		<expr><operator>.</operator><name>tuple_satisfies_snapshot</name> <operator>=</operator> <name>orioledb_tuple_satisfies_snapshot</name></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">140000</literal></expr></cpp:if>
		<expr><operator>.</operator><name>compute_xid_horizon_for_tuples</name> <operator>=</operator> <name>orioledb_compute_xid_horizon_for_tuples</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr><operator>.</operator><name>relation_set_new_filenode</name> <operator>=</operator> <name>orioledb_relation_set_new_filenode</name></expr>,
		<expr><operator>.</operator><name>relation_nontransactional_truncate</name> <operator>=</operator> <name>orioledb_relation_nontransactional_truncate</name></expr>,
		<expr><operator>.</operator><name>relation_copy_data</name> <operator>=</operator> <name>orioledb_relation_copy_data</name></expr>,
		<expr><operator>.</operator><name>relation_copy_for_cluster</name> <operator>=</operator> <name>orioledb_relation_copy_for_cluster</name></expr>,
		<expr><operator>.</operator><name>relation_vacuum</name> <operator>=</operator> <name>orioledb_vacuum_rel</name></expr>,
		<expr><operator>.</operator><name>scan_analyze_next_block</name> <operator>=</operator> <name>orioledb_scan_analyze_next_block</name></expr>,
		<expr><operator>.</operator><name>scan_analyze_next_tuple</name> <operator>=</operator> <name>orioledb_scan_analyze_next_tuple</name></expr>,
		<expr><operator>.</operator><name>index_build_range_scan</name> <operator>=</operator> <name>orioledb_index_build_range_scan</name></expr>,
		<expr><operator>.</operator><name>index_validate_scan</name> <operator>=</operator> <name>orioledb_index_validate_scan</name></expr>,

		<expr><operator>.</operator><name>relation_size</name> <operator>=</operator> <name>orioledb_relation_size</name></expr>,
		<expr><operator>.</operator><name>relation_needs_toast_table</name> <operator>=</operator> <name>orioledb_relation_needs_toast_table</name></expr>,
		<expr><operator>.</operator><name>relation_toast_am</name> <operator>=</operator> <name>orioledb_relation_toast_am</name></expr>,

		<expr><operator>.</operator><name>relation_estimate_size</name> <operator>=</operator> <name>orioledb_estimate_rel_size</name></expr>,
		<expr><operator>.</operator><name>scan_bitmap_next_block</name> <operator>=</operator> <name>orioledb_scan_bitmap_next_block</name></expr>,
		<expr><operator>.</operator><name>scan_bitmap_next_tuple</name> <operator>=</operator> <name>orioledb_scan_bitmap_next_tuple</name></expr>,
		<expr><operator>.</operator><name>scan_sample_next_block</name> <operator>=</operator> <name>orioledb_scan_sample_next_block</name></expr>,
		<expr><operator>.</operator><name>scan_sample_next_tuple</name> <operator>=</operator> <name>orioledb_scan_sample_next_tuple</name></expr>
	}</block></expr>,
	<expr><operator>.</operator><name>get_row_ref_type</name> <operator>=</operator> <name>orioledb_get_row_ref_type</name></expr>,
	<expr><operator>.</operator><name>tuple_insert</name> <operator>=</operator> <name>orioledb_tuple_insert</name></expr>,
	<expr><operator>.</operator><name>multi_insert</name> <operator>=</operator> <name>orioledb_multi_insert</name></expr>,
	<expr><operator>.</operator><name>tuple_insert_on_conflict</name> <operator>=</operator> <name>orioledb_tuple_insert_on_conflict</name></expr>,
	<expr><operator>.</operator><name>tuple_delete</name> <operator>=</operator> <name>orioledb_tuple_delete</name></expr>,
	<expr><operator>.</operator><name>tuple_update</name> <operator>=</operator> <name>orioledb_tuple_update</name></expr>,
	<expr><operator>.</operator><name>tuple_lock</name> <operator>=</operator> <name>orioledb_tuple_lock</name></expr>,
	<expr><operator>.</operator><name>tuple_fetch_row_version</name> <operator>=</operator> <name>orioledb_fetch_row_version</name></expr>,
	<expr><operator>.</operator><name>tuple_refetch_row_version</name> <operator>=</operator> <name>orioledb_refetch_row_version</name></expr>,
	<expr><operator>.</operator><name>init_modify</name> <operator>=</operator> <name>orioledb_init_modify</name></expr>,
	<expr><operator>.</operator><name>free_rd_amcache</name> <operator>=</operator> <name>orioledb_free_rd_amcache</name></expr>,
	<expr><operator>.</operator><name>rewrite_table</name> <operator>=</operator> <name>orioledb_rewrite_table</name></expr>,
	<expr><operator>.</operator><name>change_not_null</name> <operator>=</operator> <name>orioledb_change_not_null</name></expr>,
	<expr><operator>.</operator><name>alter_column_type</name> <operator>=</operator> <name>orioledb_alter_column_type</name></expr>,
	<expr><operator>.</operator><name>define_index_validate</name> <operator>=</operator> <name>orioledb_define_index_validate</name></expr>,
	<expr><operator>.</operator><name>define_index</name> <operator>=</operator> <name>orioledb_define_index</name></expr>,
	<expr><operator>.</operator><name>analyze_table</name> <operator>=</operator> <name>orioledb_analyze_table</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>bool</name></type>
<name>is_orioledb_rel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_tableam</name></name> <operator>==</operator> <operator>(</operator><name>TableAmRoutine</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>orioledb_am_methods</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>Datum</name></type>		<name>orioledb_tableam_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>orioledb_tableam_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>orioledb_tableam_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>orioledb_check_shmem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><operator>&amp;</operator><name>orioledb_am_methods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns private descriptor for relation
 *
 * In order to save some hash lookup, we cache descriptor in rel-&gt;rd_amcache.
 * Since rel-&gt;rd_amcache is automatically freed on cache invalidation, we
 * can't set rel-&gt;rd_amcache to the descriptor directly.  But we may use
 * pointer to allocated area contained pointer to descriptor.
 */</comment>
<function><type><name>OTableDescr</name> <modifier>*</modifier></type>
<name>relation_get_descr</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OTableDescr</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ORelOids</name></type>	<name>oids</name> <init>= <expr><block>{<expr><name>MyDatabaseId</name></expr>, <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>, <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr>}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_orioledb_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a orioledb table"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>OTableDescr</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>o_fetch_table_descr</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>table_descr_inc_refcnt</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_keys_from_rowid</name><parameter_list>(<parameter><decl><type><name>OIndexDescr</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>pkDatum</name></decl></parameter>, <parameter><decl><type><name>OBTreeKeyBound</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
					<parameter><decl><type><name>BTreeLocationHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>CommitSeqNo</name> <modifier>*</modifier></type><name>csn</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>rowid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>p</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>nonLeafTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>id</name><operator>-&gt;</operator><name>primaryIsCtid</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ORowIdAddendumNonCtid</name> <modifier>*</modifier></type><name>add</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rowid</name> <operator>=</operator> <call><name>DatumGetByteaP</name><argument_list>(<argument><expr><name>pkDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>rowid</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>add</name> <operator>=</operator> <operator>(</operator><name>ORowIdAddendumNonCtid</name> <operator>*</operator><operator>)</operator> <name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ORowIdAddendumNonCtid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>formatFlags</name></name> <operator>=</operator> <name><name>add</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>hint</name> <operator>=</operator> <name><name>add</name><operator>-&gt;</operator><name>hint</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>csn</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>csn</name> <operator>=</operator> <name><name>add</name><operator>-&gt;</operator><name>csn</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>version</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>version</name> <operator>=</operator> <call><name>o_tuple_get_version</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>o_fill_key_bound</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>BTreeKeyNonLeafKey</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ORowIdAddendumCtid</name> <modifier>*</modifier></type><name>add</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rowid</name> <operator>=</operator> <call><name>DatumGetByteaP</name><argument_list>(<argument><expr><name>pkDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>rowid</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>add</name> <operator>=</operator> <operator>(</operator><name>ORowIdAddendumCtid</name> <operator>*</operator><operator>)</operator> <name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>hint</name> <operator>=</operator> <name><name>add</name><operator>-&gt;</operator><name>hint</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>csn</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>csn</name> <operator>=</operator> <name><name>add</name><operator>-&gt;</operator><name>csn</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>version</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>version</name> <operator>=</operator> <name><name>add</name><operator>-&gt;</operator><name>version</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ORowIdAddendumCtid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name>TIDOID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name>O_VALUE_BOUND_LOWER</name> <operator>|</operator> <name>O_VALUE_BOUND_INCLUSIVE</name> <operator>|</operator> <name>O_VALUE_BOUND_COERCIBLE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>comparator</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>o_check_constraints</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Check the constraints of the tuple.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecConstraints</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Also check the tuple against the partition constraint, if there is one;
	 * except that if we got here via tuple-routing, we don't need to if
	 * there's no BR trigger defined on the partition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>rinfo</name><operator>-&gt;</operator><name>ri_RootResultRelInfo</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		 <operator>(</operator><name><name>rinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
		  <name><name>rinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecPartitionCheck</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
