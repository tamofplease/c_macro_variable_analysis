<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="../out/cloned_projects/ish/util/sync.h"><cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UTIL_SYNC_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTIL_SYNC_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdatomic.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;setjmp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"misc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debug.h"</cpp:file></cpp:include>

<comment type="line">// locks, implemented using pthread</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCK_DEBUG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name>m</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pthread_t</name></type> <name>owner</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LOCK_DEBUG</name></expr></cpp:if>
    <struct>struct <name>lock_debug</name> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt> <comment type="line">// doubles as locked</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>pid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>initialized</name></decl>;</decl_stmt>
    }</block> <decl><name>debug</name></decl>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>lock_t</name>;</typedef>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>lock_init</name><parameter_list>(<parameter><decl><type><name>lock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>m</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LOCK_DEBUG</name></expr></cpp:if>
    <expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>debug</name></name> <operator>=</operator> <operator>(</operator>struct <name>lock_debug</name><operator>)</operator> <block>{
        <expr><operator>.</operator><name>initialized</name> <operator>=</operator> <name>true</name></expr>,
    }</block></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LOCK_DEBUG</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCK_INITIALIZER</name></cpp:macro> <cpp:value>{PTHREAD_MUTEX_INITIALIZER, 0, { .initialized = true }}</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCK_INITIALIZER</name></cpp:macro> <cpp:value>{PTHREAD_MUTEX_INITIALIZER, 0}</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>__lock</name><argument_list>(<argument><expr><name>lock_t</name> <operator>*</operator><name>lock</name></expr></argument>, <argument><expr><macro><name>__attribute__</name><argument_list>(<argument>(unused)</argument>)</argument_list></macro> <specifier>const</specifier> <name>char</name> <operator>*</operator><name>file</name></expr></argument>, <argument><expr><macro><name>__attribute__</name><argument_list>(<argument>(unused)</argument>)</argument_list></macro> <name>int</name> <name>line</name></expr></argument>)</argument_list> <block>{<block_content>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>m</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>owner</name></name> <operator>=</operator> <call><name>pthread_self</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LOCK_DEBUG</name></expr></cpp:if>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>debug</name><operator>.</operator><name>initialized</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>lock</name><operator>-&gt;</operator><name>debug</name><operator>.</operator><name>file</name></name> <operator>&amp;&amp;</operator> <literal type="string">"Attempting to recursively lock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>debug</name><operator>.</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>debug</name><operator>.</operator><name>line</name></name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
    <function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>current_pid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>debug</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <call><name>current_pid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></decl></decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lock</name><parameter_list>(<parameter><type><name>lock</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__lock(lock, __FILE__, __LINE__)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>unlock</name><parameter_list>(<parameter><decl><type><name>lock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LOCK_DEBUG</name></expr></cpp:if>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>debug</name><operator>.</operator><name>initialized</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>debug</name><operator>.</operator><name>file</name></name> <operator>&amp;&amp;</operator> <literal type="string">"Attempting to unlock an unlocked lock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>debug</name></name> <operator>=</operator> <operator>(</operator>struct <name>lock_debug</name><operator>)</operator> <block>{ <expr><operator>.</operator><name>initialized</name> <operator>=</operator> <name>true</name></expr> }</block></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>owner</name></name> <operator>=</operator> <call><name>zero_init</name><argument_list>(<argument><expr><name>pthread_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>m</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>trylock</name><argument_list>(<argument><expr><name>lock_t</name> <operator>*</operator><name>lock</name></expr></argument>, <argument><expr><macro><name>__attribute__</name><argument_list>(<argument>(unused)</argument>)</argument_list></macro> <specifier>const</specifier> <name>char</name> <operator>*</operator><name>file</name></expr></argument>, <argument><expr><macro><name>__attribute__</name><argument_list>(<argument>(unused)</argument>)</argument_list></macro> <name>int</name> <name>line</name></expr></argument>)</argument_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><call><name>pthread_mutex_trylock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>m</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LOCK_DEBUG</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>status</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>debug</name><operator>.</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>debug</name><operator>.</operator><name>line</name></name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
        <function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>current_pid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
        <expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>debug</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <call><name>current_pid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>trylock</name><parameter_list>(<parameter><type><name>lock</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>trylock(lock, __FILE__, __LINE__)</cpp:value></cpp:define>

<comment type="line">// conditions, implemented using pthread conditions but hacked so you can also</comment>
<comment type="line">// be woken by a signal</comment>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>pthread_cond_t</name></type> <name>cond</name></decl>;</decl_stmt>
}</block></struct></type> <name>cond_t</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COND_INITIALIZER</name></cpp:macro> <cpp:value>((cond_t) {PTHREAD_COND_INITIALIZER})</cpp:value></cpp:define>

<comment type="line">// Must call before using the condition</comment>
<function_decl><type><name>void</name></type> <name>cond_init</name><parameter_list>(<parameter><decl><type><name>cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="line">// Must call when finished with the condition (currently doesn't do much but might do something important eventually I guess)</comment>
<function_decl><type><name>void</name></type> <name>cond_destroy</name><parameter_list>(<parameter><decl><type><name>cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="line">// Releases the lock, waits for the condition, and reacquires the lock.</comment>
<comment type="line">// Returns _EINTR if waiting stopped because the thread received a signal,</comment>
<comment type="line">// _ETIMEDOUT if waiting stopped because the timout expired, 0 otherwise.</comment>
<comment type="line">// Will never return _ETIMEDOUT if timeout is NULL.</comment>
<function_decl><type><name>int</name> <name>must_check</name></type> <name>wait_for</name><parameter_list>(<parameter><decl><type><name>cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>, <parameter><decl><type><name>lock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>timespec</name></name> <modifier>*</modifier></type><name>timeout</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="line">// Same as wait_for, except it will never return _EINTR</comment>
<function_decl><type><name>int</name></type> <name>wait_for_ignore_signals</name><parameter_list>(<parameter><decl><type><name>cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>, <parameter><decl><type><name>lock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>timespec</name></name> <modifier>*</modifier></type><name>timeout</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="line">// Wake up all waiters.</comment>
<function_decl><type><name>void</name></type> <name>notify</name><parameter_list>(<parameter><decl><type><name>cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="line">// Wake up one waiter.</comment>
<function_decl><type><name>void</name></type> <name>notify_once</name><parameter_list>(<parameter><decl><type><name>cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="line">// this is a read-write lock that prefers writers, i.e. if there are any</comment>
<comment type="line">// writers waiting a read lock will block.</comment>
<comment type="line">// on darwin pthread_rwlock_t is already like this, on linux you can configure</comment>
<comment type="line">// it to prefer writers. not worrying about anything else right now.</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>pthread_rwlock_t</name></type> <name>l</name></decl>;</decl_stmt>
    <comment type="line">// 0: unlocked</comment>
    <comment type="line">// -1: write-locked</comment>
    <comment type="line">// &gt;0: read-locked with this many readers</comment>
    <decl_stmt><decl><type><name>atomic_int</name></type> <name>val</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>pid</name></decl>;</decl_stmt>
}</block></struct></type> <name>wrlock_t</name>;</typedef>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>wrlock_init</name><parameter_list>(<parameter><decl><type><name>wrlock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>pthread_rwlockattr_t</name> <modifier>*</modifier></type><name>pattr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GLIBC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><name>pthread_rwlockattr_t</name></type> <name>attr</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pattr</name> <operator>=</operator> <operator>&amp;</operator><name>attr</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_rwlockattr_init</name><argument_list>(<argument><expr><name>pattr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_rwlockattr_setkind_np</name><argument_list>(<argument><expr><name>pattr</name></expr></argument>, <argument><expr><name>PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><call><name>pthread_rwlock_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>l</name></name></expr></argument>, <argument><expr><name>pattr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>__builtin_trap</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name><name>lock</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <name><name>lock</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>current_pid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>wrlock_destroy</name><parameter_list>(<parameter><decl><type><name>wrlock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>pthread_rwlock_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>__builtin_trap</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>read_wrlock</name><parameter_list>(<parameter><decl><type><name>wrlock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>pthread_rwlock_rdlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>__builtin_trap</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>val</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>val</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>read_wrunlock</name><parameter_list>(<parameter><decl><type><name>wrlock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>val</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>val</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>__builtin_trap</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>__write_wrlock</name><parameter_list>(<parameter><decl><type><name>wrlock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>__builtin_trap</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>val</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <call><name>current_pid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>write_wrlock</name><parameter_list>(<parameter><type><name>lock</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__write_wrlock(lock, __FILE__, __LINE__)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>write_wrunlock</name><parameter_list>(<parameter><decl><type><name>wrlock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>val</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name><name>lock</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <name><name>lock</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>__builtin_trap</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>extern</specifier> <name>__thread</name> <name>sigjmp_buf</name></type> <name>unwind_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>__thread</name> <name>bool</name></type> <name>should_unwind</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>sigunwind_start</name><parameter_list>()</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name>unwind_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>should_unwind</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>should_unwind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>sigunwind_end</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>should_unwind</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
