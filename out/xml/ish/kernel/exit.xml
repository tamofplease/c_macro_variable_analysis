<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="../out/cloned_projects/ish/kernel/exit.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"kernel/calls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"kernel/mm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"kernel/futex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"kernel/ptrace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fs/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fs/tty.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>halt_system</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>exit_tgroup</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>tgroup</name></name> <modifier>*</modifier></type><name>group</name> <init>= <expr><name><name>task</name><operator>-&gt;</operator><name>group</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>list_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>task</name><operator>-&gt;</operator><name>group_links</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>group_dead</name> <init>= <expr><call><name>list_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>threads</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>group_dead</name></expr>)</condition> <block>{<block_content>
        <comment type="line">// don't need to lock the group since the only pointers to it come from:</comment>
        <comment type="line">// - other threads' current-&gt;group, but there are none left thanks to that list_empty call</comment>
        <comment type="line">// - locking pids_lock first, which do_exit did</comment>
        <if_stmt><if>if <condition>(<expr><name><name>group</name><operator>-&gt;</operator><name>itimer</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>timer_free</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>itimer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// The group will be removed from its group and session by reap_if_zombie,</comment>
        <comment type="line">// because fish tries to set the pgid to that of an exited but not reaped</comment>
        <comment type="line">// task.</comment>
        <comment type="line">// https://github.com/Microsoft/WSL/issues/2786</comment>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>group_dead</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>exit_hook</name>)<parameter_list>(<parameter><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>)</parameter_list> <init>= <expr><name>NULL</name></expr></init>;</function_decl>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>find_new_parent</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>new_parent</name></decl>;</decl_stmt>
    <macro><name>list_for_each_entry</name><argument_list>(<argument>&amp;task-&gt;group-&gt;threads</argument>, <argument>new_parent</argument>, <argument>group_links</argument>)</argument_list></macro> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>new_parent</name><operator>-&gt;</operator><name>exiting</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>new_parent</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><call><name>pid_get_task</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>noreturn</name> <name>void</name></type> <name>do_exit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="line">// has to happen before mm_release</comment>
    <decl_stmt><decl><type><name>addr_t</name></type> <name>clear_tid</name> <init>= <expr><name><name>current</name><operator>-&gt;</operator><name>clear_tid</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>clear_tid</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>pid_t_</name></type> <name>zero</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>user_put</name><argument_list>(<argument><expr><name>clear_tid</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>futex_wake</name><argument_list>(<argument><expr><name>clear_tid</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// release all our resources</comment>
    <expr_stmt><expr><call><name>mm_release</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>mm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>mm</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fdtable_release</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>files</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>files</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fs_info_release</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>fs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <comment type="line">// sighand must be released below so it can be protected by pids_lock</comment>
    <comment type="line">// since it can be accessed by other threads</comment>

    <comment type="line">// save things that our parent might be interested in</comment>
    <expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>exit_code</name></name> <operator>=</operator> <name>status</name></expr>;</expr_stmt> <comment type="line">// FIXME locking</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>rusage_</name></name></type> <name>rusage</name> <init>= <expr><call><name>rusage_get_current</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rusage_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>rusage</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rusage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>rusage_</name></name></type> <name>group_rusage</name> <init>= <expr><name><name>current</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>rusage</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// the actual freeing needs pids_lock</comment>
    <expr_stmt><expr><call><name>lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pids_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>exiting</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <comment type="line">// release the sighand</comment>
    <expr_stmt><expr><call><name>sighand_release</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>sighand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>sighand</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>sigqueue</name></name> <modifier>*</modifier></type><name>sigqueue</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sigqueue_tmp</name></decl>;</decl_stmt>
    <macro><name>list_for_each_entry_safe</name><argument_list>(<argument>&amp;current-&gt;queue</argument>, <argument>sigqueue</argument>, <argument>sigqueue_tmp</argument>, <argument>queue</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>list_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sigqueue</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sigqueue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <decl_stmt><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>leader</name> <init>= <expr><name><name>current</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>leader</name></name></expr></init></decl>;</decl_stmt>

    <comment type="line">// reparent children</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>new_parent</name> <init>= <expr><call><name>find_new_parent</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>child</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
    <macro><name>list_for_each_entry_safe</name><argument_list>(<argument>&amp;current-&gt;children</argument>, <argument>child</argument>, <argument>tmp</argument>, <argument>siblings</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><name><name>child</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>new_parent</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>list_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>child</name><operator>-&gt;</operator><name>siblings</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>list_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>new_parent</name><operator>-&gt;</operator><name>children</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>child</name><operator>-&gt;</operator><name>siblings</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><call><name>exit_tgroup</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="line">// notify parent that we died</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>parent</name> <init>= <expr><name><name>leader</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>parent</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// init died</comment>
            <expr_stmt><expr><call><name>halt_system</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>leader</name><operator>-&gt;</operator><name>zombie</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>notify</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>child_exit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>struct</name> <name>siginfo_</name></name></type> <name>info</name> <init>= <expr><block>{
                <expr><operator>.</operator><name>code</name> <operator>=</operator> <name>SI_KERNEL_</name></expr>,
                <expr><operator>.</operator><name><name>child</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>pid</name></name></expr>,
                <expr><operator>.</operator><name><name>child</name><operator>.</operator><name>uid</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>uid</name></name></expr>,
                <expr><operator>.</operator><name><name>child</name><operator>.</operator><name>status</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>exit_code</name></name></expr>,
                <expr><operator>.</operator><name><name>child</name><operator>.</operator><name>utime</name></name> <operator>=</operator> <call><name>clock_from_timeval</name><argument_list>(<argument><expr><name><name>group_rusage</name><operator>.</operator><name>utime</name></name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name><name>child</name><operator>.</operator><name>stime</name></name> <operator>=</operator> <call><name>clock_from_timeval</name><argument_list>(<argument><expr><name><name>group_rusage</name><operator>.</operator><name>stime</name></name></expr></argument>)</argument_list></call></expr>,
            }</block></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>leader</name><operator>-&gt;</operator><name>exit_signal</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>send_signal</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name><name>leader</name><operator>-&gt;</operator><name>exit_signal</name></name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>exit_hook</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>exit_hook</name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>vfork_notify</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>current</name> <operator>!=</operator> <name>leader</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>task_destroy</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pids_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pthread_exit</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>noreturn</name> <name>void</name></type> <name>do_exit_group</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>tgroup</name></name> <modifier>*</modifier></type><name>group</name> <init>= <expr><name><name>current</name><operator>-&gt;</operator><name>group</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pids_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>group</name><operator>-&gt;</operator><name>doing_group_exit</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>doing_group_exit</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>group_exit_code</name></name> <operator>=</operator> <name>status</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>status</name> <operator>=</operator> <name><name>group</name><operator>-&gt;</operator><name>group_exit_code</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// kill everyone else in the group</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>task</name></decl>;</decl_stmt>
    <macro><name>list_for_each_entry</name><argument_list>(<argument>&amp;group-&gt;threads</argument>, <argument>task</argument>, <argument>group_links</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>deliver_signal</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>SIGKILL_</name></expr></argument>, <argument><expr><name>SIGINFO_NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>stopped</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notify</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>task</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>stopped_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pids_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>do_exit</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// always called from init process</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>halt_system</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="line">// brutally murder everything</comment>
    <comment type="line">// which will leave everything in an inconsistent state. I will solve this problem later.</comment>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_PID</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>pid_get_task</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>task</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pthread_kill</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>thread</name></name></expr></argument>, <argument><expr><name>SIGKILL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="line">// unmount all filesystems</comment>
    <expr_stmt><expr><call><name>lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mounts_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>mount</name></name> <modifier>*</modifier></type><name>mount</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
    <macro><name>list_for_each_entry_safe</name><argument_list>(<argument>&amp;mounts</argument>, <argument>mount</argument>, <argument>tmp</argument>, <argument>mounts</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>mount_remove</name><argument_list>(<argument><expr><name>mount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mounts_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>dword_t</name></type> <name>sys_exit</name><parameter_list>(<parameter><decl><type><name>dword_t</name></type> <name>status</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>STRACE</name><argument_list>(<argument><expr><literal type="string">"exit(%d)\n"</literal></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>do_exit</name><argument_list>(<argument><expr><name>status</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>dword_t</name></type> <name>sys_exit_group</name><parameter_list>(<parameter><decl><type><name>dword_t</name></type> <name>status</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>STRACE</name><argument_list>(<argument><expr><literal type="string">"exit_group(%d)\n"</literal></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>do_exit_group</name><argument_list>(<argument><expr><name>status</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WNOHANG_</name></cpp:macro> <cpp:value>(1 &lt;&lt; 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WUNTRACED_</name></cpp:macro> <cpp:value>(1 &lt;&lt; 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WEXITED_</name></cpp:macro> <cpp:value>(1 &lt;&lt; 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WCONTINUED_</name></cpp:macro> <cpp:value>(1 &lt;&lt; 3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WNOWAIT_</name></cpp:macro> <cpp:value>(1 &lt;&lt; 24)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__WALL_</name></cpp:macro> <cpp:value>(1 &lt;&lt; 30)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>P_ALL_</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>P_PID_</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>P_PGID_</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<comment type="line">// returns false if the task cannot be reaped and true if the task was reaped</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>reap_if_zombie</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>siginfo_</name></name> <modifier>*</modifier></type><name>info_out</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rusage_</name></name> <modifier>*</modifier></type><name>rusage_out</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>task</name><operator>-&gt;</operator><name>zombie</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>task</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>dword_t</name></type> <name>exit_code</name> <init>= <expr><name><name>task</name><operator>-&gt;</operator><name>exit_code</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>doing_group_exit</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>exit_code</name> <operator>=</operator> <name><name>task</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>group_exit_code</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>info_out</name><operator>-&gt;</operator><name>child</name><operator>.</operator><name>status</name></name> <operator>=</operator> <name>exit_code</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>rusage_</name></name></type> <name>rusage</name> <init>= <expr><name><name>task</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>rusage</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>WNOWAIT_</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>rusage_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>children_rusage</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rusage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>rusage_out</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>rusage_out</name> <operator>=</operator> <name>rusage</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>task</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// WNOWAIT means don't destroy the child, instead leave it so it could be waited for again.</comment>
    <if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>WNOWAIT_</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// tear down group</comment>
    <expr_stmt><expr><call><name>cond_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>task</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>child_exit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>task_leave_session</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>list_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>task</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>pgroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>group</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>task_destroy</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>notify_if_stopped</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>siginfo_</name></name> <modifier>*</modifier></type><name>info_out</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>task</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>stopped</name> <init>= <expr><name><name>task</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>stopped</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>task</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>stopped</name> <operator>||</operator> <name><name>task</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>group_exit_code</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>dword_t</name></type> <name>exit_code</name> <init>= <expr><name><name>task</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>group_exit_code</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>group_exit_code</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info_out</name><operator>-&gt;</operator><name>child</name><operator>.</operator><name>status</name></name> <operator>=</operator> <name>exit_code</name></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>reap_if_needed</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>siginfo_</name></name> <modifier>*</modifier></type><name>info_out</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rusage_</name></name> <modifier>*</modifier></type><name>rusage_out</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>task_is_leader</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>WUNTRACED_</name> <operator>&amp;&amp;</operator> <call><name>notify_if_stopped</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>info_out</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>options</name> <operator>&amp;</operator> <name>WEXITED_</name> <operator>&amp;&amp;</operator> <call><name>reap_if_zombie</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>info_out</name></expr></argument>, <argument><expr><name>rusage_out</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>info_out</name><operator>-&gt;</operator><name>sig</name></name> <operator>=</operator> <name>SIGCHLD_</name></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>task</name><operator>-&gt;</operator><name>ptrace</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>ptrace</name><operator>.</operator><name>stopped</name></name> <operator>&amp;&amp;</operator> <name><name>task</name><operator>-&gt;</operator><name>ptrace</name><operator>.</operator><name>signal</name></name></expr>)</condition> <block>{<block_content>
        <comment type="line">// I had this code here because it made something work, but it's now</comment>
        <comment type="line">// making GDB think we support events (we don't). I can't remember what</comment>
        <comment type="line">// it fixed but until then commenting it out for now.</comment>
        <expr_stmt><expr><name><name>info_out</name><operator>-&gt;</operator><name>child</name><operator>.</operator><name>status</name></name> <operator>=</operator> <comment type="block">/* task-&gt;ptrace.trap_event &lt;&lt; 16 |*/</comment> <name><name>task</name><operator>-&gt;</operator><name>ptrace</name><operator>.</operator><name>signal</name></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>ptrace</name><operator>.</operator><name>signal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>task</name><operator>-&gt;</operator><name>ptrace</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>task</name><operator>-&gt;</operator><name>ptrace</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>do_wait</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>idtype</name></decl></parameter>, <parameter><decl><type><name>pid_t_</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>siginfo_</name></name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rusage_</name></name> <modifier>*</modifier></type><name>rusage</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>idtype</name> <operator>!=</operator> <name>P_ALL_</name> <operator>&amp;&amp;</operator> <name>idtype</name> <operator>!=</operator> <name>P_PID_</name> <operator>&amp;&amp;</operator> <name>idtype</name> <operator>!=</operator> <name>P_PGID_</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>_EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>WNOHANG_</name><operator>|</operator><name>WUNTRACED_</name><operator>|</operator><name>WEXITED_</name><operator>|</operator><name>WCONTINUED_</name><operator>|</operator><name>WNOWAIT_</name><operator>|</operator><name>__WALL_</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>_EINVAL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pids_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>got_signal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<label><name>retry</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>idtype</name> <operator>!=</operator> <name>P_PID_</name></expr>)</condition> <block>{<block_content>
        <comment type="line">// look for a zombie child</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>no_children</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
        <macro><name>list_for_each_entry</name><argument_list>(<argument>&amp;current-&gt;group-&gt;threads</argument>, <argument>parent</argument>, <argument>group_links</argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>task</name></decl>;</decl_stmt>
            <macro><name>list_for_each_entry</name><argument_list>(<argument>&amp;current-&gt;children</argument>, <argument>task</argument>, <argument>siblings</argument>)</argument_list></macro> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>task_is_leader</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>idtype</name> <operator>==</operator> <name>P_PGID_</name> <operator>&amp;&amp;</operator> <name><name>task</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>pgid</name></name> <operator>!=</operator> <name>id</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>no_children</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>child</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <name><name>task</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>reap_if_needed</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>rusage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <goto>goto <name>found_something</name>;</goto></block_content></block></if></if_stmt>
            </block_content>}</block>
        </block_content>}</block>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <name>_ECHILD</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>no_children</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">// check if this child is a zombie</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>pid_get_task_zombie</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <name>_ECHILD</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>task</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>task</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>task</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>group</name></name> <operator>!=</operator> <name><name>current</name><operator>-&gt;</operator><name>group</name></name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>task</name> <operator>=</operator> <name><name>task</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>leader</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>child</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>reap_if_needed</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>rusage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>found_something</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// WNOHANG leaves the info in an implementation-defined state. set the pid</comment>
    <comment type="line">// to 0 so wait4 can pass that along correctly.</comment>
    <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>child</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>WNOHANG_</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>sig</name></name> <operator>=</operator> <name>SIGCHLD_</name></expr>;</expr_stmt>
        <goto>goto <name>found_something</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>err</name> <operator>=</operator> <name>_EINTR</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>got_signal</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

    <comment type="line">// no matching zombie found, wait for one</comment>
    <if_stmt><if>if <condition>(<expr><call><name>wait_for</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>child_exit</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pids_lock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="line">// maybe we got a SIGCHLD! go through the loop one more time to make</comment>
        <comment type="line">// sure the newly exited process is returned in that case.</comment>
        <expr_stmt><expr><name>got_signal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <goto>goto <name>retry</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <goto>goto <name>retry</name>;</goto>

    <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>sig</name></name> <operator>=</operator> <name>SIGCHLD_</name></expr>;</expr_stmt>
<label><name>found_something</name>:</label>
    <expr_stmt><expr><call><name>unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pids_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>error</name>:</label>
    <expr_stmt><expr><call><name>unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pids_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>err</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>dword_t</name></type> <name>sys_waitid</name><parameter_list>(<parameter><decl><type><name>int_t</name></type> <name>idtype</name></decl></parameter>, <parameter><decl><type><name>pid_t_</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>addr_t</name></type> <name>info_addr</name></decl></parameter>, <parameter><decl><type><name>int_t</name></type> <name>options</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>STRACE</name><argument_list>(<argument><expr><literal type="string">"waitid(%d, %d, %#x, %#x)"</literal></expr></argument>, <argument><expr><name>idtype</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>info_addr</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>siginfo_</name></name></type> <name>info</name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int_t</name></type> <name>res</name> <init>= <expr><call><name>do_wait</name><argument_list>(<argument><expr><name>idtype</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>res</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>info</name><operator>.</operator><name>child</name><operator>.</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>info_addr</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>user_put</name><argument_list>(<argument><expr><name>info_addr</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>_EFAULT</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>dword_t</name></type> <name>sys_wait4</name><parameter_list>(<parameter><decl><type><name>pid_t_</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>addr_t</name></type> <name>status_addr</name></decl></parameter>, <parameter><decl><type><name>dword_t</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>addr_t</name></type> <name>rusage_addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>STRACE</name><argument_list>(<argument><expr><literal type="string">"wait4(%d, %#x, %#x, %#x)"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>status_addr</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>rusage_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>WNOWAIT_</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>_EINVAL</name></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>idtype</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>id</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>idtype</name> <operator>=</operator> <name>P_PID_</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>id</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>idtype</name> <operator>=</operator> <name>P_ALL_</name></expr>;</expr_stmt></block_content></block></if>
    <else>else <block>{<block_content>
        <expr_stmt><expr><name>idtype</name> <operator>=</operator> <name>P_PGID_</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>id</name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>pgid</name></name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>id</name> <operator>=</operator> <operator>-</operator><name>id</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>siginfo_</name></name></type> <name>info</name> <init>= <expr><block>{<expr><operator>.</operator><name><name>child</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0xbaba</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>rusage_</name></name></type> <name>rusage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int_t</name></type> <name>res</name> <init>= <expr><call><name>do_wait</name><argument_list>(<argument><expr><name>idtype</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rusage</name></expr></argument>, <argument><expr><name>options</name> <operator>|</operator> <name>WEXITED_</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>res</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>info</name><operator>.</operator><name>child</name><operator>.</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>status_addr</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>user_put</name><argument_list>(<argument><expr><name>status_addr</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>child</name><operator>.</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>_EFAULT</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>rusage_addr</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>user_put</name><argument_list>(<argument><expr><name>rusage_addr</name></expr></argument>, <argument><expr><name>rusage</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>_EFAULT</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name><name>info</name><operator>.</operator><name>child</name><operator>.</operator><name>pid</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>dword_t</name></type> <name>sys_waitpid</name><parameter_list>(<parameter><decl><type><name>pid_t_</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>addr_t</name></type> <name>status_addr</name></decl></parameter>, <parameter><decl><type><name>dword_t</name></type> <name>options</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>sys_wait4</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>status_addr</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
