<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="../out/cloned_projects/ish/kernel/task.h"><cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TASK_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TASK_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"emu/cpu.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"kernel/mm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"kernel/fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"kernel/signal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"kernel/resource.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fs/sockrestart.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util/list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util/timer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util/sync.h"</cpp:file></cpp:include>

<comment type="line">// everything here is private to the thread executing this task and needs no</comment>
<comment type="line">// locking, unless otherwise specified</comment>
<struct>struct <name>task</name> <block>{
    <decl_stmt><decl><type><name><name>struct</name> <name>cpu_state</name></name></type> <name>cpu</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>mm</name></name> <modifier>*</modifier></type><name>mm</name></decl>;</decl_stmt> <comment type="line">// locked by general_lock</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>mem</name></name> <modifier>*</modifier></type><name>mem</name></decl>;</decl_stmt> <comment type="line">// pointer to mm.mem, for convenience</comment>
    <decl_stmt><decl><type><name>pthread_t</name></type> <name>thread</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>threadid</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>tgroup</name></name> <modifier>*</modifier></type><name>group</name></decl>;</decl_stmt> <comment type="line">// immutable</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>list</name></name></type> <name>group_links</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pid_t_</name></type> <name>pid</name></decl>, <decl><type ref="prev"/><name>tgid</name></decl>;</decl_stmt> <comment type="line">// immutable</comment>
    <decl_stmt><decl><type><name>uid_t_</name></type> <name>uid</name></decl>, <decl><type ref="prev"/><name>gid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uid_t_</name></type> <name>euid</name></decl>, <decl><type ref="prev"/><name>egid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uid_t_</name></type> <name>suid</name></decl>, <decl><type ref="prev"/><name>sgid</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_GROUPS</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>ngroups</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uid_t_</name></type> <name><name>groups</name><index>[<expr><name>MAX_GROUPS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <name><name>comm</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></type> <name>__strncpy_safe</name></decl>;</decl_stmt> <comment type="line">// locked by general_lock</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>did_exec</name></decl>;</decl_stmt> <comment type="line">// for that one annoying setsid edge case</comment>

    <decl_stmt><decl><type><name><name>struct</name> <name>fdtable</name></name> <modifier>*</modifier></type><name>files</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>fs_info</name></name> <modifier>*</modifier></type><name>fs</name></decl>;</decl_stmt>

    <comment type="line">// locked by sighand-&gt;lock</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>sighand</name></name> <modifier>*</modifier></type><name>sighand</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sigset_t_</name></type> <name>blocked</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sigset_t_</name></type> <name>pending</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sigset_t_</name></type> <name>waiting</name></decl>;</decl_stmt> <comment type="line">// if nonzero, an ongoing call to sigtimedwait is waiting on these</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>list</name></name></type> <name>queue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cond_t</name></type> <name>pause</name></decl>;</decl_stmt> <comment type="line">// please don't signal this</comment>
    <comment type="line">// private</comment>
    <decl_stmt><decl><type><name>sigset_t_</name></type> <name>saved_mask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>has_saved_mask</name></decl>;</decl_stmt>

    <struct>struct <block>{
        <comment type="line">// Locks all ptrace-related things</comment>
        <decl_stmt><decl><type><name>lock_t</name></type> <name>lock</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>cond_t</name></type> <name>cond</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>bool</name></type> <name>traced</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>stopped</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>signal</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>siginfo_</name></name></type> <name>info</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>trap_event</name></decl>;</decl_stmt>
    }</block> <decl><name>ptrace</name></decl>;</struct>

    <comment type="line">// locked by pids_lock</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>list</name></name></type> <name>children</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>list</name></name></type> <name>siblings</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>addr_t</name></type> <name>clear_tid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>addr_t</name></type> <name>robust_list</name></decl>;</decl_stmt>

    <comment type="line">// locked by pids_lock</comment>
    <decl_stmt><decl><type><name>dword_t</name></type> <name>exit_code</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>zombie</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>exiting</name></decl>;</decl_stmt>

    <comment type="line">// this structure is allocated on the stack of the parent's clone() call</comment>
    <struct>struct <name>vfork_info</name> <block>{
        <decl_stmt><decl><type><name>bool</name></type> <name>done</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>cond_t</name></type> <name>cond</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>lock_t</name></type> <name>lock</name></decl>;</decl_stmt>
    }</block> <decl><modifier>*</modifier><name>vfork</name></decl>;</struct>
    <decl_stmt><decl><type><name>int</name></type> <name>exit_signal</name></decl>;</decl_stmt>

    <comment type="line">// lock for anything that needs locking but is not covered by some other lock</comment>
    <comment type="line">// specifically: comm, mm</comment>
    <decl_stmt><decl><type><name>lock_t</name></type> <name>general_lock</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>task_sockrestart</name></name></type> <name>sockrestart</name></decl>;</decl_stmt>

    <comment type="line">// current condition/lock, so it can be notified in case of a signal</comment>
    <decl_stmt><decl><type><name>cond_t</name> <modifier>*</modifier></type><name>waiting_cond</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>lock_t</name> <modifier>*</modifier></type><name>waiting_lock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>lock_t</name></type> <name>waiting_cond_lock</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="line">// current will always give the process that is currently executing</comment>
<comment type="line">// if I have to stop using __thread, current will become a macro</comment>
<extern>extern __thread struct task *current;</extern>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>task_set_mm</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>mm</name></name> <modifier>*</modifier></type><name>mm</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>mm</name></name> <operator>=</operator> <name>mm</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>mem</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>task</name><operator>-&gt;</operator><name>mm</name><operator>-&gt;</operator><name>mem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>cpu</name><operator>.</operator><name>mmu</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>task</name><operator>-&gt;</operator><name>mem</name><operator>-&gt;</operator><name>mmu</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Creates a new process, initializes most fields from the parent. Specify</comment>
<comment type="line">// parent as NULL to create the init process. Returns NULL if out of memory.</comment>
<comment type="line">// Ends with an underscore because there's a mach function by the same name</comment>
<function_decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>task_create_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="line">// Removes the process from the process table and frees it. Must be called with pids_lock.</comment>
<function_decl><type><name>void</name></type> <name>task_destroy</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="line">// misc</comment>
<function_decl><type><name>void</name></type> <name>vfork_notify</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>pid_t_</name></type> <name>task_setsid</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>task_leave_session</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>posix_timer</name> <block>{
    <decl_stmt><decl><type><name><name>struct</name> <name>timer</name></name> <modifier>*</modifier></type><name>timer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int_t</name></type> <name>timer_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>task</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int_t</name></type> <name>signal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>union</name> <name>sigval_</name></name></type> <name>sig_value</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="line">// struct thread_group is way too long to type comfortably</comment>
<struct>struct <name>tgroup</name> <block>{
    <decl_stmt><decl><type><name><name>struct</name> <name>list</name></name></type> <name>threads</name></decl>;</decl_stmt> <comment type="line">// locked by pids_lock, by majority vote</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>leader</name></decl>;</decl_stmt> <comment type="line">// immutable</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>rusage_</name></name></type> <name>rusage</name></decl>;</decl_stmt>

    <comment type="line">// locked by pids_lock</comment>
    <decl_stmt><decl><type><name>pid_t_</name></type> <name>sid</name></decl>, <decl><type ref="prev"/><name>pgid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>list</name></name></type> <name>session</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>list</name></name></type> <name>pgroup</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>stopped</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cond_t</name></type> <name>stopped_cond</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>tty</name></name> <modifier>*</modifier></type><name>tty</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timer</name></name> <modifier>*</modifier></type><name>itimer</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMERS_MAX</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
    <decl_stmt><decl><type><name><name>struct</name> <name>posix_timer</name></name></type> <name><name>posix_timers</name><index>[<expr><name>TIMERS_MAX</name></expr>]</index></name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>rlimit_</name></name></type> <name><name>limits</name><index>[<expr><name>RLIMIT_NLIMITS_</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="line">// https://twitter.com/tblodt/status/957706819236904960</comment>
    <comment type="line">// TODO locking</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>doing_group_exit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dword_t</name></type> <name>group_exit_code</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>rusage_</name></name></type> <name>children_rusage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cond_t</name></type> <name>child_exit</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>dword_t</name></type> <name>personality</name></decl>;</decl_stmt>

    <comment type="line">// for everything in this struct not locked by something else</comment>
    <decl_stmt><decl><type><name>lock_t</name></type> <name>lock</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>task_is_leader</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><name><name>task</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>leader</name></name> <operator>==</operator> <name>task</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>pid</name> <block>{
    <decl_stmt><decl><type><name>dword_t</name></type> <name>id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>task</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>list</name></name></type> <name>session</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>list</name></name></type> <name>pgroup</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="line">// synchronizes obtaining a pointer to a task and freeing that task</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>lock_t</name></type> <name>pids_lock</name></decl>;</decl_stmt>
<comment type="line">// these functions must be called with pids_lock</comment>
<function_decl><type><name><name>struct</name> <name>pid</name></name> <modifier>*</modifier></type><name>pid_get</name><parameter_list>(<parameter><decl><type><name>dword_t</name></type> <name>pid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>pid_get_task</name><parameter_list>(<parameter><decl><type><name>dword_t</name></type> <name>pid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>pid_get_task_zombie</name><parameter_list>(<parameter><decl><type><name>dword_t</name></type> <name>id</name></decl></parameter>)</parameter_list>;</function_decl> <comment type="line">// don't return null if the task exists as a zombie</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_PID</name></cpp:macro> <cpp:value>(1 &lt;&lt; 15)</cpp:value></cpp:define> <comment type="line">// oughta be enough</comment>

<comment type="line">// TODO document</comment>
<function_decl><type><name>void</name></type> <name>task_start</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>task_run_current</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> (<modifier>*</modifier><name>exit_hook</name>)<parameter_list>(<parameter><decl><type><name><name>struct</name> <name>task</name></name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>superuser</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(current != NULL &amp;&amp; current-&gt;euid == 0)</cpp:value></cpp:define>

<comment type="line">// Update the thread name to match the current task, in the format "comm-pid".</comment>
<comment type="line">// Will ensure that the -pid part always fits, then will fit as much of comm as possible.</comment>
<function_decl><type><name>void</name></type> <name>update_thread_name</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
