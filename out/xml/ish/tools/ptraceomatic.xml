<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="../out/cloned_projects/ish/tools/ptraceomatic.c"><comment type="line">// Fun little utility that single-steps a program using ptrace and</comment>
<comment type="line">// simultaneously runs the program in ish, and asserts that everything's</comment>
<comment type="line">// working the same.</comment>
<comment type="line">// Many apologies for the messy code.</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ptrace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/user.h&gt;</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PAGE_SIZE</name></cpp:undef> <comment type="line">// defined in sys/user.h, but we want the version from emu/memory.h</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/personality.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"kernel/calls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fs/path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fs/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"emu/interrupt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"emu/cpuid.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"kernel/elf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tools/transplant.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tools/ptutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"undefined-flags.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"kernel/vdso.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xX_main_Xx.h"</cpp:file></cpp:include>

<comment type="line">// ptrace utility functions</comment>

<comment type="line">// returns 1 for a signal stop</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>step</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>trycall</name><argument_list>(<argument><expr><call><name>ptrace</name><argument_list>(<argument><expr><name>PTRACE_SINGLESTEP</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"ptrace step"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>trycall</name><argument_list>(<argument><expr><call><name>waitpid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"wait step"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>WIFSTOPPED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>WSTOPSIG</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SIGTRAP</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>signal</name> <init>= <expr><call><name>WSTOPSIG</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>printk</name><argument_list>(<argument><expr><literal type="string">"child received signal %d\n"</literal></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// a signal arrived, we now have to actually deliver it</comment>
        <expr_stmt><expr><call><name>trycall</name><argument_list>(<argument><expr><call><name>ptrace</name><argument_list>(<argument><expr><name>PTRACE_SINGLESTEP</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"ptrace step"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>trycall</name><argument_list>(<argument><expr><call><name>waitpid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"wait step"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>getregs</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>user_regs_struct</name></name> <modifier>*</modifier></type><name>regs</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>trycall</name><argument_list>(<argument><expr><call><name>ptrace</name><argument_list>(<argument><expr><name>PTRACE_GETREGS</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>regs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"ptrace getregs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>setregs</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>user_regs_struct</name></name> <modifier>*</modifier></type><name>regs</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>trycall</name><argument_list>(<argument><expr><call><name>ptrace</name><argument_list>(<argument><expr><name>PTRACE_SETREGS</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>regs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"ptrace setregs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>compare_cpus</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cpu_state</name></name> <modifier>*</modifier></type><name>cpu</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tlb</name></name> <modifier>*</modifier></type><name>tlb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>undefined_flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>user_regs_struct</name></name></type> <name>regs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>user_fpregs_struct</name></name></type> <name>fpregs</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>getregs</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>trycall</name><argument_list>(<argument><expr><call><name>ptrace</name><argument_list>(<argument><expr><name>PTRACE_GETFPREGS</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fpregs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"ptrace getregs compare"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>collapse_flags</name><argument_list>(<argument><expr><name>cpu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK</name><parameter_list>(<parameter><type><name>real</name></type></parameter>, <parameter><type><name>fake</name></type></parameter>, <parameter><type><name>fmt</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
    if ((real) != (fake)) { \
        printk(fmt ": real 0x%llx, fake 0x%llx\n", ##__VA_ARGS__, (unsigned long long) (real), (unsigned long long) (fake)); \
        debugger; \
        return -1; \
    } \
} while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_REG</name><parameter_list>(<parameter><type><name>pt</name></type></parameter>, <parameter><type><name>cp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CHECK(regs.pt, cpu-&gt;cp, #cp)</cpp:value></cpp:define>
    <expr_stmt><expr><call><name>CHECK_REG</name><argument_list>(<argument><expr><name>rax</name></expr></argument>, <argument><expr><name>eax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_REG</name><argument_list>(<argument><expr><name>rbx</name></expr></argument>, <argument><expr><name>ebx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_REG</name><argument_list>(<argument><expr><name>rcx</name></expr></argument>, <argument><expr><name>ecx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_REG</name><argument_list>(<argument><expr><name>rdx</name></expr></argument>, <argument><expr><name>edx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_REG</name><argument_list>(<argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>esi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_REG</name><argument_list>(<argument><expr><name>rdi</name></expr></argument>, <argument><expr><name>edi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_REG</name><argument_list>(<argument><expr><name>rsp</name></expr></argument>, <argument><expr><name>esp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_REG</name><argument_list>(<argument><expr><name>rbp</name></expr></argument>, <argument><expr><name>ebp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_REG</name><argument_list>(<argument><expr><name>rip</name></expr></argument>, <argument><expr><name>eip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>undefined_flags</name> <operator>|=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt> <comment type="line">// treat trap flag as undefined</comment>
    <expr_stmt><expr><name><name>regs</name><operator>.</operator><name>eflags</name></name> <operator>=</operator> <operator>(</operator><name><name>regs</name><operator>.</operator><name>eflags</name></name> <operator>&amp;</operator> <operator>~</operator><name>undefined_flags</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>cpu</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>undefined_flags</name><operator>)</operator></expr>;</expr_stmt>
    <comment type="line">// give a nice visual representation of the flags</comment>
    <if_stmt><if>if <condition>(<expr><name><name>regs</name><operator>.</operator><name>eflags</name></name> <operator>!=</operator> <name><name>cpu</name><operator>-&gt;</operator><name>eflags</name></name></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>f</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((regs.eflags &amp; (1 &lt;&lt; n)) ? #x : "-"),</cpp:value></cpp:define>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"real eflags = 0x%llx %s%s%s%s%s%s%s%s%s, fake eflags = 0x%x %s%s%s%s%s%s%s%s%s\r\n%0d"</literal></expr></argument>,
                <argument><expr><name><name>regs</name><operator>.</operator><name>eflags</name></name></expr></argument>, <argument><expr><macro><name>f</name><argument_list>(<argument>o</argument>,<argument><literal type="number">11</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>d</argument>,<argument><literal type="number">10</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>i</argument>,<argument><literal type="number">9</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>t</argument>,<argument><literal type="number">8</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>s</argument>,<argument><literal type="number">7</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>z</argument>,<argument><literal type="number">6</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>a</argument>,<argument><literal type="number">4</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>p</argument>,<argument><literal type="number">2</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>c</argument>,<argument><literal type="number">0</literal></argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>f</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>f</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((cpu-&gt;eflags &amp; (1 &lt;&lt; n)) ? #x : "-"),</cpp:value></cpp:define>
                <name><name>cpu</name><operator>-&gt;</operator><name>eflags</name></name></expr></argument>, <argument><expr><macro><name>f</name><argument_list>(<argument>o</argument>,<argument><literal type="number">11</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>d</argument>,<argument><literal type="number">10</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>i</argument>,<argument><literal type="number">9</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>t</argument>,<argument><literal type="number">8</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>s</argument>,<argument><literal type="number">7</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>z</argument>,<argument><literal type="number">6</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>a</argument>,<argument><literal type="number">4</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>p</argument>,<argument><literal type="number">2</literal></argument>)</argument_list></macro><call><name>f</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>debugger</name></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>fpregs</name><operator>.</operator><name>xmm_space</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>xmm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>qw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"xmm%d low"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>fpregs</name><operator>.</operator><name>xmm_space</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">4</literal><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>xmm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>qw</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"xmm%d high"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSW_MASK</name></cpp:macro> <cpp:value>0x7d00</cpp:value></cpp:define> <comment type="line">// only look at top, c0, c2, c3</comment>
    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name><name>fpregs</name><operator>.</operator><name>swd</name></name> <operator>&amp;</operator> <name>FSW_MASK</name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>fsw</name></name> <operator>&amp;</operator> <name>FSW_MASK</name></expr></argument>, <argument><expr><literal type="string">"fsw"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name><name>fpregs</name><operator>.</operator><name>cwd</name></name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>fcw</name></name></expr></argument>, <argument><expr><literal type="string">"fcw"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fpregs</name><operator>.</operator><name>swd</name></name> <operator>&amp;=</operator> <name>FSW_MASK</name></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><operator>(</operator><name><name>cpu</name><operator>-&gt;</operator><name>top</name></name> <operator>+</operator> <name>i</name><operator>)</operator> <operator>%</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>mm</name> <init>= <expr><name><name>cpu</name><operator>-&gt;</operator><name>mm</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>qw</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>f_signif</name> <init>=  <expr><name><name>cpu</name><operator>-&gt;</operator><name>fp</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>signif</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>expected</name> <init>= <expr><operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>fpregs</name><operator>.</operator><name>st_space</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>f_signif</name> <operator>!=</operator> <name>expected</name> <operator>&amp;&amp;</operator> <name>mm</name> <operator>!=</operator> <name>expected</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printk</name><argument_list>(<argument><expr><literal type="string">"mm/st(%d) signif: real %#llx, fake fp %#llx, fake mm %#llx\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator> <name>expected</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator> <name>f_signif</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator> <name>mm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>debugger</name></expr>;</expr_stmt>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>f_signif</name> <operator>==</operator> <name>expected</name> <operator>&amp;&amp;</operator> <name>mm</name> <operator>!=</operator> <name>expected</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>fpregs</name><operator>.</operator><name>st_space</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">4</literal><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>fp</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>signExp</name></expr></argument>, <argument><expr><literal type="string">"st(%d) sign/exp"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="line">// compare pages marked dirty</comment>
    <if_stmt><if>if <condition>(<expr><name><name>tlb</name><operator>-&gt;</operator><name>dirty_page</name></name> <operator>!=</operator> <name>TLB_PAGE_EMPTY</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>open_mem</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>page_t</name></type> <name>dirty_page</name> <init>= <expr><name><name>tlb</name><operator>-&gt;</operator><name>dirty_page</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>real_page</name><index>[<expr><name>PAGE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>trycall</name><argument_list>(<argument><expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>dirty_page</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"compare seek mem"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>trycall</name><argument_list>(<argument><expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>real_page</name></expr></argument>, <argument><expr><name>PAGE_SIZE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"compare read mem"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>pt_entry</name></name></type> <name>entry</name> <init>= <expr><operator>*</operator><call><name>mem_pt</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><call><name>PAGE</name><argument_list>(<argument><expr><name>dirty_page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>fake_page</name> <init>= <expr><name><name>entry</name><operator>.</operator><name>data</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>entry</name><operator>.</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>real_page</name></expr></argument>, <argument><expr><name>fake_page</name></expr></argument>, <argument><expr><name>PAGE_SIZE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printk</name><argument_list>(<argument><expr><literal type="string">"page %x doesn't match\n"</literal></expr></argument>, <argument><expr><name>dirty_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>debugger</name></expr>;</expr_stmt>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>tlb</name><operator>-&gt;</operator><name>dirty_page</name></name> <operator>=</operator> <name>TLB_PAGE_EMPTY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>setregs</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>trycall</name><argument_list>(<argument><expr><call><name>ptrace</name><argument_list>(<argument><expr><name>PTRACE_SETFPREGS</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fpregs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"ptrace setregs compare"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="line">// I'd like to apologize in advance for this code</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>transmit_fd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sender</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>receiver</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fake_fd</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="line">// this sends the fd over a unix domain socket. yes, I'm crazy</comment>

    <comment type="line">// sending part</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>real_fd</name> <init>= <expr><call><name>f_get</name><argument_list>(<argument><expr><name>fake_fd</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>real_fd</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>msghdr</name></name></type> <name>msg</name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>cmsg</name><index>[<expr><call><name>CMSG_SPACE</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>cmsg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmsg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_control</name></name> <operator>=</operator> <name>cmsg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_controllen</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>cmsg</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>cmsghdr</name></name> <modifier>*</modifier></type><name>cmsg_hdr</name> <init>= <expr><call><name>CMSG_FIRSTHDR</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>cmsg_hdr</name><operator>-&gt;</operator><name>cmsg_level</name></name> <operator>=</operator> <name>SOL_SOCKET</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmsg_hdr</name><operator>-&gt;</operator><name>cmsg_type</name></name> <operator>=</operator> <name>SCM_RIGHTS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmsg_hdr</name><operator>-&gt;</operator><name>cmsg_len</name></name> <operator>=</operator> <call><name>CMSG_LEN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>CMSG_DATA</name><argument_list>(<argument><expr><name>cmsg_hdr</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>real_fd</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>trycall</name><argument_list>(<argument><expr><call><name>sendmsg</name><argument_list>(<argument><expr><name>sender</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"sendmsg insanity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// receiving part</comment>
    <comment type="line">// painful, because we're 64-bit and the child is 32-bit and I want to kill myself</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>user_regs_struct</name></name></type> <name>saved_regs</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>getregs</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved_regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>user_regs_struct</name></name></type> <name>regs</name> <init>= <expr><name>saved_regs</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// reserve space for 32-bit version of cmsg</comment>
    <expr_stmt><expr><name><name>regs</name><operator>.</operator><name>rsp</name></name> <operator>-=</operator> <literal type="number">16</literal></expr>;</expr_stmt> <comment type="line">// according to my calculations</comment>
    <decl_stmt><decl><type><name>addr_t</name></type> <name>cmsg_addr</name> <init>= <expr><name><name>regs</name><operator>.</operator><name>rsp</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>cmsg_bak</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>pt_readn</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rsp</name></name></expr></argument>, <argument><expr><name>cmsg_bak</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmsg_bak</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// copy 32-bit msghdr</comment>
    <expr_stmt><expr><name><name>regs</name><operator>.</operator><name>rsp</name></name> <operator>-=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name><name>msg32</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>cmsg_addr</name></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>addr_t</name></type> <name>msg_addr</name> <init>= <expr><name><name>regs</name><operator>.</operator><name>rsp</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>msg_bak</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>pt_readn</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rsp</name></name></expr></argument>, <argument><expr><name>msg_bak</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg_bak</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pt_writen</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rsp</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>regs</name><operator>.</operator><name>rax</name></name> <operator>=</operator> <literal type="number">372</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>regs</name><operator>.</operator><name>rbx</name></name> <operator>=</operator> <name>receiver</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>regs</name><operator>.</operator><name>rcx</name></name> <operator>=</operator> <name>msg_addr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>regs</name><operator>.</operator><name>rdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="line">// assume we're already on an int $0x80</comment>
    <expr_stmt><expr><call><name>setregs</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>step</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>getregs</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>sent_fd</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>regs</name><operator>.</operator><name>rax</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pt_readn</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>cmsg_addr</name> <operator>+</operator> <literal type="number">12</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sent_fd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sent_fd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>sent_fd</name> <operator>=</operator> <name><name>regs</name><operator>.</operator><name>rax</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="line">// restore crap</comment>
    <expr_stmt><expr><call><name>pt_writen</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>cmsg_addr</name></expr></argument>, <argument><expr><name>cmsg_bak</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmsg_bak</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pt_writen</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>msg_addr</name></expr></argument>, <argument><expr><name>msg_bak</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg_bak</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setregs</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>sent_fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <operator>-</operator><name>sent_fd</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"remote recvmsg insanity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>sent_fd</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>remote_close_fd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>int80_ip</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="line">// lettuce spray</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>user_regs_struct</name></name></type> <name>saved_regs</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>getregs</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved_regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>user_regs_struct</name></name></type> <name>regs</name> <init>= <expr><name>saved_regs</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>regs</name><operator>.</operator><name>rip</name></name> <operator>=</operator> <name>int80_ip</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>regs</name><operator>.</operator><name>rax</name></name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>regs</name><operator>.</operator><name>rbx</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setregs</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>step</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>getregs</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>regs</name><operator>.</operator><name>rax</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <operator>-</operator><name><name>regs</name><operator>.</operator><name>rax</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"remote close fd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>setregs</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_ignore</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{}; int UNUSED(x) =</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ignore</name></cpp:macro> <cpp:value>_ignore(__COUNTER__)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>pt_copy</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>addr_t</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>byte_t</name></type> <name>byte</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>addr_t</name></type> <name>addr</name> <init>= <expr><name>start</name></expr></init></decl>;</init> <condition><expr><name>addr</name> <operator>&lt;</operator> <name>start</name> <operator>+</operator> <name>size</name></expr>;</condition> <incr><expr><name>addr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>ignore</name></type> <name>user_get</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>byte</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>pt_write8</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>byte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="line">// Please don't use unless absolutely necessary.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pt_copy_to_real</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>addr_t</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>byte_t</name></type> <name>byte</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>addr_t</name></type> <name>addr</name> <init>= <expr><name>start</name></expr></init></decl>;</init> <condition><expr><name>addr</name> <operator>&lt;</operator> <name>start</name> <operator>+</operator> <name>size</name></expr>;</condition> <incr><expr><name>addr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>pt_readn</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>byte</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>byte</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>ignore</name></type> <name>user_put</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>byte</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>step_tracing</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cpu_state</name></name> <modifier>*</modifier></type><name>cpu</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tlb</name></name> <modifier>*</modifier></type><name>tlb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sender</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>receiver</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="line">// step fake cpu</comment>
    <expr_stmt><expr><name><name>cpu</name><operator>-&gt;</operator><name>tf</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>interrupt</name> <init>= <expr><call><name>cpu_run_to_interrupt</name><argument_list>(<argument><expr><name>cpu</name></expr></argument>, <argument><expr><name>tlb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// hack to clean up before the exit syscall</comment>
    <if_stmt><if>if <condition>(<expr><name>interrupt</name> <operator>==</operator> <name>INT_SYSCALL</name> <operator>&amp;&amp;</operator> <name><name>cpu</name><operator>-&gt;</operator><name>eax</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>SIGKILL</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"kill tracee during exit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>interrupt</name> <operator>!=</operator> <name>INT_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>handle_interrupt</name><argument_list>(<argument><expr><name>interrupt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// step real cpu</comment>
    <comment type="line">// intercept cpuid, rdtsc, and int $0x80, though</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>user_regs_struct</name></name></type> <name>regs</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>getregs</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>inst</name> <init>= <expr><call><name>trycall</name><argument_list>(<argument><expr><call><name>ptrace</name><argument_list>(<argument><expr><name>PTRACE_PEEKTEXT</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rip</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"ptrace get inst step"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>saved_fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="line">// annoying hack for mmap</comment>
    <decl_stmt><decl><type><name>long</name></type> <name>old_sp</name> <init>= <expr><name><name>regs</name><operator>.</operator><name>rsp</name></name></expr></init></decl>;</decl_stmt> <comment type="line">// so we know where a sigframe ends</comment>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>inst</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x0f</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>inst</name> <operator>&amp;</operator> <literal type="number">0xff00</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xa2</literal></expr>)</condition> <block>{<block_content>
            <comment type="line">// cpuid</comment>
            <expr_stmt><expr><call><name>do_cpuid</name><argument_list>(<argument><expr><operator>(</operator><name>dword_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>regs</name><operator>.</operator><name>rax</name></name></expr></argument>, <argument><expr><operator>(</operator><name>dword_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>regs</name><operator>.</operator><name>rbx</name></name></expr></argument>, <argument><expr><operator>(</operator><name>dword_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>regs</name><operator>.</operator><name>rcx</name></name></expr></argument>, <argument><expr><operator>(</operator><name>dword_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>regs</name><operator>.</operator><name>rdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>regs</name><operator>.</operator><name>rip</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>(</operator><name>inst</name> <operator>&amp;</operator> <literal type="number">0xff00</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x31</literal></expr>)</condition> <block>{<block_content>
            <comment type="line">// rdtsc, no good way to get the same result here except copy from fake cpu</comment>
            <expr_stmt><expr><name><name>regs</name><operator>.</operator><name>rax</name></name> <operator>=</operator> <name><name>cpu</name><operator>-&gt;</operator><name>eax</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>regs</name><operator>.</operator><name>rdx</name></name> <operator>=</operator> <name><name>cpu</name><operator>-&gt;</operator><name>edx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>regs</name><operator>.</operator><name>rip</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <goto>goto <name>do_step</name>;</goto>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>inst</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xcd</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>inst</name> <operator>&amp;</operator> <literal type="number">0xff00</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// int $0x80, intercept the syscall unless it's one of a few actually important ones</comment>
        <decl_stmt><decl><type><name>dword_t</name></type> <name>syscall_num</name> <init>= <expr><operator>(</operator><name>dword_t</name><operator>)</operator> <name><name>regs</name><operator>.</operator><name>rax</name></name></expr></init></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name>syscall_num</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// put syscall result from fake process into real process</comment>
            <case>case <expr><literal type="number">3</literal></expr>:</case> <comment type="line">// read</comment>
                <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rcx</name></name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>edx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">7</literal></expr>:</case> <comment type="line">// waitpid</comment>
                <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rcx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dword_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">13</literal></expr>:</case> <comment type="line">// time</comment>
                <if_stmt><if>if <condition>(<expr><name><name>regs</name><operator>.</operator><name>rbx</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rbx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dword_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">43</literal></expr>:</case>
                <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rbx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>tms_</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">54</literal></expr>:</case> <block>{<block_content> <comment type="line">// ioctl (god help us)</comment>
                <decl_stmt><decl><type><name><name>struct</name> <name>fd</name></name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><call><name>f_get</name><argument_list>(<argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>ebx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&amp;&amp;</operator> <name><name>fd</name><operator>-&gt;</operator><name>ops</name><operator>-&gt;</operator><name>ioctl_size</name></name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>ssize_t</name></type> <name>ioctl_size</name> <init>= <expr><call><name><name>fd</name><operator>-&gt;</operator><name>ops</name><operator>-&gt;</operator><name>ioctl_size</name></name><argument_list>(<argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>ecx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>ioctl_size</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rdx</name></name></expr></argument>, <argument><expr><name>ioctl_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>
            <case>case <expr><literal type="number">85</literal></expr>:</case> <comment type="line">// readlink</comment>
                <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rcx</name></name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">102</literal></expr>:</case> <block>{<block_content> <comment type="line">// socketcall</comment>
                <decl_stmt><decl><type><name>dword_t</name></type> <name><name>args</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ignore</name></type> <name>user_get</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>rcx</name></name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>dword_t</name></type> <name>len</name></decl>;</decl_stmt>
                <switch>switch <condition>(<expr><name><name>cpu</name><operator>-&gt;</operator><name>ebx</name></name></expr>)</condition> <block>{<block_content>
                    <case>case <expr><literal type="number">6</literal></expr>:</case> <comment type="line">// getsockname</comment>
                        <empty_stmt>;</empty_stmt><decl_stmt><decl><type><name>ignore</name></type> <name>user_get</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="number">8</literal></expr>:</case> <comment type="line">// socketpair</comment>
                        <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>dword_t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="number">12</literal></expr>:</case> <comment type="line">// recvfrom</comment>
                        <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <decl_stmt><decl><type><name>ignore</name></type> <name>user_get</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
                <break>break;</break>
            </block_content>}</block>
            <case>case <expr><literal type="number">104</literal></expr>:</case> <comment type="line">// setitimer</comment>
                <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rdx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>itimerval_</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">116</literal></expr>:</case> <comment type="line">// sysinfo</comment>
                <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rbx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sys_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">122</literal></expr>:</case> <comment type="line">// uname</comment>
                <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rbx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>uname</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">140</literal></expr>:</case> <comment type="line">// _llseek</comment>
                <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rsi</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">145</literal></expr>:</case> <block>{<block_content> <comment type="line">// readv</comment>
                <decl_stmt><decl><type><name><name>struct</name> <name>iovec_</name></name></type> <name><name>vecs</name><index>[<expr><name><name>regs</name><operator>.</operator><name>rdx</name></name></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ignore</name></type> <name>user_get</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>rcx</name></name></expr></argument>, <argument><expr><name>vecs</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>regs</name><operator>.</operator><name>rdx</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>vecs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>base</name></expr></argument>, <argument><expr><name><name>vecs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                <break>break;</break>
            </block_content>}</block>
            <case>case <expr><literal type="number">162</literal></expr>:</case> <comment type="line">// nanosleep</comment>
                <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rcx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>timespec_</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">168</literal></expr>:</case> <comment type="line">// poll</comment>
                <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rbx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>pollfd_</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>regs</name><operator>.</operator><name>rcx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">183</literal></expr>:</case> <comment type="line">// getcwd</comment>
                <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rbx</name></name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>eax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">186</literal></expr>:</case> <comment type="line">// sigaltstack</comment>
                <if_stmt><if>if <condition>(<expr><name><name>regs</name><operator>.</operator><name>rcx</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rcx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>stack_t_</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">195</literal></expr>:</case> <comment type="line">// stat64</comment>
            <case>case <expr><literal type="number">196</literal></expr>:</case> <comment type="line">// lstat64</comment>
            <case>case <expr><literal type="number">197</literal></expr>:</case> <comment type="line">// fstat64</comment>
                <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rcx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>newstat64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">220</literal></expr>:</case> <comment type="line">// getdents64</comment>
                <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rcx</name></name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>eax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">242</literal></expr>:</case> <comment type="line">// sched_getaffinity</comment>
                <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rdx</name></name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rcx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">265</literal></expr>:</case> <comment type="line">// clock_gettime</comment>
                <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rcx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>timespec_</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">300</literal></expr>:</case> <comment type="line">// fstatat64</comment>
                <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rdx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>newstat64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">305</literal></expr>:</case> <comment type="line">// readlinkat</comment>
                <if_stmt><if>if <condition>(<expr><name><name>cpu</name><operator>-&gt;</operator><name>eax</name></name> <operator>&lt;</operator> <literal type="number">0xffff000</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rdx</name></name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>eax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">340</literal></expr>:</case> <comment type="line">// prlimit</comment>
                <if_stmt><if>if <condition>(<expr><name><name>regs</name><operator>.</operator><name>rsi</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rsi</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>rlimit_</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">355</literal></expr>:</case> <comment type="line">// getrandom</comment>
                <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rbx</name></name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rcx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

            <case>case <expr><literal type="number">90</literal></expr>:</case> <comment type="line">// mmap</comment>
            <case>case <expr><literal type="number">192</literal></expr>:</case> <comment type="line">// mmap2</comment>
                <if_stmt><if>if <condition>(<expr><name><name>cpu</name><operator>-&gt;</operator><name>eax</name></name> <operator>&lt;</operator> <literal type="number">0xfffff000</literal> <operator>&amp;&amp;</operator> <name><name>cpu</name><operator>-&gt;</operator><name>edi</name></name> <operator>!=</operator> <operator>(</operator><name>dword_t</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                    <comment type="line">// fake mmap didn't fail, change fd</comment>
                    <expr_stmt><expr><name>saved_fd</name> <operator>=</operator> <name><name>regs</name><operator>.</operator><name>rdi</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>regs</name><operator>.</operator><name>rdi</name></name> <operator>=</operator> <call><name>transmit_fd</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>sender</name></expr></argument>, <argument><expr><name>receiver</name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>edi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <goto>goto <name>do_step</name>;</goto>

            <comment type="line">// some syscalls need to just happen</comment>
            <case>case <expr><literal type="number">45</literal></expr>:</case> <comment type="line">// brk</comment>
            <case>case <expr><literal type="number">91</literal></expr>:</case> <comment type="line">// munmap</comment>
            <case>case <expr><literal type="number">119</literal></expr>:</case> <comment type="line">// sigreturn</comment>
            <case>case <expr><literal type="number">125</literal></expr>:</case> <comment type="line">// mprotect</comment>
            <case>case <expr><literal type="number">173</literal></expr>:</case> <comment type="line">// rt_sigreturn</comment>
            <case>case <expr><literal type="number">174</literal></expr>:</case> <comment type="line">// rt_sigaction</comment>
            <case>case <expr><literal type="number">175</literal></expr>:</case> <comment type="line">// rt_sigprocmask</comment>
            <case>case <expr><literal type="number">243</literal></expr>:</case> <comment type="line">// set_thread_area</comment>
                <comment type="line">//regs.rax = cpu-&gt;eax;</comment>
                <goto>goto <name>do_step</name>;</goto>
        </block_content>}</block></switch>
        <expr_stmt><expr><name><name>regs</name><operator>.</operator><name>rax</name></name> <operator>=</operator> <name><name>cpu</name><operator>-&gt;</operator><name>eax</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>regs</name><operator>.</operator><name>rip</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
<label><name>do_step</name>:</label>
        <expr_stmt><expr><call><name>setregs</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// single step on a repeated string instruction only does one</comment>
        <comment type="line">// iteration, so loop until ip changes</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>ip</name> <init>= <expr><name><name>regs</name><operator>.</operator><name>rip</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>was_signal</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><name><name>regs</name><operator>.</operator><name>rip</name></name> <operator>==</operator> <name>ip</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>was_signal</name> <operator>=</operator> <call><name>step</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>getregs</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>saved_fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>remote_close_fd</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rdi</name></name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>regs</name><operator>.</operator><name>rdi</name></name> <operator>=</operator> <name>saved_fd</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>was_signal</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// copy the return address</comment>
            <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rsp</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// and copy the rest the other way</comment>
            <expr_stmt><expr><call><name>pt_copy_to_real</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>rsp</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>addr_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>old_sp</name> <operator>-</operator> <name><name>regs</name><operator>.</operator><name>rsp</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>addr_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>setregs</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>prepare_tracee</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>transplant_vdso</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>vdso_data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>vdso_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// copy the stack</comment>
    <expr_stmt><expr><call><name>pt_copy</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><literal type="number">0xffffd000</literal></expr></argument>, <argument><expr><literal type="number">0x1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>user_regs_struct</name></name></type> <name>regs</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>getregs</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>regs</name><operator>.</operator><name>rsp</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>cpu</name><operator>.</operator><name>esp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setregs</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// find out how big the signal stack frame needs to be</comment>
    <asm>__asm__("cpuid"
            : "=b" (xsave_extra)
            : "a" (0xd), "c" (0)
            : "edx");</asm>

    <decl_stmt><decl><type><name>int</name></type> <name>features_ecx</name></decl>, <decl><type ref="prev"/><name>features_edx</name></decl>;</decl_stmt>
    <asm>__asm__("cpuid"
            : "=c" (features_ecx), "=d" (features_edx)
            : "a" (1)
            : "ebx");</asm>
    <comment type="line">// if xsave is supported, add 4 bytes. why? idk</comment>
    <if_stmt><if>if <condition>(<expr><name>features_ecx</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">26</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>xsave_extra</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="line">// if fxsave/fxrestore is supported, use 112 bytes for that</comment>
    <if_stmt><if>if <condition>(<expr><name>features_edx</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>fxsave_extra</name> <operator>=</operator> <literal type="number">112</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>envp</name><index>[<expr><literal type="number">100</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TERM"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>envp</name></expr></argument>, <argument><expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TERM"</literal></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"TERM"</literal></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>xX_main_Xx</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>envp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>err</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><operator>-</operator><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>err</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// execute the traced program in a new process and throw up some sockets</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>exec_path</name><index>[<expr><name>MAX_PATH</name></expr>]</index></name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>path_normalize</name><argument_list>(<argument><expr><name>AT_PWD</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>, <argument><expr><name>exec_path</name></expr></argument>, <argument><expr><name>N_SYMLINK_FOLLOW</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"enametoolong\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>mount</name></name> <modifier>*</modifier></type><name>mount</name> <init>= <expr><call><name>find_mount_and_trim_path</name><argument_list>(<argument><expr><name>exec_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name><name>fds</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>trycall</name><argument_list>(<argument><expr><call><name>socketpair</name><argument_list>(<argument><expr><name>AF_UNIX</name></expr></argument>, <argument><expr><name>SOCK_DGRAM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fds</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"socketpair"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>pid</name> <init>= <macro><name>start_tracee</name><argument_list>(<argument>mount-&gt;root_fd</argument>, <argument>fix_path(exec_path)</argument>, <argument>argv + optind</argument>, <argument>(char *[]) {NULL}</argument>)</argument_list></macro></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sender</name> <init>= <expr><name><name>fds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"/><name>receiver</name> <init>= <expr><name><name>fds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* close(receiver); // only needed in the child */</comment>
    <expr_stmt><expr><call><name>prepare_tracee</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>cpu_state</name></name> <modifier>*</modifier></type><name>cpu</name> <init>= <expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>cpu</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>cpu</name><operator>-&gt;</operator><name>tf</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>tlb</name></name></type> <name>tlb</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>tlb_refresh</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tlb</name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>mmu</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>undefined_flags</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>cpu_state</name></name></type> <name>old_cpu</name> <init>= <expr><operator>*</operator><name>cpu</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>true</name></expr>)</condition> <block>{<block_content>
        <while>while <condition>(<expr><call><name>compare_cpus</name><argument_list>(<argument><expr><name>cpu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tlb</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>undefined_flags</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printk</name><argument_list>(<argument><expr><literal type="string">"failure: resetting cpu\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>cpu</name> <operator>=</operator> <name>old_cpu</name></expr>;</expr_stmt>
            <asm>__asm__("int3");</asm>
            <expr_stmt><expr><call><name>cpu_run_to_interrupt</name><argument_list>(<argument><expr><name>cpu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tlb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name>undefined_flags</name> <operator>=</operator> <call><name>undefined_flags_mask</name><argument_list>(<argument><expr><name>cpu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tlb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>old_cpu</name> <operator>=</operator> <operator>*</operator><name>cpu</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>step_tracing</name><argument_list>(<argument><expr><name>cpu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tlb</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>sender</name></expr></argument>, <argument><expr><name>receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="line">// useful for calling from the debugger</comment>
<function><type><name>void</name></type> <name>dump_memory</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>addr_t</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>addr_t</name></type> <name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>addr_t</name></type> <name>addr</name> <init>= <expr><name>start</name></expr></init></decl>;</init> <condition><expr><name>addr</name> <operator>&lt;=</operator> <name>end</name></expr>;</condition> <incr><expr><name>addr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dword_t</name></expr></argument>)</argument_list></sizeof></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>dword_t</name></type> <name>val</name> <init>= <expr><call><name>pt_read</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dword_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
