<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="../out/cloned_projects/ish/tools/unicornomatic.c"><comment type="line">// Runs a program simultaneously in ish and unicorn, single steps, and asserts</comment>
<comment type="line">// everything is the same. Basically the same deal as ptraceomatic, except</comment>
<comment type="line">// ptraceomatic doesn't run on my raspberry pi and I need to verify the damn</comment>
<comment type="line">// thing still works on a raspberry pi.</comment>
<comment type="line">// Oh and hopefully the code is somewhat less messy.</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unicorn/unicorn.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"misc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"kernel/calls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"emu/interrupt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xX_main_Xx.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"undefined-flags.h"</cpp:file></cpp:include>

<comment type="line">// unicorn wrappers</comment>

<function><type><name>long</name></type> <name>trycall</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>res</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>uc_trycall</name><parameter_list>(<parameter><decl><type><name>uc_err</name></type> <name>res</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>UC_ERR_OK</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s: %s\r\n"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>uc_strerror</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>uint32_t</name></type> <name>uc_getreg</name><parameter_list>(<parameter><decl><type><name>uc_engine</name> <modifier>*</modifier></type><name>uc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reg_id</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>value</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>uc_trycall</name><argument_list>(<argument><expr><call><name>uc_reg_read</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>reg_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"uc_getreg"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>uc_setreg</name><parameter_list>(<parameter><decl><type><name>uc_engine</name> <modifier>*</modifier></type><name>uc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reg_id</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>uc_trycall</name><argument_list>(<argument><expr><call><name>uc_reg_write</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>reg_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"uc_setreg"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>uc_read</name><parameter_list>(<parameter><decl><type><name>uc_engine</name> <modifier>*</modifier></type><name>uc</name></decl></parameter>, <parameter><decl><type><name>addr_t</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>uc_trycall</name><argument_list>(<argument><expr><call><name>uc_mem_read</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"uc_read"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>uc_write</name><parameter_list>(<parameter><decl><type><name>uc_engine</name> <modifier>*</modifier></type><name>uc</name></decl></parameter>, <parameter><decl><type><name>addr_t</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>uc_trycall</name><argument_list>(<argument><expr><call><name>uc_mem_write</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"uc_write"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>uc_unmap</name><parameter_list>(<parameter><decl><type><name>uc_engine</name> <modifier>*</modifier></type><name>uc</name></decl></parameter>, <parameter><decl><type><name>addr_t</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>dword_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>addr_t</name></type> <name>addr</name> <init>= <expr><name>start</name></expr></init></decl>;</init> <condition><expr><name>addr</name> <operator>&lt;</operator> <name>start</name> <operator>+</operator> <name>size</name></expr>;</condition> <incr><expr><name>addr</name> <operator>+=</operator> <name>PAGE_SIZE</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>uc_mem_unmap</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// ignore errors</comment>
    </block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>uc_map</name><parameter_list>(<parameter><decl><type><name>uc_engine</name> <modifier>*</modifier></type><name>uc</name></decl></parameter>, <parameter><decl><type><name>addr_t</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>dword_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>uc_unmap</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>addr_t</name></type> <name>addr</name> <init>= <expr><name>start</name></expr></init></decl>;</init> <condition><expr><name>addr</name> <operator>&lt;</operator> <name>start</name> <operator>+</operator> <name>size</name></expr>;</condition> <incr><expr><name>addr</name> <operator>+=</operator> <name>PAGE_SIZE</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>uc_trycall</name><argument_list>(<argument><expr><call><name>uc_mem_map</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>PAGE_SIZE</name></expr></argument>, <argument><expr><name>UC_PROT_ALL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"mmap emulation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>uc_map_ptr</name><parameter_list>(<parameter><decl><type><name>uc_engine</name> <modifier>*</modifier></type><name>uc</name></decl></parameter>, <parameter><decl><type><name>addr_t</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>mem</name></decl></parameter>, <parameter><decl><type><name>dword_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>uc_unmap</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>addr_t</name></type> <name>addr</name> <init>= <expr><name>start</name></expr></init></decl>;</init> <condition><expr><name>addr</name> <operator>&lt;</operator> <name>start</name> <operator>+</operator> <name>size</name></expr>;</condition> <incr><expr><name>addr</name> <operator>+=</operator> <name>PAGE_SIZE</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>uc_trycall</name><argument_list>(<argument><expr><call><name>uc_mem_map_ptr</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>PAGE_SIZE</name></expr></argument>, <argument><expr><name>UC_PROT_ALL</name></expr></argument>, <argument><expr><name>mem</name> <operator>+</operator> <operator>(</operator><name>addr</name> <operator>-</operator> <name>start</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"mmap emulation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<struct>struct <name>uc_regs</name> <block>{
    <decl_stmt><decl><type><name>dword_t</name></type> <name>eax</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dword_t</name></type> <name>ebx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dword_t</name></type> <name>ecx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dword_t</name></type> <name>edx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dword_t</name></type> <name>esi</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dword_t</name></type> <name>edi</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dword_t</name></type> <name>ebp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dword_t</name></type> <name>esp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dword_t</name></type> <name>eip</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dword_t</name></type> <name>eflags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>word_t</name></type> <name>fpcw</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>word_t</name></type> <name>fpsw</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float80</name></type> <name><name>fp</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>uc_regs_ids</name><index>[]</index></name> <init>= <expr><block>{
    <expr><name>UC_X86_REG_EAX</name></expr>, <expr><name>UC_X86_REG_EBX</name></expr>, <expr><name>UC_X86_REG_ECX</name></expr>, <expr><name>UC_X86_REG_EDX</name></expr>,
    <expr><name>UC_X86_REG_ESI</name></expr>, <expr><name>UC_X86_REG_EDI</name></expr>, <expr><name>UC_X86_REG_EBP</name></expr>, <expr><name>UC_X86_REG_ESP</name></expr>,
    <expr><name>UC_X86_REG_EIP</name></expr>, <expr><name>UC_X86_REG_EFLAGS</name></expr>,
    <expr><name>UC_X86_REG_FPCW</name></expr>, <expr><name>UC_X86_REG_FPSW</name></expr>,
    <expr><name>UC_X86_REG_FP0</name></expr>, <expr><name>UC_X86_REG_FP1</name></expr>, <expr><name>UC_X86_REG_FP2</name></expr>, <expr><name>UC_X86_REG_FP3</name></expr>,
    <expr><name>UC_X86_REG_FP4</name></expr>, <expr><name>UC_X86_REG_FP5</name></expr>, <expr><name>UC_X86_REG_FP6</name></expr>, <expr><name>UC_X86_REG_FP7</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>void</name></type> <name>uc_getregs</name><parameter_list>(<parameter><decl><type><name>uc_engine</name> <modifier>*</modifier></type><name>uc</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>uc_regs</name></name> <modifier>*</modifier></type><name>regs</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name><name>ptrs</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>uc_regs_ids</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>uc_regs_ids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{
        <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>eax</name></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>ebx</name></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>ecx</name></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>edx</name></name></expr>,
        <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>esi</name></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>edi</name></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>ebp</name></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>esp</name></name></expr>,
        <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>eip</name></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>eflags</name></name></expr>,
        <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>fpcw</name></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>fpsw</name></name></expr>,
        <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>fp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>fp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>fp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>fp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>,
        <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>fp</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>fp</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>fp</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>fp</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr>,
    }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>uc_trycall</name><argument_list>(<argument><expr><call><name>uc_reg_read_batch</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>uc_regs_ids</name></expr></argument>, <argument><expr><name>ptrs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ptrs</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>ptrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"uc_reg_read_batch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>uc_setregs</name><parameter_list>(<parameter><decl><type><name>uc_engine</name> <modifier>*</modifier></type><name>uc</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>uc_regs</name></name> <modifier>*</modifier></type><name>regs</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>ptrs</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>uc_regs_ids</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>uc_regs_ids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{
        <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>eax</name></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>ebx</name></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>ecx</name></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>edx</name></name></expr>,
        <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>esi</name></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>edi</name></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>ebp</name></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>esp</name></name></expr>,
        <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>eip</name></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>eflags</name></name></expr>,
        <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>fpcw</name></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>fpsw</name></name></expr>,
        <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>fp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>fp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>fp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>fp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>,
        <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>fp</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>fp</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>fp</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr>, <expr><operator>&amp;</operator><name><name>regs</name><operator>-&gt;</operator><name>fp</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr>,
    }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>uc_trycall</name><argument_list>(<argument><expr><call><name>uc_reg_write_batch</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>uc_regs_ids</name></expr></argument>, <argument><expr><name>ptrs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ptrs</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>ptrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"uc_reg_write_batch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>compare_cpus</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cpu_state</name></name> <modifier>*</modifier></type><name>cpu</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tlb</name></name> <modifier>*</modifier></type><name>tlb</name></decl></parameter>, <parameter><decl><type><name>uc_engine</name> <modifier>*</modifier></type><name>uc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>undefined_flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>uc_regs</name></name></type> <name>regs</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>uc_getregs</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>collapse_flags</name><argument_list>(<argument><expr><name>cpu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK</name><parameter_list>(<parameter><type><name>uc</name></type></parameter>, <parameter><type><name>ish</name></type></parameter>, <parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>if ((uc) != (ish)) { \
        printk("check failed: " name ": uc 0x%llx, ish 0x%llx\n", (unsigned long long) (uc), (unsigned long long) (ish)); \
        res = -1; \
        ish = uc; \
    }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_REG</name><parameter_list>(<parameter><type><name>reg</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>CHECK(regs.reg, cpu-&gt;reg, #reg)</cpp:value></cpp:define>
    <expr_stmt><expr><call><name>CHECK_REG</name><argument_list>(<argument><expr><name>eip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_REG</name><argument_list>(<argument><expr><name>eax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_REG</name><argument_list>(<argument><expr><name>ebx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_REG</name><argument_list>(<argument><expr><name>ecx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_REG</name><argument_list>(<argument><expr><name>edx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_REG</name><argument_list>(<argument><expr><name>esi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_REG</name><argument_list>(<argument><expr><name>edi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_REG</name><argument_list>(<argument><expr><name>esp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_REG</name><argument_list>(<argument><expr><name>ebp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// check the flags, with a nice visual representation</comment>
    <expr_stmt><expr><name><name>regs</name><operator>.</operator><name>eflags</name></name> <operator>=</operator> <operator>(</operator><name><name>regs</name><operator>.</operator><name>eflags</name></name> <operator>&amp;</operator> <operator>~</operator><name>undefined_flags</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>cpu</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>undefined_flags</name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>regs</name><operator>.</operator><name>eflags</name></name> <operator>!=</operator> <name><name>cpu</name><operator>-&gt;</operator><name>eflags</name></name></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>f</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((regs.eflags &amp; (1 &lt;&lt; n)) ? #x : "-"),</cpp:value></cpp:define>
        <expr_stmt><expr><call><name>printk</name><argument_list>(<argument><expr><literal type="string">"real eflags = 0x%x %s%s%s%s%s%s%s%s%s, fake eflags = 0x%x %s%s%s%s%s%s%s%s%s\n%0d"</literal></expr></argument>,
                <argument><expr><name><name>regs</name><operator>.</operator><name>eflags</name></name></expr></argument>, <argument><expr><macro><name>f</name><argument_list>(<argument>o</argument>,<argument><literal type="number">11</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>d</argument>,<argument><literal type="number">10</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>i</argument>,<argument><literal type="number">9</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>t</argument>,<argument><literal type="number">8</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>s</argument>,<argument><literal type="number">7</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>z</argument>,<argument><literal type="number">6</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>a</argument>,<argument><literal type="number">4</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>p</argument>,<argument><literal type="number">2</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>c</argument>,<argument><literal type="number">0</literal></argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>f</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>f</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((cpu-&gt;eflags &amp; (1 &lt;&lt; n)) ? #x : "-"),</cpp:value></cpp:define>
                <name><name>cpu</name><operator>-&gt;</operator><name>eflags</name></name></expr></argument>, <argument><expr><macro><name>f</name><argument_list>(<argument>o</argument>,<argument><literal type="number">11</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>d</argument>,<argument><literal type="number">10</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>i</argument>,<argument><literal type="number">9</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>t</argument>,<argument><literal type="number">8</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>s</argument>,<argument><literal type="number">7</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>z</argument>,<argument><literal type="number">6</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>a</argument>,<argument><literal type="number">4</literal></argument>)</argument_list></macro><macro><name>f</name><argument_list>(<argument>p</argument>,<argument><literal type="number">2</literal></argument>)</argument_list></macro><call><name>f</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cpu</name><operator>-&gt;</operator><name>eflags</name></name> <operator>=</operator> <name><name>regs</name><operator>.</operator><name>eflags</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// sync up the flags so undefined flags won't error out next time</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSW_MASK</name></cpp:macro> <cpp:value>0x7d00</cpp:value></cpp:define> <comment type="line">// only look at top, c0, c2, c3</comment>
    <expr_stmt><expr><name><name>regs</name><operator>.</operator><name>fpsw</name></name> <operator>&amp;=</operator> <name>FSW_MASK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cpu</name><operator>-&gt;</operator><name>fsw</name></name> <operator>&amp;=</operator> <name>FSW_MASK</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>fpsw</name></name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>fsw</name></name></expr></argument>, <argument><expr><literal type="string">"fsw"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>fpcw</name></name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>fcw</name></name></expr></argument>, <argument><expr><literal type="string">"fcw"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_FPREG</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>CHECK(regs.fp[i].signif, cpu-&gt;fp[i].signif, "fp"#i" signif"); \
    CHECK(regs.fp[i].signExp, cpu-&gt;fp[i].signExp, "fp"#i" signExp")</cpp:value></cpp:define>
    <expr_stmt><expr><call><name>CHECK_FPREG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_FPREG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_FPREG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_FPREG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_FPREG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_FPREG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_FPREG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_FPREG</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>uc_setregs</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// compare pages marked dirty</comment>
    <if_stmt><if>if <condition>(<expr><name><name>tlb</name><operator>-&gt;</operator><name>dirty_page</name></name> <operator>!=</operator> <name>TLB_PAGE_EMPTY</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>real_page</name><index>[<expr><name>PAGE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>uc_trycall</name><argument_list>(<argument><expr><call><name>uc_mem_read</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name><name>tlb</name><operator>-&gt;</operator><name>dirty_page</name></name></expr></argument>, <argument><expr><name>real_page</name></expr></argument>, <argument><expr><name>PAGE_SIZE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"compare read"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>fake_page</name> <init>= <expr><call><name>mmu_translate</name><argument_list>(<argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>mmu</name></name></expr></argument>, <argument><expr><name><name>tlb</name><operator>-&gt;</operator><name>dirty_page</name></name></expr></argument>, <argument><expr><name>MEM_READ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>real_page</name></expr></argument>, <argument><expr><name>fake_page</name></expr></argument>, <argument><expr><name>PAGE_SIZE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printk</name><argument_list>(<argument><expr><literal type="string">"page %x doesn't match\n"</literal></expr></argument>, <argument><expr><name><name>tlb</name><operator>-&gt;</operator><name>dirty_page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>debugger</name></expr>;</expr_stmt>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>tlb</name><operator>-&gt;</operator><name>dirty_page</name></name> <operator>=</operator> <name>TLB_PAGE_EMPTY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>uc_interrupt</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_tls_pointer</name><parameter_list>(<parameter><decl><type><name>uc_engine</name> <modifier>*</modifier></type><name>uc</name></decl></parameter>, <parameter><decl><type><name>dword_t</name></type> <name>tls_ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_mem_sync</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tlb</name></name> <modifier>*</modifier></type><name>tlb</name></decl></parameter>, <parameter><decl><type><name>uc_engine</name> <modifier>*</modifier></type><name>uc</name></decl></parameter>, <parameter><decl><type><name>addr_t</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>dword_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>size</name></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>tlb_read</name><argument_list>(<argument><expr><name>tlb</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>uc_write</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mem_sync</name><parameter_list>(<parameter><type><name>addr</name></type></parameter>, <parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_mem_sync(tlb, uc, addr, size)</cpp:value></cpp:define>
<function><type><name>void</name></type> <name>step_tracing</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cpu_state</name></name> <modifier>*</modifier></type><name>cpu</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tlb</name></name> <modifier>*</modifier></type><name>tlb</name></decl></parameter>, <parameter><decl><type><name>uc_engine</name> <modifier>*</modifier></type><name>uc</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="line">// step ish</comment>
    <decl_stmt><decl><type><name>addr_t</name></type> <name>old_brk</name> <init>= <expr><name><name>current</name><operator>-&gt;</operator><name>mm</name><operator>-&gt;</operator><name>brk</name></name></expr></init></decl>;</decl_stmt> <comment type="line">// this is important</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>interrupt</name> <init>= <expr><call><name>cpu_run_to_interrupt</name><argument_list>(<argument><expr><name>cpu</name></expr></argument>, <argument><expr><name>tlb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>handle_interrupt</name><argument_list>(<argument><expr><name>interrupt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// step unicorn</comment>
    <expr_stmt><expr><name>uc_interrupt</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>dword_t</name></type> <name>eip</name> <init>= <expr><call><name>uc_getreg</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>UC_X86_REG_EIP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// intercept cpuid and rdtsc</comment>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>code</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>uc_read</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>eip</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x0f</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x31</literal> <operator>||</operator> <name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xa2</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x31</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>uc_setreg</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>UC_X86_REG_EAX</name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>eax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>uc_setreg</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>UC_X86_REG_EDX</name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>edx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xa2</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>uc_setreg</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>UC_X86_REG_EAX</name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>eax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>uc_setreg</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>UC_X86_REG_EBX</name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>ebx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>uc_setreg</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>UC_X86_REG_ECX</name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>ecx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>uc_setreg</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>UC_X86_REG_EDX</name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>edx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>uc_setreg</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>UC_X86_REG_EIP</name></expr></argument>, <argument><expr><name>eip</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <while>while <condition>(<expr><call><name>uc_getreg</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>UC_X86_REG_EIP</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>eip</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>uc_trycall</name><argument_list>(<argument><expr><call><name>uc_emu_start</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>eip</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"unicorn step"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// handle unicorn interrupts</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>uc_regs</name></name></type> <name>regs</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>uc_getregs</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>uc_interrupt</name> <operator>==</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>syscall_num</name> <init>= <expr><name><name>regs</name><operator>.</operator><name>eax</name></name></expr></init></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name>syscall_num</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// put syscall result from fake process into real process</comment>
            <case>case <expr><literal type="number">3</literal></expr>:</case> <comment type="line">// read</comment>
                <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>ecx</name></name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>edx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">7</literal></expr>:</case> <comment type="line">// waitpid</comment>
                <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>ecx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dword_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">13</literal></expr>:</case> <comment type="line">// time</comment>
                <if_stmt><if>if <condition>(<expr><name><name>regs</name><operator>.</operator><name>ebx</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>ebx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dword_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">54</literal></expr>:</case> <block>{<block_content> <comment type="line">// ioctl (god help us)</comment>
                <decl_stmt><decl><type><name><name>struct</name> <name>fd</name></name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><call><name>f_get</name><argument_list>(<argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>ebx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&amp;&amp;</operator> <name><name>fd</name><operator>-&gt;</operator><name>ops</name><operator>-&gt;</operator><name>ioctl_size</name></name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>ssize_t</name></type> <name>ioctl_size</name> <init>= <expr><call><name><name>fd</name><operator>-&gt;</operator><name>ops</name><operator>-&gt;</operator><name>ioctl_size</name></name><argument_list>(<argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>ecx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>ioctl_size</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>edx</name></name></expr></argument>, <argument><expr><name>ioctl_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>
            <case>case <expr><literal type="number">85</literal></expr>:</case> <comment type="line">// readlink</comment>
                <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>ecx</name></name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>edx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">102</literal></expr>:</case> <block>{<block_content> <comment type="line">// socketcall</comment>
                <decl_stmt><decl><type><name>dword_t</name></type> <name><name>args</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>user_get</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>ecx</name></name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>dword_t</name></type> <name>len</name></decl>;</decl_stmt>
                <switch>switch <condition>(<expr><name><name>cpu</name><operator>-&gt;</operator><name>ebx</name></name></expr>)</condition> <block>{<block_content>
                    <case>case <expr><literal type="number">6</literal></expr>:</case> <comment type="line">// getsockname</comment>
                        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>user_get</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="number">8</literal></expr>:</case> <comment type="line">// socketpair</comment>
                        <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>dword_t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="number">12</literal></expr>:</case> <comment type="line">// recvfrom</comment>
                        <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>user_get</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
                <break>break;</break>
            </block_content>}</block>
            <case>case <expr><literal type="number">104</literal></expr>:</case> <comment type="line">// setitimer</comment>
                <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>edx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>itimerval_</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">116</literal></expr>:</case> <comment type="line">// sysinfo</comment>
                <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>ebx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sys_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">122</literal></expr>:</case> <comment type="line">// uname</comment>
                <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>ebx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>uname</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">140</literal></expr>:</case> <comment type="line">// _llseek</comment>
                <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>esi</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">145</literal></expr>:</case> <block>{<block_content> <comment type="line">// readv</comment>
                <decl_stmt><decl><type><name><name>struct</name> <name>iovec_</name></name></type> <name><name>vecs</name><index>[<expr><name><name>regs</name><operator>.</operator><name>edx</name></name></expr>]</index></name></decl>;</decl_stmt>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>user_get</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>ecx</name></name></expr></argument>, <argument><expr><name>vecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>regs</name><operator>.</operator><name>edx</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>vecs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>base</name></expr></argument>, <argument><expr><name><name>vecs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                <break>break;</break>
            </block_content>}</block>
            <case>case <expr><literal type="number">162</literal></expr>:</case> <comment type="line">// nanosleep</comment>
                <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>ecx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>timespec_</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">168</literal></expr>:</case> <comment type="line">// poll</comment>
                <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>ebx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>pollfd_</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>regs</name><operator>.</operator><name>ecx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">174</literal></expr>:</case> <comment type="line">// rt_sigaction</comment>
                <if_stmt><if>if <condition>(<expr><name><name>regs</name><operator>.</operator><name>edx</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>edx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sigaction_</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">183</literal></expr>:</case> <comment type="line">// getcwd</comment>
                <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>ebx</name></name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>eax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

            <case>case <expr><literal type="number">195</literal></expr>:</case> <comment type="line">// stat64</comment>
            <case>case <expr><literal type="number">196</literal></expr>:</case> <comment type="line">// lstat64</comment>
            <case>case <expr><literal type="number">197</literal></expr>:</case> <comment type="line">// fstat64</comment>
                <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>ecx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>newstat64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">300</literal></expr>:</case> <comment type="line">// fstatat64</comment>
                <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>edx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>newstat64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">220</literal></expr>:</case> <comment type="line">// getdents64</comment>
                <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>ecx</name></name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>eax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">265</literal></expr>:</case> <comment type="line">// clock_gettime</comment>
                <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>ecx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>timespec_</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

            <case>case <expr><literal type="number">192</literal></expr>:</case> <comment type="line">// mmap2</comment>
            <case>case <expr><literal type="number">90</literal></expr>:</case> <comment type="line">// mmap</comment>
                <if_stmt><if>if <condition>(<expr><name><name>cpu</name><operator>-&gt;</operator><name>eax</name></name> <operator>&gt;=</operator> <literal type="number">0xfffff000</literal></expr>)</condition> <block>{<block_content>
                    <comment type="line">// fake mmap failed, so don't try real mmap</comment>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <comment type="line">// IMPORTANT: if you try to understand this code you will get brain cancer</comment>
                <decl_stmt><decl><type><name>addr_t</name></type> <name>start</name> <init>= <expr><name><name>cpu</name><operator>-&gt;</operator><name>eax</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>dword_t</name></type> <name>size</name> <init>= <expr><name><name>cpu</name><operator>-&gt;</operator><name>ecx</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>prot</name> <init>= <expr><name><name>cpu</name><operator>-&gt;</operator><name>edx</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>struct</name> <name>fd</name></name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><call><name>f_get</name><argument_list>(<argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>edi</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>real_fd</name> <init>= <expr><ternary><condition><expr><name>fd</name></expr> ?</condition><then> <expr><name><name>fd</name><operator>-&gt;</operator><name>real_fd</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name><name>cpu</name><operator>-&gt;</operator><name>esi</name></name> <operator>&amp;</operator> <operator>~</operator><name>MAP_FIXED</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>off_t</name></type> <name>offset</name> <init>= <expr><name><name>cpu</name><operator>-&gt;</operator><name>ebp</name></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>syscall_num</name> <operator>==</operator> <literal type="number">192</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>offset</name> <operator>&lt;&lt;=</operator> <name>PAGE_BITS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>mem</name> <init>= <expr><call><name>mmap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>prot</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>real_fd</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>mem</name> <operator>==</operator> <name>MAP_FAILED</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"mmap emulation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>uc_map_ptr</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="number">91</literal></expr>:</case> <comment type="line">// munmap</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>cpu</name><operator>-&gt;</operator><name>eax</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>uc_unmap</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>ebx</name></name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>ecx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>

            <case>case <expr><literal type="number">45</literal></expr>:</case> <comment type="line">// brk</comment>
                <comment type="line">// matches up with the logic in kernel/mmap.c</comment>
                <if_stmt><if>if <condition>(<expr><name><name>current</name><operator>-&gt;</operator><name>mm</name><operator>-&gt;</operator><name>brk</name></name> <operator>&gt;</operator> <name>old_brk</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>uc_map</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><call><name>BYTES_ROUND_UP</name><argument_list>(<argument><expr><name>old_brk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BYTES_ROUND_UP</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>mm</name><operator>-&gt;</operator><name>brk</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>BYTES_ROUND_UP</name><argument_list>(<argument><expr><name>old_brk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>current</name><operator>-&gt;</operator><name>mm</name><operator>-&gt;</operator><name>brk</name></name> <operator>&lt;</operator> <name>old_brk</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>uc_unmap</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><call><name>BYTES_ROUND_DOWN</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>mm</name><operator>-&gt;</operator><name>brk</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BYTES_ROUND_DOWN</name><argument_list>(<argument><expr><name>old_brk</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>BYTES_ROUND_DOWN</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>mm</name><operator>-&gt;</operator><name>brk</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>

            <case>case <expr><literal type="number">243</literal></expr>:</case> <block>{<block_content> <comment type="line">// set_thread_area</comment>
                <comment type="line">// icky hacky</comment>
                <decl_stmt><decl><type><name>addr_t</name></type> <name>tls_ptr</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>uc_read</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name><name>regs</name><operator>.</operator><name>ebx</name></name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tls_ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tls_ptr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>set_tls_pointer</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>tls_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>mem_sync</name><argument_list>(<argument><expr><name><name>regs</name><operator>.</operator><name>ebx</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        </block_content>}</block></switch>
        <expr_stmt><expr><call><name>uc_setreg</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>UC_X86_REG_EAX</name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>eax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>uc_interrupt</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>printk</name><argument_list>(<argument><expr><literal type="string">"unhandled unicorn interrupt 0x%x\n"</literal></expr></argument>, <argument><expr><name>uc_interrupt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>uc_interrupt_callback</name><parameter_list>(<parameter><decl><type><name>uc_engine</name> <modifier>*</modifier></type><name>uc</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>interrupt</name></decl></parameter>, <parameter><function_decl><type><name>void</name> <modifier>*</modifier></type><name>UNUSED</name><parameter_list>(<parameter><decl><type><name>user_data</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>uc_interrupt</name> <operator>=</operator> <name>interrupt</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>uc_emu_stop</name><argument_list>(<argument><expr><name>uc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>uc_unmapped_callback</name><parameter_list>(<parameter><decl><type><name>uc_engine</name> <modifier>*</modifier></type><name>uc</name></decl></parameter>, <parameter><function_decl><type><name>uc_mem_type</name></type> <name>UNUSED</name><parameter_list>(<parameter><decl><type><name>type</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>address</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><function_decl><type><name>int64_t</name></type> <name>UNUSED</name><parameter_list>(<parameter><decl><type><name>value</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><function_decl><type><name>void</name> <modifier>*</modifier></type><name>UNUSED</name><parameter_list>(<parameter><decl><type><name>user_data</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>pt_entry</name></name> <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>mem_pt</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><call><name>PAGE</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// handle stack growing</comment>
    <if_stmt><if>if <condition>(<expr><name>pt</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>pt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>P_GROWSDOWN</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>uc_map</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><call><name>BYTES_ROUND_DOWN</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>printk</name><argument_list>(<argument><expr><literal type="string">"unicorn reports unmapped access at 0x%lx size %d\n"</literal></expr></argument>, <argument><expr><name>address</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// thread local bullshit {{{</comment>
<struct>struct <name>gdt_entry</name> <block>{
    <decl_stmt><decl><type><name>uint16_t</name></type> <name>limit0</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16_t</name></type> <name>base0</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>base1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bitfield</name></type> <name>type</name><range>:<expr><literal type="number">4</literal></expr></range></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bitfield</name></type> <name>system</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bitfield</name></type> <name>dpl</name><range>:<expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bitfield</name></type> <name>present</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>limit1</name><range>:<expr><literal type="number">4</literal></expr></range></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bitfield</name></type> <name>avail</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bitfield</name></type> <name>is_64_code</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bitfield</name></type> <name>db</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bitfield</name></type> <name>granularity</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>base2</name></decl>;</decl_stmt>
}</block> <decl><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>packed</name><operator>)</operator></expr></argument>)</argument_list></decl>;</struct>

<comment type="line">// it has to go somewhere, so why not page 1, where nothing can go normally</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GDT_ADDR</name></cpp:macro> <cpp:value>0x1000</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>setup_gdt</name><parameter_list>(<parameter><decl><type><name>uc_engine</name> <modifier>*</modifier></type><name>uc</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="line">// construct gdt</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>gdt_entry</name></name></type> <name><name>gdt</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>
    <comment type="line">// descriptor 0 can't be used</comment>
    <comment type="line">// descriptor 1 = all of memory as code</comment>
    <expr_stmt><expr><name><name>gdt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>limit0</name> <operator>=</operator> <literal type="number">0xffff</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>gdt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>limit1</name> <operator>=</operator> <literal type="number">0xf</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>gdt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>granularity</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gdt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>system</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>gdt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <literal type="number">0xf</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>gdt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>db</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>gdt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>present</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <comment type="line">// descriptor 2 = all of memory as data</comment>
    <expr_stmt><expr><name><name>gdt</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>gdt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>gdt</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <literal type="number">0x3</literal></expr>;</expr_stmt>
    <comment type="line">// descriptor 12 = thread locals</comment>
    <expr_stmt><expr><name><name>gdt</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <name><name>gdt</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>gdt</name><index>[<expr><literal type="number">12</literal></expr>]</index></name><operator>.</operator><name>dpl</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

    <comment type="line">// put gdt into memory, somewhere, idgaf where</comment>
    <expr_stmt><expr><call><name>uc_trycall</name><argument_list>(<argument><expr><call><name>uc_mem_map</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>GDT_ADDR</name></expr></argument>, <argument><expr><name>PAGE_SIZE</name></expr></argument>, <argument><expr><name>UC_PROT_READ</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"map gdt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>uc_trycall</name><argument_list>(<argument><expr><call><name>uc_mem_write</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>GDT_ADDR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gdt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>gdt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"write gdt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// load segment registers</comment>
    <decl_stmt><decl><type><name>uc_x86_mmr</name></type> <name>gdtr</name> <init>= <expr><block>{<expr><operator>.</operator><name>base</name> <operator>=</operator> <name>GDT_ADDR</name></expr>, <expr><operator>.</operator><name>limit</name> <operator>=</operator> sizeof<operator>(</operator><name>gdt</name><operator>)</operator></expr>}</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>uc_trycall</name><argument_list>(<argument><expr><call><name>uc_reg_write</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>UC_X86_REG_GDTR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gdtr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"write gdtr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>uc_setreg</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>UC_X86_REG_CS</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>uc_setreg</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>UC_X86_REG_DS</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>&lt;&lt;</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>uc_setreg</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>UC_X86_REG_ES</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>&lt;&lt;</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>uc_setreg</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>UC_X86_REG_FS</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>&lt;&lt;</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>uc_setreg</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>UC_X86_REG_SS</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>&lt;&lt;</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_tls_pointer</name><parameter_list>(<parameter><decl><type><name>uc_engine</name> <modifier>*</modifier></type><name>uc</name></decl></parameter>, <parameter><decl><type><name>dword_t</name></type> <name>tls_ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>gdt_entry</name></name></type> <name>tls_entry</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>uc_read</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>GDT_ADDR</name> <operator>+</operator> <literal type="number">12</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>gdt_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>tls_entry</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tls_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tls_entry</name><operator>.</operator><name>base0</name></name> <operator>=</operator> <operator>(</operator><name>tls_ptr</name> <operator>&amp;</operator> <literal type="number">0x0000ffff</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tls_entry</name><operator>.</operator><name>base1</name></name> <operator>=</operator> <operator>(</operator><name>tls_ptr</name> <operator>&amp;</operator> <literal type="number">0x00ff0000</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tls_entry</name><operator>.</operator><name>base2</name></name> <operator>=</operator> <operator>(</operator><name>tls_ptr</name> <operator>&amp;</operator> <literal type="number">0xff000000</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>uc_write</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>GDT_ADDR</name> <operator>+</operator> <literal type="number">12</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>gdt_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>tls_entry</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tls_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="line">// }}}</comment>

<function><type><name>uc_engine</name> <modifier>*</modifier></type><name>start_unicorn</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cpu_state</name></name> <modifier>*</modifier></type><name>cpu</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>mem</name></name> <modifier>*</modifier></type><name>mem</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>uc_engine</name> <modifier>*</modifier></type><name>uc</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>uc_trycall</name><argument_list>(<argument><expr><call><name>uc_open</name><argument_list>(<argument><expr><name>UC_ARCH_X86</name></expr></argument>, <argument><expr><name>UC_MODE_32</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"uc_open"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// copy registers</comment>
    <expr_stmt><expr><call><name>uc_setreg</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>UC_X86_REG_ESP</name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>esp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>uc_setreg</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>UC_X86_REG_EIP</name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>eip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>uc_setreg</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>UC_X86_REG_EFLAGS</name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>eflags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>uc_setreg</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>UC_X86_REG_FPCW</name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>fcw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// copy memory</comment>
    <comment type="line">// XXX unicorn has a ?bug? where setting up 334 mappings takes five</comment>
    <comment type="line">// seconds on my raspi. it seems to be accidentally quadratic (dot tumblr dot com)</comment>
    <for>for <control>(<init><decl><type><name>page_t</name></type> <name>page</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>page</name> <operator>&lt;</operator> <name>MEM_PAGES</name></expr>;</condition> <incr><expr><name>page</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>pt_entry</name></name> <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>mem_pt</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>pt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>prot</name> <init>= <expr><name>UC_PROT_READ</name> <operator>|</operator> <name>UC_PROT_EXEC</name></expr></init></decl>;</decl_stmt>
        <comment type="line">// really only the write bit is meaningful (FIXME)</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>P_WRITE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>prot</name> <operator>|=</operator> <name>UC_PROT_WRITE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>addr_t</name></type> <name>addr</name> <init>= <expr><name>page</name> <operator>&lt;&lt;</operator> <name>PAGE_BITS</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>pt</name><operator>-&gt;</operator><name>data</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>pt</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>uc_trycall</name><argument_list>(<argument><expr><call><name>uc_mem_map</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>PAGE_SIZE</name></expr></argument>, <argument><expr><name>prot</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"uc_mem_map"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>uc_trycall</name><argument_list>(<argument><expr><call><name>uc_mem_write</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>PAGE_SIZE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"uc_mem_write"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="line">// set up some sort of gdt, because we need gs to work for thread locals</comment>
    <expr_stmt><expr><call><name>setup_gdt</name><argument_list>(<argument><expr><name>uc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// set up exception handler</comment>
    <decl_stmt><decl><type><name>uc_hook</name></type> <name>hook</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>uc_trycall</name><argument_list>(<argument><expr><call><name>uc_hook_add</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hook</name></expr></argument>, <argument><expr><name>UC_HOOK_INTR</name></expr></argument>, <argument><expr><name>uc_interrupt_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"uc_hook_add"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>uc_trycall</name><argument_list>(<argument><expr><call><name>uc_hook_add</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hook</name></expr></argument>, <argument><expr><name>UC_HOOK_MEM_UNMAPPED</name></expr></argument>, <argument><expr><name>uc_unmapped_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"uc_hook_add"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>uc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>xX_main_Xx</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>err</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// FIXME this often prints the wrong error message on non-x86_64</comment>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><operator>-</operator><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>err</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// create a unicorn and set it up exactly the same as the current process</comment>
    <decl_stmt><decl><type><name>uc_engine</name> <modifier>*</modifier></type><name>uc</name> <init>= <expr><call><name>start_unicorn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>cpu</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>mm</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>cpu_state</name></name> <modifier>*</modifier></type><name>cpu</name> <init>= <expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>cpu</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>tlb</name></name></type> <name>tlb</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>tlb_refresh</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tlb</name></expr></argument>, <argument><expr><name><name>cpu</name><operator>-&gt;</operator><name>mmu</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>undefined_flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>cpu_state</name></name></type> <name>old_cpu</name> <init>= <expr><operator>*</operator><name>cpu</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>true</name></expr>)</condition> <block>{<block_content>
        <while>while <condition>(<expr><call><name>compare_cpus</name><argument_list>(<argument><expr><name>cpu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tlb</name></expr></argument>, <argument><expr><name>uc</name></expr></argument>, <argument><expr><name>undefined_flags</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printk</name><argument_list>(<argument><expr><literal type="string">"resetting cpu\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>cpu</name> <operator>=</operator> <name>old_cpu</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>debugger</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>cpu_run_to_interrupt</name><argument_list>(<argument><expr><name>cpu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tlb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name>undefined_flags</name> <operator>=</operator> <call><name>undefined_flags_mask</name><argument_list>(<argument><expr><name>cpu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tlb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>old_cpu</name> <operator>=</operator> <operator>*</operator><name>cpu</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>step_tracing</name><argument_list>(<argument><expr><name>cpu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tlb</name></expr></argument>, <argument><expr><name>uc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>dump_memory</name><parameter_list>(<parameter><decl><type><name>uc_engine</name> <modifier>*</modifier></type><name>uc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>addr_t</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>size</name></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>uc_trycall</name><argument_list>(<argument><expr><call><name>uc_mem_read</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"uc_mem_read"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

</unit>
