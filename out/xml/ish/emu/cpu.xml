<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="../out/cloned_projects/ish/emu/cpu.h"><cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EMU_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMU_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"misc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"emu/mmu.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"emu/float80.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__KERNEL__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;linux/stddef.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct_decl>struct <name>cpu_state</name>;</struct_decl>
<struct_decl>struct <name>tlb</name>;</struct_decl>
<function_decl><type><name>int</name></type> <name>cpu_run_to_interrupt</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cpu_state</name></name> <modifier>*</modifier></type><name>cpu</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tlb</name></name> <modifier>*</modifier></type><name>tlb</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>cpu_poke</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cpu_state</name></name> <modifier>*</modifier></type><name>cpu</name></decl></parameter>)</parameter_list>;</function_decl>

<union>union <name>mm_reg</name> <block>{
    <decl_stmt><decl><type><name>qword_t</name></type> <name>qw</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dword_t</name></type> <name><name>dw</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</union>
<union>union <name>xmm_reg</name> <block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>__int128</name></type> <name>u128</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>qword_t</name></type> <name><name>qw</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name><name>u32</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16_t</name></type> <name><name>u16</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>u8</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name><name>f32</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name><name>f64</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</union>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>union <name>xmm_reg</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><literal type="string">"xmm_reg size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>union <name>mm_reg</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"mm_reg size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<struct>struct <name>cpu_state</name> <block>{
    <decl_stmt><decl><type><name><name>struct</name> <name>mmu</name></name> <modifier>*</modifier></type><name>mmu</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>cycle</name></decl>;</decl_stmt>

    <comment type="line">// general registers</comment>
    <comment type="line">// assumes little endian (as does literally everything)</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_REG</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>union { \
        dword_t e##n; \
        word_t n; \
    }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_REGX</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>union { \
        dword_t e##n##x; \
        word_t n##x; \
        struct { \
            byte_t n##l; \
            byte_t n##h; \
        }; \
    }</cpp:value></cpp:define>

    <union>union <block>{
        <struct>struct <block>{
            <expr_stmt><expr><call><name>_REGX</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>_REGX</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>_REGX</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>_REGX</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>_REG</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>_REG</name><argument_list>(<argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>_REG</name><argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>_REG</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>;</struct>
        <decl_stmt><decl><type><name>dword_t</name></type> <name><name>regs</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
    }</block>;</union>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>REGX</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>REG</name></cpp:undef>

    <decl_stmt><decl><type><name>dword_t</name></type> <name>eip</name></decl>;</decl_stmt>

    <comment type="line">// flags</comment>
    <union>union <block>{
        <decl_stmt><decl><type><name>dword_t</name></type> <name>eflags</name></decl>;</decl_stmt>
        <struct>struct <block>{
            <decl_stmt><decl><type><name>bitfield</name></type> <name>cf_bit</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>pad1_1</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>pf</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>pad2_0</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>af</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>pad3_0</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>zf</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>sf</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>tf</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>if_</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>df</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>of_bit</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>iopl</name><range>:<expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>
        }</block>;</struct>
        <comment type="line">// for asm</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PF_FLAG</name></cpp:macro> <cpp:value>(1 &lt;&lt; 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AF_FLAG</name></cpp:macro> <cpp:value>(1 &lt;&lt; 4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZF_FLAG</name></cpp:macro> <cpp:value>(1 &lt;&lt; 6)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SF_FLAG</name></cpp:macro> <cpp:value>(1 &lt;&lt; 7)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DF_FLAG</name></cpp:macro> <cpp:value>(1 &lt;&lt; 10)</cpp:value></cpp:define>
    }</block>;</union>
    <comment type="line">// please pretend this doesn't exist</comment>
    <decl_stmt><decl><type><name>dword_t</name></type> <name>df_offset</name></decl>;</decl_stmt>
    <comment type="line">// for maximum efficiency these are stored in bytes</comment>
    <decl_stmt><decl><type><name>byte_t</name></type> <name>cf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>byte_t</name></type> <name>of</name></decl>;</decl_stmt>
    <comment type="line">// whether the true flag values are in the above struct, or computed from</comment>
    <comment type="line">// the stored result and operands</comment>
    <decl_stmt><decl><type><name>dword_t</name></type> <name>res</name></decl>, <decl><type ref="prev"/><name>op1</name></decl>, <decl><type ref="prev"/><name>op2</name></decl>;</decl_stmt>
    <union>union <block>{
        <struct>struct <block>{
            <decl_stmt><decl><type><name>bitfield</name></type> <name>pf_res</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>zf_res</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>sf_res</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>af_ops</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
        }</block>;</struct>
        <comment type="line">// for asm</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PF_RES</name></cpp:macro> <cpp:value>(1 &lt;&lt; 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZF_RES</name></cpp:macro> <cpp:value>(1 &lt;&lt; 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SF_RES</name></cpp:macro> <cpp:value>(1 &lt;&lt; 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AF_OPS</name></cpp:macro> <cpp:value>(1 &lt;&lt; 3)</cpp:value></cpp:define>
        <decl_stmt><decl><type><name>byte_t</name></type> <name>flags_res</name></decl>;</decl_stmt>
    }</block>;</union>

    <decl_stmt><decl><type><name><name>union</name> <name>mm_reg</name></name></type> <name><name>mm</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>union</name> <name>xmm_reg</name></name></type> <name><name>xmm</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>

    <comment type="line">// fpu</comment>
    <decl_stmt><decl><type><name>float80</name></type> <name><name>fp</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
    <union>union <block>{
        <decl_stmt><decl><type><name>word_t</name></type> <name>fsw</name></decl>;</decl_stmt>
        <struct>struct <block>{
            <decl_stmt><decl><type><name>bitfield</name></type> <name>ie</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt> <comment type="line">// invalid operation</comment>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>de</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt> <comment type="line">// denormalized operand</comment>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>ze</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt> <comment type="line">// divide by zero</comment>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>oe</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt> <comment type="line">// overflow</comment>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>ue</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt> <comment type="line">// underflow</comment>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>pe</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt> <comment type="line">// precision</comment>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>stf</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt> <comment type="line">// stack fault</comment>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>es</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt> <comment type="line">// exception status</comment>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>c0</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>c1</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>c2</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name></type> <name>top</name><range>:<expr><literal type="number">3</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>c3</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>b</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt> <comment type="line">// fpu busy (?)</comment>
        }</block>;</struct>
    }</block>;</union>
    <union>union <block>{
        <decl_stmt><decl><type><name>word_t</name></type> <name>fcw</name></decl>;</decl_stmt>
        <struct>struct <block>{
            <decl_stmt><decl><type><name>bitfield</name></type> <name>im</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>dm</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>zm</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>om</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>um</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>pm</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>pad4</name><range>:<expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>pc</name><range>:<expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>rc</name><range>:<expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bitfield</name></type> <name>y</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
        }</block>;</struct>
    }</block>;</union>

    <comment type="line">// TLS bullshit</comment>
    <decl_stmt><decl><type><name>word_t</name></type> <name>gs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>addr_t</name></type> <name>tls_ptr</name></decl>;</decl_stmt>

    <comment type="line">// for the page fault handler</comment>
    <decl_stmt><decl><type><name>addr_t</name></type> <name>segfault_addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>segfault_was_write</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>dword_t</name></type> <name>trapno</name></decl>;</decl_stmt>
    <comment type="line">// access atomically</comment>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>poked_ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>_poked</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CPU_OFFSET</name><parameter_list>(<parameter><type><name>field</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>offsetof(struct cpu_state, field)</cpp:value></cpp:define>

<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><call><name>CPU_OFFSET</name><argument_list>(<argument><expr><name>eax</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>CPU_OFFSET</name><argument_list>(<argument><expr><name><name>regs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"register order"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><call><name>CPU_OFFSET</name><argument_list>(<argument><expr><name>ecx</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>CPU_OFFSET</name><argument_list>(<argument><expr><name><name>regs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"register order"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><call><name>CPU_OFFSET</name><argument_list>(<argument><expr><name>edx</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>CPU_OFFSET</name><argument_list>(<argument><expr><name><name>regs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"register order"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><call><name>CPU_OFFSET</name><argument_list>(<argument><expr><name>ebx</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>CPU_OFFSET</name><argument_list>(<argument><expr><name><name>regs</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"register order"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><call><name>CPU_OFFSET</name><argument_list>(<argument><expr><name>esp</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>CPU_OFFSET</name><argument_list>(<argument><expr><name><name>regs</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"register order"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><call><name>CPU_OFFSET</name><argument_list>(<argument><expr><name>ebp</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>CPU_OFFSET</name><argument_list>(<argument><expr><name><name>regs</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"register order"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><call><name>CPU_OFFSET</name><argument_list>(<argument><expr><name>esi</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>CPU_OFFSET</name><argument_list>(<argument><expr><name><name>regs</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"register order"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><call><name>CPU_OFFSET</name><argument_list>(<argument><expr><name>edi</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>CPU_OFFSET</name><argument_list>(<argument><expr><name><name>regs</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"register order"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>cpu_state</name></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <literal type="number">0xffff</literal></expr></argument>, <argument><expr><literal type="string">"cpu struct is too big for vector gadgets"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="line">// flags</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZF</name></cpp:macro> <cpp:value>(cpu-&gt;zf_res ? cpu-&gt;res == 0 : cpu-&gt;zf)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SF</name></cpp:macro> <cpp:value>(cpu-&gt;sf_res ? (int32_t) cpu-&gt;res &lt; 0 : cpu-&gt;sf)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CF</name></cpp:macro> <cpp:value>(cpu-&gt;cf)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OF</name></cpp:macro> <cpp:value>(cpu-&gt;of)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PF</name></cpp:macro> <cpp:value>(cpu-&gt;pf_res ? !__builtin_parity(cpu-&gt;res &amp; 0xff) : cpu-&gt;pf)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AF</name></cpp:macro> <cpp:value>(cpu-&gt;af_ops ? ((cpu-&gt;op1 ^ cpu-&gt;op2 ^ cpu-&gt;res) &gt;&gt; 4) &amp; 1 : cpu-&gt;af)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>collapse_flags</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cpu_state</name></name> <modifier>*</modifier></type><name>cpu</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>cpu</name><operator>-&gt;</operator><name>zf</name></name> <operator>=</operator> <name>ZF</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cpu</name><operator>-&gt;</operator><name>sf</name></name> <operator>=</operator> <name>SF</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cpu</name><operator>-&gt;</operator><name>pf</name></name> <operator>=</operator> <name>PF</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cpu</name><operator>-&gt;</operator><name>zf_res</name></name> <operator>=</operator> <name><name>cpu</name><operator>-&gt;</operator><name>sf_res</name></name> <operator>=</operator> <name><name>cpu</name><operator>-&gt;</operator><name>pf_res</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cpu</name><operator>-&gt;</operator><name>of_bit</name></name> <operator>=</operator> <name><name>cpu</name><operator>-&gt;</operator><name>of</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cpu</name><operator>-&gt;</operator><name>cf_bit</name></name> <operator>=</operator> <name><name>cpu</name><operator>-&gt;</operator><name>cf</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cpu</name><operator>-&gt;</operator><name>af</name></name> <operator>=</operator> <name>AF</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cpu</name><operator>-&gt;</operator><name>af_ops</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cpu</name><operator>-&gt;</operator><name>pad1_1</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cpu</name><operator>-&gt;</operator><name>pad2_0</name></name> <operator>=</operator> <name><name>cpu</name><operator>-&gt;</operator><name>pad3_0</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cpu</name><operator>-&gt;</operator><name>if_</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>expand_flags</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cpu_state</name></name> <modifier>*</modifier></type><name>cpu</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>cpu</name><operator>-&gt;</operator><name>of</name></name> <operator>=</operator> <name><name>cpu</name><operator>-&gt;</operator><name>of_bit</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cpu</name><operator>-&gt;</operator><name>cf</name></name> <operator>=</operator> <name><name>cpu</name><operator>-&gt;</operator><name>cf_bit</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cpu</name><operator>-&gt;</operator><name>zf_res</name></name> <operator>=</operator> <name><name>cpu</name><operator>-&gt;</operator><name>sf_res</name></name> <operator>=</operator> <name><name>cpu</name><operator>-&gt;</operator><name>pf_res</name></name> <operator>=</operator> <name><name>cpu</name><operator>-&gt;</operator><name>af_ops</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<enum>enum <name>reg32</name> <block>{
    <decl><name>reg_eax</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><name>reg_ecx</name></decl>, <decl><name>reg_edx</name></decl>, <decl><name>reg_ebx</name></decl>, <decl><name>reg_esp</name></decl>, <decl><name>reg_ebp</name></decl>, <decl><name>reg_esi</name></decl>, <decl><name>reg_edi</name></decl>, <decl><name>reg_count</name></decl>,
    <decl><name>reg_none</name> <init>= <expr><name>reg_count</name></expr></init></decl>,
}</block>;</enum>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reg32_name</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>reg32</name></name></type> <name>reg</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <switch>switch <condition>(<expr><name>reg</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>reg_eax</name></expr>:</case> <return>return <expr><literal type="string">"eax"</literal></expr>;</return>
        <case>case <expr><name>reg_ecx</name></expr>:</case> <return>return <expr><literal type="string">"ecx"</literal></expr>;</return>
        <case>case <expr><name>reg_edx</name></expr>:</case> <return>return <expr><literal type="string">"edx"</literal></expr>;</return>
        <case>case <expr><name>reg_ebx</name></expr>:</case> <return>return <expr><literal type="string">"ebx"</literal></expr>;</return>
        <case>case <expr><name>reg_esp</name></expr>:</case> <return>return <expr><literal type="string">"esp"</literal></expr>;</return>
        <case>case <expr><name>reg_ebp</name></expr>:</case> <return>return <expr><literal type="string">"ebp"</literal></expr>;</return>
        <case>case <expr><name>reg_esi</name></expr>:</case> <return>return <expr><literal type="string">"esi"</literal></expr>;</return>
        <case>case <expr><name>reg_edi</name></expr>:</case> <return>return <expr><literal type="string">"edi"</literal></expr>;</return>
        <default>default:</default> <return>return <expr><literal type="string">"?"</literal></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
