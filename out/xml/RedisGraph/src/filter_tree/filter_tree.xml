<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/src/filter_tree/filter_tree.c"><comment type="block">/*
 * Copyright Redis Ltd. 2018 - present
 * Licensed under your choice of the Redis Source Available License 2.0 (RSALv2) or
 * the Server Side Public License v1 (SSPLv1).
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"filter_tree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"RG.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../value.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../errors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/arr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../query_ctx.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/rmalloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../ast/ast_shared.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../datatypes/array.h"</cpp:file></cpp:include>

<comment type="line">// forward declarations</comment>
<function_decl><type><name>void</name></type> <name>_FilterTree_DeMorgan</name>
<parameter_list>(
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>root</name></decl></parameter>,
	<parameter><decl><type><name>uint</name></type> <name>negate_count</name></decl></parameter>
)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>LeftChild</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<return>return <expr><name><name>node</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>left</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>RightChild</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<return>return <expr><name><name>node</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>right</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns the negated operator of given op</comment>
<comment type="line">// for example NOT(a &gt; b) === a &lt;= b</comment>
<function><type><specifier>static</specifier> <name>AST_Operator</name></type> <name>_NegateOperator</name>
<parameter_list>(
	<parameter><decl><type><name>AST_Operator</name></type> <name>op</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<switch>switch<condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>OP_AND</name></expr>:</case>
			<return>return <expr><name>OP_OR</name></expr>;</return>
		<case>case <expr><name>OP_XOR</name></expr>:</case>
			<return>return <expr><name>OP_XNOR</name></expr>;</return>
		<case>case <expr><name>OP_XNOR</name></expr>:</case>
			<return>return <expr><name>OP_XOR</name></expr>;</return>
		<case>case <expr><name>OP_OR</name></expr>:</case>
			<return>return <expr><name>OP_AND</name></expr>;</return>
		<case>case <expr><name>OP_EQUAL</name></expr>:</case>
			<return>return <expr><name>OP_NEQUAL</name></expr>;</return>
		<case>case <expr><name>OP_NEQUAL</name></expr>:</case>
			<return>return <expr><name>OP_EQUAL</name></expr>;</return>
		<case>case <expr><name>OP_LT</name></expr>:</case>
			<return>return <expr><name>OP_GE</name></expr>;</return>
		<case>case <expr><name>OP_GT</name></expr>:</case>
			<return>return <expr><name>OP_LE</name></expr>;</return>
		<case>case <expr><name>OP_LE</name></expr>:</case>
			<return>return <expr><name>OP_GT</name></expr>;</return>
		<case>case <expr><name>OP_GE</name></expr>:</case>
			<return>return <expr><name>OP_LT</name></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>OP_UNKNOWN</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="line">// negate expression by wrapping it with a NOT function, NOT(exp)</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_NegateExpression</name>
<parameter_list>(
	<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>exp</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><call><name>AR_EXP_NewOpNode</name><argument_list>(<argument><expr><literal type="string">"not"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>exp</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>exp</name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>IsNodePredicate</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<return>return <expr><name><name>node</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>FT_N_PRED</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>FilterTree_AppendLeftChild</name>
<parameter_list>(
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>child</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>left</name></name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
	<return>return <expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>left</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>FilterTree_AppendRightChild</name>
<parameter_list>(
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>child</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>right</name></name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
	<return>return <expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>right</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>FilterTree_CreateExpressionFilter</name>
<parameter_list>(
	<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>exp</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>exp</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FT_FilterNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name>FT_N_EXP</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name> <operator>=</operator> <name>exp</name></expr>;</expr_stmt>
	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>FilterTree_CreatePredicateFilter</name>
<parameter_list>(
	<parameter><decl><type><name>AST_Operator</name></type> <name>op</name></decl></parameter>,
	<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>lhs</name></decl></parameter>,
	<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>rhs</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>filterNode</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FT_FilterNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>filterNode</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name>FT_N_PRED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>filterNode</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>filterNode</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>lhs</name></name> <operator>=</operator> <name>lhs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>filterNode</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>rhs</name></name> <operator>=</operator> <name>rhs</name></expr>;</expr_stmt>
	<return>return <expr><name>filterNode</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>FilterTree_CreateConditionFilter</name>
<parameter_list>(
	<parameter><decl><type><name>AST_Operator</name></type> <name>op</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>filterNode</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FT_FilterNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>filterNode</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name>FT_N_COND</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>filterNode</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
	<return>return <expr><name>filterNode</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_FilterTree_SubTrees</name>
<parameter_list>(
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>sub_trees</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>root</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<switch>switch<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>t</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>FT_N_EXP</name></expr>:</case>
		<case>case <expr><name>FT_N_PRED</name></expr>:</case>
			<comment type="line">// this is a simple predicate tree, can not traverse further</comment>
			<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><operator>*</operator><name>sub_trees</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FT_N_COND</name></expr>:</case>
			<switch>switch<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>op</name></name></expr>)</condition> <block>{<block_content>
				<case>case <expr><name>OP_AND</name></expr>:</case>
					<comment type="line">// break AND down to its components</comment>
					<expr_stmt><expr><call><name>_FilterTree_SubTrees</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>sub_trees</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>_FilterTree_SubTrees</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name>sub_trees</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><operator>(</operator><name>FT_FilterNode</name> <operator>*</operator><operator>)</operator><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OP_OR</name></expr>:</case>
				<case>case <expr><name>OP_XOR</name></expr>:</case>
				<case>case <expr><name>OP_XNOR</name></expr>:</case>
					<comment type="line">// OR, XOR, and XNOR trees must be return as is</comment>
					<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><operator>*</operator><name>sub_trees</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="line">// combine filters into a single filter tree using AND conditions</comment>
<comment type="line">// filters[0] AND filters[1] AND ... filters[count]</comment>
<function><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>FilterTree_Combine</name>
<parameter_list>(
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>filters</name></decl></parameter>,
	<parameter><decl><type><name>uint</name></type> <name>count</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>filters</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>root</name> <operator>=</operator> <name><name>filters</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>and</name> <init>= <expr><call><name>FilterTree_CreateConditionFilter</name><argument_list>(<argument><expr><name>OP_AND</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>FilterTree_AppendLeftChild</name><argument_list>(<argument><expr><name>and</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FilterTree_AppendRightChild</name><argument_list>(<argument><expr><name>and</name></expr></argument>, <argument><expr><name><name>filters</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>root</name> <operator>=</operator> <name>and</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>root</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>FT_FilterNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>FilterTree_SubTrees</name>
<parameter_list>(
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>FT_FilterNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>sub_trees</name> <init>= <expr><call><name>array_new</name><argument_list>(<argument><expr><name>FT_FilterNode</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_FilterTree_SubTrees</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sub_trees</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>sub_trees</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// applies a single filter to a single result</comment>
<comment type="line">// compares given values, tests if values maintain desired relation (op)</comment>
<function><type><name>FT_Result</name></type> <name>_applyFilter</name>
<parameter_list>(
	<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>aVal</name></decl></parameter>,
	<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>bVal</name></decl></parameter>,
	<parameter><decl><type><name>AST_Operator</name></type> <name>op</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>disjointOrNull</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rel</name> <init>= <expr><call><name>SIValue_Compare</name><argument_list>(<argument><expr><operator>*</operator><name>aVal</name></expr></argument>, <argument><expr><operator>*</operator><name>bVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>disjointOrNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// if there was null comparison, return false</comment>
	<if_stmt><if>if<condition>(<expr><name>disjointOrNull</name> <operator>==</operator> <name>COMPARED_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FILTER_NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="line">// values are of disjoint types</comment>
	<if_stmt><if>if<condition>(<expr><name>disjointOrNull</name> <operator>==</operator> <name>DISJOINT</name> <operator>||</operator> <name>disjointOrNull</name> <operator>==</operator> <name>COMPARED_NAN</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// the filter passes if we're testing for inequality, and fails otherwise</comment>
		<return>return <expr><operator>(</operator><name>op</name> <operator>==</operator> <name>OP_NEQUAL</name><operator>)</operator></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<switch>switch<condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>OP_EQUAL</name></expr>:</case>
			<return>return <expr><name>rel</name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
		<case>case <expr><name>OP_NEQUAL</name></expr>:</case>
			<return>return <expr><name>rel</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
		<case>case <expr><name>OP_GT</name></expr>:</case>
			<return>return <expr><name>rel</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
		<case>case <expr><name>OP_GE</name></expr>:</case>
			<return>return <expr><name>rel</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</return>
		<case>case <expr><name>OP_LT</name></expr>:</case>
			<return>return <expr><name>rel</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</return>
		<case>case <expr><name>OP_LE</name></expr>:</case>
			<return>return <expr><name>rel</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>;</return>
		<default>default:</default>
			<comment type="line">// op should be enforced by AST</comment>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="line">// we shouldn't reach this point</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>FT_Result</name></type> <name>_applyPredicateFilters</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>Record</name></type> <name>r</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// A op B</comment>
	<comment type="line">// Evaluate the left and right sides of the predicate to obtain</comment>
	<comment type="line">// comparable SIValues</comment>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>lhs</name> <init>= <expr><call><name>AR_EXP_Evaluate</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>lhs</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>rhs</name> <init>= <expr><call><name>AR_EXP_Evaluate</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>rhs</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>FT_Result</name></type> <name>ret</name> <init>= <expr><call><name>_applyFilter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lhs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rhs</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>op</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SIValue_Free</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SIValue_Free</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FT_Result</name></type> <name>_applyCondition</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>Record</name></type> <name>r</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// root-&gt;t == FT_N_COND, visit left subtree</comment>
	<decl_stmt><decl><type><name>FT_Result</name></type> <name>rhs_pass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FT_Result</name></type> <name>lhs_pass</name> <init>= <expr><call><name>FilterTree_applyFilters</name><argument_list>(<argument><expr><call><name>LeftChild</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FT_Result</name></type> <name>pass</name> <init>= <expr><name>lhs_pass</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>op</name></name> <operator>==</operator> <name>OP_AND</name> <operator>&amp;&amp;</operator> <name>lhs_pass</name> <operator>!=</operator> <name>FILTER_FAIL</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// AND truth table</comment>
		<comment type="line">// ------------------------</comment>
		<comment type="line">// AND  | T     F    NULL |</comment>
		<comment type="line">// ------------------------</comment>
		<comment type="line">// T    | T     F    NULL |</comment>
		<comment type="line">// ------------------------</comment>
		<comment type="line">// F    | F     F    F    |</comment>
		<comment type="line">// ------------------------</comment>
		<comment type="line">// NULL | NULL  F    NULL |</comment>
		<comment type="line">// ------------------------</comment>
		<comment type="line">// AND ( F, ? ) == F</comment>
		<comment type="line">// AND ( T, T ) == T</comment>
		<comment type="line">// otherwise NULL</comment>

		<comment type="line">// evaluate right subtree</comment>
		<expr_stmt><expr><name>rhs_pass</name> <operator>=</operator> <call><name>FilterTree_applyFilters</name><argument_list>(<argument><expr><call><name>RightChild</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>lhs_pass</name> <operator>==</operator> <name>FILTER_PASS</name> <operator>&amp;&amp;</operator> <name>rhs_pass</name> <operator>==</operator> <name>FILTER_PASS</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// true &amp;&amp; true == true</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>FILTER_PASS</name></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>rhs_pass</name> <operator>==</operator> <name>FILTER_FAIL</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// ? &amp;&amp; false == false</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>FILTER_FAIL</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="line">// otherwise NULL</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>FILTER_NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>op</name></name> <operator>==</operator> <name>OP_OR</name> <operator>&amp;&amp;</operator> <name>lhs_pass</name> <operator>!=</operator> <name>FILTER_PASS</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// OR truth table</comment>
		<comment type="line">// ------------------------</comment>
		<comment type="line">// OR   | T     F    NULL |</comment>
		<comment type="line">// ------------------------</comment>
		<comment type="line">// T    | T     T    T    |</comment>
		<comment type="line">// ------------------------</comment>
		<comment type="line">// F    | T     F    NULL |</comment>
		<comment type="line">// ------------------------</comment>
		<comment type="line">// NULL | T     NULL NULL |</comment>
		<comment type="line">// ------------------------</comment>
		<comment type="line">// OR ( T, ? ) == T</comment>
		<comment type="line">// OR ( F, F ) == F</comment>
		<comment type="line">// otherwise NULL</comment>

		<comment type="line">// visit right subtree</comment>
		<expr_stmt><expr><name>rhs_pass</name> <operator>=</operator> <call><name>FilterTree_applyFilters</name><argument_list>(<argument><expr><call><name>RightChild</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>rhs_pass</name> <operator>==</operator> <name>FILTER_PASS</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// ? || true == true</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>FILTER_PASS</name></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>lhs_pass</name> <operator>==</operator> <name>FILTER_FAIL</name> <operator>&amp;&amp;</operator> <name>rhs_pass</name> <operator>==</operator> <name>FILTER_FAIL</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// false || false == false</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>FILTER_FAIL</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="line">// otherwise NULL</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>FILTER_NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>op</name></name> <operator>==</operator> <name>OP_XOR</name> <operator>&amp;&amp;</operator> <name>lhs_pass</name> <operator>!=</operator> <name>FILTER_NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// XOR truth table</comment>
		<comment type="line">// ------------------------</comment>
		<comment type="line">// XOR  | T     F    NULL |</comment>
		<comment type="line">// ------------------------</comment>
		<comment type="line">// T    | F     T    NULL |</comment>
		<comment type="line">// ------------------------</comment>
		<comment type="line">// F    | T     F    NULL |</comment>
		<comment type="line">// ------------------------</comment>
		<comment type="line">// NULL | NULL  NULL NULL |</comment>
		<comment type="line">// ------------------------</comment>
		<comment type="line">// XOR ( T, F ) == T</comment>
		<comment type="line">// XOR ( F, T ) == T</comment>
		<comment type="line">// XOR ( F, F ) == F</comment>
		<comment type="line">// XOR ( T, T ) == F</comment>
		<comment type="line">// otherwise NULL</comment>

		<comment type="line">// visit right subtree</comment>
		<expr_stmt><expr><name>rhs_pass</name> <operator>=</operator> <call><name>FilterTree_applyFilters</name><argument_list>(<argument><expr><call><name>RightChild</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>rhs_pass</name> <operator>==</operator> <name>FILTER_NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>FILTER_NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>lhs_pass</name> <operator>==</operator> <name>rhs_pass</name><operator>)</operator></expr> ?</condition><then> <expr><name>FILTER_FAIL</name></expr> </then><else>: <expr><name>FILTER_PASS</name></expr></else></ternary></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>op</name></name> <operator>==</operator> <name>OP_XNOR</name> <operator>&amp;&amp;</operator> <name>lhs_pass</name> <operator>!=</operator> <name>FILTER_NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// XNOR truth table</comment>
		<comment type="line">// ------------------------</comment>
		<comment type="line">// XNOR | T     F    NULL |</comment>
		<comment type="line">// ------------------------</comment>
		<comment type="line">// T    | T     F    NULL |</comment>
		<comment type="line">// ------------------------</comment>
		<comment type="line">// F    | F     T    NULL |</comment>
		<comment type="line">// ------------------------</comment>
		<comment type="line">// NULL | NULL  NULL NULL |</comment>
		<comment type="line">// ------------------------</comment>
		<comment type="line">// XOR ( T, F ) == F</comment>
		<comment type="line">// XOR ( F, T ) == F</comment>
		<comment type="line">// XOR ( F, F ) == T</comment>
		<comment type="line">// XOR ( T, T ) == T</comment>
		<comment type="line">// otherwise NULL</comment>

		<comment type="line">// visit right subtree</comment>
		<expr_stmt><expr><name>rhs_pass</name> <operator>=</operator> <call><name>FilterTree_applyFilters</name><argument_list>(<argument><expr><call><name>RightChild</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>rhs_pass</name> <operator>==</operator> <name>FILTER_NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>FILTER_NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>lhs_pass</name> <operator>==</operator> <name>rhs_pass</name><operator>)</operator></expr> ?</condition><then> <expr><name>FILTER_PASS</name></expr> </then><else>: <expr><name>FILTER_FAIL</name></expr></else></ternary></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>op</name></name> <operator>==</operator> <name>OP_NOT</name> <operator>&amp;&amp;</operator> <name>lhs_pass</name> <operator>!=</operator> <name>FILTER_NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// NOT truth table</comment>
		<comment type="line">// -------------</comment>
		<comment type="line">// NOT         | </comment>
		<comment type="line">// -------------</comment>
		<comment type="line">// T    | F    |</comment>
		<comment type="line">// -------------</comment>
		<comment type="line">// F    | T    |</comment>
		<comment type="line">// -------------</comment>
		<comment type="line">// NULL | NULL |</comment>
		<comment type="line">// -------------</comment>

		<expr_stmt><expr><name>pass</name> <operator>=</operator> <ternary><condition><expr><name>lhs_pass</name> <operator>==</operator> <name>FILTER_PASS</name></expr> ?</condition><then> <expr><name>FILTER_FAIL</name></expr> </then><else>: <expr><name>FILTER_PASS</name></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>pass</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>FT_Result</name></type> <name>FilterTree_applyFilters</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>Record</name></type> <name>r</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<switch>switch<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>t</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>FT_N_COND</name></expr>:</case> <block>{<block_content>
			<return>return <expr><call><name>_applyCondition</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>
		<case>case <expr><name>FT_N_PRED</name></expr>:</case> <block>{<block_content>
			<return>return <expr><call><name>_applyPredicateFilters</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>
		<case>case <expr><name>FT_N_EXP</name></expr>:</case> <block>{<block_content>
			<decl_stmt><decl><type><name>FT_Result</name></type> <name>retval</name> <init>= <expr><name>FILTER_PASS</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SIValue</name></type> <name>res</name> <init>= <expr><call><name>AR_EXP_Evaluate</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<comment type="line">// expression evaluated to NULL should return NULL</comment>
				<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FILTER_NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>T_BOOL</name></expr>)</condition> <block>{<block_content>
				<comment type="line">// return false if this boolean value is false</comment>
				<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsFalse</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FILTER_FAIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>T_ARRAY</name></expr>)</condition> <block>{<block_content>
				<comment type="line">// an empty array is falsey, all other arrays should return true</comment>
				<if_stmt><if>if<condition>(<expr><call><name>SIArray_Length</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FILTER_FAIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<comment type="line">// if the expression node evaluated to an unexpected type:</comment>
				<comment type="line">// numeric, string, node or edge, emit an error</comment>
				<expr_stmt><expr><call><name>Error_SITypeMismatch</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>T_BOOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FILTER_FAIL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>SIValue_Free</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// if res was a heap allocation, free it</comment>
			<return>return <expr><name>retval</name></expr>;</return>
		</block_content>}</block>
		<default>default:</default>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="line">// we shouldn't be here</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>FILTER_FAIL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_FilterTree_CollectModified</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
	<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>modified</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>root</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<switch>switch<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>t</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>FT_N_COND</name></expr>:</case> <block>{<block_content>
			<expr_stmt><expr><call><name>_FilterTree_CollectModified</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>modified</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_FilterTree_CollectModified</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name>modified</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>FT_N_PRED</name></expr>:</case> <block>{<block_content>
			<comment type="line">// traverse left and right-hand expressions,</comment>
			<comment type="line">// adding all encountered modified to the triemap</comment>
			<comment type="line">// we'll typically encounter 0 or 1 modified in each expression,</comment>
			<comment type="line">// but there are multi-argument exceptions</comment>
			<expr_stmt><expr><call><name>AR_EXP_CollectEntities</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>lhs</name></name></expr></argument>, <argument><expr><name>modified</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AR_EXP_CollectEntities</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>rhs</name></name></expr></argument>, <argument><expr><name>modified</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>FT_N_EXP</name></expr>:</case> <block>{<block_content>
			<comment type="line">// traverse expression, adding all encountered modified to the triemap</comment>
			<expr_stmt><expr><call><name>AR_EXP_CollectEntities</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name></expr></argument>, <argument><expr><name>modified</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<default>default:</default> <block>{<block_content>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>rax</name> <modifier>*</modifier></type><name>FilterTree_CollectModified</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>modified</name> <init>= <expr><call><name>raxNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_FilterTree_CollectModified</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>modified</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>modified</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_FilterTree_CollectAttributes</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
	<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>attributes</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>root</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<switch>switch<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>t</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>FT_N_COND</name></expr>:</case> <block>{<block_content>
			<expr_stmt><expr><call><name>_FilterTree_CollectAttributes</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>attributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_FilterTree_CollectAttributes</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name>attributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>FT_N_PRED</name></expr>:</case> <block>{<block_content>
			<comment type="line">// traverse left and right-hand expressions,</comment>
			<comment type="line">// adding all encountered attributes to the triemap</comment>
			<expr_stmt><expr><call><name>AR_EXP_CollectAttributes</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>lhs</name></name></expr></argument>, <argument><expr><name>attributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AR_EXP_CollectAttributes</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>rhs</name></name></expr></argument>, <argument><expr><name>attributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>FT_N_EXP</name></expr>:</case> <block>{<block_content>
			<expr_stmt><expr><call><name>AR_EXP_CollectAttributes</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name></expr></argument>, <argument><expr><name>attributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<default>default:</default> <block>{<block_content>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>rax</name> <modifier>*</modifier></type><name>FilterTree_CollectAttributes</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>attributes</name> <init>= <expr><call><name>raxNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_FilterTree_CollectAttributes</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>attributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>attributes</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>FilterTree_FiltersAlias</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// Collect all filtered variables.</comment>
	<decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>filtered_variables</name> <init>= <expr><call><name>FilterTree_CollectModified</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>raxIterator</name></type> <name>it</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>filtered_variables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// Iterate over all keys in the rax.</comment>
	<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><literal type="string">"^"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>alias_is_filtered</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="line">// Build string on the stack to add null terminator.</comment>
		<decl_stmt><decl><type><name>char</name></type> <name><name>variable</name><index>[<expr><name><name>it</name><operator>.</operator><name>key_len</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>variable</name></expr></argument>, <argument><expr><name><name>it</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>it</name><operator>.</operator><name>key_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>variable</name><index>[<expr><name><name>it</name><operator>.</operator><name>key_len</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<comment type="line">// Check if the filtered variable is an alias.</comment>
		<if_stmt><if>if<condition>(<expr><call><name>AST_IdentifierIsAlias</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>variable</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>alias_is_filtered</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>filtered_variables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>alias_is_filtered</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>FilterTree_containsOp</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
	<parameter><decl><type><name>AST_Operator</name></type> <name>op</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<switch>switch<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>t</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>FT_N_COND</name></expr>:</case>
			<if_stmt><if>if<condition>(<expr><call><name>FilterTree_containsOp</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if<condition>(<expr><call><name>FilterTree_containsOp</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		<case>case <expr><name>FT_N_EXP</name></expr>:</case>
			<return>return <expr><name>false</name></expr>;</return>
		<case>case <expr><name>FT_N_PRED</name></expr>:</case>
			<return>return <expr><operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>op</name></name> <operator>==</operator> <name>op</name><operator>)</operator></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>_FilterTree_ContainsFunc</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func</name></decl></parameter>,
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>node</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>root</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<switch>switch<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>t</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>FT_N_COND</name></expr>:</case> <block>{<block_content>
			<return>return <expr><call><name>FilterTree_ContainsFunc</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>||</operator>
				   <call><name>FilterTree_ContainsFunc</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>
		<case>case <expr><name>FT_N_PRED</name></expr>:</case> <block>{<block_content>
			<if_stmt><if>if<condition>(<expr><call><name>AR_EXP_ContainsFunc</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>lhs</name></name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>AR_EXP_ContainsFunc</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>rhs</name></name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>node</name> <operator>=</operator> <operator>(</operator><name>FT_FilterNode</name> <operator>*</operator><operator>)</operator><name>root</name></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block>
		<case>case <expr><name>FT_N_EXP</name></expr>:</case> <block>{<block_content>
			<if_stmt><if>if<condition>(<expr><call><name>AR_EXP_ContainsFunc</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>node</name> <operator>=</operator> <operator>(</operator><name>FT_FilterNode</name> <operator>*</operator><operator>)</operator> <name>root</name></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block>
		<default>default:</default>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="string">"Unkown filter tree node type"</literal> <operator>&amp;&amp;</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>FilterTree_ContainsFunc</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func</name></decl></parameter>,
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>node</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>root</name> <operator>&amp;&amp;</operator> <name>func</name> <operator>&amp;&amp;</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>node</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><call><name>_FilterTree_ContainsFunc</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_FilterTree_ApplyNegate</name>
<parameter_list>(
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>root</name></decl></parameter>,
	<parameter><decl><type><name>uint</name></type> <name>negate_count</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<switch>switch<condition>(<expr><name><operator>(</operator><operator>*</operator><name>root</name><operator>)</operator><operator>-&gt;</operator><name>t</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>FT_N_EXP</name></expr>:</case>
			<if_stmt><if>if<condition>(<expr><name>negate_count</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>_NegateExpression</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>root</name><operator>)</operator><operator>-&gt;</operator><name><name>exp</name><operator>.</operator><name>exp</name></name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>FT_N_PRED</name></expr>:</case>
			<if_stmt><if>if<condition>(<expr><name>negate_count</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>root</name><operator>)</operator><operator>-&gt;</operator><name><name>pred</name><operator>.</operator><name>op</name></name></name> <operator>=</operator> <call><name>_NegateOperator</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>root</name><operator>)</operator><operator>-&gt;</operator><name><name>cond</name><operator>.</operator><name>op</name></name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>FT_N_COND</name></expr>:</case>
			<if_stmt><if>if<condition>(<expr><name><operator>(</operator><operator>*</operator><name>root</name><operator>)</operator><operator>-&gt;</operator><name><name>cond</name><operator>.</operator><name>op</name></name></name> <operator>==</operator> <name>OP_NOT</name></expr>)</condition> <block>{<block_content>
				<comment type="line">// _FilterTree_DeMorgan will increase negate_count by 1</comment>
				<expr_stmt><expr><call><name>_FilterTree_DeMorgan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>negate_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<if_stmt><if>if<condition>(<expr><name>negate_count</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>root</name><operator>)</operator><operator>-&gt;</operator><name><name>cond</name><operator>.</operator><name>op</name></name></name> <operator>=</operator> <call><name>_NegateOperator</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>root</name><operator>)</operator><operator>-&gt;</operator><name><name>cond</name><operator>.</operator><name>op</name></name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>_FilterTree_ApplyNegate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>root</name><operator>)</operator><operator>-&gt;</operator><name><name>cond</name><operator>.</operator><name>left</name></name></name></expr></argument>, <argument><expr><name>negate_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>_FilterTree_ApplyNegate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>root</name><operator>)</operator><operator>-&gt;</operator><name><name>cond</name><operator>.</operator><name>right</name></name></name></expr></argument>, <argument><expr><name>negate_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="line">// if a filter node that's not a child of a predicate is an expression,</comment>
<comment type="line">// it should resolve to a boolean value</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>_FilterTree_ValidExpressionNode</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>valid</name> <init>= <expr><call><name>AR_EXP_ReturnsBoolean</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>valid</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Expected boolean predicate."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>valid</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>FilterTree_Valid</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// An empty tree is has a valid structure.</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>root</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>t</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>FT_N_EXP</name></expr>:</case>
			<return>return <expr><call><name>_FilterTree_ValidExpressionNode</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return>
			<break>break;</break>
		<case>case <expr><name>FT_N_PRED</name></expr>:</case>
			<comment type="line">// Empty or semi empty predicate, invalid structure.</comment>
			<if_stmt><if>if<condition>(<expr><operator>(</operator><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>lhs</name></name> <operator>||</operator> <operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>rhs</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Filter predicate did not compare two expressions."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>FT_N_COND</name></expr>:</case>
			<comment type="line">// Empty condition, invalid structure.</comment>
			<comment type="line">// OR, AND should utilize both left and right children</comment>
			<comment type="line">// NOT utilize only the left child.</comment>
			<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>left</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>right</name></name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Empty filter condition."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>op</name></name> <operator>==</operator> <name>OP_NOT</name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>right</name></name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Invalid usage of 'NOT' filter."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>FilterTree_Valid</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>FilterTree_Valid</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="string">"Unknown filter tree node"</literal> <operator>&amp;&amp;</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_FilterTree_DeMorgan</name>
<parameter_list>(
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>root</name></decl></parameter>,
	<parameter><decl><type><name>uint</name></type> <name>negate_count</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// search for NOT nodes and reduce using DeMorgan</comment>
	<if_stmt><if>if<condition>(<expr><operator>*</operator><name>root</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><operator>(</operator><operator>*</operator><name>root</name><operator>)</operator><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>FT_N_PRED</name> <operator>||</operator> <name><operator>(</operator><operator>*</operator><name>root</name><operator>)</operator><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>FT_N_EXP</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<comment type="line">// node is of type condition</comment>
	<if_stmt><if>if<condition>(<expr><name><operator>(</operator><operator>*</operator><name>root</name><operator>)</operator><operator>-&gt;</operator><name><name>cond</name><operator>.</operator><name>op</name></name></name> <operator>==</operator> <name>OP_NOT</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>root</name><operator>)</operator><operator>-&gt;</operator><name><name>cond</name><operator>.</operator><name>right</name></name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_FilterTree_ApplyNegate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>root</name><operator>)</operator><operator>-&gt;</operator><name><name>cond</name><operator>.</operator><name>left</name></name></name></expr></argument>, <argument><expr><name>negate_count</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// replace NOT node with only child</comment>
		<decl_stmt><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><name><operator>(</operator><operator>*</operator><name>root</name><operator>)</operator><operator>-&gt;</operator><name><name>cond</name><operator>.</operator><name>left</name></name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>root</name><operator>)</operator><operator>-&gt;</operator><name><name>cond</name><operator>.</operator><name>left</name></name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FilterTree_Free</name><argument_list>(<argument><expr><operator>*</operator><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>root</name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>FilterTree_DeMorgan</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>root</name><operator>)</operator><operator>-&gt;</operator><name><name>cond</name><operator>.</operator><name>left</name></name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FilterTree_DeMorgan</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>root</name><operator>)</operator><operator>-&gt;</operator><name><name>cond</name><operator>.</operator><name>right</name></name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>FilterTree_DeMorgan</name>
<parameter_list>(
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>root</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>_FilterTree_DeMorgan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// return if this node can be used in compression - constant expression</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>_FilterTree_Compact_Exp</name>
<parameter_list>(
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>AR_EXP_IsConstant</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>AR_EXP_IsParameter</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// in place set an existing filter tree node to expression node</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>_FilterTree_In_Place_Set_Exp</name>
<parameter_list>(
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
	<parameter><decl><type><name>SIValue</name></type> <name>v</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name>FT_N_EXP</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name> <operator>=</operator> <call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// compacts 'AND' condition node</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>_FilterTree_Compact_And</name>
<parameter_list>(
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// try to compact left and right children</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_lhs_const</name> <init>= <expr><call><name>FilterTree_Compact</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_rhs_const</name> <init>= <expr><call><name>FilterTree_Compact</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// if both are not compactable, this node is not compactable</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>is_lhs_const</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_rhs_const</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// in every case from now, there will be a reduction</comment>
	<comment type="line">// save the children in local placeholders</comment>
	<comment type="line">// for current node in-place modifications</comment>
	<decl_stmt><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>lhs</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>left</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>rhs</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>right</name></name></expr></init></decl>;</decl_stmt>

	<comment type="line">// both children are constants</comment>
	<comment type="line">// this node can be set as a constant expression</comment>
	<if_stmt><if>if<condition>(<expr><name>is_lhs_const</name> <operator>&amp;&amp;</operator> <name>is_rhs_const</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// both children are contant expressions</comment>
		<comment type="line">// we can evaluate and compact</comment>
		<comment type="line">// final value is AND operation on lhs and rhs - reducing an AND node</comment>
		<decl_stmt><decl><type><name>SIValue</name></type>  <name>final_value</name>  <init>=  <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SIValue</name></type>  <name>lhs_value</name>    <init>=  <expr><call><name>AR_EXP_Evaluate</name><argument_list>(<argument><expr><name><name>lhs</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name></expr></argument>,  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SIValue</name></type>  <name>rhs_value</name>    <init>=  <expr><call><name>AR_EXP_Evaluate</name><argument_list>(<argument><expr><name><name>rhs</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name></expr></argument>,  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>lhs_value</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>rhs_value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<comment type="line">// both lhs and rhs are NOT NULL</comment>
			<expr_stmt><expr><name>final_value</name> <operator>=</operator> <call><name>SI_BoolVal</name><argument_list>(<argument><expr><call><name>SIValue_IsTrue</name><argument_list>(<argument><expr><name>lhs_value</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>SIValue_IsTrue</name><argument_list>(<argument><expr><name>rhs_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><operator>(</operator><operator>!</operator><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>lhs_value</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>SIValue_IsFalse</name><argument_list>(<argument><expr><name>lhs_value</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
				  <operator>(</operator><operator>!</operator><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>rhs_value</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>SIValue_IsFalse</name><argument_list>(<argument><expr><name>rhs_value</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
			<comment type="line">// FALSE AND NULL is NULL</comment>
			<expr_stmt><expr><name>final_value</name> <operator>=</operator>  <call><name>SI_BoolVal</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// in place set the node to be an expression node</comment>
		<expr_stmt><expr><call><name>_FilterTree_In_Place_Set_Exp</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>final_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FilterTree_Free</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FilterTree_Free</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="line">// only one of the nodes is constant, find and evaluate</comment>
		<decl_stmt><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>const_node</name> <init>= <expr><ternary><condition><expr><name>is_lhs_const</name></expr> ?</condition><then> <expr><name>lhs</name></expr> </then><else>: <expr><name>rhs</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>non_const_node</name> <init>= <expr><ternary><condition><expr><name>is_lhs_const</name></expr> ?</condition><then> <expr><name>rhs</name></expr> </then><else>: <expr><name>lhs</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="line">// evaluate constant</comment>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>const_value</name> <init>= <expr><call><name>AR_EXP_Evaluate</name><argument_list>(<argument><expr><name><name>const_node</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// if constant is null, no compaction</comment>
		<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>const_value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		
		<comment type="line">// if consant is false, everything is false</comment>
		<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsFalse</name><argument_list>(<argument><expr><name>const_value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>node</name> <operator>=</operator> <operator>*</operator><name>const_node</name></expr>;</expr_stmt>
			<comment type="line">// free const node allocation, without free the data</comment>
			<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>const_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="line">// free non const node completely</comment>
			<expr_stmt><expr><call><name>FilterTree_Free</name><argument_list>(<argument><expr><name>non_const_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="line">// const value is either true</comment>
			<comment type="line">// current node should be replaced with the non const node</comment>
			<expr_stmt><expr><operator>*</operator><name>node</name> <operator>=</operator> <operator>*</operator><name>non_const_node</name></expr>;</expr_stmt>
			<comment type="line">// free non const node allocation, without free the data</comment>
			<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>non_const_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="line">// free const node completely</comment>
			<expr_stmt><expr><call><name>FilterTree_Free</name><argument_list>(<argument><expr><name>const_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">// Compacts 'OR' condition node.</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>_FilterTree_Compact_Or</name>
<parameter_list>(
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// try to compact left and right children</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_lhs_const</name> <init>= <expr><call><name>FilterTree_Compact</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_rhs_const</name> <init>= <expr><call><name>FilterTree_Compact</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// if both are not compactable, this node is not compactable</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>is_lhs_const</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_rhs_const</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// in every case from now, there will be a reduction,</comment>
	<comment type="line">// save the children in local placeholders for current node in-place modifications</comment>
	<decl_stmt><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>lhs</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>left</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>rhs</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>right</name></name></expr></init></decl>;</decl_stmt>
	<comment type="line">// both children are constants. This node can be set as constant expression</comment>
	<if_stmt><if>if<condition>(<expr><name>is_lhs_const</name> <operator>&amp;&amp;</operator> <name>is_rhs_const</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// both children are now contant expressions, evaluate and compact</comment>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>final_value</name> <init>= <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>lhs_value</name> <init>= <expr><call><name>AR_EXP_Evaluate</name><argument_list>(<argument><expr><name><name>rhs</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>rhs_value</name> <init>= <expr><call><name>AR_EXP_Evaluate</name><argument_list>(<argument><expr><name><name>lhs</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>lhs_value</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>rhs_value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>final_value</name> <operator>=</operator>  <call><name>SI_BoolVal</name><argument_list>(<argument><expr><call><name>SIValue_IsTrue</name><argument_list>(<argument><expr><name>lhs_value</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SIValue_IsTrue</name><argument_list>(<argument><expr><name>rhs_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><operator>(</operator><operator>!</operator><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>lhs_value</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>SIValue_IsTrue</name><argument_list>(<argument><expr><name>lhs_value</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
				  <operator>(</operator><operator>!</operator><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>rhs_value</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>SIValue_IsTrue</name><argument_list>(<argument><expr><name>rhs_value</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>final_value</name> <operator>=</operator>  <call><name>SI_BoolVal</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// final value is OR operation on lhs and rhs - reducing an OR node</comment>
		<comment type="line">// in place set the node to be an expression node</comment>
		<expr_stmt><expr><call><name>_FilterTree_In_Place_Set_Exp</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>final_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FilterTree_Free</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FilterTree_Free</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="line">// only one of the nodes is constant, find and evaluate</comment>
		<decl_stmt><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>const_node</name> <init>= <expr><ternary><condition><expr><name>is_lhs_const</name></expr> ?</condition><then> <expr><name>lhs</name></expr> </then><else>: <expr><name>rhs</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>non_const_node</name> <init>= <expr><ternary><condition><expr><name>is_lhs_const</name></expr> ?</condition><then> <expr><name>rhs</name></expr> </then><else>: <expr><name>lhs</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="line">// evaluate constant</comment>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>const_value</name> <init>= <expr><call><name>AR_EXP_Evaluate</name><argument_list>(<argument><expr><name><name>const_node</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>const_value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="line">// if consant is true, everything is true</comment>
		<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsTrue</name><argument_list>(<argument><expr><name>const_value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>node</name> <operator>=</operator> <operator>*</operator><name>const_node</name></expr>;</expr_stmt>
			<comment type="line">// free const node allocation, without free the data</comment>
			<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>const_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="line">// free non const node completely</comment>
			<expr_stmt><expr><call><name>FilterTree_Free</name><argument_list>(<argument><expr><name>non_const_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="line">// const value is false, current node should be replaced with the non const node</comment>
			<expr_stmt><expr><operator>*</operator><name>node</name> <operator>=</operator> <operator>*</operator><name>non_const_node</name></expr>;</expr_stmt>
			<comment type="line">// free non const node allocation, without free the data</comment>
			<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>non_const_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="line">// free const node completely</comment>
			<expr_stmt><expr><call><name>FilterTree_Free</name><argument_list>(<argument><expr><name>const_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">// compacts 'XOR' and 'XNOR' condition nodes.</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>_FilterTree_Compact_XOr</name>
<parameter_list>(
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
	<parameter><decl><type><name>bool</name></type> <name>xnor</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// try to compact left and right children</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_lhs_const</name> <init>= <expr><call><name>FilterTree_Compact</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_rhs_const</name> <init>= <expr><call><name>FilterTree_Compact</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// if both are not compactable, this node is not compactable</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>is_lhs_const</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_rhs_const</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// in every case from now, there will be a reduction,</comment>
	<comment type="line">// save the children in local placeholders for current node in-place modifications</comment>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>final_value</name> <init>= <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>lhs</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>left</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>rhs</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>right</name></name></expr></init></decl>;</decl_stmt>

	<comment type="line">// both children are constants</comment>
	<comment type="line">// this node can be set as constant expression</comment>
	<if_stmt><if>if<condition>(<expr><name>is_lhs_const</name> <operator>&amp;&amp;</operator> <name>is_rhs_const</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// both children are now contant expressions, evaluate and compact</comment>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>lhs_value</name> <init>= <expr><call><name>AR_EXP_Evaluate</name><argument_list>(<argument><expr><name><name>lhs</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>rhs_value</name> <init>= <expr><call><name>AR_EXP_Evaluate</name><argument_list>(<argument><expr><name><name>rhs</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>lhs_value</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>rhs_value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<comment type="line">// lhs and rhs are NOT NULL</comment>
			<if_stmt><if>if<condition>(<expr><name>xnor</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>final_value</name> <operator>=</operator> <call><name>SI_BoolVal</name><argument_list>(<argument><expr><call><name>SIValue_IsTrue</name><argument_list>(<argument><expr><name>lhs_value</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>SIValue_IsTrue</name><argument_list>(<argument><expr><name>rhs_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<expr_stmt><expr><name>final_value</name> <operator>=</operator> <call><name>SI_BoolVal</name><argument_list>(<argument><expr><call><name>SIValue_IsTrue</name><argument_list>(<argument><expr><name>lhs_value</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>SIValue_IsTrue</name><argument_list>(<argument><expr><name>rhs_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// final value is XOR operation on lhs and rhs - reducing an XOR node</comment>
		<comment type="line">// in place set the node to be an expression node</comment>
		<expr_stmt><expr><call><name>_FilterTree_In_Place_Set_Exp</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>final_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FilterTree_Free</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FilterTree_Free</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>is_lhs_const</name> <operator>||</operator> <name>is_rhs_const</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// either lhs or rhs is const</comment>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>value</name></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>is_lhs_const</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>AR_EXP_Evaluate</name><argument_list>(<argument><expr><name><name>lhs</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>AR_EXP_Evaluate</name><argument_list>(<argument><expr><name><name>rhs</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="line">// reduce to NULL if `value` is NULL</comment>
		<comment type="line">// ? XOR NULL == ? XNOR NULL == NULL</comment>
		<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>_FilterTree_In_Place_Set_Exp</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FilterTree_Free</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FilterTree_Free</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// compacts a condition node if possible</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>_FilterTree_Compact_Cond</name>
<parameter_list>(
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<switch>switch<condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>op</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>OP_AND</name></expr>:</case>
			<return>return <expr><call><name>_FilterTree_Compact_And</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>OP_OR</name></expr>:</case>
			<return>return <expr><call><name>_FilterTree_Compact_Or</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>OP_XOR</name></expr>:</case>
			<return>return <expr><call><name>_FilterTree_Compact_XOr</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>OP_XNOR</name></expr>:</case>
			<return>return <expr><call><name>_FilterTree_Compact_XOr</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name> <operator>&amp;&amp;</operator> <literal type="string">"_FilterTree_Compact_Cond: Unkown filter operator to compact"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="line">// compacts a predicate node if possible</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>_FilterTree_Compact_Pred</name>
<parameter_list>(
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// check if both sides are constant expressions</comment>
	<if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>AR_EXP_IsConstant</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>lhs</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>AR_EXP_IsParameter</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>lhs</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
	   <operator>(</operator><call><name>AR_EXP_IsConstant</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>rhs</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>AR_EXP_IsParameter</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>rhs</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
		<comment type="line">// Evaluate expressions.</comment>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>lhs</name> <init>= <expr><call><name>AR_EXP_Evaluate</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>lhs</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>rhs</name> <init>= <expr><call><name>AR_EXP_Evaluate</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>rhs</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// Evalute result.</comment>
		<decl_stmt><decl><type><name>FT_Result</name></type> <name>ret</name> <init>= <expr><call><name>_applyFilter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lhs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rhs</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>op</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// Result can be NULL like WHERE null &lt;&gt; true otherwise it's bool</comment>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>v</name> <init>= <expr><ternary><condition><expr><name>ret</name> <operator>==</operator> <name>FILTER_NULL</name></expr> ?</condition><then> <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>SI_BoolVal</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<comment type="line">// Free resources and do in place replacment.</comment>
		<expr_stmt><expr><call><name>AR_EXP_Free</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>lhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AR_EXP_Free</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>rhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_FilterTree_In_Place_Set_Exp</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>FilterTree_Compact</name>
<parameter_list>(
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>root</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<switch>switch<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>t</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>FT_N_EXP</name></expr>:</case>
			<return>return <expr><call><name>_FilterTree_Compact_Exp</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>FT_N_COND</name></expr>:</case>
			<return>return <expr><call><name>_FilterTree_Compact_Cond</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>FT_N_PRED</name></expr>:</case>
			<return>return <expr><call><name>_FilterTree_Compact_Pred</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name> <operator>&amp;&amp;</operator> <literal type="string">"FilterTree_Compact: Unkown filter tree node to compect"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// Resolve unknows</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_FilterTree_ResolveVariables</name>
<parameter_list>(
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>Record</name></type> <name>r</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>root</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>t</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>FT_N_EXP</name></expr>:</case>
			<expr_stmt><expr><call><name>AR_EXP_ResolveVariables</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FT_N_COND</name></expr>:</case>
			<expr_stmt><expr><call><name>_FilterTree_ResolveVariables</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_FilterTree_ResolveVariables</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FT_N_PRED</name></expr>:</case>
			<expr_stmt><expr><call><name>AR_EXP_ResolveVariables</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>lhs</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AR_EXP_ResolveVariables</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>rhs</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name> <operator>&amp;&amp;</operator> <literal type="string">"_FilterTree_ResolveVariables: Unkown filter tree node to compect"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>FilterTree_ResolveVariables</name>
<parameter_list>(
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>Record</name></type> <name>r</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>_FilterTree_ResolveVariables</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FilterTree_Compact</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// clone an expression node</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>_FilterTree_Clone_Exp</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>exp_clone</name> <init>= <expr><call><name>AR_EXP_Clone</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>FilterTree_CreateExpressionFilter</name><argument_list>(<argument><expr><name>exp_clone</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// clones a condition node</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>_FilterTree_Clone_Cond</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>clone</name> <init>= <expr><call><name>FilterTree_CreateConditionFilter</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>op</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>left_child_clone</name> <init>= <expr><call><name>FilterTree_Clone</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>FilterTree_AppendLeftChild</name><argument_list>(<argument><expr><name>clone</name></expr></argument>, <argument><expr><name>left_child_clone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>right_child_clone</name> <init>= <expr><call><name>FilterTree_Clone</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>FilterTree_AppendRightChild</name><argument_list>(<argument><expr><name>clone</name></expr></argument>, <argument><expr><name>right_child_clone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>clone</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// clones a predicate node</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>_FilterTree_Clone_Pred</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AST_Operator</name></type> <name>op</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>op</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>lhs_exp_clone</name> <init>= <expr><call><name>AR_EXP_Clone</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>lhs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>rhs_exp_clone</name> <init>= <expr><call><name>AR_EXP_Clone</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>rhs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>FilterTree_CreatePredicateFilter</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>lhs_exp_clone</name></expr></argument>, <argument><expr><name>rhs_exp_clone</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>FilterTree_Clone</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>root</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<switch>switch<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>t</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>FT_N_EXP</name></expr>:</case>
			<return>return <expr><call><name>_FilterTree_Clone_Exp</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>FT_N_COND</name></expr>:</case>
			<return>return <expr><call><name>_FilterTree_Clone_Cond</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>FT_N_PRED</name></expr>:</case>
			<return>return <expr><call><name>_FilterTree_Clone_Pred</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name> <operator>&amp;&amp;</operator> <literal type="string">"Unkown filter tree node to clone"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_FilterTree_Print</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>ident</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>exp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>left</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>right</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>root</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
	<comment type="line">// ident</comment>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>ident</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>t</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>FT_N_EXP</name></expr>:</case>
			<expr_stmt><expr><call><name>AR_EXP_ToString</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>,  <argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FT_N_PRED</name></expr>:</case>
			<expr_stmt><expr><call><name>AR_EXP_ToString</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>lhs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AR_EXP_ToString</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>rhs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s %d %s\n"</literal></expr></argument>,  <argument><expr><name>left</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>op</name></name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FT_N_COND</name></expr>:</case>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_FilterTree_Print</name><argument_list>(<argument><expr><call><name>LeftChild</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ident</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_FilterTree_Print</name><argument_list>(<argument><expr><call><name>RightChild</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ident</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>FilterTree_Print</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>root</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"empty filter tree\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>_FilterTree_Print</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>FilterTree_Free</name>
<parameter_list>(
	<parameter><decl><type><name>FT_FilterNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>root</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
	<switch>switch<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>t</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>FT_N_EXP</name></expr>:</case>
			<expr_stmt><expr><call><name>AR_EXP_Free</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>exp</name><operator>.</operator><name>exp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FT_N_PRED</name></expr>:</case>
			<expr_stmt><expr><call><name>AR_EXP_Free</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>lhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AR_EXP_Free</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>pred</name><operator>.</operator><name>rhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FT_N_COND</name></expr>:</case>
			<expr_stmt><expr><call><name>FilterTree_Free</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FilterTree_Free</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

</unit>
