<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/src/value.c"><comment type="block">/*
 * Copyright Redis Ltd. 2018 - present
 * Licensed under your choice of the Redis Source Available License 2.0 (RSALv2) or
 * the Server Side Public License v1 (SSPLv1).
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"value.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"RG.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"graph/entities/graph_entity.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"graph/entities/node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"graph/entities/edge.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util/rmalloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"datatypes/map.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"datatypes/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"datatypes/point.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"datatypes/path/sipath.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>_SIString_ToString</name><parameter_list>(<parameter><decl><type><name>SIValue</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>bufferLen</name></decl></parameter>,
									  <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>bytesWritten</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>strLen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>stringval</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><operator>*</operator><name>bufferLen</name> <operator>-</operator> <operator>*</operator><name>bytesWritten</name> <operator>&lt;</operator> <name>strLen</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>bufferLen</name> <operator>+=</operator> <name>strLen</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <call><name>rm_realloc</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>bufferLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>bytesWritten</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name> <operator>+</operator> <operator>*</operator><name>bytesWritten</name></expr></argument>, <argument><expr><operator>*</operator><name>bufferLen</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>str</name><operator>.</operator><name>stringval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SI_LongVal</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><operator>(</operator><name>SIValue</name><operator>)</operator> <block>{
		<expr><operator>.</operator><name>longval</name> <operator>=</operator> <name>i</name></expr>, <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_INT64</name></expr>, <expr><operator>.</operator><name>allocation</name> <operator>=</operator> <name>M_NONE</name></expr>
	}</block></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SI_DoubleVal</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>d</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><operator>(</operator><name>SIValue</name><operator>)</operator> <block>{
		<expr><operator>.</operator><name>doubleval</name> <operator>=</operator> <name>d</name></expr>, <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_DOUBLE</name></expr>, <expr><operator>.</operator><name>allocation</name> <operator>=</operator> <name>M_NONE</name></expr>
	}</block></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SI_NullVal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><operator>(</operator><name>SIValue</name><operator>)</operator> <block>{
		<expr><operator>.</operator><name>longval</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_NULL</name></expr>, <expr><operator>.</operator><name>allocation</name> <operator>=</operator> <name>M_NONE</name></expr>
	}</block></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SI_BoolVal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><operator>(</operator><name>SIValue</name><operator>)</operator> <block>{
		<expr><operator>.</operator><name>longval</name> <operator>=</operator> <name>b</name></expr>, <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_BOOL</name></expr>, <expr><operator>.</operator><name>allocation</name> <operator>=</operator> <name>M_NONE</name></expr>
	}</block></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SI_PtrVal</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><operator>(</operator><name>SIValue</name><operator>)</operator> <block>{
		<expr><operator>.</operator><name>ptrval</name> <operator>=</operator> <name>v</name></expr>, <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_PTR</name></expr>, <expr><operator>.</operator><name>allocation</name> <operator>=</operator> <name>M_NONE</name></expr>
	}</block></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SI_Node</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><operator>(</operator><name>SIValue</name><operator>)</operator> <block>{
		<expr><operator>.</operator><name>ptrval</name> <operator>=</operator> <name>n</name></expr>, <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_NODE</name></expr>, <expr><operator>.</operator><name>allocation</name> <operator>=</operator> <name>M_VOLATILE</name></expr>
	}</block></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SI_Edge</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><operator>(</operator><name>SIValue</name><operator>)</operator> <block>{
		<expr><operator>.</operator><name>ptrval</name> <operator>=</operator> <name>e</name></expr>, <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_EDGE</name></expr>, <expr><operator>.</operator><name>allocation</name> <operator>=</operator> <name>M_VOLATILE</name></expr>
	}</block></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SI_Path</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>SIPath_New</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SI_EmptyArray</name><parameter_list>()</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>SIArray_New</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SI_Array</name><parameter_list>(<parameter><decl><type><name>u_int64_t</name></type> <name>initialCapacity</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>SIArray_New</name><argument_list>(<argument><expr><name>initialCapacity</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SI_EmptyMap</name><parameter_list>()</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>Map_New</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SI_Map</name><parameter_list>(<parameter><decl><type><name>u_int64_t</name></type> <name>initialCapacity</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>Map_New</name><argument_list>(<argument><expr><name>initialCapacity</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SI_DuplicateStringVal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><operator>(</operator><name>SIValue</name><operator>)</operator> <block>{
		<expr><operator>.</operator><name>stringval</name> <operator>=</operator> <call><name>rm_strdup</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>, <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_STRING</name></expr>, <expr><operator>.</operator><name>allocation</name> <operator>=</operator> <name>M_SELF</name></expr>
	}</block></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SI_ConstStringVal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><operator>(</operator><name>SIValue</name><operator>)</operator> <block>{
		<expr><operator>.</operator><name>stringval</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>s</name></expr>, <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_STRING</name></expr>, <expr><operator>.</operator><name>allocation</name> <operator>=</operator> <name>M_CONST</name></expr>
	}</block></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SI_TransferStringVal</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><operator>(</operator><name>SIValue</name><operator>)</operator> <block>{
		<expr><operator>.</operator><name>stringval</name> <operator>=</operator> <name>s</name></expr>, <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_STRING</name></expr>, <expr><operator>.</operator><name>allocation</name> <operator>=</operator> <name>M_SELF</name></expr>
	}</block></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SI_Point</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>latitude</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>longitude</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><operator>(</operator><name>SIValue</name><operator>)</operator> <block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_POINT</name></expr>, <expr><operator>.</operator><name>allocation</name> <operator>=</operator> <name>M_NONE</name></expr>,
			<expr><operator>.</operator><name>point</name> <operator>=</operator> <block>{<expr><operator>.</operator><name>latitude</name> <operator>=</operator> <name>latitude</name></expr>, <expr><operator>.</operator><name>longitude</name> <operator>=</operator> <name>longitude</name></expr>}</block></expr>
	}</block></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Make an SIValue that reuses the original's allocations, if any.
 * The returned value is not responsible for freeing any allocations,
 * and is not guaranteed that these allocations will remain in scope. */</comment>
<function><type><name>SIValue</name></type> <name>SI_ShareValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SIValue</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>dup</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>
	<comment type="line">// If the original value owns an allocation, mark that the duplicate shares it.</comment>
	<if_stmt><if>if<condition>(<expr><name><name>v</name><operator>.</operator><name>allocation</name></name> <operator>==</operator> <name>M_SELF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>dup</name><operator>.</operator><name>allocation</name></name> <operator>=</operator> <name>M_VOLATILE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>dup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Make an SIValue that creates its own copies of the original's allocations, if any.
 * This is not a deep clone: if the inner value holds its own references,
 * such as the Entity pointer to the properties of a Node or Edge, those are unmodified. */</comment>
<function><type><name>SIValue</name></type> <name>SI_CloneValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SIValue</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name><name>v</name><operator>.</operator><name>allocation</name></name> <operator>==</operator> <name>M_NONE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>v</name></expr>;</return></block_content></block></if></if_stmt> <comment type="line">// Stack value; no allocation necessary.</comment>

	<if_stmt><if>if<condition>(<expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_STRING</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Allocate a new copy of the input's string value.</comment>
		<return>return <expr><call><name>SI_DuplicateStringVal</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>stringval</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_ARRAY</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>SIArray_Clone</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_PATH</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>SIPath_Clone</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_MAP</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>Map_Clone</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Copy the memory region for Node and Edge values. This does not modify the</comment>
	<comment type="line">// inner Entity pointer to the value's properties.</comment>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>clone</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>clone</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>v</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clone</name><operator>.</operator><name>allocation</name></name> <operator>=</operator> <name>M_SELF</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_NODE</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_EDGE</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Edge</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name> <operator>&amp;&amp;</operator> <literal type="string">"Encountered heap-allocated SIValue of unhandled type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>clone</name><operator>.</operator><name>ptrval</name></name> <operator>=</operator> <call><name>rm_malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>clone</name><operator>.</operator><name>ptrval</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>ptrval</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>clone</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SI_ShallowCloneValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SIValue</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name><name>v</name><operator>.</operator><name>allocation</name></name> <operator>==</operator> <name>M_CONST</name> <operator>||</operator> <name><name>v</name><operator>.</operator><name>allocation</name></name> <operator>==</operator> <name>M_NONE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>v</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>SI_CloneValue</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Make an SIValue that shares the original's allocations but can safely expect those allocations
 *  to remain in scope. This is most frequently the case for GraphEntity properties. */</comment>
<function><type><name>SIValue</name></type> <name>SI_ConstValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SIValue</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>dup</name> <init>= <expr><operator>*</operator><name>v</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>allocation</name></name> <operator>!=</operator> <name>M_NONE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>dup</name><operator>.</operator><name>allocation</name></name> <operator>=</operator> <name>M_CONST</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>dup</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Clone 'v' and set v's allocation to volatile if 'v' owned the memory</comment>
<function><type><name>SIValue</name></type> <name>SI_TransferOwnership</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>dup</name> <init>= <expr><operator>*</operator><name>v</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>allocation</name></name> <operator>==</operator> <name>M_SELF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>allocation</name></name> <operator>=</operator> <name>M_VOLATILE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>dup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Update an SIValue marked as owning its internal allocations so that it instead is sharing them,
 * with no responsibility for freeing or guarantee regarding scope.
 * This is used in cases like performing shallow copies of scalars in Record entries. */</comment>
<function><type><name>void</name></type> <name>SIValue_MakeVolatile</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>allocation</name></name> <operator>==</operator> <name>M_SELF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>allocation</name></name> <operator>=</operator> <name>M_VOLATILE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Ensure that any allocation held by the given SIValue is guaranteed to not go out
 * of scope during the lifetime of this query by copying references to volatile memory.
 * Heap allocations that are not scoped to the input SIValue, such as strings from the AST
 * or a GraphEntity property, are not modified. */</comment>
<function><type><name>void</name></type> <name>SIValue_Persist</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// do nothing for non-volatile values</comment>
	<comment type="line">// for volatile values, persisting uses the same logic as cloning</comment>
	<if_stmt><if>if<condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>allocation</name></name> <operator>==</operator> <name>M_VOLATILE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <call><name>SI_CloneValue</name><argument_list>(<argument><expr><operator>*</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Update an SIValue's allocation type to the provided value. */</comment>
<function><type><specifier>inline</specifier> <name>void</name></type> <name>SIValue_SetAllocationType</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>SIAllocation</name></type> <name>allocation</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>allocation</name></name> <operator>=</operator> <name>allocation</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>SIValue_IsNull</name><parameter_list>(<parameter><decl><type><name>SIValue</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>SIValue_IsFalse</name><parameter_list>(<parameter><decl><type><name>SIValue</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>==</operator>  <name>T_BOOL</name> <operator>&amp;&amp;</operator> <literal type="string">"SIValue_IsFalse: Expected boolean"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>!</operator><name><name>v</name><operator>.</operator><name>longval</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>SIValue_IsTrue</name><parameter_list>(<parameter><decl><type><name>SIValue</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>==</operator>  <name>T_BOOL</name> <operator>&amp;&amp;</operator> <literal type="string">"SIValue_IsTrue: Expected boolean"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>v</name><operator>.</operator><name>longval</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>SIValue_IsNullPtr</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><name>v</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>v</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>T_NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>SIType_ToString</name><parameter_list>(<parameter><decl><type><name>SIType</name></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&amp;</operator> <name>T_MAP</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="string">"Map"</literal></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>&amp;</operator> <name>T_STRING</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="string">"String"</literal></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>&amp;</operator> <name>T_INT64</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="string">"Integer"</literal></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>&amp;</operator> <name>T_BOOL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="string">"Boolean"</literal></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>&amp;</operator> <name>T_DOUBLE</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="string">"Float"</literal></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>&amp;</operator> <name>T_PTR</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="string">"Pointer"</literal></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>&amp;</operator> <name>T_NODE</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="string">"Node"</literal></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>&amp;</operator> <name>T_EDGE</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="string">"Edge"</literal></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>&amp;</operator> <name>T_ARRAY</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="string">"List"</literal></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>&amp;</operator> <name>T_PATH</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="string">"Path"</literal></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>&amp;</operator> <name>T_DATETIME</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="string">"Datetime"</literal></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>&amp;</operator> <name>T_LOCALDATETIME</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="string">"Local Datetime"</literal></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>&amp;</operator> <name>T_DATE</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="string">"Date"</literal></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>&amp;</operator> <name>T_TIME</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="string">"Time"</literal></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>&amp;</operator> <name>T_LOCALTIME</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="string">"Local Time"</literal></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>&amp;</operator> <name>T_DURATION</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="string">"Duration"</literal></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>&amp;</operator> <name>T_POINT</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="string">"Point"</literal></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>&amp;</operator> <name>T_NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="string">"Null"</literal></expr>;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<return>return <expr><literal type="string">"Unknown"</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>SIType_ToMultipleTypeString</name><parameter_list>(<parameter><decl><type><name>SIType</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bufferLen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// Worst case: Len(SIType names) + 19*Len(", ") + Len("Or") = 177 + 38 + 2 = 217</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>bufferLen</name> <operator>&gt;=</operator> <name>MULTIPLE_TYPE_STRING_BUFFER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint</name></type>   <name>count</name>		<init>= <expr><call><name>__builtin_popcount</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>  <modifier>*</modifier></type><name>comma</name>        <init>= <expr><ternary><condition><expr><name>count</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><literal type="string">", or "</literal></expr> </then><else>: <expr><literal type="string">" or "</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIType</name></type> <name>currentType</name>  <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>bytesWritten</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="line">// Find first type</comment>
	<while>while<condition>(<expr><operator>(</operator><name>t</name> <operator>&amp;</operator> <name>currentType</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>currentType</name> <operator>=</operator> <name>currentType</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name>bytesWritten</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>bytesWritten</name></expr></argument>, <argument><expr><name>bufferLen</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>SIType_ToString</name><argument_list>(<argument><expr><name>currentType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
	<comment type="line">// Iterate over the possible SITypes except last one</comment>
	<while>while<condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>currentType</name> <operator>=</operator> <name>currentType</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>t</name> <operator>&amp;</operator> <name>currentType</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>bytesWritten</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>bytesWritten</name></expr></argument>, <argument><expr><name>bufferLen</name></expr></argument>, <argument><expr><literal type="string">", %s"</literal></expr></argument>, <argument><expr><call><name>SIType_ToString</name><argument_list>(<argument><expr><name>currentType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="line">// Find last type</comment>
	<do>do <block>{<block_content>
		<expr_stmt><expr><name>currentType</name> <operator>=</operator> <name>currentType</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block> while<condition>(<expr><operator>(</operator><name>t</name> <operator>&amp;</operator> <name>currentType</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>;</do>

	<comment type="line">// Concatenate "or" before the last SIType name</comment>
	<comment type="line">// If there are more than two, the last comma should be present</comment>
	<expr_stmt><expr><name>bytesWritten</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>bytesWritten</name></expr></argument>, <argument><expr><name>bufferLen</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>comma</name></expr></argument>, <argument><expr><call><name>SIType_ToString</name><argument_list>(<argument><expr><name>currentType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>SIValue_ToString</name><parameter_list>(<parameter><decl><type><name>SIValue</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>bufferLen</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>bytesWritten</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// uint64 max and int64 min string representation requires 21 bytes</comment>
	<comment type="line">// checkt for enough space</comment>
	<if_stmt><if>if<condition>(<expr><operator>*</operator><name>bufferLen</name> <operator>-</operator> <operator>*</operator><name>bytesWritten</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>bufferLen</name> <operator>+=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <call><name>rm_realloc</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>*</operator><name>bufferLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch<condition>(<expr><name><name>v</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>T_STRING</name></expr>:</case>
		<expr_stmt><expr><call><name>_SIString_ToString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufferLen</name></expr></argument>, <argument><expr><name>bytesWritten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>T_INT64</name></expr>:</case>
		<expr_stmt><expr><operator>*</operator><name>bytesWritten</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name> <operator>+</operator> <operator>*</operator><name>bytesWritten</name></expr></argument>, <argument><expr><operator>*</operator><name>bufferLen</name></expr></argument>, <argument><expr><literal type="string">"%lld"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name><name>v</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>T_BOOL</name></expr>:</case>
		<expr_stmt><expr><operator>*</operator><name>bytesWritten</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name> <operator>+</operator> <operator>*</operator><name>bytesWritten</name></expr></argument>, <argument><expr><operator>*</operator><name>bufferLen</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>v</name><operator>.</operator><name>longval</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>T_DOUBLE</name></expr>:</case>
	<block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name>snprintf</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name> <operator>+</operator> <operator>*</operator><name>bytesWritten</name></expr></argument>, <argument><expr><operator>*</operator><name>bufferLen</name> <operator>-</operator> <operator>*</operator><name>bytesWritten</name></expr></argument>, <argument><expr><literal type="string">"%f"</literal></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>doubleval</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// check if there was enough space in the buffer</comment>
		<if_stmt><if>if<condition>(<expr><operator>*</operator><name>bytesWritten</name> <operator>+</operator> <name>n</name> <operator>&gt;</operator> <operator>*</operator><name>bufferLen</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// realloc the buffer</comment>
			<expr_stmt><expr><operator>*</operator><name>bufferLen</name> <operator>=</operator> <operator>*</operator><name>bytesWritten</name> <operator>+</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <call><name>rm_realloc</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>*</operator><name>bufferLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="line">// write it again</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name> <operator>+</operator> <operator>*</operator><name>bytesWritten</name></expr></argument>, <argument><expr><operator>*</operator><name>bufferLen</name> <operator>-</operator> <operator>*</operator><name>bytesWritten</name></expr></argument>, <argument><expr><literal type="string">"%f"</literal></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>doubleval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>bytesWritten</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
		<break>break;</break>
	</block_content>}</block>
	<case>case <expr><name>T_NODE</name></expr>:</case>
		<expr_stmt><expr><call><name>Node_ToString</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>ptrval</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufferLen</name></expr></argument>, <argument><expr><name>bytesWritten</name></expr></argument>, <argument><expr><name>ENTITY_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>T_EDGE</name></expr>:</case>
		<expr_stmt><expr><call><name>Edge_ToString</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>ptrval</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufferLen</name></expr></argument>, <argument><expr><name>bytesWritten</name></expr></argument>, <argument><expr><name>ENTITY_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>T_ARRAY</name></expr>:</case>
		<expr_stmt><expr><call><name>SIArray_ToString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufferLen</name></expr></argument>, <argument><expr><name>bytesWritten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>T_MAP</name></expr>:</case>
		<expr_stmt><expr><call><name>Map_ToString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufferLen</name></expr></argument>, <argument><expr><name>bytesWritten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>T_PATH</name></expr>:</case>
		<expr_stmt><expr><call><name>SIPath_ToString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufferLen</name></expr></argument>, <argument><expr><name>bytesWritten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>T_NULL</name></expr>:</case>
		<expr_stmt><expr><operator>*</operator><name>bytesWritten</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name> <operator>+</operator> <operator>*</operator><name>bytesWritten</name></expr></argument>, <argument><expr><operator>*</operator><name>bufferLen</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>T_PTR</name></expr>:</case>
		<expr_stmt><expr><operator>*</operator><name>bytesWritten</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name> <operator>+</operator> <operator>*</operator><name>bytesWritten</name></expr></argument>, <argument><expr><operator>*</operator><name>bufferLen</name></expr></argument>, <argument><expr><literal type="string">"POINTER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>T_POINT</name></expr>:</case>
		<comment type="line">// max string length is 32 chars of string + 10 * 2 chars for the floats</comment>
		<comment type="line">// = 52 bytes that already checked in the header of the function</comment>
		<expr_stmt><expr><operator>*</operator><name>bytesWritten</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name> <operator>+</operator> <operator>*</operator><name>bytesWritten</name></expr></argument>, <argument><expr><operator>*</operator><name>bufferLen</name></expr></argument>, <argument><expr><literal type="string">"point({latitude: %f, longitude: %f})"</literal></expr></argument>, <argument><expr><call><name>Point_lat</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>Point_lon</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<default>default:</default>
		<comment type="line">// unrecognized type</comment>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"unrecognized type: %d\n"</literal></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>SIValue_ToDouble</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SIValue</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<switch>switch<condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>T_DOUBLE</name></expr>:</case>
		<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>doubleval</name></name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	<case>case <expr><name>T_INT64</name></expr>:</case>
	<case>case <expr><name>T_BOOL</name></expr>:</case>
		<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name><name>v</name><operator>-&gt;</operator><name>longval</name></name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>

	<default>default:</default>
		<comment type="line">// cannot convert!</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SIValue_FromString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sEnd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>parsedval</name> <init>= <expr><call><name>strtod</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sEnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// the input was not a complete number or represented a number that</comment>
	<comment type="line">// cannot be represented as a double</comment>
	<comment type="line">// create a string SIValue</comment>
	<if_stmt><if>if<condition>(<expr><name><name>sEnd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>SI_DuplicateStringVal</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// The input was fully converted; create a double SIValue.</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><name>parsedval</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>SIValue_StringJoinLen</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>strings</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>string_count</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>delimiter</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>elem_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>delimiter_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>delimiter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Compute length. */</comment>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>string_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<comment type="block">/* String elements representing bytes size strings,
		 * for all other SIValue types 32 bytes should be enough. */</comment>
		<expr_stmt><expr><name>elem_len</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>strings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>T_STRING</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>strings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>stringval</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>delimiter_len</name></expr> </then><else>: <expr><literal type="number">32</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>length</name> <operator>+=</operator> <name>elem_len</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Account for NULL terminating byte. */</comment>
	<expr_stmt><expr><name>length</name> <operator>+=</operator> <name>string_count</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<return>return <expr><name>length</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>SIValue_StringJoin</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>strings</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>string_count</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>delimiter</name></decl></parameter>,
						<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>buf_len</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>bytesWritten</name></decl></parameter>)</parameter_list> <block>{<block_content>

	<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>string_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>SIValue_ToString</name><argument_list>(<argument><expr><name><name>strings</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_len</name></expr></argument>, <argument><expr><name>bytesWritten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>i</name> <operator>&lt;</operator> <name>string_count</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>bytesWritten</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name> <operator>+</operator> <operator>*</operator><name>bytesWritten</name></expr></argument>, <argument><expr><operator>*</operator><name>buf_len</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>delimiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="line">// assumption: either a or b is a string</comment>
<function><type><specifier>static</specifier> <name>SIValue</name></type> <name>SIValue_ConcatString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SIValue</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SIValue</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>bufferLen</name> <init>= <expr><literal type="number">512</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>argument_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><call><name>rm_calloc</name><argument_list>(<argument><expr><name>bufferLen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>a</name></expr>, <expr><name>b</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SIValue_StringJoin</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bufferLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argument_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>result</name> <init>= <expr><call><name>SI_DuplicateStringVal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// assumption: either a or b is a list - static function, the caller validate types</comment>
<function><type><specifier>static</specifier> <name>SIValue</name></type> <name>SIValue_ConcatList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SIValue</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SIValue</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>a_len</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>a</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_ARRAY</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>SIArray_Length</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>b_len</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>b</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_ARRAY</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>SIArray_Length</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>resultArray</name> <init>= <expr><call><name>SI_Array</name><argument_list>(<argument><expr><name>a_len</name> <operator>+</operator> <name>b_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Append a to resultArray</comment>
	<if_stmt><if>if<condition>(<expr><name><name>a</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_ARRAY</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// in thae case of a is an array</comment>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>a_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>SIArray_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>resultArray</name></expr></argument>, <argument><expr><call><name>SIArray_Get</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="line">// in thae case of a is not an array</comment>
		<expr_stmt><expr><call><name>SIArray_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>resultArray</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>b</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_ARRAY</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// b is an array</comment>
		<decl_stmt><decl><type><name>uint</name></type> <name>bArrayLen</name> <init>= <expr><call><name>SIArray_Length</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>bArrayLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>SIArray_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>resultArray</name></expr></argument>, <argument><expr><call><name>SIArray_Get</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="line">// b is not an array</comment>
		<expr_stmt><expr><call><name>SIArray_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>resultArray</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>resultArray</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SIValue_Add</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SIValue</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SIValue</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name><name>a</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_NULL</name> <operator>||</operator> <name><name>b</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>a</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_ARRAY</name> <operator>||</operator> <name><name>b</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_ARRAY</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SIValue_ConcatList</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>a</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_STRING</name> <operator>||</operator> <name><name>b</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_STRING</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SIValue_ConcatString</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Only construct an integer return if both operands are integers. */</comment>
	<if_stmt><if>if<condition>(<expr><name><name>a</name><operator>.</operator><name>type</name></name> <operator>&amp;</operator> <name><name>b</name><operator>.</operator><name>type</name></name> <operator>&amp;</operator> <name>T_INT64</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>SI_LongVal</name><argument_list>(<argument><expr><name><name>a</name><operator>.</operator><name>longval</name></name> <operator>+</operator> <name><name>b</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Return a double representation. */</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SIValue_Subtract</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SIValue</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SIValue</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/* Only construct an integer return if both operands are integers. */</comment>
	<if_stmt><if>if<condition>(<expr><name><name>a</name><operator>.</operator><name>type</name></name> <operator>&amp;</operator> <name><name>b</name><operator>.</operator><name>type</name></name> <operator>&amp;</operator> <name>T_INT64</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>SI_LongVal</name><argument_list>(<argument><expr><name><name>a</name><operator>.</operator><name>longval</name></name> <operator>-</operator> <name><name>b</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Return a double representation. */</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SIValue_Multiply</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SIValue</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SIValue</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/* Only construct an integer return if both operands are integers. */</comment>
	<if_stmt><if>if<condition>(<expr><name><name>a</name><operator>.</operator><name>type</name></name> <operator>&amp;</operator> <name><name>b</name><operator>.</operator><name>type</name></name> <operator>&amp;</operator> <name>T_INT64</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>SI_LongVal</name><argument_list>(<argument><expr><name><name>a</name><operator>.</operator><name>longval</name></name> <operator>*</operator> <name><name>b</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Return a double representation. */</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>SIValue_Divide</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SIValue</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SIValue</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/* Always perform floating-point division. */</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Calculate a mod n for integer and floating-point inputs.</comment>
<function><type><name>SIValue</name></type> <name>SIValue_Modulo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SIValue</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SIValue</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>inputs_are_integers</name> <init>= <expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <call><name>SI_TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>T_INT64</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>inputs_are_integers</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// The modulo machine instruction may be used if a and n are both integers.</comment>

		<decl_stmt><decl><type><name>int64_t</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<comment type="line">// workaround for https://gcc.gnu.org/bugzilla/show_bug.cgi?id=30484</comment>
		<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block>{<block_content> <comment type="line">// % -1 is always return 0</comment>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name><name>a</name><operator>.</operator><name>longval</name></name> <operator>%</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name><name>n</name><operator>.</operator><name>longval</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><call><name>SI_LongVal</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="line">// Otherwise, use the library function fmod to calculate the modulo and return a double.</comment>
		<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><call><name>fmod</name><argument_list>(<argument><expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>SIArray_Compare</name><parameter_list>(<parameter><decl><type><name>SIValue</name></type> <name>arrayA</name></decl></parameter>, <parameter><decl><type><name>SIValue</name></type> <name>arrayB</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>disjointOrNull</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>arrayALen</name> <init>= <expr><call><name>SIArray_Length</name><argument_list>(<argument><expr><name>arrayA</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>arrayBLen</name> <init>= <expr><call><name>SIArray_Length</name><argument_list>(<argument><expr><name>arrayB</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// Check empty list.</comment>
	<if_stmt><if>if<condition>(<expr><name>arrayALen</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>arrayBLen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>lenDiff</name> <init>= <expr><name>arrayALen</name> <operator>-</operator> <name>arrayBLen</name></expr></init></decl>;</decl_stmt>
	<comment type="line">// Check for the common range of indices.</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>minLength</name> <init>= <expr><ternary><condition><expr><name>arrayALen</name> <operator>&lt;=</operator> <name>arrayBLen</name></expr> ?</condition><then> <expr><name>arrayALen</name></expr> </then><else>: <expr><name>arrayBLen</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<comment type="line">// notEqual holds the first false (result != 0) comparison result between two values from the same type, which are not equal.</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>notEqual</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>nullCounter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="line">// Counter for the amount of null comparison.</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>notEqualCounter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="line">// Counter for the amount of false (compare(a,b) !=0) comparisons.</comment>

	<comment type="line">// Go over the common range for both arrays.</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>minLength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>aValue</name> <init>= <expr><call><name>SIArray_Get</name><argument_list>(<argument><expr><name>arrayA</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>bValue</name> <init>= <expr><call><name>SIArray_Get</name><argument_list>(<argument><expr><name>arrayB</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// Current comparison special cases indication variable.</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>currentDisjointOrNull</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>compareResult</name> <init>= <expr><call><name>SIValue_Compare</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>bValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>currentDisjointOrNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// In case of special case such null or disjoint comparison.</comment>
		<if_stmt><if>if<condition>(<expr><name>currentDisjointOrNull</name></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name>currentDisjointOrNull</name> <operator>==</operator> <name>COMPARED_NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nullCounter</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="line">// Update null comparison counter.</comment>
			<comment type="line">// Null or disjoint comparison is also a false comparison, so increase the number of false comparisons in one.</comment>
			<expr_stmt><expr><name>notEqualCounter</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="line">// Set the first difference value, if not set before.</comment>
			<if_stmt><if>if<condition>(<expr><name>notEqual</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>notEqual</name> <operator>=</operator> <name>compareResult</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>compareResult</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<comment type="line">// In the normal false comparison case, update false comparison counter.</comment>
			<expr_stmt><expr><name>notEqualCounter</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="line">// Set the first difference value, if not set before.</comment>
			<if_stmt><if>if<condition>(<expr><name>notEqual</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>notEqual</name> <operator>=</operator> <name>compareResult</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="line">// Note: In the case of compareResult = 0, there is nothing to be done.</comment>
	</block_content>}</block></for>
	<comment type="line">// If all the elements in the shared range yielded false comparisons.</comment>
	<if_stmt><if>if<condition>(<expr><name>notEqualCounter</name> <operator>==</operator> <name>minLength</name> <operator>&amp;&amp;</operator> <name>notEqualCounter</name> <operator>&gt;</operator> <name>nullCounter</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>notEqual</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="line">// If there was a null comperison on non disjoint arrays.</comment>
	<if_stmt><if>if<condition>(<expr><name>nullCounter</name> <operator>&amp;&amp;</operator> <name>arrayALen</name> <operator>==</operator> <name>arrayBLen</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name>disjointOrNull</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>disjointOrNull</name> <operator>=</operator> <name>COMPARED_NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>notEqual</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="line">// If there was a difference in some member, without any null compare.</comment>
	<if_stmt><if>if<condition>(<expr><name>notEqual</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>notEqual</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="line">// In this state, the common range is equal. We return lenDiff, which is 0 in case the lists are equal, and not 0 otherwise.</comment>
	<return>return <expr><name>lenDiff</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>SIValue_Compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SIValue</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SIValue</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>disjointOrNull</name></decl></parameter>)</parameter_list> <block>{<block_content>

	<comment type="block">/* No special case (null or disjoint comparison) happened yet.
	 * If indication for such cases is required, first set the indication value to zero (not happen). */</comment>
	<if_stmt><if>if<condition>(<expr><name>disjointOrNull</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>disjointOrNull</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* In order to be comparable, both SIValues must be from the same type. */</comment>
	<if_stmt><if>if<condition>(<expr><name><name>a</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name><name>b</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
		<switch>switch<condition>(<expr><name><name>a</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>T_INT64</name></expr>:</case>
		<case>case <expr><name>T_BOOL</name></expr>:</case>
			<return>return <expr><call><name>SAFE_COMPARISON_RESULT</name><argument_list>(<argument><expr><name><name>a</name><operator>.</operator><name>longval</name></name> <operator>-</operator> <name><name>b</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_DOUBLE</name></expr>:</case>
			<if_stmt><if>if<condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name><name>a</name><operator>.</operator><name>doubleval</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name><name>b</name><operator>.</operator><name>doubleval</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<if_stmt><if>if<condition>(<expr><name>disjointOrNull</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>disjointOrNull</name> <operator>=</operator> <name>COMPARED_NAN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><call><name>SAFE_COMPARISON_RESULT</name><argument_list>(<argument><expr><name><name>a</name><operator>.</operator><name>doubleval</name></name> <operator>-</operator> <name><name>b</name><operator>.</operator><name>doubleval</name></name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_STRING</name></expr>:</case>
			<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>.</operator><name>stringval</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>.</operator><name>stringval</name></name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_NODE</name></expr>:</case>
		<case>case <expr><name>T_EDGE</name></expr>:</case>
			<return>return <expr><call><name>ENTITY_GET_ID</name><argument_list>(<argument><expr><operator>(</operator><name>GraphEntity</name> <operator>*</operator><operator>)</operator><name><name>a</name><operator>.</operator><name>ptrval</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>ENTITY_GET_ID</name><argument_list>(<argument><expr><operator>(</operator><name>GraphEntity</name> <operator>*</operator><operator>)</operator><name><name>b</name><operator>.</operator><name>ptrval</name></name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_ARRAY</name></expr>:</case>
			<return>return <expr><call><name>SIArray_Compare</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>disjointOrNull</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_PATH</name></expr>:</case>
			<return>return <expr><call><name>SIPath_Compare</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_MAP</name></expr>:</case>
			<return>return <expr><call><name>Map_Compare</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>disjointOrNull</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_NULL</name></expr>:</case>
			<break>break;</break>
		<case>case <expr><name>T_POINT</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>lon_diff</name> <init>= <expr><call><name>SAFE_COMPARISON_RESULT</name><argument_list>(<argument><expr><call><name>Point_lon</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>Point_lon</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><name>lon_diff</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>SAFE_COMPARISON_RESULT</name><argument_list>(<argument><expr><call><name>Point_lat</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>Point_lat</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><name>lon_diff</name></expr>;</return>
		</block_content>}</block>
		<default>default:</default>
			<comment type="line">// Both inputs were of an incomparable type, like a pointer, or not implemented comparison yet.</comment>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* The inputs have different SITypes - compare them if they
	 * are both numerics of differing types. */</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>SI_NUMERIC</name> <operator>&amp;&amp;</operator> <call><name>SI_TYPE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>SI_NUMERIC</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if<condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name>disjointOrNull</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>disjointOrNull</name> <operator>=</operator> <name>COMPARED_NAN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>double</name></type> <name>diff</name> <init>= <expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>SAFE_COMPARISON_RESULT</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Check if either type is null.</comment>
	<if_stmt><if>if<condition>(<expr><name><name>a</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_NULL</name> <operator>||</operator> <name><name>b</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Check if indication is required and inform about null comparison.</comment>
		<if_stmt><if>if<condition>(<expr><name>disjointOrNull</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>disjointOrNull</name> <operator>=</operator> <name>COMPARED_NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="line">// Check if indication is required, and inform about disjoint comparison.</comment>
		<if_stmt><if>if<condition>(<expr><name>disjointOrNull</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>disjointOrNull</name> <operator>=</operator> <name>DISJOINT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="line">// In case of disjoint or null comparison, return value type difference.</comment>
	<return>return <expr><name><name>a</name><operator>.</operator><name>type</name></name> <operator>-</operator> <name><name>b</name><operator>.</operator><name>type</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Hashes the id and properties of the node*/</comment>
<function><type><name>XXH64_hash_t</name></type> <name>SINode_HashCode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SIValue</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>XXH_errorcode</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XXH64_state_t</name></type> <name>state</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>XXH64_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>XXH_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>v</name><operator>.</operator><name>ptrval</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><call><name>ENTITY_GET_ID</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIType</name></type> <name>t</name> <init>= <expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name>t</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>XXH64_hash_t</name></type> <name>hashCode</name> <init>= <expr><call><name>XXH64_digest</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>hashCode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Hashes the id and properties of the edge. */</comment>
<function><type><name>XXH64_hash_t</name></type> <name>SIEdge_HashCode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SIValue</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>XXH_errorcode</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XXH64_state_t</name></type> <name>state</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>XXH64_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>XXH_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Edge</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Edge</name> <operator>*</operator><operator>)</operator><name><name>v</name><operator>.</operator><name>ptrval</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><call><name>ENTITY_GET_ID</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIType</name></type> <name>t</name> <init>= <expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name>t</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>XXH64_hash_t</name></type> <name>hashCode</name> <init>= <expr><call><name>XXH64_digest</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>hashCode</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>SIValue_HashUpdate</name><parameter_list>(<parameter><decl><type><name>SIValue</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>XXH64_state_t</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// handles null value and defaults</comment>
	<decl_stmt><decl><type><name>int64_t</name></type> <name>null</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XXH64_hash_t</name></type> <name>inner_hash</name></decl>;</decl_stmt>
	<comment type="line">// in case of identical binary representation of the value,</comment>
	<comment type="line">// we should hash the type as well</comment>
	<decl_stmt><decl><type><name>SIType</name></type> <name>t</name> <init>= <expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch<condition>(<expr><name>t</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>T_NULL</name></expr>:</case>
			<expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>null</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>T_STRING</name></expr>:</case>
			<expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>stringval</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>stringval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>T_INT64</name></expr>:</case>
			<comment type="line">// change type to numeric</comment>
			<expr_stmt><expr><name>t</name> <operator>=</operator> <name>SI_NUMERIC</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>.</operator><name>longval</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>T_BOOL</name></expr>:</case>
			<expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>.</operator><name>longval</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>T_DOUBLE</name></expr>:</case>
			<expr_stmt><expr><name>t</name> <operator>=</operator> <name>SI_NUMERIC</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="line">// check if the double value is actually an integer</comment>
			<comment type="line">// if so, hash it as Long</comment>
			<decl_stmt><decl><type><name>int64_t</name></type> <name>casted</name> <init>= <expr><operator>(</operator><name>int64_t</name><operator>)</operator> <name><name>v</name><operator>.</operator><name>doubleval</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type> <name>diff</name> <init>= <expr><name><name>v</name><operator>.</operator><name>doubleval</name></name> <operator>-</operator> <name>casted</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><name>diff</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>.</operator><name>doubleval</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>doubleval</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>casted</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>casted</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<return>return;</return>
		<case>case <expr><name>T_EDGE</name></expr>:</case>
			<expr_stmt><expr><name>inner_hash</name> <operator>=</operator> <call><name>SIEdge_HashCode</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_hash</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>inner_hash</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>T_NODE</name></expr>:</case>
			<expr_stmt><expr><name>inner_hash</name> <operator>=</operator> <call><name>SINode_HashCode</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_hash</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>inner_hash</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>T_ARRAY</name></expr>:</case>
			<expr_stmt><expr><name>inner_hash</name> <operator>=</operator> <call><name>SIArray_HashCode</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_hash</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>inner_hash</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>T_MAP</name></expr>:</case>
			<expr_stmt><expr><name>inner_hash</name> <operator>=</operator> <call><name>Map_HashCode</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_hash</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>inner_hash</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>T_PATH</name></expr>:</case>
			<expr_stmt><expr><name>inner_hash</name> <operator>=</operator> <call><name>SIPath_HashCode</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_hash</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>inner_hash</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
			<comment type="line">// TODO: Implement for temporal types once we support them.</comment>
		<default>default:</default>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="line">// hash SIValue</comment>
<function><type><name>XXH64_hash_t</name></type> <name>SIValue_HashCode</name><parameter_list>(<parameter><decl><type><name>SIValue</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// initialize the hash state</comment>
	<decl_stmt><decl><type><name>XXH64_state_t</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XXH_errorcode</name></type> <name>res</name> <init>= <expr><call><name>XXH64_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>XXH_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// update the state with the SIValue</comment>
	<expr_stmt><expr><call><name>SIValue_HashUpdate</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// generate and return the hash</comment>
	<return>return <expr><call><name>XXH64_digest</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>SIValue_Free</name><parameter_list>(<parameter><decl><type><name>SIValue</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// The free routine only performs work if it owns a heap allocation.</comment>
	<if_stmt><if>if<condition>(<expr><name><name>v</name><operator>.</operator><name>allocation</name></name> <operator>!=</operator> <name>M_SELF</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<switch>switch<condition>(<expr><name><name>v</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>T_STRING</name></expr>:</case>
		<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>stringval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>v</name><operator>.</operator><name>stringval</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return;</return>
	<case>case <expr><name>T_NODE</name></expr>:</case>
	<case>case <expr><name>T_EDGE</name></expr>:</case>
		<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>ptrval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	<case>case <expr><name>T_ARRAY</name></expr>:</case>
		<expr_stmt><expr><call><name>SIArray_Free</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	<case>case <expr><name>T_PATH</name></expr>:</case>
		<expr_stmt><expr><call><name>SIPath_Free</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	<case>case <expr><name>T_MAP</name></expr>:</case>
		<expr_stmt><expr><call><name>Map_Free</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<default>default:</default>
		<return>return;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

</unit>
