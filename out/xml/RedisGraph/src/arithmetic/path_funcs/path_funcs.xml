<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/src/arithmetic/path_funcs/path_funcs.c"><comment type="block">/*
 * Copyright Redis Ltd. 2018 - present
 * Licensed under your choice of the Redis Source Available License 2.0 (RSALv2) or
 * the Server Side Public License v1 (SSPLv1).
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"path_funcs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../func_desc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../ast/ast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../util/arr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../query_ctx.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../util/rmalloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../configuration/config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../datatypes/path/sipath_builder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../algorithms/LAGraph/LAGraph_bfs.h"</cpp:file></cpp:include>

<comment type="block">/* Creates a path from a given sequence of graph entities.
 * The first argument is the ast node represents the path.
 * Arguments 2...n are the sequence of graph entities combines the path.
 * The sequence is always in odd length and defined as:
 * Odd indices members are always representing the value of a single node.
 * Even indices members are either representing the value of a single edge,
 * or an sipath, in case of variable length traversal. */</comment>
<function><type><name>SIValue</name></type> <name>AR_TOPATH</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_path</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ptrval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>nelements</name> <init>= <expr><call><name>cypher_ast_pattern_path_nelements</name><argument_list>(<argument><expr><name>ast_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>argc</name> <operator>==</operator> <operator>(</operator><name>nelements</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SIValue</name></type> <name>path</name> <init>= <expr><call><name>SIPathBuilder_New</name><argument_list>(<argument><expr><name>nelements</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelements</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>element</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NULL</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* If any element of the path does not exist, the entire path is invalid.
			 * Free it and return a null value. */</comment>
			<expr_stmt><expr><call><name>SIValue_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if<condition>(<expr><name>i</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<comment type="line">// Nodes are in even position.</comment>
			<expr_stmt><expr><call><name>SIPathBuilder_AppendNode</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="line">// Edges and paths are in odd positions.</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_rel_pattern</name> <init>= <expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>ast_path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>RTL_pattern</name> <init>= <expr><call><name>cypher_ast_rel_pattern_get_direction</name><argument_list>(<argument><expr><name>ast_rel_pattern</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_REL_INBOUND</name></expr></init></decl>;</decl_stmt>
			<comment type="line">// Element type can be either edge, or path.</comment>
			<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_EDGE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>SIPathBuilder_AppendEdge</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>element</name></expr></argument>, <argument><expr><name>RTL_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<comment type="line">// If element is not an edge, it is a path.</comment>
			<else>else <block>{<block_content>
				<comment type="block">/* Path with 0 edges should not be appended. Their source and destination nodes are the same,
				 * and the source node already appended.
				 * The build should continue to the next edge/path value. Consider the following query:
				 * "MATCH p=(a:L1)-[*0..]-&gt;(b:L1)-[]-&gt;(c:L2)" for the graph in the form of (:L1)-[]-&gt;(:L2). The path build should
				 * return a path with with the relevant entities.
				 */</comment>
				<if_stmt><if>if<condition>(<expr><call><name>SIPath_Length</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>SIPathBuilder_AppendPath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>element</name></expr></argument>, <argument><expr><name>RTL_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>path</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Routine for freeing a shortest path function's private data.</comment>
<function><type><name>void</name></type> <name>ShortestPath_Free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx_ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>ShortestPathCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name>ctx_ptr</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>reltypes</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reltypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>reltype_names</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reltype_names</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>free_matrices</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>GrB_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>R</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Routine for cloning a shortest path function's private data.</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>ShortestPath_Clone</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>orig</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>ShortestPathCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name>orig</name></expr></init></decl>;</decl_stmt>
	<comment type="line">// Allocate space for the clone</comment>
	<decl_stmt><decl><type><name>ShortestPathCtx</name> <modifier>*</modifier></type><name>ctx_clone</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShortestPathCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ctx_clone</name><operator>-&gt;</operator><name>minHops</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>minHops</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx_clone</name><operator>-&gt;</operator><name>maxHops</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>maxHops</name></name></expr>;</expr_stmt>
	<comment type="block">/* Clone reltype names but not IDs, to avoid
	 * a scenario in which a traversed type is created after the
	 * shortestPath query is cached. */</comment>
	<expr_stmt><expr><name><name>ctx_clone</name><operator>-&gt;</operator><name>reltype_count</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>reltype_count</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx_clone</name><operator>-&gt;</operator><name>reltypes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>reltype_names</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>array_clone</name><argument_list>(<argument><expr><name><name>ctx_clone</name><operator>-&gt;</operator><name>reltype_names</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reltype_names</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>ctx_clone</name><operator>-&gt;</operator><name>reltype_names</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<comment type="line">// Do not clone matrix data</comment>
	<expr_stmt><expr><name><name>ctx_clone</name><operator>-&gt;</operator><name>R</name></name> <operator>=</operator> <name>GrB_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx_clone</name><operator>-&gt;</operator><name>free_matrices</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>ctx_clone</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>AR_SHORTEST_PATH</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Node</name>             <modifier>*</modifier></type><name>srcNode</name>   <init>=  <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ptrval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>             <modifier>*</modifier></type><name>destNode</name>  <init>=  <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ptrval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShortestPathCtx</name>  <modifier>*</modifier></type><name>ctx</name>       <init>=  <expr><name>private_data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GrB_Index</name></type> <name>src_id</name>            <init>=  <expr><call><name>ENTITY_GET_ID</name><argument_list>(<argument><expr><name>srcNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GrB_Index</name></type> <name>dest_id</name>           <init>=  <expr><call><name>ENTITY_GET_ID</name><argument_list>(<argument><expr><name>destNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>GrB_Info</name></type> <name>res</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Edge</name> <modifier>*</modifier></type><name>edges</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GrB_Vector</name></type> <name>V</name> <init>= <expr><name>GrB_NULL</name></expr></init></decl>;</decl_stmt>  <comment type="line">// vector of results</comment>
	<decl_stmt><decl><type><name>GrB_Vector</name></type> <name>PI</name> <init>= <expr><name>GrB_NULL</name></expr></init></decl>;</decl_stmt> <comment type="line">// vector backtracking results to their parents</comment>
	<decl_stmt><decl><type><name>GraphContext</name> <modifier>*</modifier></type><name>gc</name> <init>= <expr><call><name>QueryCtx_GetGraphCtx</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>GrB_Index</name></type> <name>max_level</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>maxHops</name></name> <operator>==</operator> <name>EDGE_LENGTH_INF</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>ctx</name><operator>-&gt;</operator><name>maxHops</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>R</name></name> <operator>==</operator> <name>GrB_NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// First invocation, initialize unset context members.</comment>
		<if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>reltype_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<comment type="line">// Retrieve IDs of traversed relationship types.</comment>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>reltypes</name></name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reltype_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>reltype_count</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<decl_stmt><decl><type><name>Schema</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>GraphContext_GetSchema</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reltype_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>SCHEMA_EDGE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<comment type="line">// Skip missing schemas</comment>
				<if_stmt><if>if<condition>(<expr><name>s</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reltypes</name></name></expr></argument>, <argument><expr><call><name>Schema_GetID</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="line">// Update the reltype count, as it may have changed due to missing schemas</comment>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>reltype_count</name></name> <operator>=</operator> <call><name>array_len</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reltypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Get edge matrix and transpose matrix, if available.</comment>
		<if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>reltypes</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// No edge types were specified, use the overall adjacency matrix.</comment>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>free_matrices</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>RG_Matrix_export</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>R</name></name></expr></argument>, <argument><expr><call><name>Graph_GetAdjacencyMatrix</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>g</name></name></expr></argument>,
						<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>reltype_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<comment type="line">// If edge types were specified but none were valid,</comment>
			<comment type="line">// use the zero matrix</comment>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>free_matrices</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>RG_Matrix_export</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>R</name></name></expr></argument>, <argument><expr><call><name>Graph_GetZeroMatrix</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>g</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>reltype_count</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>free_matrices</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>RG_Matrix_export</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>R</name></name></expr></argument>, <argument><expr><call><name>Graph_GetRelationMatrix</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>g</name></name></expr></argument>,
						<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reltypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="line">// we have multiple edge types, combine them into a boolean matrix</comment>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>free_matrices</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>GrB_Index</name></type> <name>dims</name> <init>= <expr><call><name>Graph_RequiredMatrixDim</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>g</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>GrB_Matrix_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>R</name></name></expr></argument>, <argument><expr><name>GrB_BOOL</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>reltype_count</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>adj</name></decl>;</decl_stmt>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>RG_Matrix_export</name><argument_list>(<argument><expr><operator>&amp;</operator><name>adj</name></expr></argument>, <argument><expr><call><name>Graph_GetRelationMatrix</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>g</name></name></expr></argument>,
							<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reltypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>GrB_eWiseAdd</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>R</name></name></expr></argument>, <argument><expr><name>GrB_NULL</name></expr></argument>, <argument><expr><name>GrB_NULL</name></expr></argument>,
						<argument><expr><name>GxB_ANY_PAIR_BOOL</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>R</name></name></expr></argument>, <argument><expr><name>adj</name></expr></argument>, <argument><expr><name>GrB_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>GrB_Matrix_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>adj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<decl_stmt><decl><type><name>GrB_Index</name></type> <name>nrows</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>GrB_Matrix_nrows</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nrows</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>R</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Invoke the BFS algorithm</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LG_BreadthFirstSearch_SSGrB</name><argument_list>(<argument><expr><operator>&amp;</operator><name>V</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>PI</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>R</name></name></expr></argument>, <argument><expr><name>src_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dest_id</name></expr></argument>,
		<argument><expr><name>max_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>V</name> <operator>!=</operator> <name>GrB_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>PI</name> <operator>!=</operator> <name>GrB_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SIValue</name></type> <name>p</name> <init>= <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// The length of the path is equal to the level of the destination node</comment>
	<decl_stmt><decl><type><name>GrB_Index</name></type> <name>path_len</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>GrB_Vector_extractElement</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path_len</name></expr></argument>, <argument><expr><name>V</name></expr></argument>, <argument><expr><name>dest_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>res</name> <operator>==</operator> <name>GrB_NO_VALUE</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt> <comment type="line">// no path found</comment>

	<comment type="line">// Only emit a path with no edges if minHops is 0</comment>
	<if_stmt><if>if<condition>(<expr><name>path_len</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>minHops</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* Build path in reverse, starting by appending the destination node.
	 * The path is built in reverse because we have the destination's parent
	 * in the PI array, and can use this to backtrack until we reach the source. */</comment>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>SIPathBuilder_New</name><argument_list>(<argument><expr><name>path_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SIPathBuilder_AppendNode</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>SI_Node</name><argument_list>(<argument><expr><name>destNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>Edge</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>NodeID</name></type> <name>id</name> <init>= <expr><name><name>destNode</name><operator>-&gt;</operator><name>id</name></name></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>path_len</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>array_clear</name><argument_list>(<argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>GrB_Index</name></type> <name>parent_id</name></decl>;</decl_stmt>
		<comment type="line">// Find the parent of the reached node.</comment>
		<decl_stmt><decl><type><name>GrB_Info</name></type> <name>res</name> <init>= <expr><call><name>GrB_Vector_extractElement</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parent_id</name></expr></argument>, <argument><expr><name>PI</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Retrieve edges connecting the parent node to the current node.</comment>
		<if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>reltype_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>Graph_GetEdgesConnectingNodes</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>g</name></name></expr></argument>, <argument><expr><name>parent_id</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>GRAPH_NO_RELATION</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>reltype_count</name></name></expr>;</condition> <incr><expr><name>j</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<expr_stmt><expr><call><name>Graph_GetEdgesConnectingNodes</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>g</name></name></expr></argument>, <argument><expr><name>parent_id</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reltypes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>(<expr><call><name>array_len</name><argument_list>(<argument><expr><name>edges</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>array_len</name><argument_list>(<argument><expr><name>edges</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// Append the edge to the path</comment>
		<expr_stmt><expr><call><name>SIPathBuilder_AppendEdge</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>SI_Edge</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Append the reached node to the path.</comment>
		<expr_stmt><expr><name>id</name> <operator>=</operator> <name><name>edges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>srcNodeID</name></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Node</name></type> <name>n</name> <init>= <expr><call><name>GE_NEW_NODE</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Graph_GetNode</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>g</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SIPathBuilder_AppendNode</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>SI_Node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="line">// Reverse the path so it starts at the source</comment>
	<expr_stmt><expr><call><name>Path_Reverse</name><argument_list>(<argument><expr><name><name>p</name><operator>.</operator><name>ptrval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
	<if_stmt><if>if<condition>(<expr><name>V</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>GrB_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>V</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name>PI</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>GrB_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>PI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name>edges</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>AR_PATH_NODES</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>SIPath_Nodes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>AR_PATH_RELATIONSHIPS</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>SIPath_Relationships</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>AR_PATH_LENGTH</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>SI_LongVal</name><argument_list>(<argument><expr><call><name>SIPath_Length</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>Register_PathFuncs</name><parameter_list>()</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIType</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIType</name></type> <name>ret_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AR_FuncDesc</name> <modifier>*</modifier></type><name>func_desc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_NULL</name> <operator>|</operator> <name>T_NODE</name> <operator>|</operator> <name>T_EDGE</name> <operator>|</operator> <name>T_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_PATH</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"topath"</literal></expr></argument>, <argument><expr><name>AR_TOPATH</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>VAR_ARG_LEN</name></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_NULL</name> <operator>|</operator> <name>T_NODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_NULL</name> <operator>|</operator> <name>T_NODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_PATH</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"shortestpath"</literal></expr></argument>, <argument><expr><name>AR_SHORTEST_PATH</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_SetPrivateDataRoutines</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>, <argument><expr><name>ShortestPath_Free</name></expr></argument>, <argument><expr><name>ShortestPath_Clone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_NULL</name> <operator>|</operator> <name>T_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"nodes"</literal></expr></argument>, <argument><expr><name>AR_PATH_NODES</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_NULL</name> <operator>|</operator> <name>T_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"relationships"</literal></expr></argument>, <argument><expr><name>AR_PATH_RELATIONSHIPS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_NULL</name> <operator>|</operator> <name>T_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_INT64</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"length"</literal></expr></argument>, <argument><expr><name>AR_PATH_LENGTH</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

</unit>
