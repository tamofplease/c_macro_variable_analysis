<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/src/arithmetic/numeric_funcs/numeric_funcs.c"><comment type="block">/*
 * Copyright Redis Ltd. 2018 - present
 * Licensed under your choice of the Redis Source Available License 2.0 (RSALv2) or
 * the Server Side Public License v1 (SSPLv1).
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"numeric_funcs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"RG.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../errors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../func_desc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../util/arr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../util/rmalloc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>M_PI</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_PI</name></cpp:macro> <cpp:value>(3.14159265358979323846)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* M_PI */</comment>

<comment type="block">/* The '+' operator is overloaded to perform string concatenation
 * as well as arithmetic addition. */</comment>
<function><type><name>SIValue</name></type> <name>AR_ADD</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>SIValue_Add</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* returns the subtracting given values. */</comment>
<function><type><name>SIValue</name></type> <name>AR_SUB</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>SIValue_Subtract</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* returns the multiplication of given values. */</comment>
<function><type><name>SIValue</name></type> <name>AR_MUL</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>SIValue_Multiply</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* returns the division of given values. */</comment>
<function><type><name>SIValue</name></type> <name>AR_DIV</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// check for division by zero e.g. n / 0</comment>
	<if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>T_INT64</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>Error_DivisionByZero</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>SIValue_Divide</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>AR_MODULO</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// check for modulo by zero e.g. n % 0</comment>
	<if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>T_INT64</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>Error_DivisionByZero</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>SIValue_Modulo</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* TODO All AR_* functions need to emit appropriate failures when provided
 * with arguments of invalid types and handle multiple arguments. */</comment>
<comment type="block">/* returns the absolute value of the given number. */</comment>
<function><type><name>SIValue</name></type> <name>AR_ABS</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>result</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SIValue_Multiply</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>SI_LongVal</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* returns the smallest floating point number that is greater than or equal to the given number and equal to a mathematical integer. */</comment>
<function><type><name>SIValue</name></type> <name>AR_CEIL</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>result</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<comment type="line">// No modification is required for non-decimal values</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_DOUBLE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>result</name><operator>.</operator><name>doubleval</name></name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>doubleval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* returns the largest floating point number that is less than or equal to the given number and equal to a mathematical integer. */</comment>
<function><type><name>SIValue</name></type> <name>AR_FLOOR</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>result</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<comment type="line">// No modification is required for non-decimal values</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_DOUBLE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>result</name><operator>.</operator><name>doubleval</name></name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>doubleval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* returns a random floating point number in the range from 0 to 1; i.e. [0,1]. The numbers returned follow an approximate uniform distribution. */</comment>
<function><type><name>SIValue</name></type> <name>AR_RAND</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator><call><name>rand</name><argument_list>()</argument_list></call> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>RAND_MAX</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* returns the value of the given number rounded to the nearest integer. */</comment>
<function><type><name>SIValue</name></type> <name>AR_ROUND</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>result</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<comment type="line">// No modification is required for non-decimal values</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_DOUBLE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>result</name><operator>.</operator><name>doubleval</name></name> <operator>=</operator> <call><name>round</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>doubleval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* returns the signum of the given number: 0 if the number is 0, -1 for any negative number, and 1 for any positive number. */</comment>
<function><type><name>SIValue</name></type> <name>AR_SIGN</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<decl_stmt><decl><type><name>int64_t</name></type> <name>sign</name> <init>= <expr><call><name>SIGN</name><argument_list>(<argument><expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>SI_LongVal</name><argument_list>(<argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// tries to convert input to integer</comment>
<function><type><name>SIValue</name></type> <name>AR_TOINTEGER</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sEnd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<switch>switch<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>T_INT64</name></expr>:</case>
		<return>return <expr><name>arg</name></expr>;</return>
	<case>case <expr><name>T_DOUBLE</name></expr>:</case>
		<comment type="line">// Remove floating point.</comment>
		<return>return <expr><call><name>SI_LongVal</name><argument_list>(<argument><expr><call><name>floor</name><argument_list>(<argument><expr><name><name>arg</name><operator>.</operator><name>doubleval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	<case>case <expr><name>T_STRING</name></expr>:</case>
		<if_stmt><if>if<condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>arg</name><operator>.</operator><name>stringval</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>parsedval</name> <init>= <expr><call><name>strtod</name><argument_list>(<argument><expr><name><name>arg</name><operator>.</operator><name>stringval</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sEnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* The input was not a complete number or represented a number that
		 * cannot be represented as a double. */</comment>
		<if_stmt><if>if<condition>(<expr><name><name>sEnd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
		<comment type="line">// Remove floating point.</comment>
		<return>return <expr><call><name>SI_LongVal</name><argument_list>(<argument><expr><call><name>floor</name><argument_list>(<argument><expr><name>parsedval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	<default>default:</default>
		<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="line">// tries to convert input to float</comment>
<function><type><name>SIValue</name></type> <name>AR_TOFLOAT</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sEnd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<switch>switch<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>T_INT64</name></expr>:</case>
		<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><name><name>arg</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</return>
	<case>case <expr><name>T_DOUBLE</name></expr>:</case>
		<return>return <expr><name>arg</name></expr>;</return>
	<case>case <expr><name>T_STRING</name></expr>:</case>
		<if_stmt><if>if<condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>arg</name><operator>.</operator><name>stringval</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>parsedval</name> <init>= <expr><call><name>strtof</name><argument_list>(<argument><expr><name><name>arg</name><operator>.</operator><name>stringval</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sEnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* The input was not a complete number or represented a number that
		 * cannot be represented as a double. */</comment>
		<if_stmt><if>if<condition>(<expr><name><name>sEnd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><name>parsedval</name></expr></argument>)</argument_list></call></expr>;</return>
	<default>default:</default>
		<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="line">// returns the square root of a number</comment>
<function><type><name>SIValue</name></type> <name>AR_SQRT</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<comment type="line">// return NULL if input is none numeric</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// return sqrt of input</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><call><name>sqrt</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns base^exponent</comment>
<function><type><name>SIValue</name></type> <name>AR_POW</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>base</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>exp</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<comment type="line">// return NULL if input is NULL</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// return base^exponent</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><call><name>pow</name><argument_list>(<argument><expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns the base of the natural logarithm, e.</comment>
<function><type><name>SIValue</name></type> <name>AR_E</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// base of the natural logarithm (e) == e^1</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><call><name>exp</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns e^value</comment>
<function><type><name>SIValue</name></type> <name>AR_EXP</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<comment type="line">// return NULL if input is none numeric</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// return e^value</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><call><name>exp</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns ln(val)</comment>
<function><type><name>SIValue</name></type> <name>AR_LOG</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<comment type="line">// return NULL if input is none numeric</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// return ln of input</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><call><name>log</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns log10(val)</comment>
<function><type><name>SIValue</name></type> <name>AR_LOG10</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<comment type="line">// return NULL if input is none numeric</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// return log10 of input</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><call><name>log10</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns sin(x)</comment>
<function><type><name>SIValue</name></type> <name>AR_SIN</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<comment type="line">// return NULL if input is none numeric</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// return sin(x) of input</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><call><name>sin</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns cos(x)</comment>
<function><type><name>SIValue</name></type> <name>AR_COS</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<comment type="line">// return NULL if input is none numeric</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// return cos(x) of input</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><call><name>cos</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns tan(x)</comment>
<function><type><name>SIValue</name></type> <name>AR_TAN</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<comment type="line">// return NULL if input is none numeric</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// return tan(x) of input</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><call><name>tan</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns cot(x) = cos(x)/sin(x)</comment>
<function><type><name>SIValue</name></type> <name>AR_COT</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<comment type="line">// return NULL if input is none numeric</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	
	<decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// return cot(x) of input</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><call><name>cos</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>/</operator><call><name>sin</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns asin(x)</comment>
<function><type><name>SIValue</name></type> <name>AR_ASIN</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<comment type="line">// return NULL if input is none numeric</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	
	<decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	
	<comment type="line">// return asin(x) of input</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><call><name>asin</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns acos(x)</comment>
<function><type><name>SIValue</name></type> <name>AR_ACOS</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<comment type="line">// return NULL if input is none numeric</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	
	<decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// return acos(x) of input</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><call><name>acos</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns atan(x)</comment>
<function><type><name>SIValue</name></type> <name>AR_ATAN</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<comment type="line">// return NULL if input is none numeric</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	
	<decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// return atan(x) of input</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><call><name>atan</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns atan2(y, x)</comment>
<function><type><name>SIValue</name></type> <name>AR_ATAN2</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>argY</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>argX</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="line">// return NULL if input is NULL</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>argY</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>argX</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	
	<decl_stmt><decl><type><name>double</name></type> <name>y</name> <init>= <expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>argY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>x</name> <init>= <expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>argX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	
	<comment type="line">// return atan2(y, x) of input</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><call><name>atan2</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns degrees(x)</comment>
<function><type><name>SIValue</name></type> <name>AR_DEGREES</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="line">// return NULL if input is NULL</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	
	<decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	
	<comment type="line">// return degrees(value) of input</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><name>value</name> <operator>*</operator> <operator>(</operator><literal type="number">180</literal><operator>/</operator><name>M_PI</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns radians(x)</comment>
<function><type><name>SIValue</name></type> <name>AR_RADIANS</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="line">// return NULL if input is NULL</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	
	<decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	
	<comment type="line">// return radians(value) of input</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>( <argument><expr><name>value</name> <operator>*</operator> <operator>(</operator><name>M_PI</name> <operator>/</operator> <literal type="number">180.0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns radians(x)</comment>
<function><type><name>SIValue</name></type> <name>AR_PI</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>	
	<comment type="line">// return pi() of input</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><name>M_PI</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns haversin(x)</comment>
<function><type><name>SIValue</name></type> <name>AR_HAVERSIN</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="line">// return NULL if input is NULL</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	
	<decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><call><name>SI_GET_NUMERIC</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	
	<comment type="line">// return haversin(y, x) of input</comment>
	<return>return <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><operator>(</operator><literal type="number">1</literal><operator>-</operator><call><name>cos</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>Register_NumericFuncs</name><parameter_list>()</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIType</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIType</name></type> <name>ret_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AR_FuncDesc</name> <modifier>*</modifier></type><name>func_desc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_STRING</name> <operator>|</operator> <name>T_ARRAY</name> <operator>|</operator> <name>T_BOOL</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>SI_NUMERIC</name> <operator>|</operator> <name>T_STRING</name> <operator>|</operator> <name>T_ARRAY</name> <operator>|</operator> <name>T_BOOL</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"add"</literal></expr></argument>, <argument><expr><name>AR_ADD</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"sub"</literal></expr></argument>, <argument><expr><name>AR_SUB</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"mul"</literal></expr></argument>, <argument><expr><name>AR_MUL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"div"</literal></expr></argument>, <argument><expr><name>AR_DIV</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"mod"</literal></expr></argument>, <argument><expr><name>AR_MODULO</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"abs"</literal></expr></argument>, <argument><expr><name>AR_ABS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"ceil"</literal></expr></argument>, <argument><expr><name>AR_CEIL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"floor"</literal></expr></argument>, <argument><expr><name>AR_FLOOR</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_DOUBLE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"rand"</literal></expr></argument>, <argument><expr><name>AR_RAND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"round"</literal></expr></argument>, <argument><expr><name>AR_ROUND</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_INT64</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"sign"</literal></expr></argument>, <argument><expr><name>AR_SIGN</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_STRING</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_INT64</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"tointeger"</literal></expr></argument>, <argument><expr><name>AR_TOINTEGER</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>SI_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_INT64</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"tointegerornull"</literal></expr></argument>, <argument><expr><name>AR_TOINTEGER</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_STRING</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_DOUBLE</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"tofloat"</literal></expr></argument>, <argument><expr><name>AR_TOFLOAT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>SI_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_DOUBLE</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"tofloatornull"</literal></expr></argument>, <argument><expr><name>AR_TOFLOAT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_DOUBLE</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"sqrt"</literal></expr></argument>, <argument><expr><name>AR_SQRT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_DOUBLE</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"pow"</literal></expr></argument>, <argument><expr><name>AR_POW</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_DOUBLE</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"exp"</literal></expr></argument>, <argument><expr><name>AR_EXP</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_DOUBLE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"e"</literal></expr></argument>, <argument><expr><name>AR_E</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_DOUBLE</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"log"</literal></expr></argument>, <argument><expr><name>AR_LOG</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_DOUBLE</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"log10"</literal></expr></argument>, <argument><expr><name>AR_LOG10</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_DOUBLE</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"sin"</literal></expr></argument>, <argument><expr><name>AR_SIN</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_DOUBLE</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"cos"</literal></expr></argument>, <argument><expr><name>AR_COS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_DOUBLE</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"tan"</literal></expr></argument>, <argument><expr><name>AR_TAN</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_DOUBLE</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"cot"</literal></expr></argument>, <argument><expr><name>AR_COT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_DOUBLE</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"asin"</literal></expr></argument>, <argument><expr><name>AR_ASIN</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_DOUBLE</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"acos"</literal></expr></argument>, <argument><expr><name>AR_ACOS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_DOUBLE</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"atan"</literal></expr></argument>, <argument><expr><name>AR_ATAN</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_DOUBLE</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"atan2"</literal></expr></argument>, <argument><expr><name>AR_ATAN2</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_DOUBLE</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"degrees"</literal></expr></argument>, <argument><expr><name>AR_DEGREES</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_DOUBLE</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"radians"</literal></expr></argument>, <argument><expr><name>AR_RADIANS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_DOUBLE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"pi"</literal></expr></argument>, <argument><expr><name>AR_PI</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>SI_NUMERIC</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_DOUBLE</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"haversin"</literal></expr></argument>, <argument><expr><name>AR_HAVERSIN</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
