<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/src/arithmetic/arithmetic_expression_construct.c"><comment type="block">/*
 * Copyright Redis Ltd. 2018 - present
 * Licensed under your choice of the Redis Source Available License 2.0 (RSALv2) or
 * the Server Side Public License v1 (SSPLv1).
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"arithmetic_expression_construct.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"RG.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../errors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../query_ctx.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/rmalloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../datatypes/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../configuration/config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../ast/ast_build_filter_tree.h"</cpp:file></cpp:include>

<comment type="line">// Forward declaration</comment>
<function_decl><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_EXP_FromASTNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_ExpNodeFromGraphEntity</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>entity</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_ExpFromNamedPath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>__AR_EXP_ContainsNestedAgg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>in_agg</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// Is this an aggregation node?</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>agg_node</name> <init>= <expr><operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AR_EXP_OP</name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>aggregate</name></name> <operator>==</operator> <name>true</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<comment type="line">// Aggregation node nested within another aggregation node.</comment>
	<if_stmt><if>if<condition>(<expr><name>agg_node</name> <operator>&amp;&amp;</operator> <name>in_agg</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AR_EXP_OP</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Scan child nodes.</comment>
		<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>child_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<comment type="line">// Cary on `in_agg`.</comment>
			<if_stmt><if>if<condition>(<expr><call><name>__AR_EXP_ContainsNestedAgg</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>agg_node</name> <operator>|</operator> <name>in_agg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return true if expression contains nested calls to aggregation functions
 * e.g. MAX(MIN(1)) */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>_AR_EXP_ContainsNestedAgg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>exp</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>in_agg</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>__AR_EXP_ContainsNestedAgg</name><argument_list>(<argument><expr><name>exp</name></expr></argument>, <argument><expr><name>in_agg</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP_COUNT</name></cpp:macro> <cpp:value>25</cpp:value></cpp:define>
<comment type="line">// The OpName array is strictly parallel with the AST_Operator enum.</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>OpName</name><index>[<expr><name>OP_COUNT</name></expr>]</index></name> <init>= <expr><block>{
	<expr><literal type="string">"UNKNOWN"</literal></expr>, <expr><literal type="string">"NULL"</literal></expr>, <expr><literal type="string">"OR"</literal></expr>, <expr><literal type="string">"XOR"</literal></expr>, <expr><literal type="string">"AND"</literal></expr>, <expr><literal type="string">"NOT"</literal></expr>, <expr><literal type="string">"EQ"</literal></expr>, <expr><literal type="string">"NEQ"</literal></expr>, <expr><literal type="string">"LT"</literal></expr>, <expr><literal type="string">"GT"</literal></expr>, <expr><literal type="string">"LE"</literal></expr>,  <expr><literal type="string">"GE"</literal></expr>,
	<expr><literal type="string">"ADD"</literal></expr>, <expr><literal type="string">"SUB"</literal></expr>, <expr><literal type="string">"MUL"</literal></expr>, <expr><literal type="string">"DIV"</literal></expr>, <expr><literal type="string">"MOD"</literal></expr>, <expr><literal type="string">"POW"</literal></expr>, <expr><literal type="string">"CONTAINS"</literal></expr>, <expr><literal type="string">"STARTS WITH"</literal></expr>,
	<expr><literal type="string">"ENDS WITH"</literal></expr>, <expr><literal type="string">"IN"</literal></expr>, <expr><literal type="string">"IS NULL"</literal></expr>, <expr><literal type="string">"IS NOT NULL"</literal></expr>, <expr><literal type="string">"XNOR"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>_ASTOpToString</name><parameter_list>(<parameter><decl><type><name>AST_Operator</name></type> <name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;</operator> <name>OP_COUNT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>OpName</name><index>[<expr><name>op</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>AR_EXP_NewOpNodeFromAST</name><parameter_list>(<parameter><decl><type><name>AST_Operator</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>uint</name></type> <name>child_count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func_name</name> <init>= <expr><call><name>_ASTOpToString</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>AR_EXP_NewOpNode</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>child_count</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_EXP_FromApplyExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>                    <name>distinct</name>    <init>=  <expr><call><name>cypher_ast_apply_operator_get_distinct</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type>                    <name>arg_count</name>   <init>=  <expr><call><name>cypher_ast_apply_operator_narguments</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name>  <modifier>*</modifier></type><name>func_node</name>  <init>=  <expr><call><name>cypher_ast_apply_operator_get_func_name</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>              <modifier>*</modifier></type><name>func_name</name>  <init>=  <expr><call><name>cypher_ast_function_name_get_value</name><argument_list>(<argument><expr><name>func_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>                    <name>aggregate</name>   <init>=  <expr><call><name>AR_FuncIsAggregate</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>AR_EXP_NewOpNode</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>arg_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>ErrorCtx_EncounteredError</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="line">// no children to free</comment>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>child_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AR_EXP_Free</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>internal</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Attempted to access variable before it has been defined"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for<control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arg_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>cypher_ast_apply_operator_get_argument</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// Recursively convert arguments</comment>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if<condition>(<expr><name>aggregate</name> <operator>&amp;&amp;</operator> <name>distinct</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// when we aggregating distinct values</comment>
		<comment type="line">// for example COUNT(DISTINCT x)</comment>
		<comment type="line">// we use distinct function</comment>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>arg_count</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>distinct</name> <init>= <expr><call><name>AR_EXP_NewOpNode</name><argument_list>(<argument><expr><literal type="string">"distinct"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>arg_count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// move x to be child of distinct</comment>
		<expr_stmt><expr><name><name>distinct</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<comment type="line">// distinct is child of COUNT</comment>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>distinct</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>op</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_EXP_FromApplyAllExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// ApplyAll operators use accessors similar to normal Apply operators with the exception</comment>
	<comment type="line">// that they have no argument accessors - by definition, they have one argument (all/STAR).</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>func_node</name> <init>= <expr><call><name>cypher_ast_apply_all_operator_get_func_name</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func_name</name> <init>= <expr><call><name>cypher_ast_function_name_get_value</name><argument_list>(<argument><expr><name>func_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>AR_EXP_NewOpNode</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Introduce a fake child constant so that the function always operates on something.</comment>
	<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_BoolVal</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>op</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_EXP_FromIdentifierExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// Identifier referencing another entity</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>AR_EXP_NewVariableOperandNode</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_EXP_FromIdentifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name> <init>= <expr><call><name>QueryCtx_GetAST</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>ast</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Attempted to access the AST before it has been constructed.
		 * This can occur in scenarios like parameter evaluation:
		 * CYPHER param=[a] MATCH (a) RETURN a */</comment>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Attempted to access variable before it has been defined"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// check if the identifier is a named path identifier</comment>
	<decl_stmt><decl><type><name>AnnotationCtx</name> <modifier>*</modifier></type><name>named_paths_ctx</name> <init>=
		<expr><call><name>AST_AnnotationCtxCollection_GetNamedPathsCtx</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>anot_ctx_collection</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>named_path_annotation</name> <init>=
		<expr><call><name>cypher_astnode_get_annotation</name><argument_list>(<argument><expr><name>named_paths_ctx</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// if the identifier is a named path identifier,</comment>
	<comment type="line">// evaluate the path expression accordingly</comment>
	<if_stmt><if>if<condition>(<expr><name>named_path_annotation</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>_AR_ExpFromNamedPath</name><argument_list>(<argument><expr><name>named_path_annotation</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<comment type="line">// else, evalute the identifier</comment>
	<return>return <expr><call><name>_AR_EXP_FromIdentifierExpression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_EXP_FromPropertyExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// the property expression is constructed of two parts:</comment>
	<comment type="line">// 1. an expression evaluating to a graph entity, in the future a map type</comment>
	<comment type="line">// 2. a property name string.</comment>
	<comment type="line">// examples: a.v, arr[0].v</comment>

	<comment type="line">//--------------------------------------------------------------------------</comment>
	<comment type="line">// Extract entity and property name expressions.</comment>
	<comment type="line">//--------------------------------------------------------------------------</comment>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>prop_expr</name> <init>= <expr><call><name>cypher_ast_property_operator_get_expression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>prop_name_node</name> <init>= <expr><call><name>cypher_ast_property_operator_get_prop_name</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prop_name</name> <init>= <expr><call><name>cypher_ast_prop_name_get_value</name><argument_list>(<argument><expr><name>prop_name_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>entity</name> <init>= <expr><call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>prop_expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><call><name>AR_EXP_NewAttributeAccessNode</name><argument_list>(<argument><expr><name>entity</name></expr></argument>, <argument><expr><name>prop_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>root</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SIValue</name></type> <name>_AR_EXP_FromIntegerString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value_str</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64_t</name></type> <name>l</name> <init>= <expr><call><name>strtol</name><argument_list>(<argument><expr><name>value_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>endptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="line">// Failed to convert integer value; set compile-time error to be raised later.</comment>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Invalid numeric value '%s'"</literal></expr></argument>, <argument><expr><name>value_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Integer overflow '%s'"</literal></expr></argument>, <argument><expr><name>value_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>converted</name> <init>= <expr><call><name>SI_LongVal</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>converted</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_EXP_FromIntegerExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value_str</name> <init>= <expr><call><name>cypher_ast_integer_get_valuestr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>converted</name> <init>= <expr><call><name>_AR_EXP_FromIntegerString</name><argument_list>(<argument><expr><name>value_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><name>converted</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_EXP_FromFloatExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value_str</name> <init>= <expr><call><name>cypher_ast_float_get_valuestr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>d</name> <init>= <expr><call><name>strtod</name><argument_list>(<argument><expr><name>value_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>endptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="line">// Failed to convert integer value; set compile-time error to be raised later.</comment>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Invalid numeric value '%s'"</literal></expr></argument>, <argument><expr><name>value_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Float overflow '%s'"</literal></expr></argument>, <argument><expr><name>value_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>converted</name> <init>= <expr><call><name>SI_DoubleVal</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><name>converted</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_EXP_FromStringExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value_str</name> <init>= <expr><call><name>cypher_ast_string_get_value</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>converted</name> <init>= <expr><call><name>SI_ConstStringVal</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>value_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><name>converted</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_EXP_FromTrueExpression</name><parameter_list>()</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>converted</name> <init>= <expr><call><name>SI_BoolVal</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><name>converted</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_EXP_FromFalseExpression</name><parameter_list>()</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>converted</name> <init>= <expr><call><name>SI_BoolVal</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><name>converted</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_EXP_FromNullExpression</name><parameter_list>()</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>converted</name> <init>= <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><name>converted</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_EXP_FromUnaryOpExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>cypher_ast_unary_operator_get_argument</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// CYPHER_AST_EXPRESSION</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_operator_t</name> <modifier>*</modifier></type><name>operator</name> <init>= <expr><call><name>cypher_ast_unary_operator_get_operator</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>operator</name> <operator>==</operator> <name>CYPHER_OP_UNARY_MINUS</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// This expression can be something like -3 or -a.val</comment>
		<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_INTEGER</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value_str</name> <init>= <expr><call><name>cypher_ast_integer_get_valuestr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>minus_str</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>value_str</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>minus_str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>value_str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>value_str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>minus_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>minus_str</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>value_str</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>SIValue</name></type> <name>converted</name> <init>= <expr><call><name>_AR_EXP_FromIntegerString</name><argument_list>(<argument><expr><name>minus_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><name>converted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>minus_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>AR_EXP_NewOpNodeFromAST</name><argument_list>(<argument><expr><name>OP_MULT</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_LongVal</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>operator</name> <operator>==</operator> <name>CYPHER_OP_UNARY_PLUS</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* This expression is something like +3 or +a.val.
		 * I think the + can always be safely ignored. */</comment>
		<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>operator</name> <operator>==</operator> <name>CYPHER_OP_NOT</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>AR_EXP_NewOpNodeFromAST</name><argument_list>(<argument><expr><name>OP_NOT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>operator</name> <operator>==</operator> <name>CYPHER_OP_IS_NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>AR_EXP_NewOpNodeFromAST</name><argument_list>(<argument><expr><name>OP_IS_NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>operator</name> <operator>==</operator> <name>CYPHER_OP_IS_NOT_NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>AR_EXP_NewOpNodeFromAST</name><argument_list>(<argument><expr><name>OP_IS_NOT_NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="line">// No supported operator found.</comment>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>op</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_EXP_FromBinaryOpExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_operator_t</name> <modifier>*</modifier></type><name>operator</name> <init>= <expr><call><name>cypher_ast_binary_operator_get_operator</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AST_Operator</name></type> <name>operator_enum</name> <init>= <expr><call><name>AST_ConvertOperatorNode</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// Arguments are of type CYPHER_AST_EXPRESSION</comment>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>AR_EXP_NewOpNodeFromAST</name><argument_list>(<argument><expr><name>operator_enum</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>lhs_node</name> <init>= <expr><call><name>cypher_ast_binary_operator_get_argument1</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>lhs_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>rhs_node</name> <init>= <expr><call><name>cypher_ast_binary_operator_get_argument2</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>rhs_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>op</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_EXP_FromComparisonExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// 1 &lt; 2 = 2 &lt;= 4</comment>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>length</name> <init>= <expr><call><name>cypher_ast_comparison_get_length</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>AR_EXP_NewOpNodeFromAST</name><argument_list>(<argument><expr><name>OP_AND</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_operator_t</name> <modifier>*</modifier></type><name>operator</name> <init>= <expr><call><name>cypher_ast_comparison_get_operator</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AST_Operator</name></type> <name>operator_enum</name> <init>= <expr><call><name>AST_ConvertOperatorNode</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>lhs_node</name> <init>= <expr><call><name>cypher_ast_comparison_get_argument</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>rhs_node</name> <init>= <expr><call><name>cypher_ast_comparison_get_argument</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>inner_op</name> <init>= <expr><call><name>AR_EXP_NewOpNodeFromAST</name><argument_list>(<argument><expr><name>operator_enum</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>inner_op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>lhs_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>inner_op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>rhs_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>inner_op</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_operator_t</name> <modifier>*</modifier></type><name>operator</name> <init>= <expr><call><name>cypher_ast_comparison_get_operator</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AST_Operator</name></type> <name>operator_enum</name> <init>= <expr><call><name>AST_ConvertOperatorNode</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>AR_EXP_NewOpNodeFromAST</name><argument_list>(<argument><expr><name>operator_enum</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>lhs_node</name> <init>= <expr><call><name>cypher_ast_comparison_get_argument</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>rhs_node</name> <init>= <expr><call><name>cypher_ast_comparison_get_argument</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>lhs_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>rhs_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>op</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_EXP_FromCaseExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">//Determin number of child expressions:</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>arg_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expression</name> <init>= <expr><call><name>cypher_ast_case_get_expression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>alternatives</name> <init>= <expr><call><name>cypher_ast_case_nalternatives</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Simple form: 2 * alternatives + default
	 * Generic form: 2 * alternatives + default */</comment>
	<if_stmt><if>if<condition>(<expr><name>expression</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>arg_count</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>alternatives</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>arg_count</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>alternatives</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="line">// Create Expression and child expressions</comment>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>AR_EXP_NewOpNode</name><argument_list>(<argument><expr><literal type="string">"case"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>arg_count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Value to compare against</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>expression</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>offset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Alternatives</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>alternatives</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>predicate</name> <init>= <expr><call><name>cypher_ast_case_get_predicate</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>offset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>cypher_ast_case_get_value</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>offset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="line">// Default value.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>deflt</name> <init>= <expr><call><name>cypher_ast_case_get_default</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>deflt</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Default not specified, use NULL.</comment>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>=</operator> <call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>deflt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>op</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_ExpFromCollectionExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>expCount</name> <init>= <expr><call><name>cypher_ast_collection_length</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>AR_EXP_NewOpNode</name><argument_list>(<argument><expr><literal type="string">"tolist"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>expCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>expCount</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>exp_node</name> <init>= <expr><call><name>cypher_ast_collection_get</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>exp_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>op</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_ExpFromMapExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/* create a new map construction expression
	 * determine number of elements in map
	 * double argument count to accommodate both key and value */</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>element_count</name> <init>= <expr><call><name>cypher_ast_map_nentries</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>AR_EXP_NewOpNode</name><argument_list>(<argument><expr><literal type="string">"tomap"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>element_count</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// process each key value pair</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>element_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>key_node</name> <init>= <expr><call><name>cypher_ast_map_get_key</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>cypher_ast_prop_name_get_value</name><argument_list>(<argument><expr><name>key_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>cypher_ast_map_get_value</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// this is a bit of an overkill, as key is supposed to be a const string</comment>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_ConstStringVal</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>op</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_ExpFromMapProjection</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// MATCH (n) RETURN n { .name, .age, scores: collect(m.score) }</comment>
	<comment type="line">// MATCH (n) RETURN n { .* }</comment>

	<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>identifier</name> <init>= <expr><call><name>cypher_ast_map_projection_get_expression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// Return an error if the identifier is not a string literal, like 5 in:</comment>
	<comment type="line">// RETURN 5 {v: 'b'}</comment>
	<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CYPHER_AST_IDENTIFIER</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Encountered unhandled type when trying to read map projection identifier"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>entity_name</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>selector</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>n_selectors</name> <init>= <expr><call><name>cypher_ast_map_projection_nselectors</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>tomapOp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>propertiesOp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// Count the number of selectors of type CYPHER_AST_MAP_PROJECTION_ALL_PROPERTIES, because these are not children of tomap OpNode</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>allProps_selectors</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_selectors</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>selector</name> <operator>=</operator> <call><name>cypher_ast_map_projection_get_selector</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>selector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_MAP_PROJECTION_ALL_PROPERTIES</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// { .* }</comment>
			<expr_stmt><expr><name>allProps_selectors</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if<condition>(<expr><name>allProps_selectors</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="line">// { .* }</comment>
		<comment type="line">// Use properties() to get a map with all properties</comment>
		<expr_stmt><expr><name>propertiesOp</name> <operator>=</operator> <call><name>AR_EXP_NewOpNode</name><argument_list>(<argument><expr><literal type="string">"properties"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>propertiesOp</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_NewVariableOperandNode</name><argument_list>(<argument><expr><name>entity_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><name>n_selectors</name> <operator>==</operator> <name>allProps_selectors</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>propertiesOp</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tomapOp</name> <operator>=</operator> <call><name>AR_EXP_NewOpNode</name><argument_list>(<argument><expr><literal type="string">"tomap"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>(</operator><name>n_selectors</name> <operator>-</operator> <name>allProps_selectors</name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_selectors</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>selector</name> <operator>=</operator> <call><name>cypher_ast_map_projection_get_selector</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prop_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>prop</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>selector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_MAP_PROJECTION_PROPERTY</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// { .name }</comment>
			<expr_stmt><expr><name>prop</name> <operator>=</operator> <call><name>cypher_ast_map_projection_property_get_prop_name</name><argument_list>(<argument><expr><name>selector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>prop_name</name> <operator>=</operator> <call><name>cypher_ast_prop_name_get_value</name><argument_list>(<argument><expr><name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tomapOp</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>j</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_ConstStringVal</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>prop_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>entity</name> <init>= <expr><call><name>AR_EXP_NewVariableOperandNode</name><argument_list>(<argument><expr><name>entity_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>tomapOp</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>j</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_NewAttributeAccessNode</name><argument_list>(<argument><expr><name>entity</name></expr></argument>, <argument><expr><name>prop_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_MAP_PROJECTION_LITERAL</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// { v: n.v }</comment>
			<expr_stmt><expr><name>prop</name> <operator>=</operator> <call><name>cypher_ast_map_projection_literal_get_prop_name</name><argument_list>(<argument><expr><name>selector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>prop_name</name> <operator>=</operator> <call><name>cypher_ast_prop_name_get_value</name><argument_list>(<argument><expr><name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>literal_exp</name> <init>=
				<expr><call><name>cypher_ast_map_projection_literal_get_expression</name><argument_list>(<argument><expr><name>selector</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>tomapOp</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>j</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_ConstStringVal</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>prop_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tomapOp</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>j</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>literal_exp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_MAP_PROJECTION_IDENTIFIER</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// { v }</comment>
			<expr_stmt><expr><name>prop</name> <operator>=</operator> <call><name>cypher_ast_map_projection_identifier_get_identifier</name><argument_list>(<argument><expr><name>selector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>prop_name</name> <operator>=</operator> <call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tomapOp</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>j</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_ConstStringVal</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>prop_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tomapOp</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>j</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_NewVariableOperandNode</name><argument_list>(<argument><expr><name>prop_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_MAP_PROJECTION_ALL_PROPERTIES</name></expr>)</condition> <block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="string">"Unexpected AST node type"</literal> <operator>&amp;&amp;</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if<condition>(<expr><name>propertiesOp</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// To support case like: CREATE (a:A {z:1}) RETURN a{.*, .undefinedProp}</comment>
		<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>mergemapOp</name> <init>= <expr><call><name>AR_EXP_NewOpNode</name><argument_list>(<argument><expr><literal type="string">"merge_maps"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>mergemapOp</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>tomapOp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mergemapOp</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>propertiesOp</name></expr>;</expr_stmt>
		<return>return <expr><name>mergemapOp</name></expr>;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<return>return <expr><name>tomapOp</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_ExpFromSubscriptExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>AR_EXP_NewOpNode</name><argument_list>(<argument><expr><literal type="string">"subscript"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>exp_node</name> <init>= <expr><call><name>cypher_ast_subscript_operator_get_expression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>exp_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>subscript_node</name> <init>= <expr><call><name>cypher_ast_subscript_operator_get_subscript</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>subscript_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>op</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_ExpFromSliceExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>AR_EXP_NewOpNode</name><argument_list>(<argument><expr><literal type="string">"slice"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>exp_node</name> <init>= <expr><call><name>cypher_ast_slice_operator_get_expression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>start_node</name> <init>= <expr><call><name>cypher_ast_slice_operator_get_start</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>end_node</name> <init>= <expr><call><name>cypher_ast_slice_operator_get_end</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>exp_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>start_node</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>start_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_LongVal</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>end_node</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>end_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_LongVal</name><argument_list>(<argument><expr><name>INT32_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>op</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_ExpFromNamedPath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>path_len</name> <init>= <expr><call><name>cypher_ast_pattern_path_nelements</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* The method TO_PATH accepts as its first parameter the ast node which represents the path.
	 * The other parameters are the graph entities (node, edge, path) which the path builder implemented
	 * in TO_PATH requires in order to build a complete path. The order of the evaluated graph entities
	 * is the same order in which they apeare in the AST.*/</comment>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>AR_EXP_NewOpNode</name><argument_list>(<argument><expr><literal type="string">"topath"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>path_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// Set path AST as first paramerter.</comment>
	<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_PtrVal</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>path_len</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<comment type="line">// Set graph entities as parameters, ordered according to the path AST.</comment>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<return>return <expr><name>op</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_ExpFromShortestPath</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// allShortestPaths is handled separately</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_ast_shortest_path_is_single</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>path_len</name> <init>= <expr><call><name>cypher_ast_pattern_path_nelements</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>path_len</name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"shortestPath requires a path containing a single relationship"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Retrieve the minimum and maximum number of hops, if specified.</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>start</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>end</name> <init>= <expr><name>EDGE_LENGTH_INF</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>edge</name> <init>= <expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>range</name> <init>= <expr><call><name>cypher_ast_rel_pattern_get_varlength</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>range</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>end</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="line">// Not a variable-length edge</comment>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>range_start</name> <init>= <expr><call><name>cypher_ast_range_get_start</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>range_start</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// If specified, the edge's minimum hop value must be 0 or 1</comment>
			<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>AST_ParseIntegerNode</name><argument_list>(<argument><expr><name>range_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name>start</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"shortestPath does not support a minimal length different from 0 or 1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>range_end</name> <init>= <expr><call><name>cypher_ast_range_get_end</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>range_end</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>AST_ParseIntegerNode</name><argument_list>(<argument><expr><name>range_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if<condition>(<expr><name>end</name> <operator>!=</operator> <name>EDGE_LENGTH_INF</name> <operator>&amp;&amp;</operator> <name>end</name> <operator>&lt;</operator> <name>start</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Maximum number of hops must be greater than or equal to minimum number of hops"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name><name>enum</name> <name>cypher_rel_direction</name></name></type> <name>dir</name> <init>= <expr><call><name>cypher_ast_rel_pattern_get_direction</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>dir</name> <operator>==</operator> <name>CYPHER_REL_BIDIRECTIONAL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"RedisGraph does not currently support undirected shortestPath traversals"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>cypher_ast_rel_pattern_get_properties</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"RedisGraph does not currently support filters on relationships in shortestPath"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>cypher_ast_node_pattern_get_properties</name><argument_list>(<argument><expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
	   <call><name>cypher_ast_node_pattern_get_properties</name><argument_list>(<argument><expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Node filters may not be introduced in shortestPath"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Collect the IDs of all relationship types</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>reltype_count</name> <init>= <expr><call><name>cypher_ast_rel_pattern_nreltypes</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>reltype_names</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>reltype_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>reltype_names</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>reltype_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>reltype_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reltype</name> <init>= <expr><call><name>cypher_ast_reltype_get_name</name><argument_list>(<argument><expr><call><name>cypher_ast_rel_pattern_get_reltype</name><argument_list>(<argument><expr><name>edge</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>reltype_names</name></expr></argument>, <argument><expr><name>reltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>AR_EXP_NewOpNode</name><argument_list>(<argument><expr><literal type="string">"shortestpath"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Instantiate a context struct with traversal details.</comment>
	<decl_stmt><decl><type><name>ShortestPathCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShortestPathCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>R</name></name>              <operator>=</operator>  <name>GrB_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>minHops</name></name>        <operator>=</operator>  <name>start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>maxHops</name></name>        <operator>=</operator>  <name>end</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>reltypes</name></name>       <operator>=</operator>  <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>reltype_names</name></name>  <operator>=</operator>  <name>reltype_names</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>reltype_count</name></name>  <operator>=</operator>  <call><name>array_len</name><argument_list>(<argument><expr><name>reltype_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>free_matrices</name></name>  <operator>=</operator>  <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AR_SetPrivateData</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_src</name> <init>= <expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_dest</name> <init>= <expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>dir</name> <operator>==</operator> <name>CYPHER_REL_OUTBOUND</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Standard traversal</comment>
		<expr_stmt><expr><name>src</name> <operator>=</operator> <call><name>_AR_ExpNodeFromGraphEntity</name><argument_list>(<argument><expr><name>ast_src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>_AR_ExpNodeFromGraphEntity</name><argument_list>(<argument><expr><name>ast_dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="line">// Inbound traversal, swap source and dest</comment>
		<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>_AR_ExpNodeFromGraphEntity</name><argument_list>(<argument><expr><name>ast_src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>src</name> <operator>=</operator> <call><name>_AR_ExpNodeFromGraphEntity</name><argument_list>(<argument><expr><name>ast_dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>src</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt>

	<return>return <expr><name>op</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_ExpNodeFromGraphEntity</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>entity</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>AST_ToString</name><argument_list>(<argument><expr><name>entity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>AR_EXP_NewVariableOperandNode</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_ExpNodeFromParameter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>param</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>identifier</name> <init>= <expr><call><name>cypher_ast_parameter_get_name</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>AR_EXP_NewParameterOperandNode</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_ExpNodeFromComprehensionFunction</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>comp_exp</name></decl></parameter>,
	<parameter><decl><type><name>cypher_astnode_type_t</name></type> <name>type</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// set the appropriate function name according to the node type</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func_name</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_ANY</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>func_name</name> <operator>=</operator> <literal type="string">"ANY"</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_ALL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>func_name</name> <operator>=</operator> <literal type="string">"ALL"</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_SINGLE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>func_name</name> <operator>=</operator> <literal type="string">"SINGLE"</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_NONE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>func_name</name> <operator>=</operator> <literal type="string">"NONE"</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>func_name</name> <operator>=</operator> <literal type="string">"LIST_COMPREHENSION"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="line">// using the sample query:</comment>
	<comment type="line">// WITH [1,2,3] AS arr RETURN [val IN arr WHERE val % 2 = 1 | val * 2] AS comp</comment>

	<comment type="line">// the comprehension's local variable, WHERE expression, and eval routine</comment>
	<comment type="line">// do not change for each invocation, so are bundled together in the function's context</comment>
	<decl_stmt><decl><type><name>ListComprehensionCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ListComprehensionCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>ft</name></name>            <operator>=</operator>  <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>eval_exp</name></name>      <operator>=</operator>  <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>local_record</name></name>  <operator>=</operator>  <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>variable_str</name></name>  <operator>=</operator>  <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>variable_idx</name></name>  <operator>=</operator>  <name>INVALID_INDEX</name></expr>;</expr_stmt>

	<comment type="line">// retrieve the variable name introduced in this context to iterate over list elements</comment>
	<comment type="line">// in the above query, this is 'val'</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>variable_node</name> <init>= <expr><call><name>cypher_ast_list_comprehension_get_identifier</name><argument_list>(<argument><expr><name>comp_exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>variable_node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// retrieve the variable string for the local variable</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>variable_str</name></name> <operator>=</operator> <call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>variable_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// the predicate node is the set of WHERE conditions in the comprehension</comment>
	<comment type="line">// if any</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>predicate_node</name> <init>=
		<expr><call><name>cypher_ast_list_comprehension_get_predicate</name><argument_list>(<argument><expr><name>comp_exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// build a FilterTree to represent this predicate</comment>
	<if_stmt><if>if<condition>(<expr><name>predicate_node</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>AST_ConvertFilters</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>ft</name></name></expr></argument>, <argument><expr><name>predicate_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>!=</operator> <name>CYPHER_AST_LIST_COMPREHENSION</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Functions like any() and all() must have a predicate node.</comment>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"'%s' function requires a WHERE predicate"</literal></expr></argument>, <argument><expr><name>func_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// construct the operator node that will generate updated values,</comment>
	<comment type="line">// if one is provided</comment>
	<comment type="line">//</comment>
	<comment type="line">// in the above query, this will be an operation node representing "val * 2"</comment>
	<comment type="line">// this will always be NULL for comprehensions like any() and all()</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>eval_node</name> <init>= <expr><call><name>cypher_ast_list_comprehension_get_eval</name><argument_list>(<argument><expr><name>comp_exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>eval_node</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>eval_exp</name></name> <operator>=</operator> <call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>eval_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// build an operation node to represent the list comprehension</comment>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>AR_EXP_NewOpNode</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// add the context as function's private data</comment>
	<expr_stmt><expr><call><name>AR_SetPrivateData</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// 'arr' is the list expression</comment>
	<comment type="line">// note that this value could resolve to an alias, a literal array,</comment>
	<comment type="line">// a function call, and so on</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>list_node</name> <init>= <expr><call><name>cypher_ast_list_comprehension_get_expression</name><argument_list>(<argument><expr><name>comp_exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>list_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// the list expression is the function's first child</comment>
	<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>

	<comment type="line">// the second child will be a pointer to the Record being evaluated</comment>
	<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_NewRecordNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>op</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_ExpNodeFromReduceFunction</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>reduce_exp</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// reduce(sum = 0, n IN [1,2,3] | sum + n)</comment>

	<decl_stmt><decl><type><name>ListReduceCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ListReduceCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>exp</name></name>              <operator>=</operator>  <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>record</name></name>           <operator>=</operator>  <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>variable</name></name>         <operator>=</operator>  <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>accumulator</name></name>      <operator>=</operator>  <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>variable_idx</name></name>     <operator>=</operator>  <name>INVALID_INDEX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>accumulator_idx</name></name>  <operator>=</operator>  <name>INVALID_INDEX</name></expr>;</expr_stmt>

	<comment type="line">// retrieve the accumulator string `sum`</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>accumulator_node</name> <init>= <expr><call><name>cypher_ast_reduce_get_accumulator</name><argument_list>(<argument><expr><name>reduce_exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>accumulator_node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>accumulator</name></name> <operator>=</operator> <call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>accumulator_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// retrieve the variable name `n`</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>identifier_node</name> <init>= <expr><call><name>cypher_ast_reduce_get_identifier</name><argument_list>(<argument><expr><name>reduce_exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>identifier_node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>identifier_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">//--------------------------------------------------------------------------</comment>
	<comment type="line">// sub expressions</comment>
	<comment type="line">//--------------------------------------------------------------------------</comment>

	<comment type="line">// accumulator init exp</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>init_exp</name> <init>= <expr><call><name>cypher_ast_reduce_get_init</name><argument_list>(<argument><expr><name>reduce_exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>init_val</name> <init>= <expr><call><name>AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>init_exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// array exp</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>exp_node</name> <init>= <expr><call><name>cypher_ast_reduce_get_expression</name><argument_list>(<argument><expr><name>reduce_exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>exp_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// eval exp</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>eval_node</name> <init>= <expr><call><name>cypher_ast_reduce_get_eval</name><argument_list>(<argument><expr><name>reduce_exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>exp</name></name> <operator>=</operator> <call><name>AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>eval_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// build an operation node to represent the reduction</comment>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>reduce</name> <init>= <expr><call><name>AR_EXP_NewOpNode</name><argument_list>(<argument><expr><literal type="string">"REDUCE"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// add the context as function's private data</comment>
	<expr_stmt><expr><call><name>AR_SetPrivateData</name><argument_list>(<argument><expr><name>reduce</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">//--------------------------------------------------------------------------</comment>
	<comment type="line">// set expression child nodes</comment>
	<comment type="line">//--------------------------------------------------------------------------</comment>

	<comment type="line">// accumulator init value</comment>
	<expr_stmt><expr><name><name>reduce</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>init_val</name></expr>;</expr_stmt>

	<comment type="line">// list to reduce</comment>
	<expr_stmt><expr><name><name>reduce</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>

	<comment type="line">// record</comment>
	<expr_stmt><expr><name><name>reduce</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_NewRecordNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>reduce</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_ExpFromLabelsOperatorFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>exp</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func_name</name> <init>= <expr><literal type="string">"hasLabels"</literal></expr></init></decl>;</decl_stmt>

	<comment type="line">// create node expression</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>cypher_ast_labels_operator_get_expression</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>node_exp</name> <init>= <expr><call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// create labels expression</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>nlabels</name> <init>= <expr><call><name>cypher_ast_labels_operator_nlabels</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>labels</name> <init>= <expr><call><name>SI_Array</name><argument_list>(<argument><expr><name>nlabels</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nlabels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>label</name> <init>= <expr><call><name>cypher_ast_labels_operator_get_label</name><argument_list>(<argument><expr><name>exp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>label_str</name> <init>= <expr><call><name>cypher_ast_label_get_name</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SIArray_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>labels</name></expr></argument>, <argument><expr><call><name>SI_ConstStringVal</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>label_str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>labels_exp</name> <init>= <expr><call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><name>labels</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// create func expression</comment>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>AR_EXP_NewOpNode</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// set function arguments</comment>
	<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>node_exp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>labels_exp</name></expr>;</expr_stmt>

	<return>return <expr><name>op</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_EXP_FromASTNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list> <block>{<block_content>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_type_t</name></type> <name>t</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// function invocations</comment>
	<if_stmt><if>if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_APPLY_OPERATOR</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_EXP_FromApplyExpression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
		<comment type="line">// function invocations with STAR projections</comment>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_APPLY_ALL_OPERATOR</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_EXP_FromApplyAllExpression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
		<comment type="line">// variables (full nodes and edges, UNWIND artifacts</comment>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_EXP_FromIdentifier</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
		<comment type="line">// entity-property pair</comment>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_PROPERTY_OPERATOR</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_EXP_FromPropertyExpression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
		<comment type="line">// sIValue constant types</comment>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_INTEGER</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_EXP_FromIntegerExpression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_FLOAT</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_EXP_FromFloatExpression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_STRING</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_EXP_FromStringExpression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_TRUE</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_EXP_FromTrueExpression</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_FALSE</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_EXP_FromFalseExpression</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_EXP_FromNullExpression</name><argument_list>()</argument_list></call></expr>;</return>
		<comment type="line">// handling for unary operators (-5, +a.val)</comment>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_UNARY_OPERATOR</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_EXP_FromUnaryOpExpression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_BINARY_OPERATOR</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_EXP_FromBinaryOpExpression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_COMPARISON</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_EXP_FromComparisonExpression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_CASE</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_EXP_FromCaseExpression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_COLLECTION</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_ExpFromCollectionExpression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_SUBSCRIPT_OPERATOR</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_ExpFromSubscriptExpression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_SLICE_OPERATOR</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_ExpFromSliceExpression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_NAMED_PATH</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_ExpFromNamedPath</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_SHORTEST_PATH</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_ExpFromShortestPath</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_NODE_PATTERN</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>CYPHER_AST_REL_PATTERN</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_ExpNodeFromGraphEntity</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_PARAMETER</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_ExpNodeFromParameter</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_LIST_COMPREHENSION</name> <operator>||</operator>
			  <name>t</name> <operator>==</operator> <name>CYPHER_AST_ANY</name> <operator>||</operator>
			  <name>t</name> <operator>==</operator> <name>CYPHER_AST_ALL</name> <operator>||</operator>
			  <name>t</name> <operator>==</operator> <name>CYPHER_AST_SINGLE</name> <operator>||</operator>
			  <name>t</name> <operator>==</operator> <name>CYPHER_AST_NONE</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_ExpNodeFromComprehensionFunction</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_MAP</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_ExpFromMapExpression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_MAP_PROJECTION</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_ExpFromMapProjection</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_LABELS_OPERATOR</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_ExpFromLabelsOperatorFunction</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_REDUCE</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>_AR_ExpNodeFromReduceFunction</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_PATTERN_PATH</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>CYPHER_AST_PATTERN_COMPREHENSION</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// this variable is assign by operitions that created in build_pattern_comprehension_ops.c</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>AST_ToString</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>AR_EXP_NewVariableOperandNode</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/*
		   Unhandled types:
		*/</comment>
		<expr_stmt><expr><call><name>Error_UnsupportedASTNodeType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>AR_EXP_FromASTNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><call><name>_AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AR_EXP_ReduceToScalar</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure expression doesn't contains nested aggregation functions
	 * count(max(n.v)) */</comment>
	<if_stmt><if>if<condition>(<expr><call><name>_AR_EXP_ContainsNestedAgg</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="line">// Set error (compile-time), this error will be raised later on.</comment>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Can't use aggregate functions inside of aggregate functions."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>root</name></expr>;</return>
</block_content>}</block></function>

</unit>
