<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/src/arithmetic/arithmetic_expression.c"><comment type="block">/*
 * Copyright Redis Ltd. 2018 - present
 * Licensed under your choice of the Redis Source Available License 2.0 (RSALv2) or
 * the Server Side Public License v1 (SSPLv1).
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"./arithmetic_expression.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../RG.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rax.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../errors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/arr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../query_ctx.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../graph/graph.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/rmalloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../graph/graphcontext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../datatypes/temporal_value.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../datatypes/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../ast/ast_shared.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<comment type="line">// returns true if given node 'n' represents an aggregation expression</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AGGREGATION_NODE</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((AR_EXP_IsOperation(n)) &amp;&amp; (n)-&gt;op.f-&gt;aggregate)</cpp:value></cpp:define>

<comment type="line">// return number of child nodes of 'n'</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NODE_CHILD_COUNT</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(n)-&gt;op.child_count</cpp:value></cpp:define>

<comment type="line">// return child at position 'idx' of 'n'</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NODE_CHILD</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>idx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(n)-&gt;op.children[(idx)]</cpp:value></cpp:define>

<comment type="line">// maximum size for which an array of SIValue will be stack-allocated, otherwise it will be heap-allocated.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_ARRAY_SIZE_ON_STACK</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// Forward declarations</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function_decl><type><specifier>static</specifier> <name>AR_EXP_Result</name></type> <name>_AR_EXP_EvaluateVariadic</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Record</name></type> <name>r</name></decl></parameter>,
		<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>AR_EXP_Result</name></type> <name>_AR_EXP_Evaluate</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Record</name></type> <name>r</name></decl></parameter>,
									  <parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_AR_EXP_ResolveVariables</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Record</name></type> <name>r</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="line">// Clear an op node internals, without freeing the node allocation itself.</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_AR_EXP_FreeOpInternals</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>op_node</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>AR_EXP_IsConstant</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>exp</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><name><name>exp</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AR_EXP_OPERAND</name> <operator>&amp;&amp;</operator> <name><name>exp</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AR_EXP_CONSTANT</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>AR_EXP_IsVariadic</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>exp</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><name><name>exp</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AR_EXP_OPERAND</name> <operator>&amp;&amp;</operator> <name><name>exp</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AR_EXP_VARIADIC</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>AR_EXP_IsParameter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>exp</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><name><name>exp</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AR_EXP_OPERAND</name> <operator>&amp;&amp;</operator> <name><name>exp</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AR_EXP_PARAM</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>AR_EXP_IsOperation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>exp</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><name><name>exp</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AR_EXP_OP</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>AR_EXP_IsAttribute</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>exp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>attr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>exp</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// an arithmetic expression performs attribute extraction</comment>
	<comment type="line">// if it applys the "property" function, in which case the left-handside</comment>
	<comment type="line">// child represents the graph entity from which we access the attribute</comment>
	<comment type="line">// while the right-handside represents the attribute name</comment>

	<if_stmt><if>if<condition>(<expr><name><name>exp</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AR_EXP_OP</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>AR_EXP_GetFuncName</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"property"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>attr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name><name>exp</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>AR_EXP_IsConstant</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>v</name> <init>= <expr><name><name>r</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>constant</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>attr</name> <operator>=</operator> <name><name>v</name><operator>.</operator><name>stringval</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>AR_EXP_PerformsDistinct</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>exp</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>AR_EXP_ContainsFunc</name><argument_list>(<argument><expr><name>exp</name></expr></argument>, <argument><expr><literal type="string">"distinct"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// repurpose node to a constant expression</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AR_EXP_InplaceRepurposeConstant</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>SIValue</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// free node internals</comment>
	<if_stmt><if>if<condition>(<expr><call><name>AR_EXP_IsOperation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>_AR_EXP_FreeOpInternals</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if<condition>(<expr><call><name>AR_EXP_IsConstant</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>SIValue_Free</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>constant</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// repurpose as constant operand</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name>              <operator>=</operator>  <name>AR_EXP_OPERAND</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>type</name></name>      <operator>=</operator>  <name>AR_EXP_CONSTANT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>constant</name></name>  <operator>=</operator>  <name>v</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_EXP_CloneOperand</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>exp</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>clone</name> <init>= <expr><call><name>rm_calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AR_ExpNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AR_EXP_OPERAND</name></expr>;</expr_stmt>
	<switch>switch<condition>(<expr><name><name>exp</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>AR_EXP_CONSTANT</name></expr>:</case>
		<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AR_EXP_CONSTANT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>constant</name></name> <operator>=</operator> <call><name>SI_ShallowCloneValue</name><argument_list>(<argument><expr><name><name>exp</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>constant</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>AR_EXP_VARIADIC</name></expr>:</case>
		<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>exp</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>variadic</name><operator>.</operator><name>entity_alias</name></name> <operator>=</operator> <name><name>exp</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>variadic</name><operator>.</operator><name>entity_alias</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>variadic</name><operator>.</operator><name>entity_alias_idx</name></name> <operator>=</operator> <name><name>exp</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>variadic</name><operator>.</operator><name>entity_alias_idx</name></name></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>AR_EXP_PARAM</name></expr>:</case>
		<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AR_EXP_PARAM</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>param_name</name></name> <operator>=</operator> <name><name>exp</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>param_name</name></name></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>AR_EXP_BORROW_RECORD</name></expr>:</case>
		<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AR_EXP_BORROW_RECORD</name></expr>;</expr_stmt>
		<break>break;</break>
	<default>default:</default>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>clone</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_EXP_NewOpNode</name><parameter_list>(<parameter><decl><type><name>uint</name></type> <name>child_count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>rm_calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AR_ExpNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name>            <operator>=</operator>  <name>AR_EXP_OP</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name></name>     <operator>=</operator>  <call><name>rm_malloc</name><argument_list>(<argument><expr><name>child_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AR_ExpNode</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>child_count</name></name>  <operator>=</operator>  <name>child_count</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_EXP_CloneOp</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>exp</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func_name</name> <init>= <expr><name><name>exp</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>include_internal</name> <init>= <expr><name><name>exp</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>internal</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>child_count</name> <init>= <expr><name><name>exp</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>child_count</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>clone</name> <init>= <expr><call><name>AR_EXP_NewOpNode</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><name>include_internal</name></expr></argument>, <argument><expr><name>child_count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AR_Func_Clone</name></type> <name>clone_cb</name> <init>= <expr><name><name>clone</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>callbacks</name><operator>.</operator><name>clone</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pdata</name> <init>= <expr><name><name>exp</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>private_data</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>clone_cb</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// clone callback specified, use it to duplicate function's private data</comment>
		<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>private_data</name></name> <operator>=</operator> <call><name>clone_cb</name><argument_list>(<argument><expr><name><name>exp</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>private_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// clone child nodes</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>exp</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>child_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>AR_EXP_Clone</name><argument_list>(<argument><expr><name><name>exp</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>clone</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_AR_EXP_ValidateArgsCount</name>
<parameter_list>(
	<parameter><decl><type><name>AR_FuncDesc</name> <modifier>*</modifier></type><name>fdesc</name></decl></parameter>,
	<parameter><decl><type><name>uint</name></type> <name>argc</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// Make sure number of arguments is as expected.</comment>
	<if_stmt><if>if<condition>(<expr><name><name>fdesc</name><operator>-&gt;</operator><name>min_argc</name></name> <operator>&gt;</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Set the query-level error.</comment>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Received %d arguments to function '%s', expected at least %d"</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>,
						  <argument><expr><name><name>fdesc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>fdesc</name><operator>-&gt;</operator><name>min_argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name><name>fdesc</name><operator>-&gt;</operator><name>max_argc</name></name> <operator>&lt;</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Set the query-level error.</comment>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Received %d arguments to function '%s', expected at most %d"</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>,
						  <argument><expr><name><name>fdesc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>fdesc</name><operator>-&gt;</operator><name>max_argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>AR_EXP_NewOpNode</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func_name</name></decl></parameter>,
	<parameter><decl><type><name>bool</name></type> <name>include_internal</name></decl></parameter>,
	<parameter><decl><type><name>uint</name></type> <name>child_count</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// retrieve function</comment>
	<decl_stmt><decl><type><name>AR_FuncDesc</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><call><name>AR_GetFunc</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><name>include_internal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>_AR_EXP_NewOpNode</name><argument_list>(<argument><expr><name>child_count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>func</name><operator>-&gt;</operator><name>internal</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>_AR_EXP_ValidateArgsCount</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>child_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>func</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>f</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>

	<comment type="line">// add aggregation context as function private data</comment>
	<if_stmt><if>if<condition>(<expr><name><name>func</name><operator>-&gt;</operator><name>aggregate</name></name></expr>)</condition> <block>{<block_content>
		<comment type="line">// generate aggregation context and store it in node's private data</comment>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>callbacks</name><operator>.</operator><name>private_data</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>private_data</name></name> <operator>=</operator> <call><name><name>func</name><operator>-&gt;</operator><name>callbacks</name><operator>.</operator><name>private_data</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>_AR_EXP_InitializeOperand</name><parameter_list>(<parameter><decl><type><name>AR_OperandNodeType</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>rm_calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AR_ExpNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AR_EXP_OPERAND</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>AR_EXP_NewVariableOperandNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>_AR_EXP_InitializeOperand</name><argument_list>(<argument><expr><name>AR_EXP_VARIADIC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>variadic</name><operator>.</operator><name>entity_alias</name></name> <operator>=</operator> <name>alias</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>variadic</name><operator>.</operator><name>entity_alias_idx</name></name> <operator>=</operator> <name>IDENTIFIER_NOT_FOUND</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>AR_EXP_NewAttributeAccessNode</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>entity</name></decl></parameter>,
										  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attr</name></decl></parameter>)</parameter_list> <block>{<block_content>

	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>attr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>entity</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// use property index when possible, prop_idx is set to ATTRIBUTE_NOTFOUND</comment>
	<comment type="line">// if the graph is not aware of it in which case we'll try to resolve</comment>
	<comment type="line">// the property using its string representation</comment>

	<decl_stmt><decl><type><name>GraphContext</name> <modifier>*</modifier></type><name>gc</name> <init>= <expr><call><name>QueryCtx_GetGraphCtx</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>prop_idx</name> <init>= <expr><call><name>SI_LongVal</name><argument_list>(<argument><expr><name>ATTRIBUTE_ID_NONE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>prop_name</name> <init>= <expr><call><name>SI_ConstStringVal</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>attr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Attribute_ID</name></type> <name>idx</name> <init>= <expr><call><name>GraphContext_GetAttributeID</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>idx</name> <operator>!=</operator> <name>ATTRIBUTE_ID_NONE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>prop_idx</name> <operator>=</operator> <call><name>SI_LongVal</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// entity is an expression which should be evaluated to a graph entity</comment>
	<comment type="line">// attr is the name of the attribute we want to extract from entity</comment>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><call><name>AR_EXP_NewOpNode</name><argument_list>(<argument><expr><literal type="string">"property"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>entity</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><name>prop_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>AR_EXP_NewConstOperandNode</name><argument_list>(<argument><expr><name>prop_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>root</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>AR_EXP_NewConstOperandNode</name><parameter_list>(<parameter><decl><type><name>SIValue</name></type> <name>constant</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>_AR_EXP_InitializeOperand</name><argument_list>(<argument><expr><name>AR_EXP_CONSTANT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>constant</name></name> <operator>=</operator> <name>constant</name></expr>;</expr_stmt>
	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>AR_EXP_NewParameterOperandNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>param_name</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>_AR_EXP_InitializeOperand</name><argument_list>(<argument><expr><name>AR_EXP_PARAM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>param_name</name></name> <operator>=</operator> <name>param_name</name></expr>;</expr_stmt>
	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>AR_EXP_NewRecordNode</name><parameter_list>()</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>_AR_EXP_InitializeOperand</name><argument_list>(<argument><expr><name>AR_EXP_BORROW_RECORD</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>AR_SetPrivateData</name>
<parameter_list>(
	<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pdata</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// validations</comment>
	<comment type="line">// node must be an operation</comment>
	<comment type="line">// operation private data must be NULL</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AR_EXP_OP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>private_data</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>private_data</name></name> <operator>=</operator> <name>pdata</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Compact tree by evaluating constant expressions
 * e.g. MINUS(X) where X is a constant number will be reduced to
 * a single node with the value -X
 * PLUS(MINUS(A), B) will be reduced to a single constant: B-A. */</comment>
<function><type><name>bool</name></type> <name>AR_EXP_ReduceToScalar</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>reduce_params</name></decl></parameter>, <parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>val</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AR_EXP_OPERAND</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// In runtime, parameters are set so they can be evaluated</comment>
		<if_stmt><if>if<condition>(<expr><name>reduce_params</name> <operator>&amp;&amp;</operator> <call><name>AR_EXP_IsParameter</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>SIValue</name></type> <name>v</name> <init>= <expr><call><name>AR_EXP_Evaluate</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><name>val</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>AR_EXP_IsConstant</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<comment type="line">// Root is already a constant</comment>
			<if_stmt><if>if<condition>(<expr><name>val</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>constant</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="line">// Root is variadic, no way to reduce.</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="line">// root represents an operation.</comment>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>AR_EXP_IsOperation</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* See if we're able to reduce each child of root
		 * if so we'll be able to reduce root. */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>reduce_children</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>child_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>AR_EXP_ReduceToScalar</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>reduce_params</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<comment type="line">// Root reduce is not possible, but continue to reduce every reducable child.</comment>
				<expr_stmt><expr><name>reduce_children</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<comment type="line">// Can't reduce root as one of its children is not a constant.</comment>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><name>reduce_children</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="line">// All child nodes are constants, make sure function is marked as reducible.</comment>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>reducible</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="line">// Evaluate function.</comment>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>v</name> <init>= <expr><call><name>AR_EXP_Evaluate</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>val</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="line">// Reduce.</comment>
		<comment type="line">// Clear children and function context.</comment>
		<expr_stmt><expr><call><name>_AR_EXP_FreeOpInternals</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// In-place update, set as constant.</comment>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AR_EXP_OPERAND</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AR_EXP_CONSTANT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>constant</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_AR_EXP_OpResolveVariables</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Record</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AR_EXP_OP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>child_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_AR_EXP_ResolveVariables</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_AR_EXP_OperandResolveVariables</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Record</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AR_EXP_OPERAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// return if this is not a variadic node</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>AR_EXP_IsVariadic</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<comment type="line">// see if record contains a value for this variadic</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>variadic</name><operator>.</operator><name>entity_alias</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>idx</name> <init>= <expr><call><name>Record_GetEntryIdx</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>idx</name> <operator>!=</operator> <name>INVALID_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>Record_ContainsEntry</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<comment type="line">// replace variadic with constant</comment>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>v</name> <init>= <expr><call><name>SI_CloneValue</name><argument_list>(<argument><expr><call><name>Record_Get</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_AR_EXP_InplaceRepurposeConstant</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_AR_EXP_ResolveVariables</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Record</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>r</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>root</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<switch>switch<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>AR_EXP_OP</name></expr>:</case>
			<expr_stmt><expr><call><name>_AR_EXP_OpResolveVariables</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AR_EXP_OPERAND</name></expr>:</case>
			<expr_stmt><expr><call><name>_AR_EXP_OperandResolveVariables</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name> <operator>&amp;&amp;</operator> <literal type="string">"unknown arithmetic expression node type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>AR_EXP_ResolveVariables</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Record</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>_AR_EXP_ResolveVariables</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_EXP_ReduceToScalar</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>_AR_EXP_ValidateInvocation</name>
<parameter_list>(
	<parameter><decl><type><name>AR_FuncDesc</name> <modifier>*</modifier></type><name>fdesc</name></decl></parameter>,
	<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>,
	<parameter><decl><type><name>uint</name></type> <name>argc</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIType</name></type> <name>actual_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIType</name></type> <name>expected_type</name> <init>= <expr><name>T_NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>expected_types_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name><name>fdesc</name><operator>-&gt;</operator><name>types</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>actual_type</name> <operator>=</operator> <call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* For a function that accepts a variable number of arguments.
		* the last specified type in fdesc-&gt;types is repeatable. */</comment>
		<if_stmt><if>if<condition>(<expr><name>i</name> <operator>&lt;</operator> <name>expected_types_count</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>expected_type</name> <operator>=</operator> <name><name>fdesc</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><name>actual_type</name> <operator>&amp;</operator> <name>expected_type</name><operator>)</operator></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>Error_SITypeMismatch</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>expected_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Evaluating an expression tree constructs an array of SIValues.
 * Free all of these values, in case an intermediate node on the tree caused a heap allocation.
 * For example, in the expression:
 * a.first_name + toUpper(a.last_name)
 * the result of toUpper() is allocated within this tree, and will leak if not freed here. */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>_AR_EXP_FreeResultsArray</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>results</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>SIValue_Free</name><argument_list>(<argument><expr><name><name>results</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="line">// Large arrays are heap-allocated, so here is where we free it.</comment>
	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <name>MAX_ARRAY_SIZE_ON_STACK</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_EXP_Result</name></type> <name>_AR_EXP_EvaluateFunctionCall</name>
<parameter_list>(
	<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>Record</name></type> <name>r</name></decl></parameter>,
	<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>result</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AR_EXP_Result</name></type> <name>res</name> <init>= <expr><name>EVAL_OK</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>child_count</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>child_count</name></name></expr></init></decl>;</decl_stmt>

	<comment type="line">// evaluate each child before evaluating current node</comment>
	<decl_stmt><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>sub_trees</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<comment type="line">// if array size is above the threshold, we allocate it on the heap (otherwise on stack)</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>array_on_stack_size</name> <init>= <expr><ternary><condition><expr><name>child_count</name> <operator>&gt;</operator> <name>MAX_ARRAY_SIZE_ON_STACK</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>child_count</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name><name>sub_trees_on_stack</name><index>[<expr><name>array_on_stack_size</name></expr>]</index></name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>child_count</name> <operator>&gt;</operator> <name>MAX_ARRAY_SIZE_ON_STACK</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>sub_trees</name> <operator>=</operator> <call><name>rm_malloc</name><argument_list>(<argument><expr><name>child_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SIValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>sub_trees</name> <operator>=</operator> <name>sub_trees_on_stack</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>param_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>child_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>child_idx</name> <operator>&lt;</operator> <call><name>NODE_CHILD_COUNT</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>child_idx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>v</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>NODE_CHILD</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>child_idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_AR_EXP_Evaluate</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><name>res</name> <operator>==</operator> <name>EVAL_ERR</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// encountered an error while evaluating a subtree</comment>
			<comment type="line">// free all values generated up to this point</comment>
			<comment type="line">// and propagate the error upwards</comment>
			<expr_stmt><expr><call><name>_AR_EXP_FreeResultsArray</name><argument_list>(<argument><expr><name>sub_trees</name></expr></argument>, <argument><expr><name>child_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>res</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>param_found</name> <operator>|=</operator> <operator>(</operator><name>res</name> <operator>==</operator> <name>EVAL_FOUND_PARAM</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sub_trees</name><index>[<expr><name>child_idx</name></expr>]</index></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if<condition>(<expr><name>param_found</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>res</name> <operator>=</operator> <name>EVAL_FOUND_PARAM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// validate before evaluation</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>_AR_EXP_ValidateInvocation</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name>sub_trees</name></expr></argument>, <argument><expr><name>child_count</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="line">// the expression tree failed its validations and set an error message</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>EVAL_ERR</name></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// evaluate self</comment>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>v</name> <init>= <expr><call><name><name>node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>func</name></name><argument_list>(<argument><expr><name>sub_trees</name></expr></argument>, <argument><expr><name>child_count</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>private_data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>aggregate</name></name> <operator>||</operator> <call><name>SI_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <call><name>AR_FuncDesc_RetType</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ErrorCtx_EncounteredError</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="line">// an error was encountered while evaluating this function,</comment>
		<comment type="line">// and has already been set in the QueryCtx</comment>
		<comment type="line">// exit with an error</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>EVAL_ERR</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name>result</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>SIValue_Persist</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>_AR_EXP_FreeResultsArray</name><argument_list>(<argument><expr><name>sub_trees</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>child_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>_AR_EXP_UpdateEntityIdx</name><parameter_list>(<parameter><decl><type><name>AR_OperandNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Record</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>r</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Set the query-level error.</comment>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"_AR_EXP_UpdateEntityIdx: No record was given to locate a value with alias %s"</literal></expr></argument>,
						  <argument><expr><name><name>node</name><operator>-&gt;</operator><name>variadic</name><operator>.</operator><name>entity_alias</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>entry_alias_idx</name> <init>= <expr><call><name>Record_GetEntryIdx</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>variadic</name><operator>.</operator><name>entity_alias</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>entry_alias_idx</name> <operator>==</operator> <name>INVALID_INDEX</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Set the query-level error.</comment>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"_AR_EXP_UpdateEntityIdx: Unable to locate a value with alias %s within the record"</literal></expr></argument>,
						  <argument><expr><name><name>node</name><operator>-&gt;</operator><name>variadic</name><operator>.</operator><name>entity_alias</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>variadic</name><operator>.</operator><name>entity_alias_idx</name></name> <operator>=</operator> <name>entry_alias_idx</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_EXP_Result</name></type> <name>_AR_EXP_EvaluateVariadic</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Record</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// Make sure entity record index is known.</comment>
	<if_stmt><if>if<condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>variadic</name><operator>.</operator><name>entity_alias_idx</name></name> <operator>==</operator> <name>IDENTIFIER_NOT_FOUND</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>_AR_EXP_UpdateEntityIdx</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>operand</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>EVAL_ERR</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>aliasIdx</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>variadic</name><operator>.</operator><name>entity_alias_idx</name></name></expr></init></decl>;</decl_stmt>

	<comment type="line">// the value was not created here; share with the caller</comment>
	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>SI_ShareValue</name><argument_list>(<argument><expr><call><name>Record_Get</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>aliasIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>EVAL_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AR_EXP_Result</name></type> <name>_AR_EXP_EvaluateParam</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>params</name> <init>= <expr><call><name>QueryCtx_GetParams</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>param_node</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>params</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>param_node</name> <operator>=</operator> <call><name>raxFind</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>param_name</name></name></expr></argument>,
										<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>param_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name>params</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>param_node</name> <operator>==</operator> <name>raxNotFound</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Set the query-level error.</comment>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Missing parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>EVAL_ERR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="line">// In place replacement;</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AR_EXP_CONSTANT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>constant</name></name> <operator>=</operator> <call><name>SI_ShareValue</name><argument_list>(<argument><expr><name><name>param_node</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>constant</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>constant</name></name></expr>;</expr_stmt>
	<return>return <expr><name>EVAL_FOUND_PARAM</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>AR_EXP_Result</name></type> <name>_AR_EXP_EvaluateBorrowRecord</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Record</name></type> <name>r</name></decl></parameter>,
														 <parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// Wrap the current Record in an SI pointer.</comment>
	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>SI_PtrVal</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>EVAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Evaluate an expression tree,
 * placing the calculated value in 'result'
 * and returning whether an error occurred during evaluation. */</comment>
<function><type><specifier>static</specifier> <name>AR_EXP_Result</name></type> <name>_AR_EXP_Evaluate</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Record</name></type> <name>r</name></decl></parameter>,
									  <parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AR_EXP_Result</name></type> <name>res</name> <init>= <expr><name>EVAL_OK</name></expr></init></decl>;</decl_stmt>
	<switch>switch<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>AR_EXP_OP</name></expr>:</case>
		<return>return <expr><call><name>_AR_EXP_EvaluateFunctionCall</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
	<case>case <expr><name>AR_EXP_OPERAND</name></expr>:</case>
		<switch>switch<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>AR_EXP_CONSTANT</name></expr>:</case>
			<comment type="line">// The value is constant or has been computed elsewhere, and is shared with the caller.</comment>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>SI_ShareValue</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>constant</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>res</name></expr>;</return>
		<case>case <expr><name>AR_EXP_VARIADIC</name></expr>:</case>
			<return>return <expr><call><name>_AR_EXP_EvaluateVariadic</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>AR_EXP_PARAM</name></expr>:</case>
			<return>return <expr><call><name>_AR_EXP_EvaluateParam</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>AR_EXP_BORROW_RECORD</name></expr>:</case>
			<return>return <expr><call><name>_AR_EXP_EvaluateBorrowRecord</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name> <operator>&amp;&amp;</operator> <literal type="string">"Invalid expression type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	<default>default:</default>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name> <operator>&amp;&amp;</operator> <literal type="string">"Unknown expression type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>AR_EXP_Evaluate</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Record</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AR_EXP_Result</name></type> <name>res</name> <init>= <expr><call><name>_AR_EXP_Evaluate</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>res</name> <operator>==</operator> <name>EVAL_ERR</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_RaiseRuntimeException</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// Raise an exception if we're in a run-time context.</comment>
		<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return> <comment type="line">// Otherwise return NULL; the query-level error will be emitted after cleanup.</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// At least one param node was encountered during evaluation,</comment>
	<comment type="line">// tree should be parameters free, try reducing the tree.</comment>
	<if_stmt><if>if<condition>(<expr><name>res</name> <operator>==</operator> <name>EVAL_FOUND_PARAM</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>AR_EXP_ReduceToScalar</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>AR_EXP_Aggregate</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Record</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>AGGREGATION_NODE</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>AR_EXP_Result</name></type> <name>res</name> <init>= <expr><call><name>_AR_EXP_EvaluateFunctionCall</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>res</name> <operator>==</operator> <name>EVAL_ERR</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ErrorCtx_RaiseRuntimeException</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// Raise an exception if we're in a run-time context.</comment>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><call><name>AR_EXP_IsOperation</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="line">// keep searching for aggregation nodes</comment>
		<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>child_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>AR_EXP_Aggregate</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_AR_EXP_FinalizeAggregations</name>
<parameter_list>(
	<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">//--------------------------------------------------------------------------</comment>
	<comment type="line">// finalize aggregation node</comment>
	<comment type="line">//--------------------------------------------------------------------------</comment>

	<if_stmt><if>if<condition>(<expr><call><name>AGGREGATION_NODE</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>AggregateCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>private_data</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Aggregate_Finalize</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>v</name> <init>= <expr><call><name>Aggregate_GetResult</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <call><name>AR_FuncDesc_RetType</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// free node internals</comment>
		<expr_stmt><expr><call><name>_AR_EXP_FreeOpInternals</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// replace root with constant node</comment>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>type</name></name>             <operator>=</operator> <name>AR_EXP_OPERAND</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>type</name></name>     <operator>=</operator> <name>AR_EXP_CONSTANT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>constant</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

		<comment type="line">// return, aggregation nodes cannot contain nested aggregation nodes</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">//--------------------------------------------------------------------------</comment>
	<comment type="line">// recursively traverse child nodes</comment>
	<comment type="line">//--------------------------------------------------------------------------</comment>

	<if_stmt><if>if<condition>(<expr><call><name>AR_EXP_IsOperation</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>NODE_CHILD_COUNT</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>NODE_CHILD</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>_AR_EXP_FinalizeAggregations</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>AR_EXP_FinalizeAggregations</name>
<parameter_list>(
	<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>Record</name></type> <name>r</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>root</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_AR_EXP_FinalizeAggregations</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>AR_EXP_Evaluate</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>AR_EXP_CollectEntities</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>aliases</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>AR_EXP_IsOperation</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>child_count</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>AR_EXP_CollectEntities</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if> <else>else <block>{<block_content> <comment type="line">// type == AR_EXP_OPERAND</comment>
		<if_stmt><if>if<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AR_EXP_VARIADIC</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>entity</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>variadic</name><operator>.</operator><name>entity_alias</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name>aliases</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>entity</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>entity</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>AR_EXP_CollectAttributes</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>attributes</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>AR_EXP_IsOperation</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>AR_EXP_GetFuncName</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"property"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>AR_EXP_IsConstant</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>constant</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attr</name> <init>= <expr><name><name>arg</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>constant</name><operator>.</operator><name>stringval</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name>attributes</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>attr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// continue scanning expression</comment>
		<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>child_count</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>AR_EXP_CollectAttributes</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>attributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>AR_EXP_ContainsAggregation</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>AGGREGATION_NODE</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>AR_EXP_IsOperation</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>child_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><call><name>AR_EXP_ContainsAggregation</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>AR_EXP_ContainsFunc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>root</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>AR_EXP_IsOperation</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if<condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><call><name>AR_EXP_GetFuncName</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>child_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if<condition>(<expr><call><name>AR_EXP_ContainsFunc</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>AR_EXP_ContainsVariadic</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>root</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>AR_EXP_IsOperation</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>child_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if<condition>(<expr><call><name>AR_EXP_ContainsVariadic</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><call><name>AR_EXP_IsVariadic</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// return type of expression</comment>
<comment type="line">// e.g. the expression: `1+3` return type is SI_NUMERIC</comment>
<comment type="line">// e.g. the expression : `ToString(4+3)` return type is T_STRING</comment>
<function><type><name>SIType</name></type> <name>AR_EXP_ReturnType</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>exp</name></decl></parameter>  <comment type="line">// expression to query</comment>
)</parameter_list>
<block>{<block_content>
	<comment type="line">// validation</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>exp</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>exp</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AR_EXP_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SIType</name></type> <name>t</name> <init>= <expr><name>T_NULL</name></expr></init></decl>;</decl_stmt> <comment type="line">// returned type</comment>

	<if_stmt><if>if<condition>(<expr><name><name>exp</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AR_EXP_OP</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// expression is a function call</comment>
		<comment type="line">// get function return type</comment>
		<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>AR_FuncDesc_RetType</name><argument_list>(<argument><expr><name><name>exp</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="line">// expression is an operand</comment>
		<if_stmt><if>if <condition>(<expr><name><name>exp</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AR_EXP_CONSTANT</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>exp</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>constant</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>AR_EXP_ReturnsBoolean</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>exp</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>exp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>exp</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AR_EXP_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SIType</name></type> <name>t</name> <init>= <expr><call><name>AR_EXP_ReturnType</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// return true if `t` is either Boolean or NULL</comment>
	<comment type="line">// in case `exp` is a variable or parameter</comment>
	<comment type="line">// whether it evaluates to boolean cannot be determined at this point</comment>
	<return>return <expr><name>t</name> <operator>&amp;</operator> <name>T_BOOL</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>T_NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_AR_EXP_ToString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>str_size</name></decl></parameter>,
					  <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>bytes_written</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/* Make sure there are at least 64 bytes in str. */</comment>
	<if_stmt><if>if<condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>bytes_written</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>str_size</name> <operator>=</operator> <literal type="number">128</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <call><name>rm_calloc</name><argument_list>(<argument><expr><operator>*</operator><name>str_size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><operator>(</operator><operator>*</operator><name>str_size</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>str_size</name> <operator>+=</operator> <literal type="number">128</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <call><name>rm_realloc</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>*</operator><name>str_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Concat Op. */</comment>
	<if_stmt><if>if<condition>(<expr><call><name>AR_EXP_IsOperation</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Binary operation? */</comment>
		<decl_stmt><decl><type><name>char</name></type> <name>binary_op</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func_name</name> <init>= <expr><call><name>AR_EXP_GetFuncName</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><literal type="string">"ADD"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>binary_op</name> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><literal type="string">"SUB"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>binary_op</name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><literal type="string">"MUL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>binary_op</name> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><literal type="string">"DIV"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <expr_stmt><expr><name>binary_op</name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if<condition>(<expr><name>binary_op</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>_AR_EXP_ToString</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>str_size</name></expr></argument>, <argument><expr><name>bytes_written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Make sure there are at least 64 bytes in str. */</comment>
			<if_stmt><if>if<condition>(<expr><operator>(</operator><operator>*</operator><name>str_size</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>str_size</name> <operator>+=</operator> <literal type="number">128</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <call><name>rm_realloc</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>*</operator><name>str_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><operator>*</operator><name>bytes_written</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>str</name> <operator>+</operator> <operator>*</operator><name>bytes_written</name><operator>)</operator></expr></argument>, <argument><expr><literal type="string">" %c "</literal></expr></argument>, <argument><expr><name>binary_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>_AR_EXP_ToString</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>str_size</name></expr></argument>, <argument><expr><name>bytes_written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="block">/* Operation isn't necessarily a binary operation, use function call representation. */</comment>
			<expr_stmt><expr><operator>*</operator><name>bytes_written</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>str</name> <operator>+</operator> <operator>*</operator><name>bytes_written</name><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>, <argument><expr><call><name>AR_EXP_GetFuncName</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>child_count</name></name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<expr_stmt><expr><call><name>_AR_EXP_ToString</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>str_size</name></expr></argument>, <argument><expr><name>bytes_written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Make sure there are at least 64 bytes in str. */</comment>
				<if_stmt><if>if<condition>(<expr><operator>(</operator><operator>*</operator><name>str_size</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>str_size</name> <operator>+=</operator> <literal type="number">128</literal></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <call><name>rm_realloc</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>*</operator><name>str_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if<condition>(<expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>child_count</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>bytes_written</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>str</name> <operator>+</operator> <operator>*</operator><name>bytes_written</name><operator>)</operator></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><operator>*</operator><name>bytes_written</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>str</name> <operator>+</operator> <operator>*</operator><name>bytes_written</name><operator>)</operator></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="line">// Concat Operand node.</comment>
		<if_stmt><if>if<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AR_EXP_CONSTANT</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>SIValue_ToString</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>constant</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>str_size</name></expr></argument>, <argument><expr><name>bytes_written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>bytes_written</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>str</name> <operator>+</operator> <operator>*</operator><name>bytes_written</name><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>variadic</name><operator>.</operator><name>entity_alias</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>AR_EXP_ToString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>str_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>bytes_written</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_AR_EXP_ToString</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>AR_EXP_GetFuncName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AR_ExpNode</name> <modifier>*</modifier></type><name>exp</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>exp</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>exp</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AR_EXP_OP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>exp</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>name</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>AR_EXP_Clone</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>exp</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>exp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>clone</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<switch>switch<condition>(<expr><name><name>exp</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>AR_EXP_OPERAND</name></expr>:</case>
		<expr_stmt><expr><name>clone</name> <operator>=</operator> <call><name>_AR_EXP_CloneOperand</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>AR_EXP_OP</name></expr>:</case>
		<expr_stmt><expr><name>clone</name> <operator>=</operator> <call><name>_AR_EXP_CloneOp</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<default>default:</default>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>resolved_name</name></name> <operator>=</operator> <name><name>exp</name><operator>-&gt;</operator><name>resolved_name</name></name></expr>;</expr_stmt>

	<return>return <expr><name>clone</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>_AR_EXP_FreeOpInternals</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>op_node</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>AGGREGATION_NODE</name><argument_list>(<argument><expr><name>op_node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>AR_FuncDesc</name> <modifier>*</modifier></type><name>agg_func</name> <init>= <expr><name><name>op_node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>f</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>AggregateCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>op_node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>private_data</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>ctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Aggregate_Free</name><argument_list>(<argument><expr><name>agg_func</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name><name>op_node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>callbacks</name><operator>.</operator><name>free</name></name> <operator>&amp;&amp;</operator> <name><name>op_node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>private_data</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name><name>op_node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>callbacks</name><operator>.</operator><name>free</name></name><argument_list>(<argument><expr><name><name>op_node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>private_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for<control>(<init><decl><type><name>int</name></type> <name>child_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>child_idx</name> <operator>&lt;</operator> <name><name>op_node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>child_count</name></name></expr>;</condition> <incr><expr><name>child_idx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>AR_EXP_Free</name><argument_list>(<argument><expr><name><name>op_node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name><index>[<expr><name>child_idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name><name>op_node</name><operator>-&gt;</operator><name>op</name><operator>.</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>void</name></type> <name>AR_EXP_Free</name><parameter_list>(<parameter><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>AR_EXP_IsOperation</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_AR_EXP_FreeOpInternals</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><call><name>AR_EXP_IsConstant</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>SIValue_Free</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>operand</name><operator>.</operator><name>constant</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

</unit>
