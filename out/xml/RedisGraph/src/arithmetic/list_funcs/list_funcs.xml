<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/src/arithmetic/list_funcs/list_funcs.c"><comment type="block">/*
 * Copyright Redis Ltd. 2018 - present
 * Licensed under your choice of the Redis Source Available License 2.0 (RSALv2) or
 * the Server Side Public License v1 (SSPLv1).
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"list_funcs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"RG.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../func_desc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../errors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../util/arr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive><cpp:file>"../../query_ctx.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../datatypes/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../util/rax_extensions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../string_funcs/string_funcs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../boolean_funcs/boolean_funcs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../numeric_funcs/numeric_funcs.h"</cpp:file></cpp:include>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// reduce context</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// routine for freeing a reduction function private data</comment>
<function><type><name>void</name></type> <name>ListReduceCtx_Free</name>
<parameter_list>(
	<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx_ptr</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>ListReduceCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name>ctx_ptr</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>exp</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>AR_EXP_Free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>exp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>record</name></name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>mapping</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>record</name><operator>-&gt;</operator><name>mapping</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Record_Free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>record</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>mapping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Routine for cloning a comprehension function's private data.</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>ListReduceCtx_Clone</name>
<parameter_list>(
	<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>orig</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>ListReduceCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name>orig</name></expr></init></decl>;</decl_stmt>
	<comment type="line">// allocate space for the clone</comment>
	<decl_stmt><decl><type><name>ListReduceCtx</name> <modifier>*</modifier></type><name>clone</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ListReduceCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// clone the variadic node</comment>
	<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>record</name></name>           <operator>=</operator>  <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>variable_idx</name></name>     <operator>=</operator>  <name><name>ctx</name><operator>-&gt;</operator><name>variable_idx</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>variable</name></name>         <operator>=</operator>  <name><name>ctx</name><operator>-&gt;</operator><name>variable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>accumulator_idx</name></name>  <operator>=</operator>  <name><name>ctx</name><operator>-&gt;</operator><name>accumulator_idx</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>accumulator</name></name>      <operator>=</operator>  <name><name>ctx</name><operator>-&gt;</operator><name>accumulator</name></name></expr>;</expr_stmt>

	<comment type="line">// clone the eval routine</comment>
	<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>exp</name></name> <operator>=</operator> <call><name>AR_EXP_Clone</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>exp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>clone</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_PopulateReduceCtx</name>
<parameter_list>(
	<parameter><decl><type><name>ListReduceCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
	<parameter><decl><type><name>Record</name></type> <name>outer_record</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>record_map</name> <init>= <expr><call><name>raxClone</name><argument_list>(<argument><expr><name><name>outer_record</name><operator>-&gt;</operator><name>mapping</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">//--------------------------------------------------------------------------</comment>
	<comment type="line">// map variable name</comment>
	<comment type="line">//--------------------------------------------------------------------------</comment>

	<decl_stmt><decl><type><name>intptr_t</name></type> <name>id</name> <init>= <expr><call><name>raxSize</name><argument_list>(<argument><expr><name>record_map</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>raxTryInsert</name><argument_list>(<argument><expr><name>record_map</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>,
				 <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">//--------------------------------------------------------------------------</comment>
	<comment type="line">// map accumulator name</comment>
	<comment type="line">//--------------------------------------------------------------------------</comment>

	<expr_stmt><expr><name>id</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>raxTryInsert</name><argument_list>(<argument><expr><name>record_map</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>accumulator</name></name></expr></argument>,
				 <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>accumulator</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>record</name></name> <operator>=</operator> <call><name>Record_New</name><argument_list>(<argument><expr><name>record_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// this could just be assigned to 'id'</comment>
	<comment type="line">// but for safety we'll use a Record lookup</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>variable_idx</name></name> <operator>=</operator> <call><name>Record_GetEntryIdx</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>record</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>accumulator_idx</name></name> <operator>=</operator> <call><name>Record_GetEntryIdx</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>record</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>accumulator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>variable_idx</name></name> <operator>!=</operator> <name>INVALID_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>accumulator_idx</name></name> <operator>!=</operator> <name>INVALID_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Forward declaration of property function.</comment>
<function_decl><type><name>SIValue</name></type> <name>AR_PROPERTY</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Create a list from a given squence of values.
   "RETURN [1, '2', True, null]" */</comment>
<function><type><name>SIValue</name></type> <name>AR_TOLIST</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>array</name> <init>= <expr><call><name>SI_Array</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>SIArray_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>array</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>array</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Convert a list of values to a list of new type values.
   Uses the function *converter_ptr to convert each value in input list
*/</comment>
<function><type><specifier>static</specifier> <name>SIValue</name></type> <name>_AR_TOTYPELIST</name>
<parameter_list>(
    <parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>list</name></decl></parameter>,                    				<comment type="line">// list of elements to convert</comment>
    <parameter><function_decl><type><name>SIValue</name></type> (<modifier>*</modifier><name>converter_ptr</name>)<parameter_list>(<parameter><decl><type><name>SIValue</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter> 	<comment type="line">// convert function e.g. AR_TOFLOAT</comment>
)</parameter_list> <block>{<block_content>
	<comment type="line">// get array length</comment>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>arrayLen</name> <init>= <expr><call><name>SIArray_Length</name><argument_list>(<argument><expr><operator>*</operator><name>list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SIValue</name></type> <name>array</name> <init>= <expr><call><name>SI_Array</name><argument_list>(<argument><expr><name>arrayLen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arrayLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>v</name> <init>= <expr><call><name>SIArray_Get</name><argument_list>(<argument><expr><operator>*</operator><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SIArray_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>array</name></expr></argument>, <argument><expr><call><name>converter_ptr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SIValue_Free</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>array</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Convert a list of values to a list of boolean values.
   The conversion of each item in list is done using toBooleanOrNull */</comment>
<function><type><name>SIValue</name></type> <name>AR_TOBOOLEANLIST</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>originalArray</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>_AR_TOTYPELIST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>originalArray</name></expr></argument>, <argument><expr><name>AR_TO_BOOLEAN</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Convert a list of values to a list of float values.
   The conversion of each item in list is done using toFloatOrNull */</comment>
<function><type><name>SIValue</name></type> <name>AR_TOFLOATLIST</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>originalArray</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>_AR_TOTYPELIST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>originalArray</name></expr></argument>, <argument><expr><name>AR_TOFLOAT</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Convert a list of values to a list of integer values.
   The conversion of each item in list is done using toIntegerOrNull */</comment>
<function><type><name>SIValue</name></type> <name>AR_TOINTEGERLIST</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>originalArray</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>_AR_TOTYPELIST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>originalArray</name></expr></argument>, <argument><expr><name>AR_TOINTEGER</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Convert a list of values to a list of string values.
   The conversion of each item in list is done using toStringOrNull */</comment>
<function><type><name>SIValue</name></type> <name>AR_TOSTRINGLIST</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>originalArray</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="line">// get array length</comment>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>arrayLen</name> <init>= <expr><call><name>SIArray_Length</name><argument_list>(<argument><expr><name>originalArray</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SIValue</name></type> <name>array</name> <init>= <expr><call><name>SI_Array</name><argument_list>(<argument><expr><name>arrayLen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arrayLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>v</name> <init>= <expr><call><name>SIArray_Get</name><argument_list>(<argument><expr><name>originalArray</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>vstr</name> <init>= <expr><call><name>AR_TOSTRING</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SIArray_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>array</name></expr></argument>, <argument><expr><name>vstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SIValue_Free</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SIValue_Free</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>array</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* If given an array, returns a value in a specific index in an array.
   Valid index range is [-arrayLen, arrayLen).
   Invalid index will return null.
   "RETURN [1, 2, 3][0]" will yield 1.

   If given a map or graph entity, returns the property value associated
   with the given key string. */</comment>
<function><type><name>SIValue</name></type> <name>AR_SUBSCRIPT</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NULL</name> <operator>||</operator> <call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name>T_MAP</name> <operator>|</operator> <name>SI_GRAPHENTITY</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>T_STRING</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>Error_SITypeMismatch</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* If the first argument is a map or graph entity, this is a property lookup of a form like:
		 * WITH {val: 5} AS a return a['val']
		 * MATCH (a) RETURN a['val']
		 * Pass the arguments to the AR_PROPERTY function. */</comment>
		<decl_stmt><decl><type><name>SIValue</name></type> <name><name>property_args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>, <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>, <macro><name>SI_LongVal</name><argument_list>(<argument>ATTRIBUTE_ID_NONE</argument>)</argument_list></macro>}</block></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>AR_PROPERTY</name><argument_list>(<argument><expr><name>property_args</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_STRING</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// String indexes are only permitted on maps, not arrays.</comment>
		<expr_stmt><expr><call><name>Error_SITypeMismatch</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>T_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>SIValue</name></type> <name>list</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32_t</name></type> <name>index</name> <init>= <expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>longval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>arrayLen</name> <init>= <expr><call><name>SIArray_Length</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// given a negativ index, the accses is calculated as arrayLen+index</comment>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>absIndex</name> <init>= <expr><call><name>abs</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// index range can be [-arrayLen, arrayLen) (lower bound inclusive, upper exclusive)</comment>
	<comment type="line">// this is because 0 = arrayLen+(-arrayLen)</comment>
	<if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>index</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>absIndex</name></expr></argument> &gt;</argument_list></name> <name>arrayLen</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>index</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>absIndex</name> <operator>&gt;=</operator> <name>arrayLen</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <ternary><condition><expr><name>index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>index</name></expr> </then><else>: <expr><name>arrayLen</name> <operator>-</operator> <name>absIndex</name></expr></else></ternary></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>res</name> <init>= <expr><call><name>SIArray_Get</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// clone is in case for nested heap allocated values returned from the array</comment>
	<return>return <expr><call><name>SI_CloneValue</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return a sub array from an array given a range of indices.
   Valid indices ragne is [-arrayLen, arrayLen).
   If range start value is bigger then range end value an empty list will be returnd.
   If indices are still integers but not in the valid range, only values within the valid range
   will be returned.
   If one of the indices is null, null will be returnd.
   "RETURN [1, 2, 3][0..1]" will yield [1, 2] */</comment>
<function><type><name>SIValue</name></type> <name>AR_SLICE</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>argc</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NULL</name> <operator>||</operator>
	   <call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NULL</name> <operator>||</operator>
	   <call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_ARRAY</name> <operator>&amp;&amp;</operator> <call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_INT64</name> <operator>&amp;&amp;</operator> <call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>array</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="line">// get array length</comment>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>arrayLen</name> <init>= <expr><call><name>SIArray_Length</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// get start and end index</comment>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>start</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32_t</name></type> <name>startIndex</name> <init>= <expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>start</name><operator>.</operator><name>longval</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>end</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32_t</name></type> <name>endIndex</name> <init>= <expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>end</name><operator>.</operator><name>longval</name></name></expr></init></decl>;</decl_stmt>

	<comment type="line">// if negative index, calculate offset from end</comment>
	<if_stmt><if>if<condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <name>arrayLen</name> <operator>-</operator> <call><name>abs</name><argument_list>(<argument><expr><name>startIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="line">// if offset from the end is out of bound, start at 0</comment>
	<if_stmt><if>if<condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// if negative index, calculate offset from end</comment>
	<if_stmt><if>if<condition>(<expr><name>endIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>endIndex</name> <operator>=</operator> <name>arrayLen</name> <operator>-</operator> <call><name>abs</name><argument_list>(<argument><expr><name>endIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="line">// if index out of bound, end at arrayLen</comment>
	<if_stmt><if>if<condition>(<expr><operator>(</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>arrayLen</name><operator>)</operator> <operator>&lt;</operator> <name>endIndex</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>endIndex</name> <operator>=</operator> <name>arrayLen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="line">// cant go in reverse</comment>
	<if_stmt><if>if<condition>(<expr><name>endIndex</name> <operator>&lt;=</operator> <name>startIndex</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>SI_EmptyArray</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>SIValue</name></type> <name>subArray</name> <init>= <expr><call><name>SI_Array</name><argument_list>(<argument><expr><name>endIndex</name> <operator>-</operator> <name>startIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>endIndex</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>SIArray_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>subArray</name></expr></argument>, <argument><expr><call><name>SIArray_Get</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>subArray</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create a new list of integers in the range of [start, end]. If a step was given
   the step between two consecutive list members will be this step.
   If step was not suppllied, it will be default as 1
   "RETURN range(3,8,2)" will yield [3, 5, 7] */</comment>
<function><type><name>SIValue</name></type> <name>AR_RANGE</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int64_t</name></type> <name>start</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>longval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64_t</name></type> <name>end</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>longval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64_t</name></type> <name>interval</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>interval</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>longval</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>interval</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ErrorCtx_RaiseRuntimeException</name><argument_list>(<argument><expr><literal type="string">"ArgumentError: step argument to range() can't be 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="line">// Incase expection handler wasn't set, return NULL.</comment>
			<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint64_t</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><operator>(</operator><name>end</name> <operator>&gt;=</operator> <name>start</name> <operator>&amp;&amp;</operator> <name>interval</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>end</name> <operator>&lt;=</operator> <name>start</name> <operator>&amp;&amp;</operator> <name>interval</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>end</name> <operator>-</operator> <name>start</name><operator>)</operator> <operator>/</operator> <name>interval</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>SIValue</name></type> <name>array</name> <init>= <expr><call><name>SI_Array</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint64_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>SIArray_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>array</name></expr></argument>, <argument><expr><call><name>SI_LongVal</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>start</name> <operator>+=</operator> <name>interval</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>array</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Checks if a value is in a given list.
   "RETURN 3 IN [1, 2, 3]" will return true */</comment>
<function><type><name>SIValue</name></type> <name>AR_IN</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>lookupValue</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>lookupList</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<comment type="line">// indicate if there was a null comparison during the array scan</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>comparedNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>arrayLen</name> <init>= <expr><call><name>SIArray_Length</name><argument_list>(<argument><expr><name>lookupList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arrayLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>disjointOrNull</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>compareValue</name> <init>= <expr><call><name>SIValue_Compare</name><argument_list>(<argument><expr><name>lookupValue</name></expr></argument>, <argument><expr><call><name>SIArray_Get</name><argument_list>(<argument><expr><name>lookupList</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>disjointOrNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>disjointOrNull</name> <operator>==</operator> <name>COMPARED_NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>comparedNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>(<expr><name>compareValue</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_BoolVal</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<comment type="line">// if there was a null comparison return null, other wise return false as the lookup item did not found</comment>
	<return>return <expr><ternary><condition><expr><name>comparedNull</name></expr> ?</condition><then> <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>SI_BoolVal</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return a list/string/map/path size.
   "RETURN size([1, 2, 3])" will return 3
   TODO: when map and path are implemented, add their functionality */</comment>
<function><type><name>SIValue</name></type> <name>AR_SIZE</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>value</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<switch>switch<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>T_ARRAY</name></expr>:</case>
			<return>return <expr><call><name>SI_LongVal</name><argument_list>(<argument><expr><call><name>SIArray_Length</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_STRING</name></expr>:</case>
			<return>return <expr><call><name>SI_LongVal</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>value</name><operator>.</operator><name>stringval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_NULL</name></expr>:</case>
			<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Return the first member of a list.
   "RETURN head([1, 2, 3])" will return 1 */</comment>
<function><type><name>SIValue</name></type> <name>AR_HEAD</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>value</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>arrayLen</name> <init>= <expr><call><name>SIArray_Length</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>arrayLen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>retval</name> <init>= <expr><call><name>SIArray_Get</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SIValue_Persist</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the last member of a list.
   "RETURN last([1, 2, 3])" will return 3 */</comment>
<function><type><name>SIValue</name></type> <name>AR_LAST</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>value</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>arrayLen</name> <init>= <expr><call><name>SIArray_Length</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>arrayLen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>retval</name> <init>= <expr><call><name>SIArray_Get</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>arrayLen</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SIValue_Persist</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return a sublist of a list, which contains all the values withiout the first value.
   "RETURN tail([1, 2, 3])" will return [2, 3] */</comment>
<function><type><name>SIValue</name></type> <name>AR_TAIL</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>value</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>arrayLen</name> <init>= <expr><call><name>SIArray_Length</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>array</name> <init>= <expr><call><name>SI_Array</name><argument_list>(<argument><expr><name>arrayLen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>arrayLen</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>array</name></expr>;</return></block_content></block></if></if_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arrayLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>SIArray_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>array</name></expr></argument>, <argument><expr><call><name>SIArray_Get</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>array</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIValue</name></type> <name>AR_REDUCE</name>
<parameter_list>(
	<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
	<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// reduce(sum = 0, n IN [1,2,3] | sum + n)</comment>
	<comment type="line">// argv[0] - accumulator initial value</comment>
	<comment type="line">// argv[1] - array</comment>
	<comment type="line">// argv[2] - input record</comment>

	<comment type="line">// return NULL if expected array is NULL</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// set arguments</comment>
	<decl_stmt><decl><type><name>SIValue</name></type>        <name>accum</name>  <init>=  <expr><call><name>SI_ShareValue</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type>        <name>list</name>   <init>=  <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Record</name></type>         <name>rec</name>    <init>=  <expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>ptrval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListReduceCtx</name>  <modifier>*</modifier></type><name>ctx</name>   <init>=  <expr><name>private_data</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// on first invocation build the internal record</comment>
	<if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>record</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>_PopulateReduceCtx</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<decl_stmt><decl><type><name>Record</name></type> <name>r</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>record</name></name></expr></init></decl>;</decl_stmt>

	<comment type="line">// populate record with the contents of the input record</comment>
	<expr_stmt><expr><call><name>Record_Clone</name><argument_list>(<argument><expr><name>rec</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// init accumulator within internal record</comment>
	<expr_stmt><expr><call><name>Record_AddScalar</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>accumulator_idx</name></name></expr></argument>, <argument><expr><name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// evaluate expression for each list element</comment>
	<comment type="line">// e.g. for `n` in `list`, compute: sum = sum + n</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>len</name> <init>= <expr><call><name>SIArray_Length</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<comment type="line">// retrieve the current element</comment>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>elem</name> <init>= <expr><call><name>SIArray_Get</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// set current element to the record</comment>
		<expr_stmt><expr><call><name>Record_AddScalar</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>variable_idx</name></name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// compute sum = sum + i</comment>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>new_accum</name> <init>= <expr><call><name>AR_EXP_Evaluate</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>exp</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SIValue_Free</name><argument_list>(<argument><expr><name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>accum</name> <operator>=</operator> <name>new_accum</name></expr>;</expr_stmt>
		<comment type="line">// update accumulator within internal record</comment>
		<expr_stmt><expr><call><name>Record_AddScalar</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>accumulator_idx</name></name></expr></argument>, <argument><expr><name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="line">// clear internal record</comment>
	<expr_stmt><expr><call><name>Record_Remove</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>variable_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Record_Remove</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>accumulator_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SIValue_Persist</name><argument_list>(<argument><expr><operator>&amp;</operator><name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>accum</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>Register_ListFuncs</name><parameter_list>()</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIType</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIType</name></type> <name>ret_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AR_FuncDesc</name> <modifier>*</modifier></type><name>func_desc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>SI_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_ARRAY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"tolist"</literal></expr></argument>, <argument><expr><name>AR_TOLIST</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>VAR_ARG_LEN</name></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"toBooleanList"</literal></expr></argument>, <argument><expr><name>AR_TOBOOLEANLIST</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"toFloatList"</literal></expr></argument>, <argument><expr><name>AR_TOFLOATLIST</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"toIntegerList"</literal></expr></argument>, <argument><expr><name>AR_TOINTEGERLIST</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"toStringList"</literal></expr></argument>, <argument><expr><name>AR_TOSTRINGLIST</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_ARRAY</name> <operator>|</operator> <name>T_MAP</name> <operator>|</operator> <name>SI_GRAPHENTITY</name> <operator>|</operator> <name>T_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_INT64</name> <operator>|</operator> <name>T_STRING</name> <operator>|</operator> <name>T_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>SI_ALL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"subscript"</literal></expr></argument>, <argument><expr><name>AR_SUBSCRIPT</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_INT64</name> <operator>|</operator> <name>T_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_INT64</name> <operator>|</operator> <name>T_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"slice"</literal></expr></argument>, <argument><expr><name>AR_SLICE</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"range"</literal></expr></argument>, <argument><expr><name>AR_RANGE</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>SI_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_NULL</name> <operator>|</operator> <name>T_BOOL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"in"</literal></expr></argument>, <argument><expr><name>AR_IN</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_STRING</name> <operator>|</operator> <name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_NULL</name> <operator>|</operator> <name>T_INT64</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name>AR_SIZE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>SI_ALL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"head"</literal></expr></argument>, <argument><expr><name>AR_HEAD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>SI_ALL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"last"</literal></expr></argument>, <argument><expr><name>AR_LAST</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>SI_ALL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"tail"</literal></expr></argument>, <argument><expr><name>AR_TAIL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>SI_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="line">// accumulator initial value</comment>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// array to iterate over</comment>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>             <comment type="line">// input record</comment>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>SI_ALL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"reduce"</literal></expr></argument>, <argument><expr><name>AR_REDUCE</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_SetPrivateDataRoutines</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>, <argument><expr><name>ListReduceCtx_Free</name></expr></argument>,
							  <argument><expr><name>ListReduceCtx_Clone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

</unit>
