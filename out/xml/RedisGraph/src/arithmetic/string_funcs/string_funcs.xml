<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/src/arithmetic/string_funcs/string_funcs.c"><comment type="block">/*
 * Copyright Redis Ltd. 2018 - present
 * Licensed under your choice of the Redis Source Available License 2.0 (RSALv2) or
 * the Server Side Public License v1 (SSPLv1).
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"string_funcs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../func_desc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../errors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../util/arr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../util/rmalloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../util/uuid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../util/strutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../util/json_encoder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../datatypes/array.h"</cpp:file></cpp:include>

<comment type="line">// toString supports only integer, float, string, boolean, point, duration, </comment>
<comment type="line">// date, time, localtime, localdatetime or datetime values</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGABLE</name></cpp:macro> <cpp:value>(SI_NUMERIC | T_POINT | T_DURATION | T_DATETIME | T_STRING | T_BOOL)</cpp:value></cpp:define>

<comment type="line">// returns a string containing the specified number of leftmost characters of the original string.</comment>
<function><type><name>SIValue</name></type> <name>AR_LEFT</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>int64_t</name></type> <name>newlen</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>longval</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>newlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"length must be positive integer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>stringval</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>newlen</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// No need to truncate this string based on the requested length</comment>
		<return>return <expr><call><name>SI_DuplicateStringVal</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>stringval</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>left_str</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><operator>(</operator><name>newlen</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>left_str</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>stringval</name></expr></argument>, <argument><expr><name>newlen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>left_str</name><index>[<expr><name>newlen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<return>return <expr><call><name>SI_TransferStringVal</name><argument_list>(<argument><expr><name>left_str</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns the original string with leading whitespace removed.</comment>
<function><type><name>SIValue</name></type> <name>AR_LTRIM</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>trimmed</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>stringval</name></expr></init></decl>;</decl_stmt>

	<while>while<condition>(<expr><operator>*</operator><name>trimmed</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>trimmed</name> <operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><call><name>SI_DuplicateStringVal</name><argument_list>(<argument><expr><name>trimmed</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns a string containing the specified number of rightmost characters of the original string.</comment>
<function><type><name>SIValue</name></type> <name>AR_RIGHT</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>int64_t</name></type> <name>newlen</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>longval</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>newlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"length must be positive integer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int64_t</name></type> <name>start</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>stringval</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>newlen</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>start</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="line">// No need to truncate this string based on the requested length</comment>
		<return>return <expr><call><name>SI_DuplicateStringVal</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>stringval</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>SI_DuplicateStringVal</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>stringval</name> <operator>+</operator> <name>start</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns the original string with trailing whitespace removed.</comment>
<function><type><name>SIValue</name></type> <name>AR_RTRIM</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>stringval</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while<condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>trimmed</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>trimmed</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trimmed</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<return>return <expr><call><name>SI_TransferStringVal</name><argument_list>(<argument><expr><name>trimmed</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// incase the parameter type is </comment>
<comment type="line">// 1. string - returns a string in which the order of all characters in the original string have been reversed.</comment>
<comment type="line">// 2. array  - returns an array in which the order of all elements in the original array have been reversed.</comment>
<function><type><name>SIValue</name></type> <name>AR_REVERSE</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>SIValue</name></type> <name>value</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_STRING</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// string reverse</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><name><name>value</name><operator>.</operator><name>stringval</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>str_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>reverse</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><operator>(</operator><name>str_len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>str_len</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<while>while<condition>(<expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>reverse</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>str</name><index>[<expr><name>i</name><operator>--</operator></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><name><name>reverse</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<return>return <expr><call><name>SI_TransferStringVal</name><argument_list>(<argument><expr><name>reverse</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<decl_stmt><decl><type><name>SIValue</name></type> <name>reverse</name> <init>= <expr><call><name>SI_CloneValue</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>array_reverse</name><argument_list>(<argument><expr><name><name>reverse</name><operator>.</operator><name>array</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>reverse</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">// returns a substring of the original string, beginning with a 0-based index start and length.</comment>
<function><type><name>SIValue</name></type> <name>AR_SUBSTRING</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/*
	    argv[0] - original string
	    argv[1] - start position
	    argv[2] - length
	    If length is omitted, the function returns the substring starting at the position given by start and extending to the end of original.
	    If either start or length is null or a negative integer, an error is raised.
	    If start is 0, the substring will start at the beginning of original.
	    If length is 0, the empty string will be returned.
	*/</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>original</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>stringval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>original_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>original</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>start</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>longval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64_t</name></type> <name>length</name></decl>;</decl_stmt>

	<comment type="block">/* Make sure start doesn't overreach. */</comment>
	<if_stmt><if>if<condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"start must be positive integer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name>start</name> <operator>&gt;=</operator> <name>original_len</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_ConstStringVal</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>suffix_len</name> <init>= <expr><name>original_len</name> <operator>-</operator> <name>start</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>length</name> <operator>=</operator> <name>suffix_len</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>length</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>longval</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>length</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"length must be positive integer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>SI_ConstStringVal</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Make sure length does not overreach. */</comment>
		<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>length</name></expr></argument>, <argument><expr><name>suffix_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>substring</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><operator>(</operator><name>length</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>substring</name></expr></argument>, <argument><expr><name>original</name> <operator>+</operator> <name>start</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>substring</name><index>[<expr><name>length</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<return>return <expr><call><name>SI_TransferStringVal</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns the original string in lowercase.</comment>
<function><type><name>SIValue</name></type> <name>AR_TOLOWER</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>original</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>stringval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>lower_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>original</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lower</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><operator>(</operator><name>lower_len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>str_tolower</name><argument_list>(<argument><expr><name>original</name></expr></argument>, <argument><expr><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>SI_TransferStringVal</name><argument_list>(<argument><expr><name>lower</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns the original string in uppercase.</comment>
<function><type><name>SIValue</name></type> <name>AR_TOUPPER</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>original</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>stringval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>upper_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>original</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>upper</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><operator>(</operator><name>upper_len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>str_toupper</name><argument_list>(<argument><expr><name>original</name></expr></argument>, <argument><expr><name>upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>SI_TransferStringVal</name><argument_list>(<argument><expr><name>upper</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// converts an integer, float or boolean value to a string.</comment>
<function><type><name>SIValue</name></type> <name>AR_TOSTRING</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>STRINGABLE</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>SIValue_StringJoinLen</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>bytesWritten</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SIValue_ToString</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesWritten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>SI_TransferStringVal</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else <block>{<block_content>
		<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">// Returns a JSON string representation of a map value.</comment>
<function><type><name>SIValue</name></type> <name>AR_TOJSON</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>JsonEncoder_SIValue</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>SI_TransferStringVal</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns the original string with leading and trailing whitespace removed.</comment>
<function><type><name>SIValue</name></type> <name>AR_TRIM</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>ltrim</name> <init>= <expr><call><name>AR_LTRIM</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type> <name>trimmed</name> <init>= <expr><call><name>AR_RTRIM</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ltrim</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SIValue_Free</name><argument_list>(<argument><expr><name>ltrim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>trimmed</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns true if argv[1] is a substring of argv[0].</comment>
<function><type><name>SIValue</name></type> <name>AR_CONTAINS</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// No string contains null.</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hay</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>stringval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>needle</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>stringval</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// See if needle is in hay.</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><operator>(</operator><call><name>strstr</name><argument_list>(<argument><expr><name>hay</name></expr></argument>, <argument><expr><name>needle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>SI_BoolVal</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns true if argv[0] starts with argv[1].</comment>
<function><type><name>SIValue</name></type> <name>AR_STARTSWITH</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// No string contains null.</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>stringval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sub_string</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>stringval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>str_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>sub_string_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>sub_string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// If sub-string is longer then string return quickly.</comment>
	<if_stmt><if>if<condition>(<expr><name>sub_string_len</name> <operator>&gt;</operator> <name>str_len</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_BoolVal</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// Compare character by character, see if there's a match.</comment>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sub_string_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>sub_string</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_BoolVal</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><call><name>SI_BoolVal</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns true if argv[0] ends with argv[1].</comment>
<function><type><name>SIValue</name></type> <name>AR_ENDSWITH</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// No string contains null.</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>stringval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sub_string</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>stringval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>str_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>sub_string_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>sub_string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// If sub-string is longer then string return quickly.</comment>
	<if_stmt><if>if<condition>(<expr><name>sub_string_len</name> <operator>&gt;</operator> <name>str_len</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_BoolVal</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// Advance str to the "end"</comment>
	<expr_stmt><expr><name>str</name> <operator>+=</operator> <operator>(</operator><name>str_len</name> <operator>-</operator> <name>sub_string_len</name><operator>)</operator></expr>;</expr_stmt>
	<comment type="line">// Compare character by character, see if there's a match.</comment>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sub_string_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>sub_string</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_BoolVal</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><call><name>SI_BoolVal</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns a string in which all occurrences of a specified string in the original string have been replaced by ANOTHER (specified) string.</comment>
<comment type="line">// for example: RETURN replace('Well I wish I was in the land of cotton', 'cotton', 'the free')</comment>
<comment type="line">// the result is Well I wish I was in the land of the free</comment>
<function><type><name>SIValue</name></type> <name>AR_REPLACE</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// No string contains null.</comment>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator>
	   <call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator>
	   <call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// argv[0] is the original string to be manipulated</comment>
	<comment type="line">// argv[1] is the search sub string to be replaced</comment>
	<comment type="line">// argv[2] is the string to be replaced with</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name>            <init>=  <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>stringval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_string</name>     <init>=  <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>stringval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_string</name>     <init>=  <expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>stringval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>      <name>str_len</name>        <init>=  <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>      <name>old_string_len</name> <init>=  <expr><call><name>strlen</name><argument_list>(<argument><expr><name>old_string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>      <name>new_string_len</name> <init>=  <expr><call><name>strlen</name><argument_list>(<argument><expr><name>new_string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name>  <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>arr</name> <init>= <expr><call><name>array_new</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while<condition>(<expr><name>ptr</name> <operator>&lt;=</operator> <name>str</name> <operator>+</operator> <name>str_len</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// find pointer to next substring</comment>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>old_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// if no substring found, then break from the loop</comment>
		<if_stmt><if>if<condition>(<expr><name>ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

		<comment type="line">// store ptr for replace use</comment>
		<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// increment our string pointer in case search string is empty move one char</comment>
		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <ternary><condition><expr><name>old_string_len</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>old_string_len</name></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></while>

	<decl_stmt><decl><type><name>int</name></type> <name>occurrences</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// if sub string not found return original string</comment>
	<if_stmt><if>if<condition>(<expr><name>occurrences</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>SI_DuplicateStringVal</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// calculate new buffer size</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>buffer_size</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><name>occurrences</name> <operator>*</operator> <name>new_string_len</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>occurrences</name> <operator>*</operator> <name>old_string_len</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="line">// allocate buffer</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <call><name>rm_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>buffer_size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// set pointers to start point</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer_ptr</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// iterate occurrences</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>occurrences</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<comment type="line">// calculate len to copy from last to current occurance</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>

		<comment type="line">// copy part from original string</comment>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buffer_ptr</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// move forward to copy more data to the buffer</comment>
		<expr_stmt><expr><name>buffer_ptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

		<comment type="line">// copy new string instead of old string</comment>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buffer_ptr</name></expr></argument>, <argument><expr><name>new_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// move forward to copy more data to the buffer</comment>
		<expr_stmt><expr><name>buffer_ptr</name> <operator>+=</operator> <name>new_string_len</name></expr>;</expr_stmt>

		<comment type="line">// move forwart to copy more data from the original string</comment>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>old_string_len</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="line">// copy rest of the string from the original string</comment>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buffer_ptr</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>buffer_size</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>SI_TransferStringVal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns a list of strings resulting from the splitting of the original string around matches of the given delimiter</comment>
<function><type><name>SIValue</name></type> <name>AR_SPLIT</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SIValue_IsNull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>SI_NullVal</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>str</name>       <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>stringval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>delimiter</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>stringval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIValue</name></type>     <name>tokens</name>    <init>= <expr><call><name>SIArray_New</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>delimiter</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if<condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>SIArray_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokens</name></expr></argument>, <argument><expr><call><name>SI_ConstStringVal</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type> <name><name>token</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>token</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<while>while<condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SIArray_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokens</name></expr></argument>, <argument><expr><call><name>SI_ConstStringVal</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="line">// strtok should work on a mutable copy</comment>
		<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rm_strdup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name>  <init>= <expr><call><name>strtok</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>delimiter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if<condition>(<expr><operator>!</operator><name>token</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>SIArray_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokens</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>tokens</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<while>while<condition>(<expr><name>token</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>SIValue</name></type> <name>si_token</name> <init>= <expr><call><name>SI_ConstStringVal</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>SIArray_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokens</name></expr></argument>, <argument><expr><name>si_token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>delimiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
		
		<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>tokens</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">//==============================================================================</comment>
<comment type="line">//=== Scalar functions =========================================================</comment>
<comment type="line">//==============================================================================</comment>

<function><type><name>SIValue</name></type> <name>AR_RANDOMUUID</name><parameter_list>(<parameter><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>uuid</name> <init>= <expr><call><name>UUID_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>SI_TransferStringVal</name><argument_list>(<argument><expr><name>uuid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>Register_StringFuncs</name><parameter_list>()</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SIType</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SIType</name></type> <name>ret_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AR_FuncDesc</name> <modifier>*</modifier></type><name>func_desc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>T_STRING</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_INT64</name> <operator>|</operator> <name>T_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_STRING</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"left"</literal></expr></argument>, <argument><expr><name>AR_LEFT</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>T_STRING</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_STRING</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"ltrim"</literal></expr></argument>, <argument><expr><name>AR_LTRIM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>T_STRING</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_INT64</name> <operator>|</operator> <name>T_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_STRING</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"right"</literal></expr></argument>, <argument><expr><name>AR_RIGHT</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>T_STRING</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_STRING</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"rtrim"</literal></expr></argument>, <argument><expr><name>AR_RTRIM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>T_STRING</name> <operator>|</operator> <name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_STRING</name> <operator>|</operator> <name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"reverse"</literal></expr></argument>, <argument><expr><name>AR_REVERSE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>T_STRING</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>T_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_STRING</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"substring"</literal></expr></argument>, <argument><expr><name>AR_SUBSTRING</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>T_STRING</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_STRING</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"tolower"</literal></expr></argument>, <argument><expr><name>AR_TOLOWER</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>T_STRING</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_STRING</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"toupper"</literal></expr></argument>, <argument><expr><name>AR_TOUPPER</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>STRINGABLE</name> <operator>|</operator> <name>T_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_STRING</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"tostring"</literal></expr></argument>, <argument><expr><name>AR_TOSTRING</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>SI_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_STRING</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"tostringornull"</literal></expr></argument>, <argument><expr><name>AR_TOSTRING</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>SI_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_STRING</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"tojson"</literal></expr></argument>, <argument><expr><name>AR_TOJSON</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>T_STRING</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_STRING</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"trim"</literal></expr></argument>, <argument><expr><name>AR_TRIM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>T_STRING</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>T_STRING</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_BOOL</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"contains"</literal></expr></argument>, <argument><expr><name>AR_CONTAINS</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>T_STRING</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>T_STRING</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_BOOL</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"starts with"</literal></expr></argument>, <argument><expr><name>AR_STARTSWITH</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>T_STRING</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>T_STRING</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_BOOL</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"ends with"</literal></expr></argument>, <argument><expr><name>AR_ENDSWITH</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_STRING</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"randomuuid"</literal></expr></argument>, <argument><expr><name>AR_RANDOMUUID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>T_STRING</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>T_STRING</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>T_STRING</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_STRING</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"replace"</literal></expr></argument>, <argument><expr><name>AR_REPLACE</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>SIType</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>T_STRING</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><operator>(</operator><name>T_STRING</name> <operator>|</operator> <name>T_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <name>T_ARRAY</name> <operator>|</operator> <name>T_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>func_desc</name> <operator>=</operator> <call><name>AR_FuncDescNew</name><argument_list>(<argument><expr><literal type="string">"split"</literal></expr></argument>, <argument><expr><name>AR_SPLIT</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AR_RegFunc</name><argument_list>(<argument><expr><name>func_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
