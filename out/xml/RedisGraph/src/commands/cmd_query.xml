<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/src/commands/cmd_query.c"><comment type="block">/*
 * Copyright Redis Ltd. 2018 - present
 * Licensed under your choice of the Redis Source Available License 2.0 (RSALv2) or
 * the Server Side Public License v1 (SSPLv1).
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"RG.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../errors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_context.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../ast/ast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/arr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/cron.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../query_ctx.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../graph/graph.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/rmalloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/cache/cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/thpool/pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../execution_plan/execution_plan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"execution_ctx.h"</cpp:file></cpp:include>

<comment type="line">// GraphQueryCtx stores the allocations required to execute a query.</comment>
<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>GraphContext</name> <modifier>*</modifier></type><name>graph_ctx</name></decl>;</decl_stmt>  <comment type="line">// graph context</comment>
	<decl_stmt><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>rm_ctx</name></decl>;</decl_stmt>   <comment type="line">// redismodule context</comment>
	<decl_stmt><decl><type><name>QueryCtx</name> <modifier>*</modifier></type><name>query_ctx</name></decl>;</decl_stmt>      <comment type="line">// query context</comment>
	<decl_stmt><decl><type><name>ExecutionCtx</name> <modifier>*</modifier></type><name>exec_ctx</name></decl>;</decl_stmt>   <comment type="line">// execution context</comment>
	<decl_stmt><decl><type><name>CommandCtx</name> <modifier>*</modifier></type><name>command_ctx</name></decl>;</decl_stmt>  <comment type="line">// command context</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>readonly_query</name></decl>;</decl_stmt>      <comment type="line">// read only query</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>profile</name></decl>;</decl_stmt>             <comment type="line">// profile query</comment>
	<decl_stmt><decl><type><name>CronTaskHandle</name></type> <name>timeout</name></decl>;</decl_stmt>   <comment type="line">// timeout cron task</comment>
}</block></struct></type> <name>GraphQueryCtx</name>;</typedef>

<function><type><specifier>static</specifier> <name>GraphQueryCtx</name> <modifier>*</modifier></type><name>GraphQueryCtx_New</name>
<parameter_list>(
	<parameter><decl><type><name>GraphContext</name> <modifier>*</modifier></type><name>graph_ctx</name></decl></parameter>,
	<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>rm_ctx</name></decl></parameter>,
	<parameter><decl><type><name>ExecutionCtx</name> <modifier>*</modifier></type><name>exec_ctx</name></decl></parameter>,
	<parameter><decl><type><name>CommandCtx</name> <modifier>*</modifier></type><name>command_ctx</name></decl></parameter>,
	<parameter><decl><type><name>bool</name></type> <name>readonly_query</name></decl></parameter>,
	<parameter><decl><type><name>bool</name></type> <name>profile</name></decl></parameter>,
	<parameter><decl><type><name>CronTaskHandle</name></type> <name>timeout</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>GraphQueryCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GraphQueryCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>rm_ctx</name></name>          <operator>=</operator>  <name>rm_ctx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>exec_ctx</name></name>        <operator>=</operator>  <name>exec_ctx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>graph_ctx</name></name>       <operator>=</operator>  <name>graph_ctx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>query_ctx</name></name>       <operator>=</operator>  <call><name>QueryCtx_GetQueryCtx</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>command_ctx</name></name>     <operator>=</operator>  <name>command_ctx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>readonly_query</name></name>  <operator>=</operator>  <name>readonly_query</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>profile</name></name>         <operator>=</operator>  <name>profile</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>timeout</name></name>         <operator>=</operator>  <name>timeout</name></expr>;</expr_stmt>

	<return>return <expr><name>ctx</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <specifier>static</specifier> <specifier>inline</specifier></type> <name>GraphQueryCtx_Free</name><parameter_list>(<parameter><decl><type><name>GraphQueryCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>ctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>abort_and_check_timeout</name><parameter_list>(<parameter><decl><type><name>GraphQueryCtx</name> <modifier>*</modifier></type><name>gq_ctx</name></decl></parameter>, <parameter><decl><type><name>ExecutionPlan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// abort timeout if set</comment>
	<if_stmt><if>if<condition>(<expr><name><name>gq_ctx</name><operator>-&gt;</operator><name>timeout</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>Cron_AbortTask</name><argument_list>(<argument><expr><name><name>gq_ctx</name><operator>-&gt;</operator><name>timeout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// emit error if query timed out</comment>
	<if_stmt><if>if<condition>(<expr><call><name>ExecutionPlan_Drained</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Query timed out"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_index_operation</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>GraphContext</name> <modifier>*</modifier></type><name>gc</name></decl></parameter>, <parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>,
							 <parameter><decl><type><name>ExecutionType</name></type> <name>exec_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>Index</name>       <modifier>*</modifier></type><name>idx</name>         <init>=  <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SchemaType</name></type>  <name>schema_type</name>  <init>=  <expr><name>SCHEMA_NODE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexType</name></type>   <name>idx_type</name>     <init>=  <expr><name>IDX_EXACT_MATCH</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>index_op</name> <init>= <expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>exec_type</name> <operator>==</operator> <name>EXECUTION_TYPE_INDEX_CREATE</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// retrieve strings from AST node</comment>
		<decl_stmt><decl><type><name>bool</name></type>                  <name>index_added</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>            <modifier>*</modifier></type><name>label</name>      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>          <name>nprops</name>      <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>t</name>           <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>index_op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_CREATE_NODE_PROPS_INDEX</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>nprops</name> <operator>=</operator> <call><name>cypher_ast_create_node_props_index_nprops</name><argument_list>(<argument><expr><name>index_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>label</name>  <operator>=</operator> <call><name>cypher_ast_label_get_name</name><argument_list>(<argument><expr><call><name>cypher_ast_create_node_props_index_get_label</name><argument_list>(<argument><expr><name>index_op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>nprops</name> <operator>=</operator> <call><name>cypher_ast_create_pattern_props_index_nprops</name><argument_list>(<argument><expr><name>index_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>label</name>  <operator>=</operator> <call><name>cypher_ast_label_get_name</name><argument_list>(<argument><expr><call><name>cypher_ast_create_pattern_props_index_get_label</name><argument_list>(<argument><expr><name>index_op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="line">// determine if index is created over node label or edge relationship</comment>
			<comment type="line">// default to node</comment>
			<if_stmt><if>if<condition>(<expr><call><name>cypher_ast_create_pattern_props_index_pattern_is_relation</name><argument_list>(<argument><expr><name>index_op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>schema_type</name> <operator>=</operator> <name>SCHEMA_EDGE</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	
		<comment type="line">// add index for each property</comment>
		<expr_stmt><expr><call><name>QueryCtx_LockForCommit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<for>for<control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nprops</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>prop_name</name> <init>= <expr><ternary><condition><expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_CREATE_NODE_PROPS_INDEX</name></expr>
				?</condition><then> <expr><call><name>cypher_ast_create_node_props_index_get_prop_name</name><argument_list>(<argument><expr><name>index_op</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>
				</then><else>: <expr><call><name>cypher_ast_property_operator_get_prop_name</name><argument_list>(<argument><expr><call><name>cypher_ast_create_pattern_props_index_get_property_operator</name><argument_list>(<argument><expr><name>index_op</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prop</name> <init>= <expr><call><name>cypher_ast_prop_name_get_value</name><argument_list>(<argument><expr><name>prop_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>index_added</name> <operator>|=</operator> <operator>(</operator><call><name>GraphContext_AddExactMatchIndex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idx</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>,
						<argument><expr><name>schema_type</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>prop</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>INDEX_OK</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="line">// populate the index only when at least one attribute was introduced</comment>
		<if_stmt><if>if<condition>(<expr><name>index_added</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>Index_Construct</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name><name>gc</name><operator>-&gt;</operator><name>g</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>exec_type</name> <operator>==</operator> <name>EXECUTION_TYPE_INDEX_DROP</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// retrieve strings from AST node</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>label</name> <init>= <expr><call><name>cypher_ast_label_get_name</name><argument_list>(
				<argument><expr><call><name>cypher_ast_drop_props_index_get_label</name><argument_list>(<argument><expr><name>index_op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prop</name> <init>= <expr><call><name>cypher_ast_prop_name_get_value</name><argument_list>(
				<argument><expr><call><name>cypher_ast_drop_props_index_get_prop_name</name><argument_list>(<argument><expr><name>index_op</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// determine if schema type from which index is removed</comment>
		<comment type="line">// default to node</comment>
		<comment type="line">// TODO: support index name</comment>
		<if_stmt><if>if<condition>(<expr><call><name>GraphContext_GetSchema</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>schema_type</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>schema_type</name> <operator>=</operator> <name>SCHEMA_EDGE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>QueryCtx_LockForCommit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>GraphContext_DeleteIndex</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name>schema_type</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>prop</name></expr></argument>,
				<argument><expr><name>idx_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>INDEX_OK</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"ERR Unable to drop index on :%s(%s): no such index."</literal></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"ERR Encountered unknown query execution type."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// Query timeout</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// timeout handler</comment>
<function><type><name>void</name></type> <name>QueryTimedOut</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pdata</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>pdata</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>ExecutionPlan</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>ExecutionPlan</name> <operator>*</operator><operator>)</operator><name>pdata</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ExecutionPlan_Drain</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// set timeout for query execution</comment>
<function><type><name>CronTaskHandle</name></type> <name>Query_SetTimeOut</name><parameter_list>(<parameter><decl><type><name>uint</name></type> <name>timeout</name></decl></parameter>, <parameter><decl><type><name>ExecutionPlan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// increase execution plan ref count</comment>
	<return>return <expr><call><name>Cron_AddTask</name><argument_list>(<argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>QueryTimedOut</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <specifier>static</specifier> <name>bool</name></type> <name>_readonly_cmd_mode</name><parameter_list>(<parameter><decl><type><name>CommandCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>strcasecmp</name><argument_list>(<argument><expr><call><name>CommandCtx_GetCommandName</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"graph.RO_QUERY"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* _ExecuteQuery accepts a GraphQeuryCtx as an argument
 * it may be called directly by a reader thread or the Redis main thread,
 * or dispatched as a worker thread job. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_ExecuteQuery</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>args</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>GraphQueryCtx</name>   <modifier>*</modifier></type><name>gq_ctx</name>       <init>=  <expr><name>args</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryCtx</name>        <modifier>*</modifier></type><name>query_ctx</name>    <init>=  <expr><name><name>gq_ctx</name><operator>-&gt;</operator><name>query_ctx</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GraphContext</name>    <modifier>*</modifier></type><name>gc</name>           <init>=  <expr><name><name>gq_ctx</name><operator>-&gt;</operator><name>graph_ctx</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RedisModuleCtx</name>  <modifier>*</modifier></type><name>rm_ctx</name>       <init>=  <expr><name><name>gq_ctx</name><operator>-&gt;</operator><name>rm_ctx</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>            <name>profile</name>       <init>=  <expr><name><name>gq_ctx</name><operator>-&gt;</operator><name>profile</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>            <name>readonly</name>      <init>=  <expr><name><name>gq_ctx</name><operator>-&gt;</operator><name>readonly_query</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecutionCtx</name>    <modifier>*</modifier></type><name>exec_ctx</name>     <init>=  <expr><name><name>gq_ctx</name><operator>-&gt;</operator><name>exec_ctx</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandCtx</name>      <modifier>*</modifier></type><name>command_ctx</name>  <init>=  <expr><name><name>gq_ctx</name><operator>-&gt;</operator><name>command_ctx</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AST</name>             <modifier>*</modifier></type><name>ast</name>          <init>=  <expr><name><name>exec_ctx</name><operator>-&gt;</operator><name>ast</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecutionPlan</name>   <modifier>*</modifier></type><name>plan</name>         <init>=  <expr><name><name>exec_ctx</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecutionType</name></type>   <name>exec_type</name>     <init>=  <expr><name><name>exec_ctx</name><operator>-&gt;</operator><name>exec_type</name></name></expr></init></decl>;</decl_stmt>

	<comment type="line">// if we have migrated to a writer thread,</comment>
	<comment type="line">// update thread-local storage and track the CommandCtx</comment>
	<if_stmt><if>if<condition>(<expr><name><name>command_ctx</name><operator>-&gt;</operator><name>thread</name></name> <operator>==</operator> <name>EXEC_THREAD_WRITER</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>QueryCtx_SetTLS</name><argument_list>(<argument><expr><name>query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommandCtx_TrackCtx</name><argument_list>(<argument><expr><name>command_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// instantiate the query ResultSet</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>compact</name> <init>= <expr><name><name>command_ctx</name><operator>-&gt;</operator><name>compact</name></name></expr></init></decl>;</decl_stmt>
	<comment type="line">// replicated command don't need to return result</comment>
	<decl_stmt><decl><type><name>ResultSetFormatterType</name></type> <name>resultset_format</name> <init>= 
		<expr><ternary><condition><expr><name>profile</name> <operator>||</operator> <name><name>command_ctx</name><operator>-&gt;</operator><name>replicated_command</name></name></expr>
		?</condition><then> <expr><name>FORMATTER_NOP</name></expr> 
		</then><else>: <expr><ternary><condition><expr><operator>(</operator><name>compact</name><operator>)</operator></expr> 
			?</condition><then> <expr><name>FORMATTER_COMPACT</name></expr> 
			</then><else>: <expr><name>FORMATTER_VERBOSE</name></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultSet</name> <modifier>*</modifier></type><name>result_set</name> <init>= <expr><call><name>NewResultSet</name><argument_list>(<argument><expr><name>rm_ctx</name></expr></argument>, <argument><expr><name>resultset_format</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>exec_ctx</name><operator>-&gt;</operator><name>cached</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ResultSet_CachedExecution</name><argument_list>(<argument><expr><name>result_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="line">// indicate a cached execution</comment>

	<expr_stmt><expr><call><name>QueryCtx_SetResultSet</name><argument_list>(<argument><expr><name>result_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// acquire the appropriate lock</comment>
	<if_stmt><if>if<condition>(<expr><name>readonly</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>Graph_AcquireReadLock</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>g</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/* if this is a writer query `we need to re-open the graph key with write flag
		 * this notifies Redis that the key is "dirty" any watcher on that key will
		 * be notified */</comment>
		<expr_stmt><expr><call><name>CommandCtx_ThreadSafeContextLock</name><argument_list>(<argument><expr><name>command_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><call><name>GraphContext_MarkWriter</name><argument_list>(<argument><expr><name>rm_ctx</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>CommandCtx_ThreadSafeContextUnlock</name><argument_list>(<argument><expr><name>command_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>exec_type</name> <operator>==</operator> <name>EXECUTION_TYPE_QUERY</name></expr>)</condition> <block>{<block_content>  <comment type="line">// query operation</comment>
		<comment type="line">// set policy after lock acquisition,</comment>
		<comment type="line">// avoid resetting policies between readers and writers</comment>
		<expr_stmt><expr><call><name>Graph_SetMatrixPolicy</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>g</name></name></expr></argument>, <argument><expr><name>SYNC_POLICY_FLUSH_RESIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecutionPlan_PreparePlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>profile</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ExecutionPlan_Profile</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>abort_and_check_timeout</name><argument_list>(<argument><expr><name>gq_ctx</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ErrorCtx_EncounteredError</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>ExecutionPlan_Print</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>rm_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else <block>{<block_content>
			<expr_stmt><expr><name>result_set</name> <operator>=</operator> <call><name>ExecutionPlan_Execute</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>abort_and_check_timeout</name><argument_list>(<argument><expr><name>gq_ctx</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>ExecutionPlan_Free</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>exec_ctx</name><operator>-&gt;</operator><name>plan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>exec_type</name> <operator>==</operator> <name>EXECUTION_TYPE_INDEX_CREATE</name> <operator>||</operator>
			  <name>exec_type</name> <operator>==</operator> <name>EXECUTION_TYPE_INDEX_DROP</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_index_operation</name><argument_list>(<argument><expr><name>rm_ctx</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>, <argument><expr><name>ast</name></expr></argument>, <argument><expr><name>exec_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="string">"Unhandled query type"</literal> <operator>&amp;&amp;</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="line">// in case of an error, rollback any modifications</comment>
	<if_stmt><if>if<condition>(<expr><call><name>ErrorCtx_EncounteredError</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>UndoLog_Rollback</name><argument_list>(<argument><expr><name><name>query_ctx</name><operator>-&gt;</operator><name>undo_log</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// clear resultset statistics, avoiding commnad being replicated</comment>
		<expr_stmt><expr><call><name>ResultSet_Clear</name><argument_list>(<argument><expr><name>result_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<comment type="line">// replicate command if graph was modified</comment>
	<if_stmt><if>if<condition>(<expr><call><name>ResultSetStat_IndicateModification</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result_set</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>QueryCtx_Replicate</name><argument_list>(<argument><expr><name>query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><call><name>QueryCtx_UnlockCommit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>profile</name> <operator>||</operator> <call><name>ErrorCtx_EncounteredError</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="line">// if we encountered an error, ResultSet_Reply will emit the error</comment>
		<comment type="line">// send result-set back to client</comment>
		<expr_stmt><expr><call><name>ResultSet_Reply</name><argument_list>(<argument><expr><name>result_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>readonly</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>Graph_ReleaseLock</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>g</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="line">// release read lock</comment>

	<comment type="line">// log query to slowlog</comment>
	<decl_stmt><decl><type><name>SlowLog</name> <modifier>*</modifier></type><name>slowlog</name> <init>= <expr><call><name>GraphContext_GetSlowLog</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SlowLog_Add</name><argument_list>(<argument><expr><name>slowlog</name></expr></argument>, <argument><expr><name><name>command_ctx</name><operator>-&gt;</operator><name>command_name</name></name></expr></argument>, <argument><expr><name><name>command_ctx</name><operator>-&gt;</operator><name>query</name></name></expr></argument>,
				<argument><expr><call><name>QueryCtx_GetExecutionTime</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// clean up</comment>
	<expr_stmt><expr><call><name>ExecutionCtx_Free</name><argument_list>(<argument><expr><name>exec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GraphContext_DecreaseRefCount</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommandCtx_Free</name><argument_list>(<argument><expr><name>command_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>QueryCtx_Free</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// reset the QueryCtx and free its allocations</comment>
	<expr_stmt><expr><call><name>ErrorCtx_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ResultSet_Free</name><argument_list>(<argument><expr><name>result_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GraphQueryCtx_Free</name><argument_list>(<argument><expr><name>gq_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_DelegateWriter</name><parameter_list>(<parameter><decl><type><name>GraphQueryCtx</name> <modifier>*</modifier></type><name>gq_ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>gq_ctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">//---------------------------------------------------------------------------</comment>
	<comment type="line">// Migrate to writer thread</comment>
	<comment type="line">//---------------------------------------------------------------------------</comment>

	<comment type="line">// write queries will be executed on a dedicated writer thread,</comment>
	<comment type="line">// clear this thread data</comment>
	<expr_stmt><expr><call><name>ErrorCtx_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>QueryCtx_RemoveFromTLS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// untrack the CommandCtx</comment>
	<expr_stmt><expr><call><name>CommandCtx_UntrackCtx</name><argument_list>(<argument><expr><name><name>gq_ctx</name><operator>-&gt;</operator><name>command_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// update execution thread to writer</comment>
	<expr_stmt><expr><name><name>gq_ctx</name><operator>-&gt;</operator><name>command_ctx</name><operator>-&gt;</operator><name>thread</name></name> <operator>=</operator> <name>EXEC_THREAD_WRITER</name></expr>;</expr_stmt>

	<comment type="line">// dispatch work to the writer thread</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>ThreadPools_AddWorkWriter</name><argument_list>(<argument><expr><name>_ExecuteQuery</name></expr></argument>, <argument><expr><name>gq_ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_query</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>profile</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>CommandCtx</name>     <modifier>*</modifier></type><name>command_ctx</name> <init>= <expr><operator>(</operator><name>CommandCtx</name> <operator>*</operator><operator>)</operator><name>args</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name>         <init>= <expr><call><name>CommandCtx_GetRedisCtx</name><argument_list>(<argument><expr><name>command_ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GraphContext</name>   <modifier>*</modifier></type><name>gc</name>          <init>= <expr><call><name>CommandCtx_GetGraphContext</name><argument_list>(<argument><expr><name>command_ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecutionCtx</name>   <modifier>*</modifier></type><name>exec_ctx</name>    <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CommandCtx_TrackCtx</name><argument_list>(<argument><expr><name>command_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>QueryCtx_SetGlobalExecutionCtx</name><argument_list>(<argument><expr><name>command_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>command_ctx</name><operator>-&gt;</operator><name>query</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Error: empty query."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>QueryCtx_BeginTimer</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// Start query timing.</comment>

	<comment type="line">// parse query parameters and build an execution plan or retrieve it from the cache</comment>
	<expr_stmt><expr><name>exec_ctx</name> <operator>=</operator> <call><name>ExecutionCtx_FromQuery</name><argument_list>(<argument><expr><name><name>command_ctx</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>exec_ctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>ExecutionType</name></type> <name>exec_type</name> <init>= <expr><name><name>exec_ctx</name><operator>-&gt;</operator><name>exec_type</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>profile</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>exec_type</name> <operator>==</operator> <name>EXECUTION_TYPE_INDEX_CREATE</name> <operator>||</operator>
	     <name>exec_type</name> <operator>==</operator> <name>EXECUTION_TYPE_INDEX_DROP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>RedisModule_ReplyWithError</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">"Can't profile index operations."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>readonly</name> <init>= <expr><call><name>AST_ReadOnly</name><argument_list>(<argument><expr><name><name>exec_ctx</name><operator>-&gt;</operator><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// write query executing via GRAPH.RO_QUERY isn't allowed</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>profile</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>readonly</name> <operator>&amp;&amp;</operator> <call><name>_readonly_cmd_mode</name><argument_list>(<argument><expr><name>command_ctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"graph.RO_QUERY is to be executed only on read-only queries"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>CronTaskHandle</name></type> <name>timeout_task</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="line">// enforce specified timeout when query is readonly</comment>
	<comment type="line">// or timeout applies to both read and write</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>enforce_timeout</name> <init>= <expr><name><name>command_ctx</name><operator>-&gt;</operator><name>timeout</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>readonly</name> <operator>||</operator> <name><name>command_ctx</name><operator>-&gt;</operator><name>timeout_rw</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>command_ctx</name><operator>-&gt;</operator><name>replicated_command</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>enforce_timeout</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>timeout_task</name> <operator>=</operator> <call><name>Query_SetTimeOut</name><argument_list>(<argument><expr><name><name>command_ctx</name><operator>-&gt;</operator><name>timeout</name></name></expr></argument>, <argument><expr><name><name>exec_ctx</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// populate the container struct for invoking _ExecuteQuery.</comment>
	<decl_stmt><decl><type><name>GraphQueryCtx</name> <modifier>*</modifier></type><name>gq_ctx</name> <init>= <expr><call><name>GraphQueryCtx_New</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>exec_ctx</name></expr></argument>, <argument><expr><name>command_ctx</name></expr></argument>,
											  <argument><expr><name>readonly</name></expr></argument>, <argument><expr><name>profile</name></expr></argument>, <argument><expr><name>timeout_task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// if 'thread' is redis main thread, continue running</comment>
	<comment type="line">// if readonly is true we're executing on a worker thread from</comment>
	<comment type="line">// the read-only threadpool</comment>
	<if_stmt><if>if<condition>(<expr><name>readonly</name> <operator>||</operator> <name><name>command_ctx</name><operator>-&gt;</operator><name>thread</name></name> <operator>==</operator> <name>EXEC_THREAD_MAIN</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_ExecuteQuery</name><argument_list>(<argument><expr><name>gq_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>_DelegateWriter</name><argument_list>(<argument><expr><name>gq_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return;</return>

<label><name>cleanup</name>:</label>
	<comment type="line">// if there were any query compile time errors, report them</comment>
	<if_stmt><if>if<condition>(<expr><call><name>ErrorCtx_EncounteredError</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ErrorCtx_EmitException</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Cleanup routine invoked after encountering errors in this function.</comment>
	<expr_stmt><expr><call><name>ExecutionCtx_Free</name><argument_list>(<argument><expr><name>exec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GraphContext_DecreaseRefCount</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommandCtx_Free</name><argument_list>(<argument><expr><name>command_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>QueryCtx_Free</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// Reset the QueryCtx and free its allocations.</comment>
	<expr_stmt><expr><call><name>ErrorCtx_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>Graph_Profile</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>_query</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>Graph_Query</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>_query</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
