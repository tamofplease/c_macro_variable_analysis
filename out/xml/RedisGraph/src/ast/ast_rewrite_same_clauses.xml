<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/src/ast/ast_rewrite_same_clauses.c"><comment type="block">/*
 * Copyright Redis Ltd. 2018 - present
 * Licensed under your choice of the Redis Source Available License 2.0 (RSALv2) or
 * the Server Side Public License v1 (SSPLv1).
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../query_ctx.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../errors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/arr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/qsort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/sds/sds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../procedures/procedure.h"</cpp:file></cpp:include>

<comment type="line">// compressing multiple consecutive CREATE clauses into a single CREATE clause</comment>
<comment type="line">// this function collects all patterns scattered across multiple CREATE clauses</comment>
<comment type="line">// and combines them into a single CREATE clause</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>replace_create_clause</name>
<parameter_list>(
	<parameter><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,      <comment type="line">// ast root</comment>
	<parameter><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>clauses</name></decl></parameter>,  <comment type="line">// clause being replaced</comment>
	<parameter><decl><type><name>int</name></type> <name>scope_start</name></decl></parameter>,             <comment type="line">// beginning of scope</comment>
	<parameter><decl><type><name>int</name></type> <name>scope_end</name></decl></parameter>                <comment type="line">// ending of scope</comment>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name><name>struct</name> <name>cypher_input_range</name></name></type> <name>range</name> <init>= <expr><call><name>cypher_astnode_range</name><argument_list>(<argument><expr><name><name>clauses</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>paths</name> <init>= <expr><call><name>array_new</name><argument_list>(<argument><expr><name>cypher_astnode_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// collect paths</comment>
	<for>for <control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>pattern</name> <init>=
			<expr><call><name>cypher_ast_create_get_pattern</name><argument_list>(<argument><expr><name><name>clauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint</name></type> <name>npaths</name> <init>= <expr><call><name>cypher_ast_pattern_npaths</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>npaths</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name> <init>=
				<expr><call><name>cypher_ast_pattern_get_path</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>paths</name></expr></argument>, <argument><expr><call><name>cypher_ast_clone</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	
	<comment type="line">// build the replacement pattern</comment>
	<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name>pattern</name> <init>= <expr><call><name>cypher_ast_pattern</name><argument_list>(<argument><expr><name>paths</name></expr></argument>, <argument><expr><call><name>array_len</name><argument_list>(<argument><expr><name>paths</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>paths</name></expr></argument>, <argument><expr><call><name>array_len</name><argument_list>(<argument><expr><name>paths</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	
	<comment type="line">// build the replacement clause</comment>
	<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name>new_clause</name> <init>= <expr><call><name>cypher_ast_create</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pattern</name></expr></argument>,
			<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// replace original clause with the new one</comment>
	<expr_stmt><expr><call><name>cypher_ast_query_replace_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>new_clause</name></expr></argument>, <argument><expr><name>scope_start</name></expr></argument>, <argument><expr><name>scope_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// compressing multiple consecutive MATCH clauses into a single MATCH clause</comment>
<comment type="line">// this function collects all patterns scattered across multiple MATCH clauses</comment>
<comment type="line">// and combines them into a single MATCH clause</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>replace_match_clause</name>
<parameter_list>(
	<parameter><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,      <comment type="line">// ast root</comment>
	<parameter><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>clauses</name></decl></parameter>,  <comment type="line">// clause being replaced</comment>
	<parameter><decl><type><name>int</name></type> <name>scope_start</name></decl></parameter>,             <comment type="line">// beginning of scope</comment>
	<parameter><decl><type><name>int</name></type> <name>scope_end</name></decl></parameter>                <comment type="line">// ending of scope</comment>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name>predicate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>cypher_input_range</name></name></type> <name>range</name> <init>= <expr><call><name>cypher_astnode_range</name><argument_list>(<argument><expr><name><name>clauses</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>paths</name> <init>= <expr><call><name>array_new</name><argument_list>(<argument><expr><name>cypher_astnode_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// collect MATCH patterns and predicates</comment>
	<for>for <control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>pattern</name> <init>=
			<expr><call><name>cypher_ast_match_get_pattern</name><argument_list>(<argument><expr><name><name>clauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint</name></type> <name>npaths</name> <init>= <expr><call><name>cypher_ast_pattern_npaths</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>npaths</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name> <init>=
				<expr><call><name>cypher_ast_pattern_get_path</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>paths</name></expr></argument>, <argument><expr><call><name>cypher_ast_clone</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
		</block_content>}</block></for>

		<comment type="line">// combine MATCH predicates into a single predicate using AND connectors</comment>
		<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name>new_predicate</name> <init>=
			<expr><operator>(</operator><name>cypher_astnode_t</name> <operator>*</operator><operator>)</operator><call><name>cypher_ast_match_get_predicate</name><argument_list>(<argument><expr><name><name>clauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>new_predicate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>new_predicate</name> <operator>=</operator> <call><name>cypher_ast_clone</name><argument_list>(<argument><expr><name>new_predicate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name>predicate</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>predicate</name> <operator>=</operator> <name>new_predicate</name></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<comment type="line">// concat using AND</comment>
				<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name><name>children</name><index>[]</index></name> <init>= <expr><block>{<expr><name>predicate</name></expr>, <expr><name>new_predicate</name></expr>}</block></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>predicate</name> <operator>=</operator> <call><name>cypher_ast_binary_operator</name><argument_list>(<argument><expr><name>CYPHER_OP_AND</name></expr></argument>, <argument><expr><name>predicate</name></expr></argument>,
						<argument><expr><name>new_predicate</name></expr></argument>, <argument><expr><name>children</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	
	<comment type="line">// build the replacement pattern</comment>
	<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name>pattern</name> <init>=
		<expr><call><name>cypher_ast_pattern</name><argument_list>(<argument><expr><name>paths</name></expr></argument>, <argument><expr><call><name>array_len</name><argument_list>(<argument><expr><name>paths</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>paths</name></expr></argument>, <argument><expr><call><name>array_len</name><argument_list>(<argument><expr><name>paths</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	
	<comment type="line">// build the replacement clause</comment>
	<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name><name>children</name><index>[]</index></name> <init>= <expr><block>{<expr><name>pattern</name></expr>, <expr><name>predicate</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name>new_clause</name> <init>= <expr><call><name>cypher_ast_match</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			<argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>children</name></expr></argument>, <argument><expr><ternary><condition><expr><name>predicate</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// replace original clause with the new one</comment>
	<expr_stmt><expr><call><name>cypher_ast_query_replace_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>new_clause</name></expr></argument>, <argument><expr><name>scope_start</name></expr></argument>, <argument><expr><name>scope_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// compressing multiple consecutive DELETE clauses into a single DELETE clause</comment>
<comment type="line">// this function collects all expressions scattered across multiple DELETE</comment>
<comment type="line">// clauses and combines them into a single DELETE clause</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>replace_delete_clause</name>
<parameter_list>(
	<parameter><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,      <comment type="line">// ast root</comment>
	<parameter><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>clauses</name></decl></parameter>,  <comment type="line">// clause being replaced</comment>
	<parameter><decl><type><name>int</name></type> <name>scope_start</name></decl></parameter>,             <comment type="line">// beginning of scope</comment>
	<parameter><decl><type><name>int</name></type> <name>scope_end</name></decl></parameter>                <comment type="line">// ending of scope</comment>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name><name>struct</name> <name>cypher_input_range</name></name></type> <name>range</name> <init>= <expr><call><name>cypher_astnode_range</name><argument_list>(<argument><expr><name><name>clauses</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>exps</name> <init>= <expr><call><name>array_new</name><argument_list>(<argument><expr><name>cypher_astnode_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>identifiers</name> <init>= <expr><call><name>raxNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// collect expressions</comment>
	<for>for <control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>uint</name></type> <name>nexps</name> <init>= <expr><call><name>cypher_ast_delete_nexpressions</name><argument_list>(<argument><expr><name><name>clauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nexps</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>exp</name> <init>=
				<expr><call><name>cypher_ast_delete_get_expression</name><argument_list>(<argument><expr><name><name>clauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			
			<comment type="line">// do not aggregate multiple appearances of an identifier</comment>
			<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr>)</condition> <block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>identifier</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if<condition>(<expr><call><name>raxTryInsert</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>identifier</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>exps</name></expr></argument>, <argument><expr><call><name>cypher_ast_clone</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// build the replacement clause</comment>
	<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name>new_clause</name> <init>= <expr><call><name>cypher_ast_delete</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>exps</name></expr></argument>,
			<argument><expr><call><name>array_len</name><argument_list>(<argument><expr><name>exps</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exps</name></expr></argument>, <argument><expr><call><name>array_len</name><argument_list>(<argument><expr><name>exps</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// replace original clause with the new one</comment>
	<expr_stmt><expr><call><name>cypher_ast_query_replace_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>new_clause</name></expr></argument>, <argument><expr><name>scope_start</name></expr></argument>, <argument><expr><name>scope_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>exps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// compressing multiple consecutive SET clauses into a single SET clause</comment>
<comment type="line">// this function collects all expressions scattered across multiple SET</comment>
<comment type="line">// clauses and combines them into a single SET clause</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>replace_set_clause</name>
<parameter_list>(
	<parameter><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,      <comment type="line">// ast root</comment>
	<parameter><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>clauses</name></decl></parameter>,  <comment type="line">// clause being replaced</comment>
	<parameter><decl><type><name>int</name></type> <name>scope_start</name></decl></parameter>,             <comment type="line">// beginning of scope</comment>
	<parameter><decl><type><name>int</name></type> <name>scope_end</name></decl></parameter>                <comment type="line">// ending of scope</comment>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name><name>struct</name> <name>cypher_input_range</name></name></type> <name>range</name> <init>= <expr><call><name>cypher_astnode_range</name><argument_list>(<argument><expr><name><name>clauses</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>items</name> <init>= <expr><call><name>array_new</name><argument_list>(<argument><expr><name>cypher_astnode_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>uint</name></type> <name>nitems</name> <init>= <expr><call><name>cypher_ast_set_nitems</name><argument_list>(<argument><expr><name><name>clauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>item</name> <init>=
				<expr><call><name>cypher_ast_set_get_item</name><argument_list>(<argument><expr><name><name>clauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><call><name>cypher_ast_clone</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	
	<comment type="line">// build the replacement clause</comment>
	<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name>new_clause</name> <init>= <expr><call><name>cypher_ast_set</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><call><name>array_len</name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>items</name></expr></argument>, <argument><expr><call><name>array_len</name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// replace original clause with the new one</comment>
	<expr_stmt><expr><call><name>cypher_ast_query_replace_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>new_clause</name></expr></argument>, <argument><expr><name>scope_start</name></expr></argument>, <argument><expr><name>scope_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// compressing multiple consecutive REMOVE clauses into a single REMOVE clause</comment>
<comment type="line">// this function collects all expressions scattered across multiple REMOVE</comment>
<comment type="line">// clauses and combines them into a single REMOVE clause</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>replace_remove_clause</name>
<parameter_list>(
	<parameter><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,      <comment type="line">// ast root</comment>
	<parameter><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>clauses</name></decl></parameter>,  <comment type="line">// clause being replaced</comment>
	<parameter><decl><type><name>int</name></type> <name>scope_start</name></decl></parameter>,             <comment type="line">// beginning of scope</comment>
	<parameter><decl><type><name>int</name></type> <name>scope_end</name></decl></parameter>                <comment type="line">// ending of scope</comment>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name><name>struct</name> <name>cypher_input_range</name></name></type> <name>range</name> <init>= <expr><call><name>cypher_astnode_range</name><argument_list>(<argument><expr><name><name>clauses</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>items</name> <init>= <expr><call><name>array_new</name><argument_list>(<argument><expr><name>cypher_astnode_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>uint</name></type> <name>nitems</name> <init>= <expr><call><name>cypher_ast_remove_nitems</name><argument_list>(<argument><expr><name><name>clauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>item</name> <init>=
				<expr><call><name>cypher_ast_remove_get_item</name><argument_list>(<argument><expr><name><name>clauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><call><name>cypher_ast_clone</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	
	<comment type="line">// build the replacement clause</comment>
	<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name>new_clause</name> <init>=
		<expr><call><name>cypher_ast_remove</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><call><name>array_len</name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>items</name></expr></argument>, <argument><expr><call><name>array_len</name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// replace original clause with fully populated one</comment>
	<expr_stmt><expr><call><name>cypher_ast_query_replace_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>new_clause</name></expr></argument>, <argument><expr><name>scope_start</name></expr></argument>, <argument><expr><name>scope_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// returns true if AST clause type is compressible</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>is_compressible</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// compressible clauses:</comment>
	<comment type="line">// 1. None OPTIONAL MATCH</comment>
	<comment type="line">// 2. CREATE</comment>
	<comment type="line">// 3. SET</comment>
	<comment type="line">// 4. DELETE</comment>
	<comment type="line">// 5. REMOVE</comment>
	<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>t</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><operator>(</operator> <operator>(</operator><name>t</name> <operator>==</operator> <name>CYPHER_AST_MATCH</name> <operator>&amp;&amp;</operator>
			  <operator>!</operator><call><name>cypher_ast_match_is_optional</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
			  <name>t</name> <operator>==</operator> <name>CYPHER_AST_CREATE</name>                 <operator>||</operator>
			  <name>t</name> <operator>==</operator> <name>CYPHER_AST_SET</name>                    <operator>||</operator>
			  <name>t</name> <operator>==</operator> <name>CYPHER_AST_DELETE</name>                 <operator>||</operator>
			  <name>t</name> <operator>==</operator> <name>CYPHER_AST_REMOVE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="line">// rewrite result by compressing consecutive clauses of the same type</comment>
<comment type="line">// to a single clause, returning true if the rewrite has been performed</comment>
<function><type><name>bool</name></type> <name>AST_RewriteSameClauses</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name></decl></parameter> <comment type="line">// root of AST</comment>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>rewritten</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	
	<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CYPHER_AST_STATEMENT</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>rewritten</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// retrieve the root's body</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>body</name> <init>= <expr><call><name>cypher_ast_statement_get_body</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CYPHER_AST_QUERY</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>rewritten</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>clause_count</name> <init>= <expr><call><name>cypher_ast_query_nclauses</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// traverse clauses</comment>
	<comment type="line">// compress consecutive clauses</comment>
	<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>clauses</name> <init>= <expr><call><name>array_new</name><argument_list>(<argument><expr><name>cypher_astnode_t</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>clause_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>t</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// check compressibility, move on if not compressible</comment>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>is_compressible</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="line">//----------------------------------------------------------------------</comment>
		<comment type="line">// collect clauses of the same type as current clause</comment>
		<comment type="line">//----------------------------------------------------------------------</comment>

		<for>for <control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><name>i</name></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>clause_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>t2</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><name>t2</name> <operator>!=</operator> <name>t</name> <operator>||</operator> <operator>!</operator><call><name>is_compressible</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>, <argument><expr><operator>(</operator><name>cypher_astnode_t</name> <operator>*</operator><operator>)</operator><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="line">//----------------------------------------------------------------------</comment>
		<comment type="line">// compress clauses</comment>
		<comment type="line">//----------------------------------------------------------------------</comment>

		<decl_stmt><decl><type><name>uint</name></type> <name>s</name> <init>= <expr><name>i</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint</name></type> <name>e</name> <init>= <expr><name>s</name> <operator>+</operator> <call><name>array_len</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>array_len</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
			<comment type="line">// multiple consecutive clauses of the same type</comment>
			<comment type="line">// compress them</comment>
			<if_stmt><if>if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_CREATE</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>replace_create_clause</name><argument_list>(<argument><expr><operator>(</operator><name>cypher_astnode_t</name> <operator>*</operator><operator>)</operator><name>body</name></expr></argument>, <argument><expr><name>clauses</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_MATCH</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>replace_match_clause</name><argument_list>(<argument><expr><operator>(</operator><name>cypher_astnode_t</name> <operator>*</operator><operator>)</operator><name>body</name></expr></argument>, <argument><expr><name>clauses</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_DELETE</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>replace_delete_clause</name><argument_list>(<argument><expr><operator>(</operator><name>cypher_astnode_t</name> <operator>*</operator><operator>)</operator><name>body</name></expr></argument>, <argument><expr><name>clauses</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_SET</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>replace_set_clause</name><argument_list>(<argument><expr><operator>(</operator><name>cypher_astnode_t</name> <operator>*</operator><operator>)</operator><name>body</name></expr></argument>, <argument><expr><name>clauses</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_REMOVE</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>replace_remove_clause</name><argument_list>(<argument><expr><operator>(</operator><name>cypher_astnode_t</name> <operator>*</operator><operator>)</operator><name>body</name></expr></argument>, <argument><expr><name>clauses</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>rewritten</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="line">// update clause count, skip compressed clauses</comment>
			<expr_stmt><expr><name>clause_count</name> <operator>-=</operator> <call><name>array_len</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>array_clear</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rewritten</name></expr>;</return>
</block_content>}</block></function>

</unit>
