<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/src/ast/ast_build_reference_map.c"><comment type="block">/*
 * Copyright Redis Ltd. 2018 - present
 * Licensed under your choice of the Redis Source Available License 2.0 (RSALv2) or
 * the Server Side Public License v1 (SSPLv1).
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"RG.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/arr.h"</cpp:file></cpp:include>

<comment type="line">// Forward declerations:</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapReferencedEntitiesInPath</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
											 <parameter><decl><type><name>bool</name></type> <name>force_mapping</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Check if a path is a named path or shortest path.
 * If so, all the entities it contains should be mapped,
 * otherwise only referenced entities should be mapped. */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>_shouldForceMapping</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><operator>(</operator><name>type</name> <operator>==</operator> <name>CYPHER_AST_NAMED_PATH</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>CYPHER_AST_SHORTEST_PATH</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Adds an identifier or an alias to the reference map.</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>_AST_UpdateRefMap</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>referenced_entities</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Map identifiers within an expression.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapExpression</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>exp</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// In case of identifier.</comment>
	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>identifier_name</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_AST_UpdateRefMap</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>identifier_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_PATTERN_PATH</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// In case of pattern filter or path projection.</comment>
		<expr_stmt><expr><call><name>_AST_MapReferencedEntitiesInPath</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>exp</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_SHORTEST_PATH</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Reference all entity names in a shortest path.</comment>
		<expr_stmt><expr><call><name>_AST_MapReferencedEntitiesInPath</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>exp</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="line">// Recurse over children.</comment>
		<decl_stmt><decl><type><name>uint</name></type> <name>child_count</name> <init>= <expr><call><name>cypher_astnode_nchildren</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>child_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>cypher_astnode_get_child</name><argument_list>(<argument><expr><name>exp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="line">// Recursively continue mapping.</comment>
			<expr_stmt><expr><call><name>_AST_MapExpression</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">// Maps the RHS of "AS" projected entities.</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>_AST_MapProjectionAlias</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>projection</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_alias</name> <init>= <expr><call><name>cypher_ast_projection_get_alias</name><argument_list>(<argument><expr><name>projection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>ast_alias</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// The projection was not aliased, so the projection itself must be an identifier.</comment>
		<expr_stmt><expr><name>ast_alias</name> <operator>=</operator> <call><name>cypher_ast_projection_get_expression</name><argument_list>(<argument><expr><name>projection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>ast_alias</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="line">// WITH and RETURN projections are always either aliased or themselves identifiers.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>ast_alias</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_AST_UpdateRefMap</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Adds referenced entities of ORDER BY clause.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapOrderByReferences</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>order_by</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>count</name> <init>= <expr><call><name>cypher_ast_order_by_nitems</name><argument_list>(<argument><expr><name>order_by</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// Go over each order by expression.</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>cypher_ast_order_by_get_item</name><argument_list>(<argument><expr><name>order_by</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expression</name> <init>= <expr><call><name>cypher_ast_sort_item_get_expression</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_AST_MapExpression</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="line">// Adds a node to the referenced entities rax, in case it has labels or properties (inline filter).</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapReferencedNode</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_mapping</name></decl></parameter>)</parameter_list> <block>{<block_content>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>properties</name> <init>= <expr><call><name>cypher_ast_node_pattern_get_properties</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// Disregard empty property maps.</comment>
	<if_stmt><if>if<condition>(<expr><name>properties</name> <operator>&amp;&amp;</operator> <call><name>cypher_astnode_nchildren</name><argument_list>(<argument><expr><name>properties</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>properties</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="line">// A node with inlined filters is always referenced for the FilterTree.</comment>
	<comment type="line">// (In the case of a CREATE path, these are properties being set)</comment>
	<if_stmt><if>if<condition>(<expr><name>properties</name> <operator>||</operator> <name>force_mapping</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>AST_ToString</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_AST_UpdateRefMap</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Map any references within the properties map, such as 'b' in:</comment>
		<comment type="line">// ({val: ID(b)})</comment>
		<if_stmt><if>if<condition>(<expr><name>properties</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>_AST_MapExpression</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>properties</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// Adds an edge to the referenced entities rax if it has multiple types or any properties (inline filter).</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapReferencedEdge</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_mapping</name></decl></parameter>)</parameter_list> <block>{<block_content>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>properties</name> <init>= <expr><call><name>cypher_ast_rel_pattern_get_properties</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// Disregard empty property maps.</comment>
	<if_stmt><if>if<condition>(<expr><name>properties</name> <operator>&amp;&amp;</operator> <call><name>cypher_astnode_nchildren</name><argument_list>(<argument><expr><name>properties</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>properties</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="line">// An edge with inlined filters is always referenced for the FilterTree.</comment>
	<comment type="line">// (In the case of a CREATE path, these are properties being set)</comment>
	<if_stmt><if>if<condition>(<expr><name>properties</name> <operator>||</operator> <name>force_mapping</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>AST_ToString</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_AST_UpdateRefMap</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Map any references within the properties map, such as 'b' in:</comment>
		<comment type="line">// ({val: ID(b)})</comment>
		<if_stmt><if>if<condition>(<expr><name>properties</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>_AST_MapExpression</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>properties</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// Maps entities in a given path.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapReferencedEntitiesInPath</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
											 <parameter><decl><type><name>bool</name></type> <name>force_mapping</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>path_len</name> <init>= <expr><call><name>cypher_ast_pattern_path_nelements</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// Node are in even positions.</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>path_len</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_AST_MapReferencedNode</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>force_mapping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<comment type="line">// Edges are in odd positions.</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>path_len</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_AST_MapReferencedEdge</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>force_mapping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="line">// Add referenced aliases from MATCH clause - inline filtered and explicit WHERE filter.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapMatchClauseReferences</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>match_clause</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// Inline filters.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>pattern</name> <init>= <expr><call><name>cypher_ast_match_get_pattern</name><argument_list>(<argument><expr><name>match_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>path_count</name> <init>= <expr><call><name>cypher_ast_pattern_npaths</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>path_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>cypher_ast_pattern_get_path</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>force_mapping</name> <init>= <expr><call><name>_shouldForceMapping</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_AST_MapReferencedEntitiesInPath</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>force_mapping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="line">// Where clause.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>predicate</name> <init>= <expr><call><name>cypher_ast_match_get_predicate</name><argument_list>(<argument><expr><name>match_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>predicate</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>_AST_MapExpression</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>predicate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// Add referenced aliases from CREATE clause.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapCreateClauseReferences</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>create_clause</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>pattern</name> <init>= <expr><call><name>cypher_ast_create_get_pattern</name><argument_list>(<argument><expr><name>create_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>path_count</name> <init>= <expr><call><name>cypher_ast_pattern_npaths</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>path_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>cypher_ast_pattern_get_path</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>force_mapping</name> <init>= <expr><call><name>_shouldForceMapping</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_AST_MapReferencedEntitiesInPath</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>force_mapping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="line">// Maps entities in SET clauses that update an individual property.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapSetPropertyReferences</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>set_item</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// Retrieve the alias being modified from the property descriptor.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_prop</name> <init>= <expr><call><name>cypher_ast_set_property_get_property</name><argument_list>(<argument><expr><name>set_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_entity</name> <init>= <expr><call><name>cypher_ast_property_operator_get_expression</name><argument_list>(<argument><expr><name>ast_prop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>ast_entity</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>ast_entity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_AST_UpdateRefMap</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Map expression right hand side, e.g. a.v = 1, a.x = b.x</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>set_exp</name> <init>= <expr><call><name>cypher_ast_set_property_get_expression</name><argument_list>(<argument><expr><name>set_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_AST_MapExpression</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>set_exp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// maps entities in SET clauses that update labels</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapSetLabelsReferences</name>
<parameter_list>(
	<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>set_item</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>set_item</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_SET_LABELS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>identifier</name> <init>=
		<expr><call><name>cypher_ast_set_labels_get_identifier</name><argument_list>(<argument><expr><name>set_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_AST_UpdateRefMap</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Maps entities in SET clauses that replace all properties.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapSetAllPropertiesReferences</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>set_item</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// Retrieve the alias being modified.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_alias</name> <init>= <expr><call><name>cypher_ast_set_all_properties_get_identifier</name><argument_list>(<argument><expr><name>set_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>ast_alias</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>ast_alias</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_AST_UpdateRefMap</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Map expression right hand side, e.g. a = {v: b.v}</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>set_exp</name> <init>= <expr><call><name>cypher_ast_set_all_properties_get_expression</name><argument_list>(<argument><expr><name>set_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_AST_MapExpression</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>set_exp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Maps entities in SET clauses that merge multiple properties.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapMergePropertiesReferences</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>set_item</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// Retrieve the alias being modified.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_alias</name> <init>= <expr><call><name>cypher_ast_merge_properties_get_identifier</name><argument_list>(<argument><expr><name>set_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>ast_alias</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>ast_alias</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_AST_UpdateRefMap</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Map expression right hand side, e.g. a += {v: b.v}</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>set_exp</name> <init>= <expr><call><name>cypher_ast_merge_properties_get_expression</name><argument_list>(<argument><expr><name>set_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_AST_MapExpression</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>set_exp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapSetItemReferences</name>
<parameter_list>(
	<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>set_item</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>set_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_SET_PROPERTY</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_AST_MapSetPropertyReferences</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>set_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_SET_ALL_PROPERTIES</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_AST_MapSetAllPropertiesReferences</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>set_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_MERGE_PROPERTIES</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_AST_MapMergePropertiesReferences</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>set_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_SET_LABELS</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_AST_MapSetLabelsReferences</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>set_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">// Maps entities in SET clause.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapSetClauseReferences</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>set_clause</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>nitems</name> <init>= <expr><call><name>cypher_ast_set_nitems</name><argument_list>(<argument><expr><name>set_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<comment type="line">// Get the SET directive at this index.</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>set_item</name> <init>= <expr><call><name>cypher_ast_set_get_item</name><argument_list>(<argument><expr><name>set_clause</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_AST_MapSetItemReferences</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>set_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapRemovePropertyReferences</name>
<parameter_list>(
	<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>remove_item</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>remove_item</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_REMOVE_PROPERTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_prop</name> <init>=
		<expr><call><name>cypher_ast_remove_property_get_property</name><argument_list>(<argument><expr><name>remove_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_entity</name> <init>=
		<expr><call><name>cypher_ast_property_operator_get_expression</name><argument_list>(<argument><expr><name>ast_prop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>ast_entity</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>ast_entity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_AST_UpdateRefMap</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// maps entities in REMOVE clauses that update labels</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapRemoveLabelsReferences</name>
<parameter_list>(
	<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>remove_item</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>ast</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>remove_item</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>remove_item</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_REMOVE_LABELS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>identifier</name> <init>=
		<expr><call><name>cypher_ast_remove_labels_get_identifier</name><argument_list>(<argument><expr><name>remove_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_AST_UpdateRefMap</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapRemoveItemReferences</name>
<parameter_list>(
	<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>remove_item</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>ast</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>remove_item</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>remove_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_REMOVE_LABELS</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_AST_MapRemoveLabelsReferences</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>remove_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_REMOVE_PROPERTY</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_AST_MapRemovePropertyReferences</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>remove_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">// maps entities in REMOVE clause</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapRemoveClauseReferences</name>
<parameter_list>(
	<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>remove_clause</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>ast</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>remove_clause</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>nitems</name> <init>= <expr><call><name>cypher_ast_remove_nitems</name><argument_list>(<argument><expr><name>remove_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<comment type="line">// get the SET directive at this index</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>set_item</name> <init>=
			<expr><call><name>cypher_ast_remove_get_item</name><argument_list>(<argument><expr><name>remove_clause</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_AST_MapRemoveItemReferences</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>set_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="line">// maps entities in UNWIND clause</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapUnwindClauseReferences</name>
<parameter_list>(
	<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>unwind_clause</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>ast</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>unwind_clause</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type> <name>expr</name> <init>= <expr><call><name>cypher_ast_unwind_get_expression</name><argument_list>(<argument><expr><name>unwind_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_AST_MapExpression</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// maps entities in DELETE clause</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapDeleteClauseReferences</name>
<parameter_list>(
	<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>delete_clause</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>ast</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>delete_clause</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>nitems</name> <init>= <expr><call><name>cypher_ast_delete_nexpressions</name><argument_list>(<argument><expr><name>delete_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>delete_exp</name> <init>=
			<expr><call><name>cypher_ast_delete_get_expression</name><argument_list>(<argument><expr><name>delete_clause</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_AST_MapExpression</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>delete_exp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="line">// Maps entities in MERGE clause. Either by implicit filters, or modified entities by SET clause.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapMergeClauseReference</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>merge_clause</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// Collect implicitly filtered entities.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>merge_path</name> <init>= <expr><call><name>cypher_ast_merge_get_pattern_path</name><argument_list>(<argument><expr><name>merge_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>force_mapping</name> <init>= <expr><call><name>_shouldForceMapping</name><argument_list>(<argument><expr><name>merge_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_AST_MapReferencedEntitiesInPath</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>merge_path</name></expr></argument>, <argument><expr><name>force_mapping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Map modified entities, either by ON MATCH or ON CREATE clause.</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>merge_actions</name> <init>= <expr><call><name>cypher_ast_merge_nactions</name><argument_list>(<argument><expr><name>merge_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>merge_actions</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>action</name> <init>= <expr><call><name>cypher_ast_merge_get_action</name><argument_list>(<argument><expr><name>merge_clause</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// ON CREATE.</comment>
		<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_ON_CREATE</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>uint</name></type> <name>on_create_items</name> <init>= <expr><call><name>cypher_ast_on_create_nitems</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>on_create_items</name></expr>;</condition> <incr><expr><name>j</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>set_item</name> <init>= <expr><call><name>cypher_ast_on_create_get_item</name><argument_list>(<argument><expr><name>action</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>_AST_MapSetItemReferences</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>set_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_ON_MATCH</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// ON MATCH.</comment>
			<decl_stmt><decl><type><name>uint</name></type> <name>on_match_items</name> <init>= <expr><call><name>cypher_ast_on_match_nitems</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>on_match_items</name></expr>;</condition> <incr><expr><name>j</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>set_item</name> <init>= <expr><call><name>cypher_ast_on_match_get_item</name><argument_list>(<argument><expr><name>action</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>_AST_MapSetItemReferences</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>set_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="line">// Map the LHS of "AS" projected entities. "WITH a as x order by x" will just collect a to the map.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapWithReferredEntities</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast_segment</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>with_clause</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>projectionCount</name> <init>= <expr><call><name>cypher_ast_with_nprojections</name><argument_list>(<argument><expr><name>with_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>projectionCount</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>projection</name> <init>= <expr><call><name>cypher_ast_with_get_projection</name><argument_list>(<argument><expr><name>with_clause</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// The expression forms the LHS of the projection.</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>exp</name> <init>= <expr><call><name>cypher_ast_projection_get_expression</name><argument_list>(<argument><expr><name>projection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_AST_MapExpression</name><argument_list>(<argument><expr><name>ast_segment</name></expr></argument>, <argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="line">// Add referenced aliases for WITH's ORDER BY entities.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>order_by</name> <init>= <expr><call><name>cypher_ast_with_get_order_by</name><argument_list>(<argument><expr><name>with_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>order_by</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>_AST_MapOrderByReferences</name><argument_list>(<argument><expr><name>ast_segment</name></expr></argument>, <argument><expr><name>order_by</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// Map the LHS of "AS" projected entities. "RETURN a as x order by x" will just collect a to the map.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapReturnReferredEntities</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast_segment</name></decl></parameter>,
										   <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>return_clause</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// Add referenced aliases for RETURN projections.</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>projectionCount</name> <init>= <expr><call><name>cypher_ast_return_nprojections</name><argument_list>(<argument><expr><name>return_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>projectionCount</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>projection</name> <init>= <expr><call><name>cypher_ast_return_get_projection</name><argument_list>(<argument><expr><name>return_clause</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// The expression forms the LHS of the projection.</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>exp</name> <init>= <expr><call><name>cypher_ast_projection_get_expression</name><argument_list>(<argument><expr><name>projection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_AST_MapExpression</name><argument_list>(<argument><expr><name>ast_segment</name></expr></argument>, <argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="line">// Add referenced aliases for RETURN's ORDER BY entities.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>order_by</name> <init>= <expr><call><name>cypher_ast_return_get_order_by</name><argument_list>(<argument><expr><name>return_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>order_by</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>_AST_MapOrderByReferences</name><argument_list>(<argument><expr><name>ast_segment</name></expr></argument>, <argument><expr><name>order_by</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_ASTClause_BuildReferenceMap</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>clause</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_RETURN</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// add referenced aliases for RETURN projections</comment>
		<decl_stmt><decl><type><name>uint</name></type> <name>projectionCount</name> <init>= <expr><call><name>cypher_ast_return_nprojections</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>projectionCount</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>_AST_MapProjectionAlias</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><call><name>cypher_ast_return_get_projection</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<comment type="line">// add referenced aliases for RETURN's ORDER BY entities</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>order_by</name> <init>= <expr><call><name>cypher_ast_return_get_order_by</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>order_by</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>_AST_MapOrderByReferences</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>order_by</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_WITH</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// add referenced aliases for WITH projections</comment>
		<decl_stmt><decl><type><name>uint</name></type> <name>projectionCount</name> <init>= <expr><call><name>cypher_ast_with_nprojections</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>projectionCount</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>_AST_MapProjectionAlias</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><call><name>cypher_ast_with_get_projection</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<comment type="line">// add referenced aliases for WITH's ORDER BY entities</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>order_by</name> <init>= <expr><call><name>cypher_ast_with_get_order_by</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>order_by</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>_AST_MapOrderByReferences</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>order_by</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_MATCH</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// add referenced aliases from MATCH clause</comment>
		<comment type="line">// inline filtered and explicit WHERE filter</comment>
		<expr_stmt><expr><call><name>_AST_MapMatchClauseReferences</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_CREATE</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// add referenced aliases for CREATE clause</comment>
		<expr_stmt><expr><call><name>_AST_MapCreateClauseReferences</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_MERGE</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// add referenced aliases for MERGE clause</comment>
		<comment type="line">// inline filtered and modified entities</comment>
		<expr_stmt><expr><call><name>_AST_MapMergeClauseReference</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_SET</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// add referenced aliases for SET clause</comment>
		<expr_stmt><expr><call><name>_AST_MapSetClauseReferences</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_DELETE</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// add referenced aliases for DELETE clause</comment>
		<expr_stmt><expr><call><name>_AST_MapDeleteClauseReferences</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_REMOVE</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// add referenced aliases for REMOVE clause</comment>
		<expr_stmt><expr><call><name>_AST_MapRemoveClauseReferences</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_UNWIND</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// add referenced aliases for UNWIND clause</comment>
		<expr_stmt><expr><call><name>_AST_MapUnwindClauseReferences</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// Map the referred aliases (LHS) in entities projected by a WITH or RETURN clause.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_MapProjectionClause</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast_segment</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>projection</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>projection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_WITH</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>CYPHER_AST_RETURN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_WITH</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_AST_MapWithReferredEntities</name><argument_list>(<argument><expr><name>ast_segment</name></expr></argument>, <argument><expr><name>projection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>_AST_MapReturnReferredEntities</name><argument_list>(<argument><expr><name>ast_segment</name></expr></argument>, <argument><expr><name>projection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">// Populate the AST's map of all referenced aliases.</comment>
<function><type><name>void</name></type> <name>AST_BuildReferenceMap</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>project_clause</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>referenced_entities</name></name> <operator>=</operator> <call><name>raxNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// If this segment is followed by a projection clause, map that clause's references.</comment>
	<if_stmt><if>if<condition>(<expr><name>project_clause</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>_AST_MapProjectionClause</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>project_clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Check every clause in this AST.</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>clause_count</name> <init>= <expr><call><name>cypher_ast_query_nclauses</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>clause_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_ASTClause_BuildReferenceMap</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
</unit>
