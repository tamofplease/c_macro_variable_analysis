<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/src/ast/ast_rewrite_star_projections.c"><comment type="block">/*
 * Copyright Redis Ltd. 2018 - present
 * Licensed under your choice of the Redis Source Available License 2.0 (RSALv2) or
 * the Server Side Public License v1 (SSPLv1).
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../query_ctx.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../errors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/arr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/sds/sds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../procedures/procedure.h"</cpp:file></cpp:include>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">//  Annotation context - WITH/RETURN * projections</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_collect_aliases_in_path</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
	<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>identifiers</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>path_len</name> <init>= <expr><call><name>cypher_ast_pattern_path_nelements</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// every even offset corresponds to a node</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>path_len</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_node</name> <init>=
			<expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_alias</name> <init>=
			<expr><call><name>cypher_ast_node_pattern_get_identifier</name><argument_list>(<argument><expr><name>ast_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if<condition>(<expr><name>ast_alias</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>  <comment type="line">// unaliased node, do nothing</comment>

		<comment type="line">// add node alias to projection rax</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>identifier</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>ast_alias</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>raxTryInsert</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>identifier</name></expr></argument>,
			<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>ast_alias</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="line">// every odd offset corresponds to an edge</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>path_len</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_edge</name> <init>=
			<expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_alias</name> <init>=
			<expr><call><name>cypher_ast_rel_pattern_get_identifier</name><argument_list>(<argument><expr><name>ast_edge</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if<condition>(<expr><name>ast_alias</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>  <comment type="line">// unaliased edge, do nothing</comment>

		<comment type="line">// add edge alias to projection rax</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>identifier</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>ast_alias</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>raxTryInsert</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>identifier</name></expr></argument>,
			<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>ast_alias</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_collect_aliases_in_pattern</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>,
	<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>identifiers</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>path_count</name> <init>= <expr><call><name>cypher_ast_pattern_npaths</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>path_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>_collect_aliases_in_path</name><argument_list>(<argument><expr><call><name>cypher_ast_pattern_get_path</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_collect_with_projections</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>with_clause</name></decl></parameter>,
	<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>identifiers</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>projection_count</name> <init>= <expr><call><name>cypher_ast_with_nprojections</name><argument_list>(<argument><expr><name>with_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>projection_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>projection</name> <init>=
			<expr><call><name>cypher_ast_with_get_projection</name><argument_list>(<argument><expr><name>with_clause</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>identifier_node</name> <init>=
			<expr><call><name>cypher_ast_projection_get_alias</name><argument_list>(<argument><expr><name>projection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>identifier_node</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// the projection was not aliased</comment>
			<comment type="line">// so the projection itself must be an identifier</comment>
			<expr_stmt><expr><name>identifier_node</name> <operator>=</operator> <call><name>cypher_ast_projection_get_expression</name><argument_list>(<argument><expr><name>projection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>identifier_node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="line">// do not include empty projections, which may have been made to</comment>
			<comment type="line">// handle the MATCH () WITH * case</comment>
			<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>identifier_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>identifier</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>identifier_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>raxTryInsert</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>identifier</name></expr></argument>,
			<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>identifier_node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_collect_call_projections</name><parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>call_clause</name></decl></parameter>,
	<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>identifiers</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>yield_count</name> <init>= <expr><call><name>cypher_ast_call_nprojections</name><argument_list>(<argument><expr><name>call_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>yield_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="line">// error if this is a RETURN clause with no aliases</comment>
		<comment type="line">// e.g.</comment>
		<comment type="line">// CALL db.indexes() RETURN *</comment>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"RETURN * is not allowed when there are no variables in scope"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>yield_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>projection</name> <init>= <expr><call><name>cypher_ast_call_get_projection</name><argument_list>(<argument><expr><name>call_clause</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_exp</name> <init>= <expr><call><name>cypher_ast_projection_get_expression</name><argument_list>(<argument><expr><name>projection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>alias_node</name> <init>= <expr><call><name>cypher_ast_projection_get_alias</name><argument_list>(<argument><expr><name>projection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>alias_node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>alias_node</name> <operator>=</operator> <name>ast_exp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>identifier</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>alias_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>raxTryInsert</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>identifier</name></expr></argument>,
			<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>alias_node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_collect_aliases_in_scope</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
	<parameter><decl><type><name>uint</name></type> <name>scope_start</name></decl></parameter>,
	<parameter><decl><type><name>uint</name></type> <name>scope_end</name></decl></parameter>,
	<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>identifiers</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>scope_start</name> <operator>!=</operator> <name>scope_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>identifiers</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><name>scope_start</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>scope_end</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_WITH</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// the WITH clause contains either</comment>
			<comment type="line">// aliases or its own STAR projection</comment>
			<expr_stmt><expr><call><name>_collect_with_projections</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_MATCH</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// the MATCH clause contains one pattern of N paths</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>pattern</name> <init>=
				<expr><call><name>cypher_ast_match_get_pattern</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>_collect_aliases_in_pattern</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_CREATE</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// the CREATE clause contains one pattern of N paths</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>pattern</name> <init>=
				<expr><call><name>cypher_ast_create_get_pattern</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>_collect_aliases_in_pattern</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_MERGE</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// the MERGE clause contains one path</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name> <init>=
				<expr><call><name>cypher_ast_merge_get_pattern_path</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>_collect_aliases_in_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_UNWIND</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// the UNWIND clause introduces one alias</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>unwind_alias</name> <init>=
				<expr><call><name>cypher_ast_unwind_get_alias</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>identifier</name> <init>=
				<expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>unwind_alias</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>raxTryInsert</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>identifier</name></expr></argument>,
				<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>unwind_alias</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_CALL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>_collect_call_projections</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>replace_clause</name>
<parameter_list>(
	<parameter><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,    <comment type="line">// ast root</comment>
	<parameter><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,  <comment type="line">// clause being replaced</comment>
	<parameter><decl><type><name>int</name></type> <name>scope_start</name></decl></parameter>,           <comment type="line">// begining of scope</comment>
	<parameter><decl><type><name>int</name></type> <name>scope_end</name></decl></parameter>              <comment type="line">// ending of scope</comment>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>t</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">//--------------------------------------------------------------------------</comment>
	<comment type="line">// collect identifiers</comment>
	<comment type="line">//--------------------------------------------------------------------------</comment>
	<decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>identifiers</name> <init>= <expr><call><name>raxNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_collect_aliases_in_scope</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scope_start</name></expr></argument>, <argument><expr><name>scope_end</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>identifiers_count</name> <init>= <expr><call><name>raxSize</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">//--------------------------------------------------------------------------</comment>
	<comment type="line">// determine number of projections</comment>
	<comment type="line">//--------------------------------------------------------------------------</comment>

	<comment type="line">// `existing_projections_count` refers to explicit projections</comment>
	<comment type="line">// e.g.</comment>
	<comment type="line">// RETURN *, x, 1+2</comment>
	<comment type="line">// `x`, `1+2` are explicit projections</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>existing_projections_count</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>t</name> <operator>==</operator> <name>CYPHER_AST_WITH</name><operator>)</operator></expr> ?</condition><then>
		<expr><call><name>cypher_ast_with_nprojections</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr> </then><else>:
		<expr><call><name>cypher_ast_return_nprojections</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<comment type="line">//--------------------------------------------------------------------------</comment>
	<comment type="line">// remove explicit identifiers</comment>
	<comment type="line">//--------------------------------------------------------------------------</comment>

	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>existing_projections_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>projection</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>t</name> <operator>==</operator> <name>CYPHER_AST_WITH</name><operator>)</operator></expr> ?</condition><then>
			<expr><call><name>cypher_ast_with_get_projection</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> </then><else>:
			<expr><call><name>cypher_ast_return_get_projection</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<comment type="line">// if the projection has an alias use it,</comment>
		<comment type="line">// otherwise the expression is the alias</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>exp</name> <init>=
			<expr><call><name>cypher_ast_projection_get_alias</name><argument_list>(<argument><expr><name>projection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>exp</name> <operator>=</operator> <ternary><condition><expr><name>exp</name></expr> ?</condition><then> <expr><name>exp</name></expr> </then><else>: <expr><call><name>cypher_ast_projection_get_expression</name><argument_list>(<argument><expr><name>projection</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>identifier</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>identifier</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="line">// update identifiers_count after duplication removal</comment>
	<expr_stmt><expr><name>identifiers_count</name> <operator>=</operator> <call><name>raxSize</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// require atleast 1 projection</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>nprojections</name> <init>= <expr><name>identifiers_count</name> <operator>+</operator> <name>existing_projections_count</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>proj_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="line">// projections will be added to projections[proj_idx];</comment>
	<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name><name>projections</name><index>[<expr><name>nprojections</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="line">//--------------------------------------------------------------------------</comment>
	<comment type="line">// convert identifiers to expressions</comment>
	<comment type="line">//--------------------------------------------------------------------------</comment>

	<decl_stmt><decl><type><name>raxIterator</name></type> <name>it</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><literal type="string">"^"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>cypher_astnode_t</name><modifier>*</modifier></type>         <name>exp</name>        <init>= <expr><call><name>cypher_ast_clone</name><argument_list>(<argument><expr><name><name>it</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name><modifier>*</modifier></type>   <name>alias</name>      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>cypher_astnode_t</name><modifier>*</modifier><modifier>*</modifier></type>        <name>children</name>   <init>= <expr><operator>&amp;</operator><name>exp</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>              <name>nchildren</name>  <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>cypher_input_range</name></name></type> <name>range</name>      <init>= <expr><call><name>cypher_astnode_range</name><argument_list>(<argument><expr><name><name>it</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>projections</name><index>[<expr><name>proj_idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>cypher_ast_projection</name><argument_list>(<argument><expr><name>exp</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>children</name></expr></argument>,
				<argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">//--------------------------------------------------------------------------</comment>
	<comment type="line">// handle no projections</comment>
	<comment type="line">//--------------------------------------------------------------------------</comment>

	<comment type="line">// e.g.</comment>
	<comment type="line">// MATCH () RETURN *</comment>
	<comment type="line">// MATCH () WITH * RETURN *</comment>
	<if_stmt><if>if<condition>(<expr><name>nprojections</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_RETURN</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// error if this is a RETURN clause with no aliases</comment>
			<comment type="line">// e.g.</comment>
			<comment type="line">// MATCH () RETURN *</comment>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"RETURN * is not allowed when there are no variables in scope"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="line">// build an empty projection</comment>
			<comment type="line">// to make variable-less WITH clauses work:</comment>
			<comment type="line">// MATCH () WITH * CREATE ()</comment>
			<decl_stmt><decl><type><name><name>struct</name> <name>cypher_input_range</name></name></type> <name>range</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
			<comment type="line">// build a null node to project and an empty identifier as its alias</comment>
			<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expression</name> <init>= <expr><call><name>cypher_ast_null</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name>identifier</name> <init>= <expr><call><name>cypher_ast_identifier</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name><name>children</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>expression</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>identifier</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>projections</name><index>[<expr><name>proj_idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>cypher_ast_projection</name><argument_list>(<argument><expr><name>expression</name></expr></argument>,
					<argument><expr><name>identifier</name></expr></argument>, <argument><expr><name>children</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nprojections</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">//--------------------------------------------------------------------------</comment>
	<comment type="line">// introduce explicit projections</comment>
	<comment type="line">//--------------------------------------------------------------------------</comment>

	<comment type="line">// clone explicit projections into projections array</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>existing_projections_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>projection</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>t</name> <operator>==</operator> <name>CYPHER_AST_WITH</name><operator>)</operator></expr> ?</condition><then>
			<expr><call><name>cypher_ast_with_get_projection</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> </then><else>:
			<expr><call><name>cypher_ast_return_get_projection</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<comment type="line">// if the projection has an alias use it,</comment>
		<comment type="line">// otherwise the expression is the alias</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>exp</name> <init>=
			<expr><call><name>cypher_ast_projection_get_alias</name><argument_list>(<argument><expr><name>projection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>exp</name> <operator>=</operator> <ternary><condition><expr><name>exp</name></expr> ?</condition><then> <expr><name>exp</name></expr> </then><else>: <expr><call><name>cypher_ast_projection_get_expression</name><argument_list>(<argument><expr><name>projection</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// maintain expression</comment>
		<expr_stmt><expr><name><name>projections</name><index>[<expr><name>proj_idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>cypher_ast_clone</name><argument_list>(<argument><expr><name>projection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nprojections</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="line">// update `nprojections` to actual number of projections</comment>
	<comment type="line">// value might be reduced due to duplicates</comment>
	<expr_stmt><expr><name>nprojections</name> <operator>=</operator> <name>proj_idx</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// prepare arguments for new return clause node</comment>
	<decl_stmt><decl><type><name>bool</name></type>                    <name>distinct</name>   <init>=  <expr><name>false</name></expr></init></decl> ;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name>  <modifier>*</modifier></type><name>skip</name>      <init>=  <expr><name>NULL</name></expr></init></decl>  ;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name>  <modifier>*</modifier></type><name>limit</name>     <init>=  <expr><name>NULL</name></expr></init></decl>  ;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name>  <modifier>*</modifier></type><name>order_by</name>  <init>=  <expr><name>NULL</name></expr></init></decl>  ;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name>  <modifier>*</modifier></type><name>predicate</name> <init>=  <expr><name>NULL</name></expr></init></decl>  ;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_WITH</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>distinct</name>      <operator>=</operator>  <call><name>cypher_ast_with_is_distinct</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>skip</name>          <operator>=</operator>  <call><name>cypher_ast_with_get_skip</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>limit</name>         <operator>=</operator>  <call><name>cypher_ast_with_get_limit</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>order_by</name>      <operator>=</operator>  <call><name>cypher_ast_with_get_order_by</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>predicate</name>     <operator>=</operator>  <call><name>cypher_ast_with_get_predicate</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>distinct</name>      <operator>=</operator>  <call><name>cypher_ast_return_is_distinct</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>skip</name>          <operator>=</operator>  <call><name>cypher_ast_return_get_skip</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>limit</name>         <operator>=</operator>  <call><name>cypher_ast_return_get_limit</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>order_by</name>      <operator>=</operator>  <call><name>cypher_ast_return_get_order_by</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="line">// copy projections to the children array</comment>
	<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name><name>children</name><index>[<expr><name>nprojections</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nprojections</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name><name>children</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>projections</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="line">// clone any ORDER BY, SKIP, LIMIT, and WHERE modifiers to</comment>
	<comment type="line">// add to the children array and populate the new clause</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>nchildren</name> <init>= <expr><name>nprojections</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>order_by</name></expr>)</condition><block type="pseudo"><block_content>  <expr_stmt><expr><name>order_by</name>   <operator>=</operator> <name><name>children</name><index>[<expr><name>nchildren</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>cypher_ast_clone</name><argument_list>(<argument><expr><name>order_by</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name>skip</name></expr>)</condition><block type="pseudo"><block_content>      <expr_stmt><expr><name>skip</name>       <operator>=</operator> <name><name>children</name><index>[<expr><name>nchildren</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>cypher_ast_clone</name><argument_list>(<argument><expr><name>skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name>limit</name></expr>)</condition><block type="pseudo"><block_content>     <expr_stmt><expr><name>limit</name>      <operator>=</operator> <name><name>children</name><index>[<expr><name>nchildren</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>cypher_ast_clone</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name>predicate</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>predicate</name>  <operator>=</operator> <name><name>children</name><index>[<expr><name>nchildren</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>cypher_ast_clone</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name><name>struct</name> <name>cypher_input_range</name></name></type> <name>range</name> <init>= <expr><call><name>cypher_astnode_range</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// build the replacement clause</comment>
	<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name>new_clause</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_WITH</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>new_clause</name> <operator>=</operator> <call><name>cypher_ast_with</name><argument_list>(<argument><expr><name>distinct</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>,
									 <argument><expr><name>projections</name></expr></argument>,
									 <argument><expr><name>nprojections</name></expr></argument>,
									 <argument><expr><name>order_by</name></expr></argument>,
									 <argument><expr><name>skip</name></expr></argument>,
									 <argument><expr><name>limit</name></expr></argument>,
									 <argument><expr><name>predicate</name></expr></argument>,
									 <argument><expr><name>children</name></expr></argument>,
									 <argument><expr><name>nchildren</name></expr></argument>,
									 <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>new_clause</name> <operator>=</operator> <call><name>cypher_ast_return</name><argument_list>(<argument><expr><name>distinct</name></expr></argument>,
									   <argument><expr><name>false</name></expr></argument>,
									   <argument><expr><name>projections</name></expr></argument>,
									   <argument><expr><name>nprojections</name></expr></argument>,
									   <argument><expr><name>order_by</name></expr></argument>,
									   <argument><expr><name>skip</name></expr></argument>,
									   <argument><expr><name>limit</name></expr></argument>,
									   <argument><expr><name>children</name></expr></argument>,
									   <argument><expr><name>nchildren</name></expr></argument>,
									   <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>cypher_ast_free</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// replace original clause with fully populated one</comment>
	<expr_stmt><expr><call><name>cypher_ast_query_set_clause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>new_clause</name></expr></argument>, <argument><expr><name>scope_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>AST_RewriteStarProjections</name>
<parameter_list>(
	<parameter><decl><type><name>cypher_parse_result_t</name> <modifier>*</modifier></type><name>result</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>rewritten</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<comment type="line">// retrieve the statement node</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>statement</name> <init>= <expr><call><name>cypher_parse_result_get_root</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>statement</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CYPHER_AST_STATEMENT</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rewritten</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// retrieve the root query node from the statement</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><call><name>cypher_ast_statement_get_body</name><argument_list>(<argument><expr><name>statement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CYPHER_AST_QUERY</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rewritten</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// rewrite all WITH * / RETURN * clauses to include all aliases</comment>
	<decl_stmt><decl><type><name>uint</name></type>  <name>scope_start</name>   <init>=  <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type>  <name>clause_count</name>  <init>=  <expr><call><name>cypher_ast_query_nclauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>clause_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>t</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>t</name> <operator>!=</operator> <name>CYPHER_AST_WITH</name> <operator>&amp;&amp;</operator> <name>t</name> <operator>!=</operator> <name>CYPHER_AST_RETURN</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>has_include_existing</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>t</name> <operator>==</operator> <name>CYPHER_AST_WITH</name><operator>)</operator></expr> ?</condition><then>
									<expr><call><name>cypher_ast_with_has_include_existing</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr> </then><else>:
									<expr><call><name>cypher_ast_return_has_include_existing</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if<condition>(<expr><name>has_include_existing</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// clause contains a star projection, replace it</comment>
			<expr_stmt><expr><call><name>replace_clause</name><argument_list>(<argument><expr><operator>(</operator><name>cypher_astnode_t</name> <operator>*</operator><operator>)</operator><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>cypher_astnode_t</name> <operator>*</operator><operator>)</operator><name>clause</name></expr></argument>,
						   <argument><expr><name>scope_start</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rewritten</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// update scope start</comment>
		<expr_stmt><expr><name>scope_start</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>rewritten</name></expr>;</return>
</block_content>}</block></function>

</unit>
