<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/src/ast/ast.c"><comment type="block">/*
 * Copyright Redis Ltd. 2018 - present
 * Licensed under your choice of the Redis Source Available License 2.0 (RSALv2) or
 * the Server Side Public License v1 (SSPLv1).
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"RG.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../errors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/arr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../query_ctx.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../procedures/procedure.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ast_rewrite_same_clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ast_rewrite_star_projections.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../arithmetic/arithmetic_expression.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../arithmetic/arithmetic_expression_construct.h"</cpp:file></cpp:include>

<comment type="line">// TODO duplicated logic, find shared place for it</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>_prepareIterateAll</name><parameter_list>(<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>raxIterator</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><literal type="string">"^"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Note each function call within given expression</comment>
<comment type="line">// Example: given the expression: "abs(max(min(a), abs(k)))"</comment>
<comment type="line">// referred_funcs will include: "abs", "max" and "min".</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_consume_function_call_expression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
											  <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>referred_funcs</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_APPLY_OPERATOR</name> <operator>||</operator>
	   <name>type</name> <operator>==</operator> <name>CYPHER_AST_APPLY_ALL_OPERATOR</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Expression is an Apply or Apply All operator.</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>apply_all</name> <init>= <expr><operator>(</operator><name>type</name> <operator>==</operator> <name>CYPHER_AST_APPLY_ALL_OPERATOR</name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<comment type="line">// Retrieve the function name and add to rax.</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>!</operator><name>apply_all</name><operator>)</operator></expr> ?</condition><then>
									   <expr><call><name>cypher_ast_apply_operator_get_func_name</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr> </then><else>:
									   <expr><call><name>cypher_ast_apply_all_operator_get_func_name</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func_name</name> <init>= <expr><call><name>cypher_ast_function_name_get_value</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name>referred_funcs</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>func_name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><name>apply_all</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <comment type="line">// Apply All operators have no arguments.</comment>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>child_count</name> <init>= <expr><call><name>cypher_astnode_nchildren</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>child_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>cypher_astnode_get_child</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_consume_function_call_expression</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>referred_funcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* This function returns the actual root of the query.
 * As cypher_parse_result_t can have multiple roots such as comments, only a root with type
 * CYPHER_AST_STATEMENT is considered as the actual root. Comment roots are ignored. */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>_AST_parse_result_root</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_parse_result_t</name> <modifier>*</modifier></type><name>parse_result</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>nroots</name> <init>= <expr><call><name>cypher_parse_result_nroots</name><argument_list>(<argument><expr><name>parse_result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nroots</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><call><name>cypher_parse_result_get_root</name><argument_list>(<argument><expr><name>parse_result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>root_type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>root_type</name> <operator>!=</operator> <name>CYPHER_AST_STATEMENT</name></expr>)</condition> <block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<return>return <expr><name>root</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="string">"_AST_parse_result_root: Parse result should have a valid root"</literal> <operator>&amp;&amp;</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This method extracts the query given parameters values, convert them into
 * constant arithmetic expressions and store them in a map of &lt;name, value&gt;
 * in the query context. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_Extract_Params</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_parse_result_t</name> <modifier>*</modifier></type><name>parse_result</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// Retrieve the AST root node from a parsed query.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>statement</name> <init>= <expr><call><name>_AST_parse_result_root</name><argument_list>(<argument><expr><name>parse_result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>noptions</name> <init>= <expr><call><name>cypher_ast_statement_noptions</name><argument_list>(<argument><expr><name>statement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>noptions</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
	<decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>params</name> <init>= <expr><call><name>raxNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>noptions</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>option</name> <init>= <expr><call><name>cypher_ast_statement_get_option</name><argument_list>(<argument><expr><name>statement</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint</name></type> <name>nparams</name> <init>= <expr><call><name>cypher_ast_cypher_option_nparams</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nparams</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><call><name>cypher_ast_cypher_option_get_param</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>paramName</name> <init>= <expr><call><name>cypher_ast_string_get_value</name><argument_list>(<argument><expr><call><name>cypher_ast_cypher_option_param_get_name</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>paramValue</name> <init>= <expr><call><name>cypher_ast_cypher_option_param_get_value</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AR_ExpNode</name> <modifier>*</modifier></type><name>exp</name> <init>= <expr><call><name>AR_EXP_FromASTNode</name><argument_list>(<argument><expr><name>paramValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>paramName</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>paramName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>exp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	<comment type="line">// Add the parameters map to the QueryCtx.</comment>
	<expr_stmt><expr><call><name>QueryCtx_SetParams</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>AST_IncreaseRefCount</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>__atomic_fetch_add</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>ref_count</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>__ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>AST_DecRefCount</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>__atomic_sub_fetch</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>ref_count</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>__ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>AST_ReadOnly</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// check for empty query</comment>
	<if_stmt><if>if<condition>(<expr><name>root</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_CREATE</name>                     <operator>||</operator>
	   <name>type</name> <operator>==</operator> <name>CYPHER_AST_MERGE</name>                      <operator>||</operator>
	   <name>type</name> <operator>==</operator> <name>CYPHER_AST_DELETE</name>                     <operator>||</operator>
	   <name>type</name> <operator>==</operator> <name>CYPHER_AST_SET</name>                        <operator>||</operator>
	   <name>type</name> <operator>==</operator> <name>CYPHER_AST_REMOVE</name>                     <operator>||</operator>
	   <name>type</name> <operator>==</operator> <name>CYPHER_AST_CREATE_NODE_PROPS_INDEX</name>    <operator>||</operator>
	   <name>type</name> <operator>==</operator> <name>CYPHER_AST_CREATE_PATTERN_PROPS_INDEX</name> <operator>||</operator>
	   <name>type</name> <operator>==</operator> <name>CYPHER_AST_DROP_PROPS_INDEX</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// in case of procedure call which modifies the graph/indices</comment>
	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_CALL</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proc_name</name> <init>= <expr><call><name>cypher_ast_proc_name_get_value</name><argument_list>(
									<argument><expr><call><name>cypher_ast_call_get_proc_name</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ProcedureCtx</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><call><name>Proc_Get</name><argument_list>(<argument><expr><name>proc_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>read_only</name> <init>= <expr><call><name>Procedure_IsReadOnly</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Proc_Free</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><operator>!</operator><name>read_only</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>num_children</name> <init>= <expr><call><name>cypher_astnode_nchildren</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_children</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>cypher_astnode_get_child</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>AST_ReadOnly</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>AST_ContainsClause</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><name>cypher_astnode_type_t</name></type> <name>clause</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>AST_GetClause</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Checks to see if an AST tree contains specified node type.</comment>
<function><type><name>bool</name></type> <name>AST_TreeContainsType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>cypher_astnode_type_t</name></type> <name>search_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>search_type</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>childCount</name> <init>= <expr><call><name>cypher_astnode_nchildren</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>childCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<if_stmt><if>if<condition>(<expr><call><name>AST_TreeContainsType</name><argument_list>(<argument><expr><call><name>cypher_astnode_get_child</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>search_type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Recursively collect the names of all function calls beneath a node</comment>
<function><type><name>void</name></type> <name>AST_ReferredFunctions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>referred_funcs</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>root_type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>root_type</name> <operator>==</operator> <name>CYPHER_AST_APPLY_OPERATOR</name> <operator>||</operator> <name>root_type</name> <operator>==</operator> <name>CYPHER_AST_APPLY_ALL_OPERATOR</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_consume_function_call_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>referred_funcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<decl_stmt><decl><type><name>uint</name></type> <name>child_count</name> <init>= <expr><call><name>cypher_astnode_nchildren</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>child_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>cypher_astnode_get_child</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>AST_ReferredFunctions</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>referred_funcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">// Retrieve the first instance of the specified clause in the AST segment, if any.</comment>
<function><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>AST_GetClause</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>,
									  <parameter><decl><type><name>cypher_astnode_type_t</name></type> <name>clause_type</name></decl></parameter>, <parameter><decl><type><name>uint</name> <modifier>*</modifier></type><name>clause_idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>clause_count</name> <init>= <expr><call><name>cypher_ast_query_nclauses</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>clause_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>clause_type</name></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name>clause_idx</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>clause_idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>child</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>AST_GetClauseByIdx</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><name>uint</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>ast</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>clause_count</name> <init>= <expr><call><name>cypher_ast_query_nclauses</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <name>clause_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>clause</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint</name> <modifier>*</modifier></type><name>AST_GetClauseIndices</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><name>cypher_astnode_type_t</name></type> <name>clause_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name> <modifier>*</modifier></type><name>clause_indices</name> <init>= <expr><call><name>array_new</name><argument_list>(<argument><expr><name>uint</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>clause_count</name> <init>= <expr><call><name>cypher_ast_query_nclauses</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>clause_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>clause_type</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>clause_indices</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>clause_indices</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint</name></type> <name>AST_GetClauseCount</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><name>cypher_astnode_type_t</name></type> <name>clause_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>clause_count</name> <init>= <expr><call><name>cypher_ast_query_nclauses</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>num_found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>clause_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>clause_type</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>num_found</name> <operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>num_found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Collect references to all clauses of the specified type in the query. Since clauses
 * cannot be nested, we only need to check the immediate children of the query node. */</comment>
<function><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>AST_GetClauses</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>,
	<parameter><decl><type><name>cypher_astnode_type_t</name></type> <name>type</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>clauses</name> <init>= <expr><call><name>array_new</name><argument_list>(<argument><expr><specifier>const</specifier> <name>cypher_astnode_t</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>clause_count</name> <init>= <expr><call><name>cypher_ast_query_nclauses</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>clause_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>type</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>clauses</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_GetTypedNodes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name>  <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>nodes</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							   <parameter><decl><type><name>cypher_astnode_type_t</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>type</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><operator>*</operator><name>nodes</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>nchildren</name> <init>= <expr><call><name>cypher_astnode_nchildren</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nchildren</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>_AST_GetTypedNodes</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>, <argument><expr><call><name>cypher_astnode_get_child</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>AST_GetTypedNodes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										   <parameter><decl><type><name>cypher_astnode_type_t</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodes</name> <init>= <expr><call><name>array_new</name><argument_list>(<argument><expr><specifier>const</specifier> <name>cypher_astnode_t</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_AST_GetTypedNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nodes</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>nodes</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>AST_CollectAliases</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>aliases</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>entity</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>entity</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier>  <name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>identifier_nodes</name> <init>=  <expr><call><name>AST_GetTypedNodes</name><argument_list>(<argument><expr><name>entity</name></expr></argument>, <argument><expr><name>CYPHER_AST_IDENTIFIER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>nodes_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>identifier_nodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nodes_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>identifier</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name><name>identifier_nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><operator>*</operator><name>aliases</name></expr></argument>, <argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>identifier_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>AST</name> <modifier>*</modifier></type><name>AST_Build</name><parameter_list>(<parameter><decl><type><name>cypher_parse_result_t</name> <modifier>*</modifier></type><name>parse_result</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AST</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>ref_count</name></name> <operator>=</operator> <call><name>rm_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>free_root</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>params_parse_result</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>referenced_entities</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>parse_result</name></name> <operator>=</operator> <name>parse_result</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>anot_ctx_collection</name></name> <operator>=</operator> <call><name>AST_AnnotationCtxCollection_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>ast</name><operator>-&gt;</operator><name>ref_count</name></name><operator>)</operator> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<comment type="line">// Retrieve the AST root node from a parsed query.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>statement</name> <init>= <expr><call><name>_AST_parse_result_root</name><argument_list>(<argument><expr><name>parse_result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// We are parsing with the CYPHER_PARSE_ONLY_STATEMENTS flag,</comment>
	<comment type="line">// and double-checking this in AST validations</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>statement</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_STATEMENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name> <operator>=</operator> <call><name>cypher_ast_statement_get_body</name><argument_list>(<argument><expr><name>statement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Empty queries should be captured by AST validations</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Set thread-local AST.</comment>
	<expr_stmt><expr><call><name>QueryCtx_SetAST</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Augment the AST with annotations for naming entities and populating WITH/RETURN * projections.</comment>
	<expr_stmt><expr><call><name>AST_Enrich</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ast</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AST</name> <modifier>*</modifier></type><name>AST_NewSegment</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>master_ast</name></decl></parameter>, <parameter><decl><type><name>uint</name></type> <name>start_offset</name></decl></parameter>, <parameter><decl><type><name>uint</name></type> <name>end_offset</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AST</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>anot_ctx_collection</name></name> <operator>=</operator> <name><name>master_ast</name><operator>-&gt;</operator><name>anot_ctx_collection</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>free_root</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>ref_count</name></name> <operator>=</operator> <call><name>rm_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>parse_result</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>params_parse_result</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>n</name> <init>= <expr><name>end_offset</name> <operator>-</operator> <name>start_offset</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>ast</name><operator>-&gt;</operator><name>ref_count</name></name><operator>)</operator> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name><name>clauses</name><index>[<expr><name>n</name></expr>]</index></name></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name><name>clauses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name><name>master_ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <name>start_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<decl_stmt><decl><type><name><name>struct</name> <name>cypher_input_range</name></name></type> <name>range</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name> <operator>=</operator> <call><name>cypher_ast_query</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>cypher_astnode_t</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator><name>clauses</name></expr></argument>, <argument><expr><name>n</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>cypher_astnode_t</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>clauses</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// TODO This overwrites the previously-held AST pointer, which could lead to inconsistencies</comment>
	<comment type="line">// in the future if we expect the variable to hold a different AST.</comment>
	<expr_stmt><expr><call><name>QueryCtx_SetAST</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// If the segments are split, the next clause is either RETURN or WITH,</comment>
	<comment type="line">// and its references should be included in this segment's map.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>project_clause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>clause_count</name> <init>= <expr><call><name>cypher_ast_query_nclauses</name><argument_list>(<argument><expr><name><name>master_ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>end_offset</name> <operator>==</operator> <name>clause_count</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>end_offset</name> <operator>=</operator> <name>clause_count</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>project_clause</name> <operator>=</operator> <call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name><name>master_ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>end_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Last clause is not necessarily a projection clause,
	 * [MATCH (a) RETURN a UNION] MATCH (a) RETURN a
	 * In this case project_clause = UNION, which is not a projection clause. */</comment>
	<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>project_type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>project_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>project_type</name> <operator>!=</operator> <name>CYPHER_AST_WITH</name> <operator>&amp;&amp;</operator> <name>project_type</name> <operator>!=</operator> <name>CYPHER_AST_RETURN</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>project_clause</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Build the map of referenced entities in this AST segment.</comment>
	<expr_stmt><expr><call><name>AST_BuildReferenceMap</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>project_clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ast</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>AST_SetParamsParseResult</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><name>cypher_parse_result_t</name> <modifier>*</modifier></type><name>params_parse_result</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// When setting this value in AST, the ast should no hold invalid pointers or leftovers from previous executions.</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>params_parse_result</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>params_parse_result</name></name> <operator>=</operator> <name>params_parse_result</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>AST</name> <modifier>*</modifier></type><name>AST_ShallowCopy</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>orig</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>AST_IncreaseRefCount</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>ast_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>AST</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AST</name> <modifier>*</modifier></type><name>shallow_copy</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><name>ast_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>shallow_copy</name></expr></argument>, <argument><expr><name>orig</name></expr></argument>, <argument><expr><name>ast_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shallow_copy</name><operator>-&gt;</operator><name>params_parse_result</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>shallow_copy</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>AST_AliasIsReferenced</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><operator>(</operator><call><name>raxFind</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>referenced_entities</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>alias</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>raxNotFound</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>AST_IdentifierIsAlias</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>identifier</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_PROJECTION</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>alias_node</name> <init>= <expr><call><name>cypher_ast_projection_get_alias</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// If this projection is aliased, check the alias.</comment>
		<if_stmt><if>if<condition>(<expr><name>alias_node</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>alias_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>alias</name></expr></argument>, <argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt> <comment type="line">// The identifier is an alias.</comment>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr>)</condition> <block>{<block_content>
				<comment type="line">// If the projection itself is the identifier, it is not an alias.</comment>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>current_identifier</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>alias_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>current_identifier</name></expr></argument>, <argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Recursively visit children.</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>child_count</name> <init>= <expr><call><name>cypher_astnode_nchildren</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>child_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>alias_found</name> <init>= <expr><call><name>AST_IdentifierIsAlias</name><argument_list>(<argument><expr><call><name>cypher_astnode_get_child</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>alias_found</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// TODO Consider augmenting libcypher-parser so that we don't need to perform this</comment>
<comment type="line">// work in-module.</comment>
<function><type><specifier>inline</specifier> <name>long</name></type> <name>AST_ParseIntegerNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>int_node</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>int_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value_str</name> <init>= <expr><call><name>cypher_ast_integer_get_valuestr</name><argument_list>(<argument><expr><name>int_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>strtol</name><argument_list>(<argument><expr><name>value_str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>AST_ClauseContainsAggregation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>aggregated</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// Retrieve all user-specified functions in clause.</comment>
	<decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>referred_funcs</name> <init>= <expr><call><name>raxNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AST_ReferredFunctions</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>referred_funcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name><name>funcName</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>raxIterator</name></type> <name>it</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_prepareIterateAll</name><argument_list>(<argument><expr><name>referred_funcs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name><name>it</name><operator>.</operator><name>key_len</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>len</name> <operator>&lt;</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// Copy the triemap key so that we can safely add a terinator character</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>funcName</name></expr></argument>, <argument><expr><name><name>it</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcName</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><call><name>AR_FuncIsAggregate</name><argument_list>(<argument><expr><name>funcName</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>aggregated</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>referred_funcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>aggregated</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>AST_BuildReturnColumnNames</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>return_clause</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// all RETURN * clauses should have been converted to explicit lists</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_ast_return_has_include_existing</name><argument_list>(<argument><expr><name>return_clause</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Collect every alias from the RETURN projections.</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>projection_count</name> <init>= <expr><call><name>cypher_ast_return_nprojections</name><argument_list>(<argument><expr><name>return_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>columns</name> <init>= <expr><call><name>array_new</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>projection_count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>projection_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>projection</name> <init>= <expr><call><name>cypher_ast_return_get_projection</name><argument_list>(<argument><expr><name>return_clause</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_alias</name> <init>= <expr><call><name>cypher_ast_projection_get_alias</name><argument_list>(<argument><expr><name>projection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// If the projection was not aliased, the projection itself is an identifier.</comment>
		<if_stmt><if>if<condition>(<expr><name>ast_alias</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ast_alias</name> <operator>=</operator> <call><name>cypher_ast_projection_get_expression</name><argument_list>(<argument><expr><name>projection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>ast_alias</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>columns</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>columns</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>AST_BuildCallColumnNames</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>call_clause</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>proc_output_columns</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>yield_count</name> <init>= <expr><call><name>cypher_ast_call_nprojections</name><argument_list>(<argument><expr><name>call_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>yield_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>proc_output_columns</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>yield_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>yield_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>projection</name> <init>= <expr><call><name>cypher_ast_call_get_projection</name><argument_list>(<argument><expr><name>call_clause</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_exp</name> <init>= <expr><call><name>cypher_ast_projection_get_expression</name><argument_list>(<argument><expr><name>projection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>identifier</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>alias_node</name> <init>= <expr><call><name>cypher_ast_projection_get_alias</name><argument_list>(<argument><expr><name>projection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><name>alias_node</name></expr>)</condition> <block>{<block_content>
				<comment type="line">// The projection either has an alias (AS), is a function call, or is a property specification (e.name).</comment>
				<expr_stmt><expr><name>identifier</name> <operator>=</operator> <call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>alias_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<comment type="line">// This expression did not have an alias, so it must be an identifier</comment>
				<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>ast_exp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="line">// Retrieve "a" from "RETURN a" or "RETURN a AS e" (theoretically; the latter case is already handled)</comment>
				<expr_stmt><expr><name>identifier</name> <operator>=</operator> <call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>ast_exp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>proc_output_columns</name></expr></argument>, <argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="line">// If the procedure call is missing its yield part, include procedure outputs.</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proc_name</name> <init>= <expr><call><name>cypher_ast_proc_name_get_value</name><argument_list>(<argument><expr><call><name>cypher_ast_call_get_proc_name</name><argument_list>(<argument><expr><name>call_clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ProcedureCtx</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><call><name>Proc_Get</name><argument_list>(<argument><expr><name>proc_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>output_count</name> <init>= <expr><call><name>Procedure_OutputCount</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>proc_output_columns</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>output_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>output_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>proc_output_columns</name></expr></argument>, <argument><expr><call><name>Procedure_GetOutput</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>Proc_Free</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>proc_output_columns</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>_AST_ExtractQueryString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_parse_result_t</name> <modifier>*</modifier></type><name>partial_result</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// Retrieve the AST root node from a parsed query.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>statement</name> <init>= <expr><call><name>_AST_parse_result_root</name><argument_list>(<argument><expr><name>partial_result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// We are parsing with the CYPHER_PARSE_ONLY_PARAMETERS flag.</comment>
	<comment type="line">// Given that, only the parameters were processed. extract the actual query and return to caller.</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>statement</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_STATEMENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>body</name> <init>= <expr><call><name>cypher_ast_statement_get_body</name><argument_list>(<argument><expr><name>statement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>cypher_ast_string_get_value</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>AST_AnnotationCtxCollection</name> <modifier>*</modifier></type><name>AST_GetAnnotationCtxCollection</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><name><name>ast</name><operator>-&gt;</operator><name>anot_ctx_collection</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>char</name> <modifier>*</modifier></type><name>_create_anon_alias</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>anon_count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>asprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>alias</name></expr></argument>, <argument><expr><literal type="string">"@anon_%d"</literal></expr></argument>, <argument><expr><name>anon_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>alias</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>AST_ToString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>QueryCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><call><name>QueryCtx_GetQueryCtx</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name> <init>= <expr><call><name>QueryCtx_GetAST</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AnnotationCtx</name> <modifier>*</modifier></type><name>to_string_ctx</name> <init>= <expr><call><name>AST_AnnotationCtxCollection_GetToStringCtx</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>anot_ctx_collection</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>cypher_astnode_get_annotation</name><argument_list>(<argument><expr><name>to_string_ctx</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>t</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_identifier</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_NODE_PATTERN</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ast_identifier</name> <operator>=</operator> <call><name>cypher_ast_node_pattern_get_identifier</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_REL_PATTERN</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ast_identifier</name> <operator>=</operator> <call><name>cypher_ast_rel_pattern_get_identifier</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>cypher_input_range</name></name></type> <name>range</name> <init>= <expr><call><name>cypher_astnode_range</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint</name></type> <name>length</name> <init>= <expr><name><name>range</name><operator>.</operator><name>end</name><operator>.</operator><name>offset</name></name> <operator>-</operator> <name><name>range</name><operator>.</operator><name>start</name><operator>.</operator><name>offset</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>query_data</name><operator>.</operator><name>query_no_params</name></name> <operator>+</operator> <name><name>range</name><operator>.</operator><name>start</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name>length</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>str</name><index>[<expr><name>length</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if<condition>(<expr><name>ast_identifier</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// Graph entity has a user-defined alias return it.</comment>
			<return>return <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>ast_identifier</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>_create_anon_alias</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>anot_ctx_collection</name><operator>-&gt;</operator><name>anon_count</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>cypher_astnode_attach_annotation</name><argument_list>(<argument><expr><name>to_string_ctx</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>AST_Free</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>ast</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>ref_count</name> <init>= <expr><call><name>AST_DecRefCount</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* free and nullify parameters parse result if needed,
	 * after execution, as they are only save for the execution lifetime */</comment>
	<if_stmt><if>if<condition>(<expr><name><name>ast</name><operator>-&gt;</operator><name>params_parse_result</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>parse_result_free</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>params_parse_result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// check if the ast has additional copies</comment>
	<if_stmt><if>if<condition>(<expr><name>ref_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="line">// no valid references, the struct can be disposed completely</comment>
		<if_stmt><if>if<condition>(<expr><name><name>ast</name><operator>-&gt;</operator><name>free_root</name></name></expr>)</condition> <block>{<block_content>
			<comment type="line">// this is a generated AST, free its root node</comment>
			<expr_stmt><expr><call><name>cypher_astnode_free</name><argument_list>(<argument><expr><operator>(</operator><name>cypher_astnode_t</name> <operator>*</operator><operator>)</operator> <name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="block">/* this is the master AST,
			 * free the annotation contexts that have been constructed */</comment>
			<expr_stmt><expr><call><name>AST_AnnotationCtxCollection_Free</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>anot_ctx_collection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>parse_result_free</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>parse_result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if<condition>(<expr><name><name>ast</name><operator>-&gt;</operator><name>referenced_entities</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>referenced_entities</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>ref_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>cypher_parse_result_t</name> <modifier>*</modifier></type><name>parse_query</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>fmemopen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>query</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>cypher_parse_result_t</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>cypher_fparse</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>CYPHER_PARSE_SINGLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// check that the parser parse the entire query</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>cypher_parse_result_eof</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Error: query with more than one statement is not supported."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>parse_result_free</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// in case ast contains any errors, report them and return</comment>
	<if_stmt><if>if<condition>(<expr><call><name>AST_ContainsErrors</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>AST_ReportErrors</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>parse_result_free</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>AST_Validate_Query</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>parse_result_free</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><call><name>cypher_parse_result_get_root</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// rewrite '*' projections</comment>
	<comment type="line">// e.g. MATCH (a), (b) RETURN *</comment>
	<comment type="line">// will be rewritten as:</comment>
	<comment type="line">//  MATCH (a), (b) RETURN a, b</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>rerun_validation</name> <init>= <expr><call><name>AST_RewriteStarProjections</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// compress clauses</comment>
	<comment type="line">// e.g. MATCH (a:N) MATCH (b:N) RETURN a,b</comment>
	<comment type="line">// will be rewritten as:</comment>
	<comment type="line">// MATCH (a:N), (b:N) RETURN a,b</comment>
	<expr_stmt><expr><name>rerun_validation</name> <operator>|=</operator> <call><name>AST_RewriteSameClauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// only perform validations again if there's been a rewrite</comment>
	<if_stmt><if>if<condition>(<expr><name>rerun_validation</name> <operator>&amp;&amp;</operator> <call><name>AST_Validate_Query</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>parse_result_free</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>cypher_parse_result_t</name> <modifier>*</modifier></type><name>parse_params</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>query_body</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>fmemopen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>query</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>cypher_parse_result_t</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>cypher_fparse</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>CYPHER_PARSE_ONLY_PARAMETERS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>AST_Validate_QueryParams</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>parse_result_free</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>_AST_Extract_Params</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>query_body</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>query_body</name> <operator>=</operator> <call><name>_AST_ExtractQueryString</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>parse_result_free</name><parameter_list>(<parameter><decl><type><name>cypher_parse_result_t</name> <modifier>*</modifier></type><name>parse_result</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>parse_result</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cypher_parse_result_free</name><argument_list>(<argument><expr><name>parse_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

</unit>
