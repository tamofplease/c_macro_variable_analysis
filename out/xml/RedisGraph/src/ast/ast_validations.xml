<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/src/ast/ast_validations.c"><comment type="block">/*
 * Copyright Redis Ltd. 2018 - present
 * Licensed under your choice of the Redis Source Available License 2.0 (RSALv2) or
 * the Server Side Public License v1 (SSPLv1).
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../RG.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../errors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ast_shared.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/arr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cypher_whitelist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/rax_extensions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../procedures/procedure.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../arithmetic/arithmetic_expression.h"</cpp:file></cpp:include>

<comment type="line">// TODO: generic function should be used to validate different features positions</comment>
<comment type="line">// static AST_Validation _NestedIn</comment>
<comment type="line">// (</comment>
<comment type="line">// 	const cypher_astnode_t *root,</comment>
<comment type="line">// 	cypher_astnode_type_t search_type,</comment>
<comment type="line">// 	cypher_astnode_type_t *whitelist,</comment>
<comment type="line">// 	bool is_in_whitelist</comment>
<comment type="line">// ) {</comment>
<comment type="line">// 	ASSERT(root != NULL);</comment>
<comment type="line">// 	ASSERT(whitelist != NULL);</comment>

<comment type="line">// 	cypher_astnode_type_t t = cypher_astnode_type(root);</comment>
<comment type="line">// 	if(t == search_type &amp;&amp; is_in_whitelist) return true;</comment>

<comment type="line">// 	if(!is_in_whitelist) {</comment>
<comment type="line">// 		int len = array_len(whitelist);</comment>
<comment type="line">// 		for (uint i = 0; i &lt; len; i++) {</comment>
<comment type="line">// 			if(t == whitelist[i]) {</comment>
<comment type="line">// 				is_in_whitelist = true;</comment>
<comment type="line">// 				break;</comment>
<comment type="line">// 			}</comment>
<comment type="line">// 		}</comment>
<comment type="line">// 	}</comment>

<comment type="line">// 	uint nchildren = cypher_astnode_nchildren(root);</comment>
<comment type="line">// 	for(uint i = 0; i &lt; nchildren; i ++) {</comment>
<comment type="line">// 		const cypher_astnode_t *child = cypher_astnode_get_child(root, i);</comment>
<comment type="line">// 		bool res = _NestedIn(child, search_type, whitelist, is_in_whitelist);</comment>
<comment type="line">// 		if(res) return true;</comment>
<comment type="line">// 	}</comment>

<comment type="line">// 	return false;</comment>
<comment type="line">// }</comment>

<comment type="line">// validate that allShortestPaths is in a supported places</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>_ValidateAllShortestPaths</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>root</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>t</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// if we found allShortestPaths in invalid parent return true</comment>
	<if_stmt><if>if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_SHORTEST_PATH</name> <operator>&amp;&amp;</operator>
	   <operator>!</operator><call><name>cypher_ast_shortest_path_is_single</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>t</name> <operator>==</operator> <name>CYPHER_AST_MATCH</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// allShortesPath is invalid in the match predicate</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>predicate</name> <init>= <expr><call><name>cypher_ast_match_get_predicate</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<return>return <expr><name>predicate</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>_ValidateAllShortestPaths</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// recursively traverse all children</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>nchildren</name> <init>= <expr><call><name>cypher_astnode_nchildren</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nchildren</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>cypher_astnode_get_child</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>_ValidateAllShortestPaths</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Forward declaration</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_AST_Path_GetDefinedIdentifiers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>identifiers</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_AST_GetDefinedIdentifiers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>identifiers</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>inline</specifier> <specifier>static</specifier> <name>void</name></type> <name>_prepareIterateAll</name><parameter_list>(<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>raxIterator</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><literal type="string">"^"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_GetIdentifiers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>identifiers</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>identifiers</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>identifier</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>identifier</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* In case current node is of type CALL
	 * Process procedure call arguments, those should be defined prior
	 * to the procedure call.
	 * Outputs are not refering to previous identifiers */</comment>
	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_CALL</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>uint</name></type> <name>arg_count</name> <init>= <expr><call><name>cypher_ast_call_narguments</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arg_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>cypher_ast_call_get_argument</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>_AST_GetIdentifiers</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Don't visit the children of pattern comprehensions, as these will be aliased later.</comment>
	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_PATTERN_COMPREHENSION</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>child_count</name> <init>= <expr><call><name>cypher_astnode_nchildren</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* In case current node is of type projection
	 * inspect first child only,
	 * @10  20..26  &gt; &gt; &gt; projection           expression=@11, alias=@14
	 * @11  20..26  &gt; &gt; &gt; &gt; apply              @12(@13)
	 * @12  20..23  &gt; &gt; &gt; &gt; &gt; function name    `max`
	 * @13  24..25  &gt; &gt; &gt; &gt; &gt; identifier       `z`
	 * @14  20..26  &gt; &gt; &gt; &gt; identifier         `max(z)` */</comment>
	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_PROJECTION</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>child_count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>child_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>cypher_astnode_get_child</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_AST_GetIdentifiers</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_LIST_COMPREHENSION</name> <operator>||</operator>
	   <name>type</name> <operator>==</operator> <name>CYPHER_AST_ANY</name> <operator>||</operator>
	   <name>type</name> <operator>==</operator> <name>CYPHER_AST_ALL</name> <operator>||</operator>
	   <name>type</name> <operator>==</operator> <name>CYPHER_AST_SINGLE</name> <operator>||</operator>
	   <name>type</name> <operator>==</operator> <name>CYPHER_AST_NONE</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// A list comprehension has a local variable that should only be accessed within its scope;</comment>
		<comment type="line">// do not leave it in the identifiers map.</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>variable_node</name> <init>= <expr><call><name>cypher_ast_list_comprehension_get_identifier</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>variable</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>variable_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>variable</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>variable</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_REDUCE</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// A reduce call has an accumulator and a local variable that should</comment>
		<comment type="line">// only be accessed within its scope;</comment>
		<comment type="line">// do not leave them in the identifiers map</comment>
		<comment type="line">// example: reduce(sum=0, n in [1,2] | sum+n)</comment>
		<decl_stmt><decl><type><specifier>const</specifier>  <name>char</name>              <modifier>*</modifier></type><name>variable</name>         <init>=  <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier>  <name>cypher_astnode_t</name>  <modifier>*</modifier></type><name>accum_node</name>       <init>=  <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier>  <name>cypher_astnode_t</name>  <modifier>*</modifier></type><name>identifier_node</name>  <init>=  <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="line">// `sum` in the above example</comment>
		<expr_stmt><expr><name>accum_node</name> <operator>=</operator> <call><name>cypher_ast_reduce_get_accumulator</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>variable</name> <operator>=</operator> <call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>accum_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>variable</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>variable</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// `n` in the above example</comment>
		<expr_stmt><expr><name>identifier_node</name> <operator>=</operator> <call><name>cypher_ast_reduce_get_identifier</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>variable</name> <operator>=</operator> <call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>identifier_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>variable</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>variable</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_GetWithAliases</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>aliases</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CYPHER_AST_WITH</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>aliases</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>num_with_projections</name> <init>= <expr><call><name>cypher_ast_with_nprojections</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_with_projections</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>cypher_ast_with_get_projection</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>alias_node</name> <init>= <expr><call><name>cypher_ast_projection_get_alias</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>alias_node</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>alias_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>cypher_ast_projection_get_expression</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="line">// This expression not being an identifier is an error case, but will be captured in a later validation.</comment>
			<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CYPHER_AST_IDENTIFIER</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
			<comment type="line">// Retrieve "a" from "WITH a"</comment>
			<expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name>aliases</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>alias</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_GetWithReferences</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>identifiers</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CYPHER_AST_WITH</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>identifiers</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>num_with_projections</name> <init>= <expr><call><name>cypher_ast_with_nprojections</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_with_projections</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>cypher_ast_with_get_projection</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_AST_GetIdentifiers</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>order_by</name> <init>= <expr><call><name>cypher_ast_with_get_order_by</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>order_by</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>_AST_GetIdentifiers</name><argument_list>(<argument><expr><name>order_by</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// Extract identifiers / aliases from a procedure call.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_GetProcCallAliases</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>identifiers</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// CALL db.labels() yield label</comment>
	<comment type="line">// CALL db.labels() yield label as l</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>node</name> <operator>&amp;&amp;</operator> <name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>projection_count</name> <init>= <expr><call><name>cypher_ast_call_nprojections</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>projection_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>identifier</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>proj_node</name> <init>= <expr><call><name>cypher_ast_call_get_projection</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>alias_node</name> <init>= <expr><call><name>cypher_ast_projection_get_alias</name><argument_list>(<argument><expr><name>proj_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>alias_node</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// Alias is given: YIELD label AS l.</comment>
			<expr_stmt><expr><name>identifier</name> <operator>=</operator> <call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>alias_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="line">// No alias, use identifier: YIELD label</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>exp_node</name> <init>= <expr><call><name>cypher_ast_projection_get_expression</name><argument_list>(<argument><expr><name>proj_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>identifier</name> <operator>=</operator> <call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>exp_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>identifiers</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>identifier</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="line">// UNWIND and WITH also form aliases, but don't need special handling for us yet.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_GetReturnAliases</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>aliases</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>node</name> <operator>&amp;&amp;</operator> <name>aliases</name> <operator>&amp;&amp;</operator> <call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_RETURN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>num_return_projections</name> <init>= <expr><call><name>cypher_ast_return_nprojections</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>num_return_projections</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_return_projections</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>cypher_ast_return_get_projection</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>alias_node</name> <init>= <expr><call><name>cypher_ast_projection_get_alias</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>alias_node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>alias_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name>aliases</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>alias</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_CollectIdentifiers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>projections</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Identifier found, add to triemap</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>identifier</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name>projections</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>identifier</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<decl_stmt><decl><type><name>uint</name></type> <name>child_count</name> <init>= <expr><call><name>cypher_astnode_nchildren</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>child_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>_CollectIdentifiers</name><argument_list>(<argument><expr><call><name>cypher_astnode_get_child</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>projections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Collect all identifiers used in the RETURN clause (but not aliases defined there) */</comment>
<function><type><specifier>static</specifier> <name>rax</name> <modifier>*</modifier></type><name>_AST_GetReturnProjections</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>return_clause</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>return_clause</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>projection_count</name> <init>= <expr><call><name>cypher_ast_return_nprojections</name><argument_list>(<argument><expr><name>return_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>projection_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>projections</name> <init>= <expr><call><name>raxNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>projection_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>projection</name> <init>= <expr><call><name>cypher_ast_return_get_projection</name><argument_list>(<argument><expr><name>return_clause</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_CollectIdentifiers</name><argument_list>(<argument><expr><name>projection</name></expr></argument>, <argument><expr><name>projections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>projections</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compares a triemap of user-specified functions with the registered functions we provide. */</comment>
<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_ValidateReferredFunctions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcName</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>include_aggregates</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AST_Validation</name></type> <name>res</name> <init>= <expr><name>AST_VALID</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>include_aggregates</name> <operator>&amp;&amp;</operator> <call><name>AR_FuncIsAggregate</name><argument_list>(<argument><expr><name>funcName</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="line">// provide a unique error for using aggregate functions from inappropriate contexts</comment>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Invalid use of aggregating function '%s'"</literal></expr></argument>, <argument><expr><name>funcName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>AST_INVALID</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>AR_FuncExists</name><argument_list>(<argument><expr><name>funcName</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="line">// if we reach this point, the function was not found</comment>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Unknown function '%s'"</literal></expr></argument>, <argument><expr><name>funcName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>AST_INVALID</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// validate that a map doesn't contains a nested aggregation function</comment>
<comment type="line">// e.g. {key: count(v)}</comment>
<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_ValidateMapExp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_MAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>AST_ClauseContainsAggregation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"RedisGraph does not allow aggregate function calls \
to be nested within maps. Aggregate functions should instead be called in a \
preceding WITH clause and have their aliased values referenced in the map."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>AST_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>AST_VALID</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_ValidateFunctionCalls</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
											 <parameter><decl><type><name>bool</name></type> <name>include_aggregates</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_APPLY_ALL_OPERATOR</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Working with a function call that has * as its argument.</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><call><name>cypher_ast_apply_all_operator_get_func_name</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func_name</name> <init>= <expr><call><name>cypher_ast_function_name_get_value</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// Verify that this is a COUNT call.</comment>
		<if_stmt><if>if<condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><literal type="string">"COUNT"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"COUNT is the only function which can accept * as an argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>AST_INVALID</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Verify that DISTINCT is not specified.</comment>
		<if_stmt><if>if<condition>(<expr><call><name>cypher_ast_apply_all_operator_get_distinct</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<comment type="line">// TODO consider opening a parser error, this construction is invalid in Neo's parser.</comment>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Cannot specify both DISTINCT and * in COUNT(DISTINCT *)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>AST_INVALID</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Validate all provided function names.</comment>
		<return>return <expr><call><name>_ValidateReferredFunctions</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><name>include_aggregates</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_APPLY_OPERATOR</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Collect the function name.</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><call><name>cypher_ast_apply_operator_get_func_name</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func_name</name> <init>= <expr><call><name>cypher_ast_function_name_get_value</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>_ValidateReferredFunctions</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><name>include_aggregates</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_MAP</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// validate map expression</comment>
		<decl_stmt><decl><type><name>AST_Validation</name></type> <name>res</name> <init>= <expr><call><name>_ValidateMapExp</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_REDUCE</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>include_aggregates</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>child_count</name> <init>= <expr><call><name>cypher_astnode_nchildren</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>child_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>cypher_astnode_get_child</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AST_Validation</name></type> <name>res</name> <init>= <expr><call><name>_ValidateFunctionCalls</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>include_aggregates</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>AST_VALID</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>_AliasIsReturned</name><parameter_list>(<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>projections</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>identifier</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>raxFind</name><argument_list>(<argument><expr><name>projections</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>identifier</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>raxNotFound</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// If we have a multi-hop traversal (fixed or variable length), we cannot currently return that entity.</comment>
<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_ValidateMultiHopTraversal</name><parameter_list>(<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>projections</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>,
												 <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>start</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>end</name> <init>= <expr><name>INT_MAX</name> <operator>-</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>range_start</name> <init>= <expr><call><name>cypher_ast_range_get_start</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>range_start</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>AST_ParseIntegerNode</name><argument_list>(<argument><expr><name>range_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>range_end</name> <init>= <expr><call><name>cypher_ast_range_get_end</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>range_end</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>AST_ParseIntegerNode</name><argument_list>(<argument><expr><name>range_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Validate specified range</comment>
	<if_stmt><if>if<condition>(<expr><name>start</name> <operator>&gt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Variable length path, maximum number of hops must be greater or equal to minimum number of hops."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>AST_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>multihop</name> <init>= <expr><operator>(</operator><name>start</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>start</name> <operator>!=</operator> <name>end</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>multihop</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_VALID</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// Multi-hop traversals cannot be referenced</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>projections</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_VALID</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// Check if relation has an alias</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_identifier</name> <init>= <expr><call><name>cypher_ast_rel_pattern_get_identifier</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>ast_identifier</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_VALID</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// Verify that the alias is not found in the RETURN clause.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>identifier</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>ast_identifier</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>_AliasIsReturned</name><argument_list>(<argument><expr><name>projections</name></expr></argument>, <argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"RedisGraph does not support the return of variable-length traversal edges '%s'. \
        Instead, use a query in the style of: 'MATCH p = (a)-[%s*]-&gt;(b) RETURN relationships(p)'."</literal></expr></argument>,
						  <argument><expr><name>identifier</name></expr></argument>, <argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>AST_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>AST_VALID</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_Validate_ReusedEdges</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>edge_aliases</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>child_count</name> <init>= <expr><call><name>cypher_astnode_nchildren</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>child_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>cypher_astnode_get_child</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>new</name> <init>= <expr><call><name>raxInsert</name><argument_list>(<argument><expr><name>edge_aliases</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>alias</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><operator>!</operator><name>new</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Cannot use the same relationship variable '%s' for multiple patterns."</literal></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>AST_INVALID</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>AST_VALID</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_ValidateRelation</name><parameter_list>(<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>projections</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>,
										<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>edge_aliases</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AST_Validation</name></type> <name>res</name> <init>= <expr><name>AST_VALID</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// Make sure edge alias is unique</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_Validate_ReusedEdges</name><argument_list>(<argument><expr><name>edge</name></expr></argument>, <argument><expr><name>edge_aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// If this is a multi-hop traversal, validate it</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>range</name> <init>= <expr><call><name>cypher_ast_rel_pattern_get_varlength</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>range</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_ValidateMultiHopTraversal</name><argument_list>(<argument><expr><name>projections</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_ValidatePath</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
	<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>projections</name></decl></parameter>,
	<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>edge_aliases</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AST_Validation</name></type> <name>res</name> <init>= <expr><name>AST_VALID</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_NAMED_PATH</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>cypher_ast_named_path_get_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_SHORTEST_PATH</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if<condition>(<expr><call><name>cypher_ast_shortest_path_is_single</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<comment type="line">// MATCH (a), (b), p = shortestPath((a)-[*]-&gt;(b)) RETURN p</comment>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>AST_INVALID</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"RedisGraph currently only supports shortestPath in WITH or RETURN clauses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="line">// MATCH (a), (b), p = allShortestPaths((a)-[*2..]-&gt;(b)) RETURN p</comment>
			<comment type="line">// validate rel pattern range doesn't contains a minimum &gt; 1</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>ranges</name> <init>=
				<expr><call><name>AST_GetTypedNodes</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>CYPHER_AST_RANGE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>range_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>range_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<decl_stmt><decl><type><name>long</name></type> <name>min_hops</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name><name>ranges</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><call><name>cypher_ast_range_get_start</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if<condition>(<expr><name>start</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>min_hops</name> <operator>=</operator> <call><name>AST_ParseIntegerNode</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if<condition>(<expr><name>min_hops</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name>res</name> <operator>=</operator> <name>AST_INVALID</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"allShortestPaths(...) does not support a minimal length different from 1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>res</name> <operator>==</operator> <name>AST_VALID</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>uint</name></type> <name>path_len</name> <init>= <expr><call><name>cypher_ast_pattern_path_nelements</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// validate relations on the path (every odd offset) and collect aliases</comment>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>path_len</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>edge</name> <init>= <expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_ValidateRelation</name><argument_list>(<argument><expr><name>projections</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>, <argument><expr><name>edge_aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_ValidatePattern</name>
<parameter_list>(
	<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>projections</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>,
	<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>edge_aliases</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AST_Validation</name></type>  <name>res</name>         <init>=  <expr><name>AST_VALID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type>            <name>path_count</name>  <init>=  <expr><call><name>cypher_ast_pattern_npaths</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>path_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_ValidatePath</name><argument_list>(<argument><expr><call><name>cypher_ast_pattern_get_path</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>projections</name></expr></argument>, <argument><expr><name>edge_aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Validate the property maps used in node/edge patterns in MATCH, and CREATE clauses</comment>
<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_ValidateInlinedProperties</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>props</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>props</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CYPHER_AST_MAP</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Emit an error if the properties are not presented as a map, as in:</comment>
		<comment type="line">// MATCH (p {invalid_property_construction}) RETURN p</comment>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Encountered unhandled type in inlined properties."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>AST_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>prop_count</name> <init>= <expr><call><name>cypher_ast_map_nentries</name><argument_list>(<argument><expr><name>props</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>prop_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>prop_val</name> <init>= <expr><call><name>cypher_ast_map_get_value</name><argument_list>(<argument><expr><name>props</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>patterns</name> <init>= <expr><call><name>AST_GetTypedNodes</name><argument_list>(<argument><expr><name>prop_val</name></expr></argument>, <argument><expr><name>CYPHER_AST_PATTERN_PATH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint</name></type> <name>patterns_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>patterns</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>patterns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>patterns_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<comment type="line">// Encountered query of the form:</comment>
			<comment type="line">// MATCH (a {prop: ()-[]-&gt;()}) RETURN a</comment>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Encountered unhandled type in inlined properties."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>AST_INVALID</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>AST_VALID</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_ValidateInlinedPropertiesOnPath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>path_len</name> <init>= <expr><call><name>cypher_ast_pattern_path_nelements</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// Check all nodes on path</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>path_len</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_identifier</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>props</name> <init>= <expr><call><name>cypher_ast_node_pattern_get_properties</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>props</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>_ValidateInlinedProperties</name><argument_list>(<argument><expr><name>props</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>AST_VALID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="line">// Check all edges on path</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>path_len</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_identifier</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>edge</name> <init>= <expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>props</name> <init>= <expr><call><name>cypher_ast_rel_pattern_get_properties</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>props</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>_ValidateInlinedProperties</name><argument_list>(<argument><expr><name>props</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>AST_VALID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>AST_VALID</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_Validate_MATCH_Clause_Filters</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>pattern</name> <init>= <expr><call><name>cypher_ast_match_get_pattern</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>path_count</name> <init>= <expr><call><name>cypher_ast_pattern_npaths</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>path_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>cypher_ast_pattern_get_path</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>_ValidateInlinedPropertiesOnPath</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>AST_VALID</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_Validate_CALL_Clauses</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/* Make sure procedure calls are valid:
	 * 1. procedure exists
	 * 2. number of arguments to procedure is as expected
	 * 3. yield refers to procedure output */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>call_clauses</name> <init>= <expr><call><name>AST_GetClauses</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>CYPHER_AST_CALL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>call_clauses</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_VALID</name></expr>;</return></block_content></block></if></if_stmt>


	<decl_stmt><decl><type><name>ProcedureCtx</name>    <modifier>*</modifier></type><name>proc</name>         <init>=  <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rax</name>             <modifier>*</modifier></type><name>identifiers</name>  <init>=  <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AST_Validation</name></type>  <name>res</name>           <init>=  <expr><name>AST_VALID</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>call_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>call_clauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>call_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>identifiers</name> <operator>=</operator> <call><name>raxNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>call_clause</name> <init>= <expr><name><name>call_clauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="line">// Make sure procedure exists.</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proc_name</name> <init>= <expr><call><name>cypher_ast_proc_name_get_value</name><argument_list>(<argument><expr><call><name>cypher_ast_call_get_proc_name</name><argument_list>(<argument><expr><name>call_clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>Proc_Get</name><argument_list>(<argument><expr><name>proc_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><name>proc</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Procedure `%s` is not registered"</literal></expr></argument>, <argument><expr><name>proc_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>AST_INVALID</name></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Validate num of arguments.</comment>
		<if_stmt><if>if<condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>argc</name></name> <operator>!=</operator> <name>PROCEDURE_VARIABLE_ARG_COUNT</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>given_arg_count</name> <init>= <expr><call><name>cypher_ast_call_narguments</name><argument_list>(<argument><expr><name>call_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><call><name>Procedure_Argc</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>given_arg_count</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Procedure `%s` requires %d arguments, got %d"</literal></expr></argument>, <argument><expr><name>proc_name</name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>,
								  <argument><expr><name>given_arg_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <name>AST_INVALID</name></expr>;</expr_stmt>
				<goto>goto <name>cleanup</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// validate projections</comment>
		<decl_stmt><decl><type><name>uint</name></type> <name>proj_count</name> <init>= <expr><call><name>cypher_ast_call_nprojections</name><argument_list>(<argument><expr><name>call_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>proj_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<comment type="line">// collect call projections</comment>
			<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>proj_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>proj</name> <init>= <expr><call><name>cypher_ast_call_get_projection</name><argument_list>(<argument><expr><name>call_clause</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_exp</name> <init>= <expr><call><name>cypher_ast_projection_get_expression</name><argument_list>(<argument><expr><name>proj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>ast_exp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>identifier</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>ast_exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="line">// make sure each yield output is mentioned only once</comment>
				<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>raxInsert</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>identifier</name></expr></argument>,
							  <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Variable `%s` already declared"</literal></expr></argument>, <argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>res</name> <operator>=</operator> <name>AST_INVALID</name></expr>;</expr_stmt>
					<goto>goto <name>cleanup</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<comment type="line">// make sure procedure is aware of output</comment>
				<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>Procedure_ContainsOutput</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Procedure `%s` does not yield output `%s`"</literal></expr></argument>,
									  <argument><expr><name>proc_name</name></expr></argument>, <argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>res</name> <operator>=</operator> <name>AST_INVALID</name></expr>;</expr_stmt>
					<goto>goto <name>cleanup</name>;</goto>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>identifiers</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Proc_Free</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>proc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></for>

<label><name>cleanup</name>:</label>
	<if_stmt><if>if<condition>(<expr><name>proc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>Proc_Free</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name>identifiers</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>call_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_ValidateNodeAlias</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>edge_aliases</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_alias</name> <init>= <expr><call><name>cypher_ast_node_pattern_get_identifier</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>ast_alias</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_VALID</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// Verify that the node's alias is not in the map of edge aliases.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>ast_alias</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>raxFind</name><argument_list>(<argument><expr><name>edge_aliases</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>alias</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>raxNotFound</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"The alias '%s' was specified for both a node and a relationship."</literal></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>AST_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>AST_VALID</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_ValidateReusedAliases</name><parameter_list>(<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>edge_aliases</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AST_Validation</name></type> <name>res</name> <init>= <expr><name>AST_VALID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>path_count</name> <init>= <expr><call><name>cypher_ast_pattern_npaths</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>path_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>cypher_ast_pattern_get_path</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint</name></type> <name>path_len</name> <init>= <expr><call><name>cypher_ast_pattern_path_nelements</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>path_len</name></expr>;</condition> <incr><expr><name>j</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_ValidateNodeAlias</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>edge_aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_Validate_MATCH_Clauses</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// Check to see if all mentioned inlined, outlined functions exists.</comment>
	<comment type="line">// Inlined functions appear within entity definition ({a:v})</comment>
	<comment type="line">// Outlined functions appear within the WHERE clause.</comment>
	<comment type="line">// libcypher-parser doesn't have a WHERE node, all of the filters</comment>
	<comment type="line">// are specified within the MATCH node sub-tree.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>match_clauses</name> <init>= <expr><call><name>AST_GetClauses</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>CYPHER_AST_MATCH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>rax</name>             <modifier>*</modifier></type><name>edge_aliases</name>     <init>=  <expr><call><name>raxNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rax</name>             <modifier>*</modifier></type><name>reused_entities</name>  <init>=  <expr><call><name>raxNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AST_Validation</name></type>  <name>res</name>               <init>=  <expr><name>AST_VALID</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>return_clause</name> <init>=
		<expr><call><name>AST_GetClause</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>CYPHER_AST_RETURN</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>projections</name> <init>= <expr><call><name>_AST_GetReturnProjections</name><argument_list>(<argument><expr><name>return_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>match_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>match_clauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>match_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>match_clause</name> <init>= <expr><name><name>match_clauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<comment type="line">// Validate the pattern described by the MATCH clause</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_ValidatePattern</name><argument_list>(<argument><expr><name>projections</name></expr></argument>,
							   <argument><expr><call><name>cypher_ast_match_get_pattern</name><argument_list>(<argument><expr><name>match_clause</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>edge_aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>res</name> <operator>==</operator> <name>AST_INVALID</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

		<comment type="line">// Validate that inlined filters do not use parameters</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_Validate_MATCH_Clause_Filters</name><argument_list>(<argument><expr><name>match_clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>res</name> <operator>==</operator> <name>AST_INVALID</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

		<comment type="line">// Validate all function references in clause. Aggregate calls cannot be made in MATCH</comment>
		<comment type="line">// clauses or their WHERE predicates.</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>include_aggregates</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_ValidateFunctionCalls</name><argument_list>(<argument><expr><name>match_clause</name></expr></argument>, <argument><expr><name>include_aggregates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>res</name> <operator>==</operator> <name>AST_INVALID</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="line">// Verify that no relation alias is also used to denote a node</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>match_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>match_clause</name> <init>= <expr><name><name>match_clauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_ValidateReusedAliases</name><argument_list>(<argument><expr><name>edge_aliases</name></expr></argument>, <argument><expr><call><name>cypher_ast_match_get_pattern</name><argument_list>(<argument><expr><name>match_clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>res</name> <operator>==</operator> <name>AST_INVALID</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></for>

<label><name>cleanup</name>:</label>
	<if_stmt><if>if<condition>(<expr><name>projections</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>projections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>edge_aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>reused_entities</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>match_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_Validate_WITH_Clauses</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// Verify that all functions used in the WITH clause and (if present) its WHERE predicate</comment>
	<comment type="line">// are defined and used validly.</comment>
	<comment type="line">// An AST segment has at most 1 WITH clause.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>with_clause</name> <init>= <expr><call><name>AST_GetClause</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>CYPHER_AST_WITH</name></expr></argument>,
														<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>with_clause</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_VALID</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>rax</name> <init>= <expr><call><name>raxNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AST_Validation</name></type> <name>res</name> <init>= <expr><name>AST_VALID</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// Verify that each WITH projection either is aliased or is itself an identifier.</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>projection_count</name> <init>= <expr><call><name>cypher_ast_with_nprojections</name><argument_list>(<argument><expr><name>with_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>projection_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>proj</name> <init>= <expr><call><name>cypher_ast_with_get_projection</name><argument_list>(<argument><expr><name>with_clause</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_alias</name> <init>= <expr><call><name>cypher_ast_projection_get_alias</name><argument_list>(<argument><expr><name>proj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><name>ast_alias</name> <operator>&amp;&amp;</operator>
		   <call><name>cypher_astnode_type</name><argument_list>(<argument><expr><call><name>cypher_ast_projection_get_expression</name><argument_list>(<argument><expr><name>proj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CYPHER_AST_IDENTIFIER</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"WITH clause projections must be aliased"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>AST_INVALID</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>(<expr><name>ast_alias</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ast_alias</name> <operator>=</operator> <call><name>cypher_ast_projection_get_expression</name><argument_list>(<argument><expr><name>proj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>ast_alias</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// column with same name is invalid</comment>
		<if_stmt><if>if<condition>(<expr><call><name>raxTryInsert</name><argument_list>(<argument><expr><name>rax</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>alias</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Error: Multiple result columns with the same name are not supported."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>AST_INVALID</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>rax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>res</name> <operator>==</operator> <name>AST_VALID</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Verify that functions invoked by the WITH clause are valid.</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_ValidateFunctionCalls</name><argument_list>(<argument><expr><name>with_clause</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Verify that MERGE doesn't redeclare bound relations and that one reltype is specified for unbound relations.</comment>
<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_ValidateMergeRelation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>entity</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>defined_aliases</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>identifier</name> <init>= <expr><call><name>cypher_ast_rel_pattern_get_identifier</name><argument_list>(<argument><expr><name>entity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>identifier</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// Verify that we're not redeclaring a bound variable.</comment>
		<if_stmt><if>if<condition>(<expr><call><name>raxFind</name><argument_list>(<argument><expr><name>defined_aliases</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>alias</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>raxNotFound</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"The bound variable %s' can't be redeclared in a MERGE clause"</literal></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>AST_INVALID</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Exactly one reltype should be specified for the introduced edge.</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>reltype_count</name> <init>= <expr><call><name>cypher_ast_rel_pattern_nreltypes</name><argument_list>(<argument><expr><name>entity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>reltype_count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Exactly one relationship type must be specified for each relation in a MERGE pattern."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>AST_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// We don't need to validate the MERGE edge's direction, as an undirected edge in MERGE</comment>
	<comment type="line">// should cause a single outgoing edge to be created.</comment>

	<return>return <expr><name>AST_VALID</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Verify that MERGE doesn't redeclare bound nodes.</comment>
<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_ValidateMergeNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>entity</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>defined_aliases</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>raxSize</name><argument_list>(<argument><expr><name>defined_aliases</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_VALID</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>identifier</name> <init>= <expr><call><name>cypher_ast_node_pattern_get_identifier</name><argument_list>(<argument><expr><name>entity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>identifier</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_VALID</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>raxFind</name><argument_list>(<argument><expr><name>defined_aliases</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>alias</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>raxNotFound</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// If the entity is unaliased or not previously bound, it cannot be redeclared.</comment>
		<return>return <expr><name>AST_VALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// If the entity is already bound, the MERGE pattern should not introduce labels or properties.</comment>
	<if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>cypher_ast_node_pattern_nlabels</name><argument_list>(<argument><expr><name>entity</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
	   <call><name>cypher_ast_node_pattern_get_properties</name><argument_list>(<argument><expr><name>entity</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"The bound node '%s' can't be redeclared in a MERGE clause"</literal></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>AST_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>AST_VALID</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Validate SET property.</comment>
<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>Validate_SETProperty</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>set_item</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_prop</name> <init>= <expr><call><name>cypher_ast_set_property_get_property</name><argument_list>(<argument><expr><name>set_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_entity</name> <init>= <expr><call><name>cypher_ast_property_operator_get_expression</name><argument_list>(<argument><expr><name>ast_prop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>ast_entity</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CYPHER_AST_IDENTIFIER</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"RedisGraph does not currently support non-alias references on the left-hand side of SET expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>AST_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>AST_VALID</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_Validate_MERGE_Clauses</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AST_Validation</name></type> <name>res</name> <init>= <expr><name>AST_VALID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name> <modifier>*</modifier></type><name>merge_clause_indices</name> <init>= <expr><call><name>AST_GetClauseIndices</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>CYPHER_AST_MERGE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>merge_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>merge_clause_indices</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>defined_aliases</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>merge_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>defined_aliases</name> <operator>=</operator> <call><name>raxNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>start_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>merge_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>uint</name></type> <name>clause_idx</name> <init>= <expr><name><name>merge_clause_indices</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="line">// Collect all entities that are bound before this MERGE clause.</comment>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><name>start_offset</name></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>clause_idx</name></expr>;</condition> <incr><expr><name>j</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>_AST_GetDefinedIdentifiers</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>defined_aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>start_offset</name> <operator>=</operator> <name>clause_idx</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>merge_clause</name> <init>= <expr><call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>clause_idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>cypher_ast_merge_get_pattern_path</name><argument_list>(<argument><expr><name>merge_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// Verify that functions invoked in the MERGE pattern are valid.</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_ValidateFunctionCalls</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>uint</name></type> <name>nelems</name> <init>= <expr><call><name>cypher_ast_pattern_path_nelements</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>j</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>entity</name> <init>= <expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="line">// Odd offsets correspond to edges, even offsets correspond to nodes.</comment>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>j</name> <operator>%</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>_ValidateMergeRelation</name><argument_list>(<argument><expr><name>entity</name></expr></argument>, <argument><expr><name>defined_aliases</name></expr></argument>)</argument_list></call></expr>
				  </then><else>: <expr><call><name>_ValidateMergeNode</name><argument_list>(<argument><expr><name>entity</name></expr></argument>, <argument><expr><name>defined_aliases</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="line">// Verify that any filters on the path refer to constants or resolved identifiers.</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_ValidateInlinedPropertiesOnPath</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>uint</name></type> <name>action_count</name> <init>= <expr><call><name>cypher_ast_merge_nactions</name><argument_list>(<argument><expr><name>merge_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>action_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>action</name> <init>= <expr><call><name>cypher_ast_merge_get_action</name><argument_list>(<argument><expr><name>merge_clause</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>_ValidateFunctionCalls</name><argument_list>(<argument><expr><name>action</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_ON_CREATE</name></expr>)</condition> <block>{<block_content>
				<comment type="line">// ON CREATE.</comment>
				<decl_stmt><decl><type><name>uint</name></type> <name>n_set_items</name> <init>= <expr><call><name>cypher_ast_on_create_nitems</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>n_set_items</name></expr>;</condition> <incr><expr><name>j</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>set_item</name> <init>= <expr><call><name>cypher_ast_on_create_get_item</name><argument_list>(<argument><expr><name>action</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>set_item</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_SET_PROPERTY</name></expr>)</condition> <block>{<block_content>
						<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>Validate_SETProperty</name><argument_list>(<argument><expr><name>set_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_ON_MATCH</name></expr>)</condition> <block>{<block_content>
				<comment type="line">// ON MATCH.</comment>
				<decl_stmt><decl><type><name>uint</name></type> <name>n_set_items</name> <init>= <expr><call><name>cypher_ast_on_match_nitems</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>n_set_items</name></expr>;</condition> <incr><expr><name>j</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>set_item</name> <init>= <expr><call><name>cypher_ast_on_match_get_item</name><argument_list>(<argument><expr><name>action</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>set_item</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_SET_PROPERTY</name></expr>)</condition> <block>{<block_content>
						<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>Validate_SETProperty</name><argument_list>(<argument><expr><name>set_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

<label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>merge_clause_indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>defined_aliases</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>defined_aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Validate each entity referenced in a single path of a CREATE clause.</comment>
<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_Validate_CREATE_Entities</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
												<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>defined_aliases</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>_ValidateInlinedPropertiesOnPath</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>nelems</name> <init>= <expr><call><name>cypher_ast_pattern_path_nelements</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	 <comment type="line">// Redeclaration of a node is not allowed only when the path is of length 0, as in: MATCH (a) CREATE (a).</comment>
	 <comment type="line">// Otherwise, using a defined alias of a node is allowed, as in: MATCH (a) CREATE (a)-[:E]-&gt;(:B)</comment>
	<if_stmt><if>if<condition>(<expr><name>nelems</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>identifier</name> <init>= <expr><call><name>cypher_ast_node_pattern_get_identifier</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>identifier</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><call><name>raxFind</name><argument_list>(<argument><expr><name>defined_aliases</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>alias</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>raxNotFound</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"The bound variable '%s' can't be redeclared in a CREATE clause"</literal></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>AST_INVALID</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="line">//Visit every relationship (every odd offset) on the path to validate its alias and structure.</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>j</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>identifier</name> <init>= <expr><call><name>cypher_ast_rel_pattern_get_identifier</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// Validate that no relation aliases are previously bound.</comment>
		<if_stmt><if>if<condition>(<expr><name>identifier</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><call><name>raxFind</name><argument_list>(<argument><expr><name>defined_aliases</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>alias</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>raxNotFound</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"The bound variable '%s' can't be redeclared in a CREATE clause"</literal></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>AST_INVALID</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Validate that each relation has exactly one type.</comment>
		<decl_stmt><decl><type><name>uint</name></type> <name>reltype_count</name> <init>= <expr><call><name>cypher_ast_rel_pattern_nreltypes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>reltype_count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Exactly one relationship type must be specified for CREATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>AST_INVALID</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Validate that each relation being created is directed.</comment>
		<if_stmt><if>if<condition>(<expr><call><name>cypher_ast_rel_pattern_get_direction</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_REL_BIDIRECTIONAL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Only directed relationships are supported in CREATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>AST_INVALID</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>AST_VALID</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_Validate_CREATE_Clauses</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AST_Validation</name></type> <name>res</name> <init>= <expr><name>AST_VALID</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint</name> <modifier>*</modifier></type><name>create_clause_indices</name> <init>= <expr><call><name>AST_GetClauseIndices</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>CYPHER_AST_CREATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>clause_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>create_clause_indices</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>defined_aliases</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>clause_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>defined_aliases</name> <operator>=</operator> <call><name>raxNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>start_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>clause_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>uint</name></type> <name>clause_idx</name> <init>= <expr><name><name>create_clause_indices</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="line">// Collect all entities that are bound before this CREATE clause.</comment>
		<for>for <control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><name>start_offset</name></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>clause_idx</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>prev_clause</name> <init>= <expr><call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>_AST_GetDefinedIdentifiers</name><argument_list>(<argument><expr><name>prev_clause</name></expr></argument>, <argument><expr><name>defined_aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>start_offset</name> <operator>=</operator> <name>clause_idx</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>clause_idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>pattern</name> <init>= <expr><call><name>cypher_ast_create_get_pattern</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// Verify that functions invoked in the CREATE pattern are valid.</comment>
		<if_stmt><if>if <condition>(<expr><call><name>_ValidateFunctionCalls</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>uint</name></type> <name>path_count</name> <init>= <expr><call><name>cypher_ast_pattern_npaths</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>prev_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>path_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>cypher_ast_pattern_get_path</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="line">// Collect aliases defined on the previous path in this CREATE clause.</comment>
			<if_stmt><if>if <condition>(<expr><name>prev_path</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>_AST_Path_GetDefinedIdentifiers</name><argument_list>(<argument><expr><name>prev_path</name></expr></argument>, <argument><expr><name>defined_aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_Validate_CREATE_Entities</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>defined_aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>AST_INVALID</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>prev_path</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<comment type="block">/* Since we combine all our CREATE clauses in a segment into one operation,
	 * make sure no data-modifying clauses can separate them. TCK example:
	 * CREATE (a:A), (b:B) MERGE (a)-[:KNOWS]-&gt;(b) CREATE (b)-[:KNOWS]-&gt;(c:C) RETURN count(*)
	 */</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><name><name>create_clause_indices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>create_clause_indices</name><index>[<expr><name>clause_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_MERGE</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"RedisGraph does not support queries of the form CREATE...MERGE...CREATE without a separating WITH clause."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>AST_INVALID</name></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
<label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>create_clause_indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>defined_aliases</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>defined_aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_Validate_DELETE_Clauses</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>delete_clauses</name> <init>= <expr><call><name>AST_GetClauses</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>CYPHER_AST_DELETE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AST_Validation</name></type> <name>res</name> <init>= <expr><name>AST_VALID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>clause_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>delete_clauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>clause_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><name><name>delete_clauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint</name></type> <name>expression_count</name> <init>= <expr><call><name>cypher_ast_delete_nexpressions</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>expression_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>exp</name> <init>= <expr><call><name>cypher_ast_delete_get_expression</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="line">// expecting an identifier or a function call</comment>
			<comment type="line">// identifiers and calls that don't resolve to a node, path or edge</comment>
			<comment type="line">// will raise an error at run-time</comment>
			<if_stmt><if>if<condition>(<expr><name>type</name> <operator>!=</operator> <name>CYPHER_AST_IDENTIFIER</name> <operator>&amp;&amp;</operator>
			   <name>type</name> <operator>!=</operator> <name>CYPHER_AST_APPLY_OPERATOR</name> <operator>&amp;&amp;</operator>
			   <name>type</name> <operator>!=</operator> <name>CYPHER_AST_APPLY_ALL_OPERATOR</name> <operator>&amp;&amp;</operator>
			   <name>type</name> <operator>!=</operator> <name>CYPHER_AST_SUBSCRIPT_OPERATOR</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"DELETE can only be called on nodes, paths and relationships"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <name>AST_INVALID</name></expr>;</expr_stmt>
				<goto>goto <name>cleanup</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="line">// validate any func</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>include_aggregates</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_ValidateFunctionCalls</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>include_aggregates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>res</name> <operator>==</operator> <name>AST_INVALID</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></for>

<label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>delete_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AST_Validation</name></type> <name>_AST_ValidateResultColumns</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>return_clause</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>return_clause</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>cypher_ast_return_has_include_existing</name><argument_list>(<argument><expr><name>return_clause</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>AST_VALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>rax</name>           <modifier>*</modifier></type><name>rax</name>          <init>= <expr><call><name>raxNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AST_Validation</name></type> <name>res</name>          <init>= <expr><name>AST_VALID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>   <modifier>*</modifier><modifier>*</modifier></type><name>columns</name>      <init>= <expr><call><name>AST_BuildReturnColumnNames</name><argument_list>(<argument><expr><name>return_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type>           <name>column_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>columns</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>column_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<comment type="line">// column with same name is invalid</comment>
		<if_stmt><if>if<condition>(<expr><call><name>raxTryInsert</name><argument_list>(<argument><expr><name>rax</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>columns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>columns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Error: Multiple result columns with the same name are not supported."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>AST_INVALID</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	
	<expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>rax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_Validate_RETURN_Clause</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>return_clause</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>return_clause</name> <operator>=</operator> <call><name>AST_GetClause</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>CYPHER_AST_RETURN</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// no RETURN clause, nothing to validate</comment>
	<if_stmt><if>if<condition>(<expr><name>return_clause</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_VALID</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// validate all user-specified functions in RETURN clause</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>include_aggregates</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>_ValidateFunctionCalls</name><argument_list>(<argument><expr><name>return_clause</name></expr></argument>, <argument><expr><name>include_aggregates</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AST_INVALID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>
	
	<return>return <expr><call><name>_AST_ValidateResultColumns</name><argument_list>(<argument><expr><name>return_clause</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_Validate_UNWIND_Clauses</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>unwind_clauses</name> <init>= <expr><call><name>AST_GetClauses</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>CYPHER_AST_UNWIND</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>unwind_clauses</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_VALID</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>AST_Validation</name></type> <name>res</name> <init>= <expr><name>AST_VALID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>clause_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>unwind_clauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>clause_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>expression</name> <init>= <expr><call><name>cypher_ast_unwind_get_expression</name><argument_list>(<argument><expr><name><name>unwind_clauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// Verify that all elements of the UNWIND collection are supported by RedisGraph</comment>
		<decl_stmt><decl><type><name>uint</name></type> <name>child_count</name> <init>= <expr><call><name>cypher_astnode_nchildren</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>child_count</name></expr>;</condition> <incr><expr><name>j</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>CypherWhitelist_ValidateQuery</name><argument_list>(<argument><expr><call><name>cypher_astnode_get_child</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<comment type="line">// Verify that UNWIND doesn't call non-existent or unsupported functions.</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_ValidateFunctionCalls</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></for>

<label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>unwind_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// LIMIT and SKIP are not independent clauses, but modifiers that can be applied to WITH or RETURN clauses</comment>
<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_Validate_LIMIT_SKIP_Modifiers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// Handle modifiers on the RETURN clause</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>return_clause</name> <init>= <expr><call><name>AST_GetClause</name><argument_list>(<argument><expr><name>ast</name></expr></argument>,
														  <argument><expr><name>CYPHER_AST_RETURN</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// Skip check if the RETURN clause does not specify a limit</comment>
	<if_stmt><if>if<condition>(<expr><name>return_clause</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Handle LIMIT modifier</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>limit</name> <init>= <expr><call><name>cypher_ast_return_get_limit</name><argument_list>(<argument><expr><name>return_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>limit</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// Handle non-integer or non parameter types specified as LIMIT value</comment>
			<comment type="line">// The value validation of integer node or parameter node is done in run time evaluation.</comment>
			<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CYPHER_AST_INTEGER</name> <operator>&amp;&amp;</operator>
			   <call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CYPHER_AST_PARAMETER</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"LIMIT specified value of invalid type, must be a positive integer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>AST_INVALID</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Handle SKIP modifier</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>skip</name> <init>= <expr><call><name>cypher_ast_return_get_skip</name><argument_list>(<argument><expr><name>return_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>skip</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// Handle non-integer or non parameter types specified as skip value</comment>
			<comment type="line">// The value validation of integer node or parameter node is done in run time evaluation.</comment>
			<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>skip</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CYPHER_AST_INTEGER</name> <operator>&amp;&amp;</operator>
			   <call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>skip</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CYPHER_AST_PARAMETER</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"SKIP specified value of invalid type, must be a positive integer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>AST_INVALID</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Handle LIMIT modifiers on all WITH clauses</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>with_clauses</name> <init>= <expr><call><name>AST_GetClauses</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>CYPHER_AST_WITH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>with_clauses</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_VALID</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>AST_Validation</name></type> <name>res</name> <init>= <expr><name>AST_VALID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>with_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>with_clauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>with_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>with_clause</name> <init>= <expr><name><name>with_clauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<comment type="line">// Handle LIMIT modifier</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>limit</name> <init>= <expr><call><name>cypher_ast_with_get_limit</name><argument_list>(<argument><expr><name>with_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>limit</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// Handle non-integer or non parameter types specified as LIMIT value</comment>
			<comment type="line">// The value validation of integer node or parameter node is done in run time evaluation.</comment>
			<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CYPHER_AST_INTEGER</name> <operator>&amp;&amp;</operator>
			   <call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CYPHER_AST_PARAMETER</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"LIMIT specified value of invalid type, must be a positive integer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>AST_INVALID</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Handle SKIP modifier</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>skip</name> <init>= <expr><call><name>cypher_ast_with_get_skip</name><argument_list>(<argument><expr><name>with_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>skip</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// Handle non-integer or non parameter types specified as skip value</comment>
			<comment type="line">// The value validation of integer node or parameter node is done in run time evaluation.</comment>
			<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>skip</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CYPHER_AST_INTEGER</name> <operator>&amp;&amp;</operator>
			   <call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>skip</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CYPHER_AST_PARAMETER</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"SKIP specified value of invalid type, must be a positive integer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>AST_INVALID</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>with_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// A query must end in a RETURN clause, a procedure, or an updating clause</comment>
<comment type="line">// (CREATE, MERGE, DELETE, SET, or REMOVE once supported)</comment>
<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_ValidateQueryTermination</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>ast</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>clause_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>return_clause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>following_clause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>clause_count</name> <init>= <expr><call><name>cypher_ast_query_nclauses</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// libcypher-parser do not enforce clause sequance order:</comment>
	<comment type="line">// queries such as 'RETURN CREATE' and 'RETURN RETURN' are considered</comment>
	<comment type="line">// valid by the parser</comment>
	<comment type="line">// make sure the only clause following RETURN is UNION</comment>

	<comment type="line">// get first instance of a RETURN clause</comment>
	<expr_stmt><expr><name>return_clause</name> <operator>=</operator> <call><name>AST_GetClause</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>CYPHER_AST_RETURN</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clause_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>return_clause</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>clause_idx</name> <operator>&lt;</operator> <name>clause_count</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<comment type="line">// RETURN clause isn't the last clause</comment>
		<comment type="line">// the only clause which can follow a RETURN is the UNION clause</comment>
		<expr_stmt><expr><name>following_clause</name> <operator>=</operator> <call><name>AST_GetClauseByIdx</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>clause_idx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>following_clause</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CYPHER_AST_UNION</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// unexpected clause following RETURN</comment>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Unexpected clause following RETURN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>AST_INVALID</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>last_clause</name> <init>= <expr><call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>clause_count</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>last_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>!=</operator> <name>CYPHER_AST_RETURN</name>   <operator>&amp;&amp;</operator>
	   <name>type</name> <operator>!=</operator> <name>CYPHER_AST_CREATE</name>   <operator>&amp;&amp;</operator>
	   <name>type</name> <operator>!=</operator> <name>CYPHER_AST_MERGE</name>    <operator>&amp;&amp;</operator>
	   <name>type</name> <operator>!=</operator> <name>CYPHER_AST_DELETE</name>   <operator>&amp;&amp;</operator>
	   <name>type</name> <operator>!=</operator> <name>CYPHER_AST_SET</name>      <operator>&amp;&amp;</operator>
	   <name>type</name> <operator>!=</operator> <name>CYPHER_AST_CALL</name></expr>
	  )</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Query cannot conclude with %s (must be RETURN or an update clause)"</literal></expr></argument>,
						  <argument><expr><call><name>cypher_astnode_typestr</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>AST_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>AST_VALID</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_RegisterCallOutputs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>call_clause</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>identifiers</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proc_name</name> <init>= <expr><call><name>cypher_ast_proc_name_get_value</name><argument_list>(<argument><expr><call><name>cypher_ast_call_get_proc_name</name><argument_list>(<argument><expr><name>call_clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProcedureCtx</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><call><name>Proc_Get</name><argument_list>(<argument><expr><name>proc_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>proc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>output_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>output</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>output_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>Procedure_GetOutput</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="line">// Perform validations not constrained to a specific scope</comment>
<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_ValidateQuerySequence</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>)</parameter_list> <block>{<block_content>

	<comment type="line">// Validate the final clause</comment>
	<if_stmt><if>if<condition>(<expr><call><name>_ValidateQueryTermination</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// The query cannot begin with a "WITH/RETURN *" projection.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>start_clause</name> <init>= <expr><call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>start_clause</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_WITH</name> <operator>&amp;&amp;</operator>
	   <call><name>cypher_ast_with_has_include_existing</name><argument_list>(<argument><expr><name>start_clause</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Query cannot begin with 'WITH *'."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>AST_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>start_clause</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_RETURN</name> <operator>&amp;&amp;</operator>
	   <call><name>cypher_ast_return_has_include_existing</name><argument_list>(<argument><expr><name>start_clause</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Query cannot begin with 'RETURN *'."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>AST_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>AST_VALID</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* In any given query scope, reading clauses (MATCH, UNWIND, and InQueryCall)
 * cannot follow updating clauses (CREATE, MERGE, DELETE, SET, REMOVE).
 * https://s3.amazonaws.com/artifacts.opencypher.org/railroad/SinglePartQuery.html
 * Additionally, a MATCH clause cannot follow an OPTIONAL MATCH clause. */</comment>
<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_ValidateClauseOrder</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>clause_count</name> <init>= <expr><call><name>cypher_ast_query_nclauses</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>encountered_optional_match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>encountered_updating_clause</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>clause_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><name>encountered_updating_clause</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>type</name> <operator>==</operator> <name>CYPHER_AST_CREATE</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>CYPHER_AST_MERGE</name> <operator>||</operator>
											<name>type</name> <operator>==</operator> <name>CYPHER_AST_DELETE</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>CYPHER_AST_SET</name> <operator>||</operator>
											<name>type</name> <operator>==</operator> <name>CYPHER_AST_REMOVE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>encountered_updating_clause</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>encountered_updating_clause</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>type</name> <operator>==</operator> <name>CYPHER_AST_MATCH</name> <operator>||</operator>
												  <name>type</name> <operator>==</operator> <name>CYPHER_AST_UNWIND</name> <operator>||</operator>
												  <name>type</name> <operator>==</operator> <name>CYPHER_AST_CALL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"A WITH clause is required to introduce %s after an updating clause."</literal></expr></argument>,
							  <argument><expr><call><name>cypher_astnode_typestr</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>AST_INVALID</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_MATCH</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// Check whether this match is optional.</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>current_clause_is_optional</name> <init>= <expr><call><name>cypher_ast_match_is_optional</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="line">// If the current clause is non-optional but we have already encountered an optional match, emit an error.</comment>
			<if_stmt><if>if<condition>(<expr><operator>!</operator><name>current_clause_is_optional</name> <operator>&amp;&amp;</operator> <name>encountered_optional_match</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"A WITH clause is required to introduce a MATCH clause after an OPTIONAL MATCH."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>AST_INVALID</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>encountered_optional_match</name> <operator>|=</operator> <name>current_clause_is_optional</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>AST_VALID</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_Path_GetDefinedIdentifiers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>identifiers</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/* Collect the aliases of named paths, nodes, and edges.
	 * All more deeply-nested identifiers are referenced rather than defined,
	 * and will not be collected. This enforces reference checking on aliases like 'fake' in:
	 * MATCH (a {val: fake}) RETURN a */</comment>
	<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_NAMED_PATH</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// If this is a named path, collect its alias.</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>alias_node</name> <init>= <expr><call><name>cypher_ast_named_path_get_identifier</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>alias_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>alias</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>path_len</name> <init>= <expr><call><name>cypher_ast_pattern_path_nelements</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>path_len</name></expr>;</condition> <incr><expr><name>j</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// Retrieve the path element's alias if one is present.</comment>
		<comment type="line">// Odd offsets correspond to edges, even offsets correspond to nodes.</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>alias_node</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>j</name> <operator>%</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then>
											 <expr><call><name>cypher_ast_rel_pattern_get_identifier</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr> </then><else>:
											 <expr><call><name>cypher_ast_node_pattern_get_identifier</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><name>alias_node</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> <comment type="line">// Skip unaliased entities.</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>alias_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>alias</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_Pattern_GetDefinedIdentifiers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>identifiers</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/* Collect all aliases defined in a MATCH or CREATE pattern,
	 * which is comprised of 1 or more paths. */</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>path_count</name> <init>= <expr><call><name>cypher_ast_pattern_npaths</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>path_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>cypher_ast_pattern_get_path</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// Collect aliases defined on each path.</comment>
		<expr_stmt><expr><call><name>_AST_Path_GetDefinedIdentifiers</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_CreateIndex_GetDefinedIdentifiers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>identifiers</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>child_count</name> <init>= <expr><call><name>cypher_astnode_nchildren</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name>child_count</name></expr>;</condition> <incr><expr><name>c</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>cypher_astnode_get_child</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>identifier</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>identifier</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_GetDefinedIdentifiers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>identifiers</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
	<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_RETURN</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Only collect aliases (which may be referenced in an ORDER BY)
		 * from the RETURN clause, rather than all identifiers */</comment>
		<expr_stmt><expr><call><name>_AST_GetReturnAliases</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_WITH</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Get alias if one is provided; otherwise use the expression identifier</comment>
		<expr_stmt><expr><call><name>_AST_GetWithAliases</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_CALL</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Get alias if one is provided; otherwise use the expression identifier</comment>
		<expr_stmt><expr><call><name>_AST_GetProcCallAliases</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_MATCH</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Collect all identifiers defined by the pattern in the MATCH clause,
		 * ignoring references in property maps and WHERE predicates. */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>match_pattern</name> <init>= <expr><call><name>cypher_ast_match_get_pattern</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_AST_Pattern_GetDefinedIdentifiers</name><argument_list>(<argument><expr><name>match_pattern</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_MERGE</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Collect all identifiers defined by the path in the MERGE clause,
		 * ignoring references in property maps and ON CREATE / ON MATCH actions. */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>merge_path</name> <init>= <expr><call><name>cypher_ast_merge_get_pattern_path</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_AST_Path_GetDefinedIdentifiers</name><argument_list>(<argument><expr><name>merge_path</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_CREATE</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Collect all identifiers defined by the pattern in the CREATE clause,
		 * ignoring references in property maps.  */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>pattern</name> <init>= <expr><call><name>cypher_ast_create_get_pattern</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_AST_Pattern_GetDefinedIdentifiers</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_UNWIND</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* UNWIND only defines its own alias, which is just 'defined' in the query:
		 * UNWIND [ref_1, ref_2] AS defined RETURN defined */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>unwind_alias_node</name> <init>= <expr><call><name>cypher_ast_unwind_get_alias</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unwind_alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>unwind_alias_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>unwind_alias</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>unwind_alias</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_CALL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_AST_RegisterCallOutputs</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_CREATE_NODE_PROPS_INDEX</name> <operator>||</operator> 
		<name>type</name> <operator>==</operator> <name>CYPHER_AST_CREATE_PATTERN_PROPS_INDEX</name> <operator>||</operator>
		<name>type</name> <operator>==</operator> <name>CYPHER_AST_DROP_PROPS_INDEX</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_AST_CreateIndex_GetDefinedIdentifiers</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else <block>{<block_content>
		<decl_stmt><decl><type><name>uint</name></type> <name>child_count</name> <init>= <expr><call><name>cypher_astnode_nchildren</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name>child_count</name></expr>;</condition> <incr><expr><name>c</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>cypher_astnode_get_child</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>_AST_GetDefinedIdentifiers</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_AST_GetReferredIdentifiers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>identifiers</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_WITH</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// WITH clauses should only have their inputs collected, not their outputs.</comment>
		<expr_stmt><expr><call><name>_AST_GetWithReferences</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>_AST_GetIdentifiers</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_Validate_Aliases_DefinedInClause</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
														<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>defined_aliases</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AST_Validation</name></type> <name>res</name> <init>= <expr><name>AST_VALID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>referred_identifiers</name> <init>= <expr><call><name>raxNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Get defined identifiers.</comment>
	<expr_stmt><expr><call><name>_AST_GetDefinedIdentifiers</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>defined_aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Get referred identifiers.</comment>
	<expr_stmt><expr><call><name>_AST_GetReferredIdentifiers</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>referred_identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>raxIterator</name></type> <name>it</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_prepareIterateAll</name><argument_list>(<argument><expr><name>referred_identifiers</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// See that each referred identifier is defined.</comment>
	<while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>it</name><operator>.</operator><name>key_len</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><name><name>it</name><operator>.</operator><name>key</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>raxFind</name><argument_list>(<argument><expr><name>defined_aliases</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>raxNotFound</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"%.*s not defined"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>AST_INVALID</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="line">// Clean up:</comment>
	<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>referred_identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check that all referred identifiers been defined. */</comment>
<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_Validate_Aliases_Defined</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AST_Validation</name></type> <name>res</name> <init>= <expr><name>AST_VALID</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// Retrieve the indices of each WITH clause to properly set the bounds of each scope.</comment>
	<comment type="line">// If the query does not have a WITH clause, there is only one scope.</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>end_offset</name> <init>= <expr><call><name>cypher_ast_query_nclauses</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>defined_aliases</name> <init>= <expr><call><name>raxNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>end_offset</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// For each clause, confirm that all referred aliases have been previously defined.</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_Validate_Aliases_DefinedInClause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>defined_aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_WITH</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// each WITH clause marks the beginning of a new scope for defined aliases</comment>
			<comment type="line">// if the WITH clause contains a star projection, all variables from</comment>
			<comment type="line">// the previous scope are carried over</comment>
			<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>cypher_ast_with_has_include_existing</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>defined_aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>defined_aliases</name> <operator>=</operator> <call><name>raxNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>_AST_GetDefinedIdentifiers</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>defined_aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>defined_aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Report encountered errors by libcypher-parser.</comment>
<function><type><name>void</name></type> <name>AST_ReportErrors</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_parse_result_t</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_parse_result_nerrors</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// report first encountered error</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_parse_error_t</name> <modifier>*</modifier></type><name>error</name> <init>=
		<expr><call><name>cypher_parse_result_get_error</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Get the position of an error.</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>cypher_input_position</name></name></type> <name>errPos</name> <init>= <expr><call><name>cypher_parse_error_position</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Get the error message of an error.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errMsg</name> <init>= <expr><call><name>cypher_parse_error_message</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Get the error context of an error.</comment>
	<comment type="line">// This returns a pointer to a null-terminated string, which contains a</comment>
	<comment type="line">// section of the input around where the error occurred, that is limited</comment>
	<comment type="line">// in length and suitable for presentation to a user.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errCtx</name> <init>= <expr><call><name>cypher_parse_error_context</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Get the offset into the context of an error.</comment>
	<comment type="line">// Identifies the point of the error within the context string, allowing</comment>
	<comment type="line">// this to be reported to the user, typically with an arrow pointing to the</comment>
	<comment type="line">// invalid character.</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>errCtxOffset</name> <init>= <expr><call><name>cypher_parse_error_context_offset</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"errMsg: %s line: %u, column: %u, offset: %zu errCtx: %s errCtxOffset: %zu"</literal></expr></argument>,
					  <argument><expr><name>errMsg</name></expr></argument>, <argument><expr><name><name>errPos</name><operator>.</operator><name>line</name></name></expr></argument>, <argument><expr><name><name>errPos</name><operator>.</operator><name>column</name></name></expr></argument>, <argument><expr><name><name>errPos</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name>errCtx</name></expr></argument>, <argument><expr><name>errCtxOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// checks if set items contains non-alias referenes in lhs</comment>
<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_Validate_SETItems</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>set_clause</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>nitems</name> <init>= <expr><call><name>cypher_ast_set_nitems</name><argument_list>(<argument><expr><name>set_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<comment type="line">// Get the SET directive at this index.</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>set_item</name> <init>= <expr><call><name>cypher_ast_set_get_item</name><argument_list>(<argument><expr><name>set_clause</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>set_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>type</name> <operator>==</operator> <name>CYPHER_AST_SET_PROPERTY</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>AST_Validation</name></type> <name>res</name> <init>= <expr><call><name>Validate_SETProperty</name><argument_list>(<argument><expr><name>set_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>AST_VALID</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// checks if SET cluase contains aggregation function</comment>
<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_Validate_SET_Clauses</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>set_clauses</name> <init>= <expr><call><name>AST_GetClauses</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>CYPHER_AST_SET</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>set_clauses</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_VALID</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>AST_Validation</name></type> <name>res</name> <init>= <expr><name>AST_VALID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>set_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>set_clauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>set_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_Validate_SETItems</name><argument_list>(<argument><expr><name><name>set_clauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

		<comment type="line">// validate function calls within the SET clause</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>include_aggregates</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_ValidateFunctionCalls</name><argument_list>(<argument><expr><name><name>set_clauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>include_aggregates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>set_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_ValidateClauses</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// Verify that the clause order in the scope is valid.</comment>
	<if_stmt><if>if<condition>(<expr><call><name>_ValidateClauseOrder</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>_Validate_CALL_Clauses</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AST_INVALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>_Validate_MATCH_Clauses</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AST_INVALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>_Validate_WITH_Clauses</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AST_INVALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>_Validate_MERGE_Clauses</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AST_INVALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>_Validate_CREATE_Clauses</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AST_INVALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>_Validate_DELETE_Clauses</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AST_INVALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>_Validate_RETURN_Clause</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AST_INVALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>_Validate_UNWIND_Clauses</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AST_INVALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>_Validate_SET_Clauses</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AST_INVALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>_Validate_LIMIT_SKIP_Modifiers</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AST_INVALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>AST_VALID</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_ValidateUnion_Clauses</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>AST_ContainsClause</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>CYPHER_AST_UNION</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_VALID</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Make sure there's no conflict between UNION clauses
	 * either all UNION clauses specify ALL or nither of them does. */</comment>
	<decl_stmt><decl><type><name>AST_Validation</name></type> <name>res</name> <init>= <expr><name>AST_VALID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name> <modifier>*</modifier></type><name>union_indices</name> <init>= <expr><call><name>AST_GetClauseIndices</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>CYPHER_AST_UNION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>union_clause_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>union_indices</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>has_all_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>union_clause_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>union_clause</name> <init>= <expr><call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name><name>union_indices</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>cypher_ast_union_has_all</name><argument_list>(<argument><expr><name>union_clause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>has_all_count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>union_indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// If we've encountered UNION ALL clause, all UNION clauses should specify ALL.</comment>
	<if_stmt><if>if<condition>(<expr><name>has_all_count</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name>has_all_count</name> <operator>!=</operator> <name>union_clause_count</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Invalid combination of UNION and UNION ALL."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>AST_INVALID</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Require all RETURN clauses to perform the exact same projection.</comment>
	<decl_stmt><decl><type><name>uint</name> <modifier>*</modifier></type><name>return_indices</name> <init>= <expr><call><name>AST_GetClauseIndices</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>CYPHER_AST_RETURN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>return_clause_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>return_indices</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// We should have one more RETURN clause than we have UNION clauses.</comment>
	<if_stmt><if>if<condition>(<expr><name>return_clause_count</name> <operator>!=</operator> <name>union_clause_count</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Found %d UNION clauses but only %d RETURN clauses."</literal></expr></argument>, <argument><expr><name>union_clause_count</name></expr></argument>,
						  <argument><expr><name>return_clause_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>AST_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>return_clause</name> <init>= <expr><call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name><name>return_indices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>proj_count</name> <init>= <expr><call><name>cypher_ast_return_nprojections</name><argument_list>(<argument><expr><name>return_clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>projections</name><index>[<expr><name>proj_count</name></expr>]</index></name></decl>;</decl_stmt>

	<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>proj_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>proj</name> <init>= <expr><call><name>cypher_ast_return_get_projection</name><argument_list>(<argument><expr><name>return_clause</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>alias_node</name> <init>= <expr><call><name>cypher_ast_projection_get_alias</name><argument_list>(<argument><expr><name>proj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>alias_node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>  <block>{<block_content>
			<comment type="line">// The projection was not aliased, so the projection itself must be an identifier.</comment>
			<expr_stmt><expr><name>alias_node</name> <operator>=</operator> <call><name>cypher_ast_projection_get_expression</name><argument_list>(<argument><expr><name>proj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>alias_node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>alias_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>projections</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>alias</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>return_clause_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>return_clause</name> <operator>=</operator> <call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name><name>return_indices</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>proj_count</name> <operator>!=</operator> <call><name>cypher_ast_return_nprojections</name><argument_list>(<argument><expr><name>return_clause</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"All sub queries in an UNION must have the same column names."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>AST_INVALID</name></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>proj_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>proj</name> <init>= <expr><call><name>cypher_ast_return_get_projection</name><argument_list>(<argument><expr><name>return_clause</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>alias_node</name> <init>= <expr><call><name>cypher_ast_projection_get_alias</name><argument_list>(<argument><expr><name>proj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><name>alias_node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>  <block>{<block_content>
				<comment type="line">// The projection was not aliased, so the projection itself must be an identifier.</comment>
				<expr_stmt><expr><name>alias_node</name> <operator>=</operator> <call><name>cypher_ast_projection_get_expression</name><argument_list>(<argument><expr><name>proj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>alias_node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CYPHER_AST_IDENTIFIER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>cypher_ast_identifier_get_name</name><argument_list>(<argument><expr><name>alias_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>projections</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"All sub queries in an UNION must have the same column names."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <name>AST_INVALID</name></expr>;</expr_stmt>
				<goto>goto <name>cleanup</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

<label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>return_indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_ValidateParamsOnly</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>statement</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>noptions</name> <init>= <expr><call><name>cypher_ast_statement_noptions</name><argument_list>(<argument><expr><name>statement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>noptions</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>option</name> <init>= <expr><call><name>cypher_ast_statement_get_option</name><argument_list>(<argument><expr><name>statement</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_type_t</name></type> <name>type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><operator>(</operator><name>type</name> <operator>==</operator> <name>CYPHER_AST_EXPLAIN_OPTION</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>type</name> <operator>==</operator> <name>CYPHER_AST_PROFILE_OPTION</name><operator>)</operator></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>invalid_option_name</name> <init>= <expr><call><name>cypher_astnode_typestr</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Please use GRAPH.%s 'key' 'query' command instead of GRAPH.QUERY 'key' '%s query'"</literal></expr></argument>,
							  <argument><expr><name>invalid_option_name</name></expr></argument>, <argument><expr><name>invalid_option_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>AST_INVALID</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>AST_VALID</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_ValidateDuplicateParameters</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>statement</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>param_names</name> <init>= <expr><call><name>raxNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>noptions</name> <init>= <expr><call><name>cypher_ast_statement_noptions</name><argument_list>(<argument><expr><name>statement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>noptions</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>option</name> <init>= <expr><call><name>cypher_ast_statement_get_option</name><argument_list>(<argument><expr><name>statement</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint</name></type> <name>nparams</name> <init>= <expr><call><name>cypher_ast_cypher_option_nparams</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nparams</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><call><name>cypher_ast_cypher_option_get_param</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>paramName</name> <init>= <expr><call><name>cypher_ast_string_get_value</name><argument_list>(<argument><expr><call><name>cypher_ast_cypher_option_param_get_name</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="line">// If parameter already exists return an error.</comment>
			<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>raxInsert</name><argument_list>(<argument><expr><name>param_names</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>paramName</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>paramName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Duplicated parameter: %s"</literal></expr></argument>, <argument><expr><name>paramName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>param_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>AST_INVALID</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>param_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>AST_VALID</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST</name> <modifier>*</modifier></type><name>_NewMockASTSegment</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>uint</name></type> <name>start_offset</name></decl></parameter>, <parameter><decl><type><name>uint</name></type> <name>end_offset</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AST</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>free_root</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>referenced_entities</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>anot_ctx_collection</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>n</name> <init>= <expr><name>end_offset</name> <operator>-</operator> <name>start_offset</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>cypher_astnode_t</name> <modifier>*</modifier></type><name><name>clauses</name><index>[<expr><name>n</name></expr>]</index></name></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name><name>clauses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>cypher_astnode_t</name> <operator>*</operator><operator>)</operator><call><name>cypher_ast_query_get_clause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <name>start_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<decl_stmt><decl><type><name><name>struct</name> <name>cypher_input_range</name></name></type> <name>range</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name> <operator>=</operator> <call><name>cypher_ast_query</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>cypher_astnode_t</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator><name>clauses</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>clauses</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>ref_count</name></name> <operator>=</operator> <call><name>rm_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>ast</name><operator>-&gt;</operator><name>ref_count</name></name><operator>)</operator> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>parse_result</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ast</name><operator>-&gt;</operator><name>params_parse_result</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>ast</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_ValidateScopes</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>mock_ast</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AST_Validation</name></type> <name>res</name> <init>= <expr><name>AST_VALID</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// Verify that the RETURN clause and terminating clause do not violate scoping rules.</comment>
	<if_stmt><if>if<condition>(<expr><call><name>_ValidateQuerySequence</name><argument_list>(<argument><expr><name>mock_ast</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// Validate identifiers, which may be passed between scopes</comment>
	<if_stmt><if>if<condition>(<expr><call><name>_Validate_Aliases_Defined</name><argument_list>(<argument><expr><name>mock_ast</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AST_INVALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// Aliases are scoped by the WITH clauses within the query.</comment>
	<comment type="line">// If we have one or more WITH clauses, MATCH validations should be performed one scope at a time.</comment>
	<decl_stmt><decl><type><name>uint</name> <modifier>*</modifier></type><name>query_scopes</name> <init>= <expr><call><name>AST_GetClauseIndices</name><argument_list>(<argument><expr><name>mock_ast</name></expr></argument>, <argument><expr><name>CYPHER_AST_WITH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>with_clause_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>query_scopes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Query has only one scope, no need to create sub-ASTs</comment>
	<if_stmt><if>if<condition>(<expr><name>with_clause_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_ValidateClauses</name><argument_list>(<argument><expr><name>mock_ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>AST</name> <modifier>*</modifier></type><name>scoped_ast</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>scope_end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>scope_start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>with_clause_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>scope_end</name> <operator>=</operator> <name><name>query_scopes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="line">// Switching from index to bound, so add 1</comment>
		<comment type="line">// Make a sub-AST containing only the clauses in this scope</comment>
		<expr_stmt><expr><name>scoped_ast</name> <operator>=</operator> <call><name>_NewMockASTSegment</name><argument_list>(<argument><expr><name><name>mock_ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>scope_start</name></expr></argument>, <argument><expr><name>scope_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Perform validations</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_ValidateClauses</name><argument_list>(<argument><expr><name>scoped_ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AST_Free</name><argument_list>(<argument><expr><name>scoped_ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
		<comment type="line">// Update the starting indices of the scope for the next iteration.</comment>
		<expr_stmt><expr><name>scope_start</name> <operator>=</operator> <name>scope_end</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="line">// Build and test the final scope (from the last WITH to the last clause)</comment>
	<expr_stmt><expr><name>scope_end</name> <operator>=</operator> <call><name>cypher_ast_query_nclauses</name><argument_list>(<argument><expr><name><name>mock_ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scoped_ast</name> <operator>=</operator> <call><name>_NewMockASTSegment</name><argument_list>(<argument><expr><name><name>mock_ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>scope_start</name></expr></argument>, <argument><expr><name>scope_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_ValidateClauses</name><argument_list>(<argument><expr><name>scoped_ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AST_Free</name><argument_list>(<argument><expr><name>scoped_ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

<label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>query_scopes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Checks to see if libcypher-parser reported any errors.</comment>
<function><type><name>bool</name></type> <name>AST_ContainsErrors</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_parse_result_t</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>cypher_parse_result_nerrors</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function checks for the existence a valid root in the query.
 * As cypher_parse_result_t can have multiple roots such as comments, only a query that has
 * a root with type CYPHER_AST_STATEMENT is considered valid. Comment roots are ignored. */</comment>
<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_AST_Validate_ParseResultRoot</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_parse_result_t</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
													<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>index</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// Check for failures in libcypher-parser</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>AST_ContainsErrors</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>nroots</name> <init>= <expr><call><name>cypher_parse_result_nroots</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nroots</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><call><name>cypher_parse_result_get_root</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>root_type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>root_type</name> <operator>==</operator> <name>CYPHER_AST_LINE_COMMENT</name> <operator>||</operator> <name>root_type</name> <operator>==</operator> <name>CYPHER_AST_BLOCK_COMMENT</name> <operator>||</operator>
		   <name>root_type</name> <operator>==</operator> <name>CYPHER_AST_COMMENT</name></expr>)</condition> <block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>root_type</name> <operator>!=</operator> <name>CYPHER_AST_STATEMENT</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Encountered unsupported query type '%s'"</literal></expr></argument>, <argument><expr><call><name>cypher_astnode_typestr</name><argument_list>(<argument><expr><name>root_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>AST_INVALID</name></expr>;</return>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="line">// We got a statement.</comment>
			<expr_stmt><expr><operator>*</operator><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<return>return <expr><name>AST_VALID</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="line">// query with no roots like ';'</comment>
	<if_stmt><if>if<condition>(<expr><name>nroots</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"Error: empty query."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>AST_INVALID</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AST_Validation</name></type> <name>_AST_ValidateUnionQuery</name><parameter_list>(<parameter><decl><type><name>AST</name> <modifier>*</modifier></type><name>mock_ast</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// Verify that the UNION clauses and the columns they join are valid.</comment>
	<decl_stmt><decl><type><name>AST_Validation</name></type> <name>res</name> <init>= <expr><call><name>_ValidateUnion_Clauses</name><argument_list>(<argument><expr><name>mock_ast</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// Each self-contained query delimited by a UNION clause has its own scope.</comment>
	<decl_stmt><decl><type><name>uint</name> <modifier>*</modifier></type><name>query_scopes</name> <init>= <expr><call><name>AST_GetClauseIndices</name><argument_list>(<argument><expr><name>mock_ast</name></expr></argument>, <argument><expr><name>CYPHER_AST_UNION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// Append the clause count to check the final scope (from the last UNION to the last clause)</comment>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>query_scopes</name></expr></argument>, <argument><expr><call><name>cypher_ast_query_nclauses</name><argument_list>(<argument><expr><name><name>mock_ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>scope_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>query_scopes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>scope_start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>scope_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>uint</name></type> <name>scope_end</name> <init>= <expr><name><name>query_scopes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<comment type="line">// Make a sub-AST containing only the clauses in this scope.</comment>
		<decl_stmt><decl><type><name>AST</name> <modifier>*</modifier></type><name>scoped_ast</name> <init>= <expr><call><name>_NewMockASTSegment</name><argument_list>(<argument><expr><name><name>mock_ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>scope_start</name></expr></argument>, <argument><expr><name>scope_end</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_ValidateScopes</name><argument_list>(<argument><expr><name>scoped_ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AST_Free</name><argument_list>(<argument><expr><name>scoped_ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

		<comment type="line">// Update the starting index of the scope for the next iteration..</comment>
		<expr_stmt><expr><name>scope_start</name> <operator>=</operator> <name>scope_end</name></expr>;</expr_stmt>
	</block_content>}</block></for>

<label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>query_scopes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AST_Validation</name></type> <name>AST_Validate_QueryParams</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_parse_result_t</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>_AST_Validate_ParseResultRoot</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><call><name>cypher_parse_result_get_root</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// in case of no parameters</comment>
	<if_stmt><if>if<condition>(<expr><call><name>cypher_ast_statement_noptions</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_VALID</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>_ValidateParamsOnly</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call>            <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content>  <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>_ValidateDuplicateParameters</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call>   <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content>  <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>_ValidateFunctionCalls</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call>  <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content>  <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>AST_VALID</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AST_Validation</name></type> <name>AST_Validate_Query</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>cypher_parse_result_t</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>_AST_Validate_ParseResultRoot</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>AST_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><call><name>cypher_parse_result_get_root</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Verify that the query does not contain any expressions not in the</comment>
	<comment type="line">// RedisGraph support whitelist</comment>
	<if_stmt><if>if<condition>(<expr><call><name>CypherWhitelist_ValidateQuery</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>AST_VALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AST_INVALID</name></expr>;</return></block_content></block></if></if_stmt>
	
	<decl_stmt><decl><type><name>AST_Validation</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>body</name> <init>= <expr><call><name>cypher_ast_statement_get_body</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name>body_type</name> <init>= <expr><call><name>cypher_astnode_type</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>body_type</name> <operator>==</operator> <name>CYPHER_AST_CREATE_NODE_PROPS_INDEX</name>    <operator>||</operator>
	   <name>body_type</name> <operator>==</operator> <name>CYPHER_AST_CREATE_PATTERN_PROPS_INDEX</name> <operator>||</operator>
	   <name>body_type</name> <operator>==</operator> <name>CYPHER_AST_DROP_PROPS_INDEX</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Index operation</comment>
		<decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>defined_aliases</name> <init>= <expr><call><name>raxNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_Validate_Aliases_DefinedInClause</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><name>defined_aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>defined_aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>res</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// validate positions of allShortestPaths</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>invalid</name> <init>= <expr><call><name>_ValidateAllShortestPaths</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>invalid</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ErrorCtx_SetError</name><argument_list>(<argument><expr><literal type="string">"RedisGraph support allShortestPaths only in match clauses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>AST_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>AST</name></type> <name>mock_ast</name></decl>;</decl_stmt> <comment type="line">// Build a fake AST with the correct AST root</comment>
	<expr_stmt><expr><name><name>mock_ast</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>body</name></expr>;</expr_stmt>

	<comment type="line">// Check for invalid queries not captured by libcypher-parser</comment>
	<if_stmt><if>if<condition>(<expr><call><name>AST_ContainsClause</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mock_ast</name></expr></argument>, <argument><expr><name>CYPHER_AST_UNION</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="line">// If the query contains a UNION clause, it has nested scopes that should be checked separately.</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_AST_ValidateUnionQuery</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mock_ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_ValidateScopes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mock_ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

</unit>
