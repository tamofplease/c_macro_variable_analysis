<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/src/module_event_handlers.c"><comment type="block">/*
 * Copyright Redis Ltd. 2018 - present
 * Licensed under your choice of the Redis Source Available License 2.0 (RSALv2) or
 * the Server Side Public License v1 (SSPLv1).
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"module_event_handlers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"RG.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util/uuid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util/thpool/pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util/redis_version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"graph/graphcontext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"configuration/config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"serializers/graphmeta_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"serializers/graphcontext_type.h"</cpp:file></cpp:include>

<comment type="line">// indicates the possibility of half-baked graphs in the keyspace</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTERMEDIATE_GRAPHS</name></cpp:macro> <cpp:value>(aux_field_counter &gt; 0)</cpp:value></cpp:define>

<comment type="line">// global array tracking all extant GraphContexts</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>GraphContext</name> <modifier>*</modifier><modifier>*</modifier></type><name>graphs_in_keyspace</name></decl>;</decl_stmt>
<comment type="line">// flag indicating whether the running process is a child</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>process_is_child</name></decl>;</decl_stmt>
<comment type="line">// graphContext type as it is registered at Redis</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>RedisModuleType</name> <modifier>*</modifier></type><name>GraphContextRedisModuleType</name></decl>;</decl_stmt>
<comment type="line">// graph meta keys type as it is registered at Redis</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>RedisModuleType</name> <modifier>*</modifier></type><name>GraphMetaRedisModuleType</name></decl>;</decl_stmt>

<comment type="line">// both of the following fields are required to verify that the module is replicated</comment>
<comment type="line">// in a successful manner. In a sharded environment, there could be a race condition between the decoding of</comment>
<comment type="line">// the last key, and the last aux_fields, so both counters should be zeroed in order to verify</comment>
<comment type="line">// that the module replicated properly.*/</comment>

<comment type="line">// holds the number of aux fields encountered during decoding of RDB file</comment>
<comment type="line">// this field is used to represent when the module is replicating its graphs</comment>
<decl_stmt><decl><type><name>uint</name></type> <name>aux_field_counter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>

<comment type="line">// holds the id of the Redis Main thread in order to figure out the context the fork is running on</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_t</name></type> <name>redis_main_thread_id</name></decl>;</decl_stmt>

<comment type="line">// this callback invokes once rename for a graph is done. Since the key value is a graph context</comment>
<comment type="line">// which saves the name of the graph for later key accesses, this data must be consistent with the key name,</comment>
<comment type="line">// otherwise, the graph context will remain with the previous graph name, and a key access to this name might</comment>
<comment type="line">// yield an empty key or wrong value. This method changes the graph name value at the graph context to be</comment>
<comment type="line">// consistent with the key name</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>_RenameGraphHandler</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>event</name></decl></parameter>,
							   <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>key_name</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>type</name> <operator>!=</operator> <name>REDISMODULE_NOTIFY_GENERIC</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_OK</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr><literal type="string">"RENAME_TO"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>RedisModule_OpenKey</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>key_name</name></expr></argument>, <argument><expr><name>REDISMODULE_WRITE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>RedisModule_ModuleTypeGetType</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GraphContextRedisModuleType</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>GraphContext</name> <modifier>*</modifier></type><name>gc</name> <init>= <expr><call><name>RedisModule_ModuleTypeGetValue</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_name</name> <init>= <expr><call><name>RedisModule_StringPtrLen</name><argument_list>(<argument><expr><name>key_name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>GraphContext_Rename</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name>new_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>RedisModule_CloseKey</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// Meta keys API</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// Checks if the graph name contains a hash tag between curly braces.</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>_GraphContext_NameContainsTag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GraphContext</name> <modifier>*</modifier></type><name>gc</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>left_curly_brace</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>, <argument><expr><literal type="string">"{"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>left_curly_brace</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>right_curly_brace</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name>left_curly_brace</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>right_curly_brace</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Calculate how many virtual keys are needed to represent the graph.</comment>
<function><type><specifier>static</specifier> <name>uint64_t</name></type> <name>_GraphContext_RequiredMetaKeys</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GraphContext</name> <modifier>*</modifier></type><name>gc</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>vkey_entity_count</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Config_Option_get</name><argument_list>(<argument><expr><name>Config_VKEY_MAX_ENTITY_COUNT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vkey_entity_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gc</name><operator>-&gt;</operator><name>encoding_context</name><operator>-&gt;</operator><name>vkey_entity_count</name></name> <operator>=</operator> <name>vkey_entity_count</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint64_t</name></type> <name>entities_count</name> <init>= <expr><call><name>Graph_NodeCount</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>g</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>Graph_EdgeCount</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>g</name></name></expr></argument>)</argument_list></call> <operator>+</operator>
		<call><name>Graph_DeletedNodeCount</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>g</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>Graph_DeletedEdgeCount</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>g</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>entities_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// calculate the required keys</comment>
	<comment type="line">// substruct one since there is also the graph context key</comment>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>key_count</name> <init>= <expr><call><name>ceil</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>entities_count</name> <operator>/</operator> <name>vkey_entity_count</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>MAX</name><argument_list>(<argument><expr><name>key_count</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_CreateGraphMetaKeys</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>GraphContext</name> <modifier>*</modifier></type><name>gc</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>meta_key_count</name> <init>= <expr><call><name>_GraphContext_RequiredMetaKeys</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>graph_name_contains_tag</name> <init>= <expr><call><name>_GraphContext_NameContainsTag</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>meta_key_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>uuid</name> <init>= <expr><call><name>UUID_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>meta_rm_string</name></decl>;</decl_stmt>
		<comment type="block">/* Meta keys need to be in the exact shard/slot as the graph context key
		 * to avoid graph sharding at the target db
		 * we want to save all the graph keys on the same shard.
		 * For that, we need to that them In so their tag hash value will be
		 * the same as the graph context key hash value.
		 * If the graph name already contains a tag, we can duplicate
		 * the graph name completely for each meta key.
		 * If not, the meta keys tag will be the graph name, so
		 * when hashing the graphcontext key name (graph name)
		 * and the graph meta key tag (graph name)
		 * the hash values will be the same. */</comment>
		<if_stmt><if>if<condition>(<expr><name>graph_name_contains_tag</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// Graph already has a tag, create a meta key of "graph_name_uuid"</comment>
			<expr_stmt><expr><name>meta_rm_string</name> <operator>=</operator> <call><name>RedisModule_CreateStringPrintf</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">"%s_%s"</literal></expr></argument>, <argument><expr><name><name>gc</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>, <argument><expr><name>uuid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="line">// Graph is untagged, one must be introduced to ensure that</comment>
			<comment type="line">// keys are propagated to the same node.</comment>
			<comment type="line">// Create a meta key of "{graph_name}graph_name_i"</comment>
			<expr_stmt><expr><name>meta_rm_string</name> <operator>=</operator> <call><name>RedisModule_CreateStringPrintf</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">"{%s}%s_%s"</literal></expr></argument>, <argument><expr><name><name>gc</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>,
															<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>, <argument><expr><name>uuid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key_name</name> <init>= <expr><call><name>RedisModule_StringPtrLen</name><argument_list>(<argument><expr><name>meta_rm_string</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>GraphEncodeContext_AddMetaKey</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>encoding_context</name></name></expr></argument>, <argument><expr><name>key_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>RedisModule_OpenKey</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>meta_rm_string</name></expr></argument>, <argument><expr><name>REDISMODULE_WRITE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// set value in key</comment>
		<expr_stmt><expr><call><name>RedisModule_ModuleTypeSetValue</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>GraphMetaRedisModuleType</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RedisModule_CloseKey</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<comment type="line">// increase graph context ref count for each virtual key</comment>
		<expr_stmt><expr><call><name>GraphContext_IncreaseRefCount</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RedisModule_FreeString</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>meta_rm_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>uuid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>RedisModule_Log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">"notice"</literal></expr></argument>, <argument><expr><literal type="string">"Created %d virtual keys for graph %s"</literal></expr></argument>,
			<argument><expr><name>meta_key_count</name></expr></argument>, <argument><expr><name><name>gc</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Delete meta keys, upon RDB encode or decode finished event triggering.</comment>
<comment type="line">// The decode flag represent the event.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_DeleteGraphMetaKeys</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>GraphContext</name> <modifier>*</modifier></type><name>gc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>decode</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>keys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>key_count</name></decl>;</decl_stmt>
	<comment type="line">// Get the meta keys required, according to the "decode" flag.</comment>
	<if_stmt><if>if<condition>(<expr><name>decode</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>GraphDecodeContext_GetMetaKeys</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>decoding_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>GraphEncodeContext_GetMetaKeys</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>encoding_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>key_count</name> <operator>=</operator> <call><name>array_len</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>key_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>meta_rm_string</name> <init>= <expr><call><name>RedisModule_CreateStringPrintf</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>RedisModule_OpenKey</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>meta_rm_string</name></expr></argument>, <argument><expr><name>REDISMODULE_WRITE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>RedisModule_DeleteKey</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RedisModule_CloseKey</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RedisModule_FreeString</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>meta_rm_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// Clear the relevant context meta keys as they are no longer valid.</comment>
	<if_stmt><if>if<condition>(<expr><name>decode</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>GraphDecodeContext_ClearMetaKeys</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>decoding_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>GraphEncodeContext_ClearMetaKeys</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>encoding_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>RedisModule_Log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">"notice"</literal></expr></argument>, <argument><expr><literal type="string">"Deleted %d virtual keys for graph %s"</literal></expr></argument>, <argument><expr><name>key_count</name></expr></argument>, <argument><expr><name><name>gc</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// create the meta keys for each graph in the keyspace</comment>
<comment type="line">// used on RDB start event</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_CreateKeySpaceMetaKeys</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>graphs_in_keyspace_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>graphs_in_keyspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>graphs_in_keyspace_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>_CreateGraphMetaKeys</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>graphs_in_keyspace</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Delete the meta keys for each graph in the key space - used on RDB finish (save/load/fail) event.
 * The decode flag represent if the graph is after encodeing or decodeing. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_ClearKeySpaceMetaKeys</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>decode</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>graphs_in_keyspace_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>graphs_in_keyspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>graphs_in_keyspace_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>_DeleteGraphMetaKeys</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>graphs_in_keyspace</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>decode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_FlushDBHandler</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>RedisModuleEvent</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>subevent</name></decl></parameter>,
							<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// reset `aux_field_counter` upon handeling FLUSH-ALL</comment>
	<if_stmt><if>if<condition>(<expr><name><name>eid</name><operator>.</operator><name>id</name></name> <operator>==</operator> <name>REDISMODULE_EVENT_FLUSHDB</name> <operator>&amp;&amp;</operator>
	   <name>subevent</name> <operator>==</operator> <name>REDISMODULE_SUBEVENT_FLUSHDB_START</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>aux_field_counter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// Checks if the event is persistence start event.</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>_IsEventPersistenceStart</name><parameter_list>(<parameter><decl><type><name>RedisModuleEvent</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>subevent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><name><name>eid</name><operator>.</operator><name>id</name></name> <operator>==</operator> <name>REDISMODULE_EVENT_PERSISTENCE</name>  <operator>&amp;&amp;</operator>
		   <operator>(</operator><name>subevent</name> <operator>==</operator> <name>REDISMODULE_SUBEVENT_PERSISTENCE_RDB_START</name>      <operator>||</operator>    <comment type="line">// Normal RDB.</comment>
			<name>subevent</name> <operator>==</operator> <name>REDISMODULE_SUBEVENT_PERSISTENCE_AOF_START</name>      <operator>||</operator>    <comment type="line">// Preamble AOF.</comment>
			<name>subevent</name> <operator>==</operator> <name>REDISMODULE_SUBEVENT_PERSISTENCE_SYNC_RDB_START</name> <operator>||</operator>    <comment type="line">// SAVE and DEBUG RELOAD.</comment>
			<name>subevent</name> <operator>==</operator> <name>REDISMODULE_SUBEVENT_PERSISTENCE_SYNC_AOF_START</name>       <comment type="line">// </comment>
		   <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Checks if the event is persistence end event.</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>_IsEventPersistenceEnd</name><parameter_list>(<parameter><decl><type><name>RedisModuleEvent</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>subevent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><name><name>eid</name><operator>.</operator><name>id</name></name> <operator>==</operator> <name>REDISMODULE_EVENT_PERSISTENCE</name> <operator>&amp;&amp;</operator>
		   <operator>(</operator><name>subevent</name> <operator>==</operator> <name>REDISMODULE_SUBEVENT_PERSISTENCE_ENDED</name> <operator>||</operator>  <comment type="line">// Save ended.</comment>
			<name>subevent</name> <operator>==</operator> <name>REDISMODULE_SUBEVENT_PERSISTENCE_FAILED</name>    <comment type="line">// Save failed.</comment>
		   <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="line">// server persistence event handler</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_PersistenceEventHandler</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>RedisModuleEvent</name></type> <name>eid</name></decl></parameter>,
		<parameter><decl><type><name>uint64_t</name></type> <name>subevent</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>INTERMEDIATE_GRAPHS</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// check for half-baked graphs</comment>
		<comment type="line">// indicated by `aux_field_counter` &gt; 0</comment>
		<comment type="line">// in such case we do not want to either perform backup nor do we want to</comment>
		<comment type="line">// synchronize our replica, as such we're aborting by existing</comment>
		<comment type="line">// assuming we're running on a fork process</comment>
		<if_stmt><if>if<condition>(<expr><name>process_is_child</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// intermediate graph(s) detected, exit!</comment>
			<expr_stmt><expr><call><name>RedisModule_Log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>REDISMODULE_LOGLEVEL_WARNING</name></expr></argument>,
					<argument><expr><literal type="string">"RedisGraph - aborting BGSAVE, detected intermediate graph(s)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="line">// don't mess with the keyspace if we have half-baked graphs</comment>
			<return>return;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>_IsEventPersistenceStart</name><argument_list>(<argument><expr><name>eid</name></expr></argument>, <argument><expr><name>subevent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_CreateKeySpaceMetaKeys</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><call><name>_IsEventPersistenceEnd</name><argument_list>(<argument><expr><name>eid</name></expr></argument>, <argument><expr><name>subevent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_ClearKeySpaceMetaKeys</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// Perform clean-up upon server shutdown.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_ShutdownEventHandler</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>RedisModuleEvent</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>subevent</name></decl></parameter>,
		<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"RS_GLOBAL_DTORS"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="line">// used only with sanitizer or valgrind</comment>
		<return>return;</return> 
	</block_content>}</block></if></if_stmt>
	<comment type="line">// Stop threads before finalize GraphBLAS.</comment>
	<expr_stmt><expr><call><name>ThreadPools_Destroy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// Server is shutting down, finalize GraphBLAS.</comment>
	<expr_stmt><expr><call><name>GrB_finalize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_RegisterServerEvents</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>RedisModule_SubscribeToServerEvent</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>RedisModuleEvent_FlushDB</name></expr></argument>,
			<argument><expr><name>_FlushDBHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RedisModule_SubscribeToServerEvent</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>RedisModuleEvent_Shutdown</name></expr></argument>,
			<argument><expr><name>_ShutdownEventHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RedisModule_SubscribeToKeyspaceEvents</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>REDISMODULE_NOTIFY_GENERIC</name></expr></argument>,
			<argument><expr><name>_RenameGraphHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RedisModule_SubscribeToServerEvent</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>RedisModuleEvent_Persistence</name></expr></argument>,
			<argument><expr><name>_PersistenceEventHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// FORK callbacks</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// before fork at parent</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>RG_ForkPrepare</name><parameter_list>()</parameter_list> <block>{<block_content>
	<comment type="line">// at this point, fork been issued, we assume that this is due to BGSAVE</comment>
	<comment type="line">// or RedisSearch GC</comment>
	<comment type="line">//</comment>
	<comment type="line">// on BGSAVE acquire read lock for each graph to ensure no graph is being</comment>
	<comment type="line">// modified, otherwise the child process might inherit a malformed matrix</comment>
	<comment type="line">//</comment>
	<comment type="line">// on BGSAVE: acquire read lock</comment>
	<comment type="line">// flush all matrices such that child won't inherit locked matrix</comment>
	<comment type="line">// release read lock immediately once forked</comment>
	<comment type="line">//</comment>
	<comment type="line">// in the case of RediSearch GC fork, quickly return</comment>

	<comment type="line">// BGSAVE is invoked from Redis main thread</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>pthread_equal</name><argument_list>(<argument><expr><call><name>pthread_self</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>redis_main_thread_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<comment type="line">// return if we have half-baked graphs</comment>
	<if_stmt><if>if<condition>(<expr><name>INTERMEDIATE_GRAPHS</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>graph_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>graphs_in_keyspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>graph_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<comment type="line">// acquire read lock, guarantee graph isn't modified</comment>
		<decl_stmt><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><name><name>graphs_in_keyspace</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>g</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Graph_AcquireReadLock</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// set matrix synchronization policy to default</comment>
		<expr_stmt><expr><call><name>Graph_SetMatrixPolicy</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>SYNC_POLICY_FLUSH_RESIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// synchronize all matrices, make sure they're in a consistent state</comment>
		<comment type="line">// do not force-flush as this can take awhile</comment>
		<expr_stmt><expr><call><name>Graph_ApplyAllPending</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="line">// after fork at parent</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>RG_AfterForkParent</name><parameter_list>()</parameter_list> <block>{<block_content>
	<comment type="line">// BGSAVE is invoked from Redis main thread</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>pthread_equal</name><argument_list>(<argument><expr><call><name>pthread_self</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>redis_main_thread_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<comment type="line">// return if we have half-baked graphs</comment>
	<if_stmt><if>if<condition>(<expr><name>INTERMEDIATE_GRAPHS</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<comment type="line">// the child process forked, release all acquired locks</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>graph_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>graphs_in_keyspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>graph_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>Graph_ReleaseLock</name><argument_list>(<argument><expr><name><name>graphs_in_keyspace</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="line">// after fork at child</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>RG_AfterForkChild</name><parameter_list>()</parameter_list> <block>{<block_content>
	<comment type="line">// mark that the child is a forked process so that it doesn't</comment>
	<comment type="line">// attempt invalid accesses of POSIX primitives it doesn't own</comment>
	<expr_stmt><expr><name>process_is_child</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="line">// restrict GraphBLAS to use a single thread this is done for 2 reasons:</comment>
	<comment type="line">// 1. save resources</comment>
	<comment type="line">// 2. avoid a bug in GNU OpenMP which hangs when performing parallel loop</comment>
	<comment type="line">// in forked process</comment>
	<expr_stmt><expr><call><name>GxB_set</name><argument_list>(<argument><expr><name>GxB_NTHREADS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>graph_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>graphs_in_keyspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>graph_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><name><name>graphs_in_keyspace</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>g</name></expr></init></decl>;</decl_stmt>

		<comment type="line">// all matrices should be synced, set synchronization policy to NOP</comment>
		<expr_stmt><expr><call><name>Graph_SetMatrixPolicy</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>SYNC_POLICY_NOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_RegisterForkHooks</name><parameter_list>()</parameter_list> <block>{<block_content>
	<expr_stmt><expr><name>redis_main_thread_id</name> <operator>=</operator> <call><name>pthread_self</name><argument_list>()</argument_list></call></expr>;</expr_stmt>  <comment type="line">// This function is being called on the main thread context.</comment>

	<comment type="block">/* Register handlers to control the behavior of fork calls. */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>pthread_atfork</name><argument_list>(<argument><expr><name>RG_ForkPrepare</name></expr></argument>, <argument><expr><name>RG_AfterForkParent</name></expr></argument>, <argument><expr><name>RG_AfterForkChild</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_ModuleEventHandler_TryClearKeyspace</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="line">// return if we have half-baked graphs</comment>
	<if_stmt><if>if<condition>(<expr><name>INTERMEDIATE_GRAPHS</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><call><name>RedisModule_GetThreadSafeContext</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_ClearKeySpaceMetaKeys</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RedisModule_FreeThreadSafeContext</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// increase the number of aux fields encountered during rdb loading</comment>
<comment type="line">// there could be more than one on multiple shards scenario</comment>
<comment type="line">// so each shard is saving the aux field in its own RDB file</comment>
<function><type><name>void</name></type> <name>ModuleEventHandler_AUXBeforeKeyspaceEvent</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><name>aux_field_counter</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// decrease the number of aux fields encountered during rdb loading</comment>
<comment type="line">// there could be more than one on multiple shards scenario</comment>
<comment type="line">// so each shard is saving the aux field in its own RDB file</comment>
<comment type="line">// once the number is zero,</comment>
<comment type="line">// the module finished replicating and the meta keys can be deleted</comment>
<function><type><name>void</name></type> <name>ModuleEventHandler_AUXAfterKeyspaceEvent</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><name>aux_field_counter</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_ModuleEventHandler_TryClearKeyspace</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>RegisterEventHandlers</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>_RegisterForkHooks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>       <comment type="line">// Set up hooks for forking logic to prevent bgsave deadlocks.</comment>
	<expr_stmt><expr><call><name>_RegisterServerEvents</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Set up hooks for rename and server events on Redis 6 and up.</comment>
</block_content>}</block></function>

</unit>
