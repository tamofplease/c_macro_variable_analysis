<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/src/graph/query_graph.c"><comment type="block">/*
 * Copyright Redis Ltd. 2018 - present
 * Licensed under your choice of the Redis Source Available License 2.0 (RSALv2) or
 * the Server Side Public License v1 (SSPLv1).
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"query_graph.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"RG.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/arr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../query_ctx.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../schema/schema.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../deps/rax/rax.h"</cpp:file></cpp:include>

<comment type="line">// sets node label and label ID</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_QueryGraphSetNodeLabel</name>
<parameter_list>(
	<parameter><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_entity</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>GraphContext</name> <modifier>*</modifier></type><name>gc</name> <init>= <expr><call><name>QueryCtx_GetGraphCtx</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// retrieve node labels from the AST entity</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>nlabels</name> <init>= <expr><call><name>cypher_ast_node_pattern_nlabels</name><argument_list>(<argument><expr><name>ast_entity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nlabels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>cypher_ast_label_get_name</name><argument_list>(
							<argument><expr><call><name>cypher_ast_node_pattern_get_label</name><argument_list>(<argument><expr><name>ast_entity</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// if a schema is found, the AST refers to an existing label</comment>
		<decl_stmt><decl><type><name>Schema</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>GraphContext_GetSchema</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>SCHEMA_NODE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>l_id</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>s</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>Schema_GetID</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>GRAPH_UNKNOWN_LABEL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>QGNode_AddLabel</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>l_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="line">// adds node to query graph</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_QueryGraphAddNode</name>
<parameter_list>(
	<parameter><decl><type><name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_entity</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>AST_ToString</name><argument_list>(<argument><expr><name>ast_entity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// look up this alias in the QueryGraph</comment>
	<comment type="line">// this node may already exist</comment>
	<comment type="line">// if it appears multiple times in query patterns</comment>
	<decl_stmt><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>QueryGraph_GetNodeByAlias</name><argument_list>(<argument><expr><name>qg</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>n</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// node has not been mapped; create it</comment>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>QGNode_New</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>QueryGraph_AddNode</name><argument_list>(<argument><expr><name>qg</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>_QueryGraphSetNodeLabel</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>ast_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// adds edge to query graph</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_QueryGraphAddEdge</name>
<parameter_list>(
	<parameter><decl><type><name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>,                      <comment type="line">// query graph to add edge to</comment>
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_entity</name></decl></parameter>,  <comment type="line">// edge entity</comment>
	<parameter><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>src</name></decl></parameter>,                         <comment type="line">// src node</comment>
	<parameter><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,                        <comment type="line">// dest node</comment>
	<parameter><decl><type><name>bool</name></type> <name>only_shortest</name></decl></parameter>                   <comment type="line">// edge is part of a shortest path</comment>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>GraphContext</name> <modifier>*</modifier></type><name>gc</name> <init>= <expr><call><name>QueryCtx_GetGraphCtx</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>AST_ToString</name><argument_list>(<argument><expr><name>ast_entity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>enum</name> <name>cypher_rel_direction</name></name></type> <name>dir</name> <init>=
		<expr><call><name>cypher_ast_rel_pattern_get_direction</name><argument_list>(<argument><expr><name>ast_entity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// each edge can only appear once in a QueryGraph</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>QueryGraph_GetEdgeByAlias</name><argument_list>(<argument><expr><name>qg</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>QGEdge</name> <modifier>*</modifier></type><name>edge</name> <init>= <expr><call><name>QGEdge_New</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>bidirectional</name></name> <operator>=</operator> <operator>(</operator><name>dir</name> <operator>==</operator> <name>CYPHER_REL_BIDIRECTIONAL</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>shortest_path</name></name> <operator>=</operator> <name>only_shortest</name></expr>;</expr_stmt>

	<comment type="line">// add the IDs of all reltype matrixes</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>nreltypes</name> <init>= <expr><call><name>cypher_ast_rel_pattern_nreltypes</name><argument_list>(<argument><expr><name>ast_entity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nreltypes</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reltype</name> <init>= <expr><call><name>cypher_ast_reltype_get_name</name><argument_list>(<argument><expr><call><name>cypher_ast_rel_pattern_get_reltype</name><argument_list>(<argument><expr><name>ast_entity</name></expr></argument>,
														  <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Schema</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>GraphContext_GetSchema</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name>reltype</name></expr></argument>, <argument><expr><name>SCHEMA_EDGE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><name>s</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// unknown relationship</comment>
			<comment type="line">// search if reltype exists in edge-&gt;reltypes to don't insert duplicated reltype</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>reltypes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<if_stmt><if>if<condition>(<expr><name><name>edge</name><operator>-&gt;</operator><name>reltypeIDs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>GRAPH_UNKNOWN_RELATION</name></expr>)</condition> <block>{<block_content>
					<if_stmt><if>if<condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>reltypes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><name>reltype</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
						<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if<condition>(<expr><operator>!</operator><name>found</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>reltypes</name></name></expr></argument>, <argument><expr><name>reltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>reltypeIDs</name></name></expr></argument>, <argument><expr><name>GRAPH_UNKNOWN_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>qg</name><operator>-&gt;</operator><name>unknown_reltype_ids</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<comment type="line">// search if s-id exists in edge-&gt;reltypeIDs to don't insert duplicated ids</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>reltypeIDs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name><name>edge</name><operator>-&gt;</operator><name>reltypeIDs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>id</name></name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><name>found</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>reltypes</name></name></expr></argument>, <argument><expr><name>reltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>reltypeIDs</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="line">// incase of a variable length edge, set edge min/max hops</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>range</name> <init>= <expr><call><name>cypher_ast_rel_pattern_get_varlength</name><argument_list>(<argument><expr><name>ast_entity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>range</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><call><name>cypher_ast_range_get_start</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><call><name>cypher_ast_range_get_end</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>start</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>minHops</name></name> <operator>=</operator> <call><name>AST_ParseIntegerNode</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if<condition>(<expr><name>end</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>maxHops</name></name> <operator>=</operator> <call><name>AST_ParseIntegerNode</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>maxHops</name></name> <operator>=</operator> <name>EDGE_LENGTH_INF</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// build and add a QGEdge representing this entity to the QueryGraph</comment>
	<comment type="line">// swap the source and destination for left-pointing relations</comment>
	<if_stmt><if>if<condition>(<expr><name>dir</name> <operator>!=</operator> <name>CYPHER_REL_INBOUND</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>QueryGraph_ConnectNodes</name><argument_list>(<argument><expr><name>qg</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>QueryGraph_ConnectNodes</name><argument_list>(<argument><expr><name>qg</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">// extracts node from 'qg' and places a copy of into 'graph'</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_QueryGraph_ExtractNode</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>,
	<parameter><decl><type><name>QueryGraph</name> <modifier>*</modifier></type><name>graph</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_node</name></decl></parameter>
)</parameter_list> <block>{<block_content>

	<comment type="line">// validate inputs</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>qg</name>        <operator>!=</operator>  <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>graph</name>     <operator>!=</operator>  <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>ast_node</name>  <operator>!=</operator>  <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// see if node is already in 'graph'</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>AST_ToString</name><argument_list>(<argument><expr><name>ast_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>QueryGraph_GetNodeByAlias</name><argument_list>(<argument><expr><name>graph</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>n</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// node is missing from 'graph', try getting it from 'qg'</comment>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>QueryGraph_GetNodeByAlias</name><argument_list>(<argument><expr><name>qg</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>n</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<comment type="line">// node is missing from 'qg', create it</comment>
			<comment type="line">// it is possible to get into a situation where we try to extract</comment>
			<comment type="line">// a path which contains entities that are missing from the</comment>
			<comment type="line">// "holistic" query graph consider:</comment>
			<comment type="line">// MATCH (a) WITH a WHERE (a)-[]-&gt;(:L1) in this case due to</comment>
			<comment type="line">// clause scoping only node 'a' is in 'qg' the filtered pattern</comment>
			<comment type="line">// which is being extracted from 'qg' has additional entities:</comment>
			<comment type="line">// an anonymous edge and node</comment>
			<expr_stmt><expr><call><name>_QueryGraphAddNode</name><argument_list>(<argument><expr><name>graph</name></expr></argument>, <argument><expr><name>ast_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="line">// add a clone of the original node</comment>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>QGNode_Clone</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="line">// clear node label information</comment>
			<expr_stmt><expr><call><name>array_clear</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>labels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>array_clear</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>labelsID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>QueryGraph_AddNode</name><argument_list>(<argument><expr><name>graph</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="line">// set node label information</comment>
			<expr_stmt><expr><call><name>_QueryGraphSetNodeLabel</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>ast_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="line">// set node label information</comment>
		<expr_stmt><expr><call><name>_QueryGraphSetNodeLabel</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>ast_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">// extracts edge from 'qg' and places a copy of into 'graph'</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_QueryGraph_ExtractEdge</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>,
	<parameter><decl><type><name>QueryGraph</name> <modifier>*</modifier></type><name>graph</name></decl></parameter>,
	<parameter><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>left</name></decl></parameter>,
	<parameter><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>right</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_edge</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>AST_ToString</name><argument_list>(<argument><expr><name>ast_edge</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// validate input, edge shouldn't be in graph</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>left</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>right</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>QueryGraph_GetEdgeByAlias</name><argument_list>(<argument><expr><name>graph</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>QGEdge</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>QueryGraph_GetEdgeByAlias</name><argument_list>(<argument><expr><name>qg</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>shortest_path</name> <init>= <expr><ternary><condition><expr><name>e</name></expr> ?</condition><then> <expr><name><name>e</name><operator>-&gt;</operator><name>shortest_path</name></name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_QueryGraphAddEdge</name><argument_list>(<argument><expr><name>graph</name></expr></argument>, <argument><expr><name>ast_edge</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>shortest_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// clones path from 'qg' into 'graph'</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_QueryGraph_ExtractPath</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>,
	<parameter><decl><type><name>QueryGraph</name> <modifier>*</modifier></type><name>graph</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name></decl></parameter>
)</parameter_list> <block>{<block_content>

	<comment type="line">// validate input</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>qg</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>graph</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>path</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>nelems</name> <init>= <expr><call><name>cypher_ast_pattern_path_nelements</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// introduce nodes to graph</comment>
	<comment type="line">// nodes are at even indices</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>ast_node</name> <operator>=</operator> <call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_QueryGraph_ExtractNode</name><argument_list>(<argument><expr><name>qg</name></expr></argument>, <argument><expr><name>graph</name></expr></argument>, <argument><expr><name>ast_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="line">// introduce edges to graph</comment>
	<comment type="line">// edges are at odd indices</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
		<comment type="line">// retrieve the QGNode corresponding to the node left of this edge</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>l_node</name> <init>= <expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>l_alias</name> <init>= <expr><call><name>AST_ToString</name><argument_list>(<argument><expr><name>l_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>left</name> <init>= <expr><call><name>QueryGraph_GetNodeByAlias</name><argument_list>(<argument><expr><name>graph</name></expr></argument>, <argument><expr><name>l_alias</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// retrieve the QGNode corresponding to the node right of this edge</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>r_node</name> <init>= <expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>r_alias</name> <init>= <expr><call><name>AST_ToString</name><argument_list>(<argument><expr><name>r_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>right</name> <init>= <expr><call><name>QueryGraph_GetNodeByAlias</name><argument_list>(<argument><expr><name>graph</name></expr></argument>, <argument><expr><name>r_alias</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>ast_node</name> <operator>=</operator> <call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_QueryGraph_ExtractEdge</name><argument_list>(<argument><expr><name>qg</name></expr></argument>, <argument><expr><name>graph</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>ast_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>QueryGraph</name> <modifier>*</modifier></type><name>QueryGraph_New</name>
<parameter_list>(
	<parameter><decl><type><name>uint</name></type> <name>node_cap</name></decl></parameter>,
	<parameter><decl><type><name>uint</name></type> <name>edge_cap</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name> <init>= <expr><call><name>rm_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueryGraph</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>qg</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>QGNode</name> <operator>*</operator></expr></argument>, <argument><expr><name>node_cap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qg</name><operator>-&gt;</operator><name>edges</name></name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>QGEdge</name> <operator>*</operator></expr></argument>, <argument><expr><name>edge_cap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qg</name><operator>-&gt;</operator><name>unknown_reltype_ids</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>qg</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>QueryGraph_AddNode</name>
<parameter_list>(
	<parameter><decl><type><name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>,
	<parameter><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name><name>qg</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>QueryGraph_ConnectNodes</name>
<parameter_list>(
	<parameter><decl><type><name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>,
	<parameter><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>src</name></decl></parameter>,
	<parameter><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
	<parameter><decl><type><name>QGEdge</name> <modifier>*</modifier></type><name>e</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>QGNode_ConnectNode</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>src</name></name> <operator>=</operator> <name>src</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>dest</name></name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name><name>qg</name><operator>-&gt;</operator><name>edges</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>QueryGraph_AddPath</name>
<parameter_list>(
	<parameter><decl><type><name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>,                <comment type="line">// query graph to add path to</comment>
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,  <comment type="line">// path to add</comment>
	<parameter><decl><type><name>bool</name></type> <name>only_shortest</name></decl></parameter>             <comment type="line">// interested only in the shortest paths</comment>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AST</name> <modifier>*</modifier></type><name>ast</name> <init>= <expr><call><name>QueryCtx_GetAST</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>nelems</name> <init>= <expr><call><name>cypher_ast_pattern_path_nelements</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// introduce nodes first</comment>
	<comment type="line">// nodes are positioned at every even offset</comment>
	<comment type="line">// into the path (0, 2, ...)</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>ast_node</name> <init>=
			<expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_QueryGraphAddNode</name><argument_list>(<argument><expr><name>qg</name></expr></argument>, <argument><expr><name>ast_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="line">// every odd offset corresponds to an edge in a path</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
		<comment type="line">// retrieve the QGNode corresponding to the node left of this edge</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>l_node</name> <init>=
			<expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>l_alias</name> <init>= <expr><call><name>AST_ToString</name><argument_list>(<argument><expr><name>l_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>left</name> <init>= <expr><call><name>QueryGraph_GetNodeByAlias</name><argument_list>(<argument><expr><name>qg</name></expr></argument>, <argument><expr><name>l_alias</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// retrieve the QGNode corresponding to the node right of this edge</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>r_node</name> <init>=
			<expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>r_alias</name> <init>= <expr><call><name>AST_ToString</name><argument_list>(<argument><expr><name>r_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>right</name> <init>= <expr><call><name>QueryGraph_GetNodeByAlias</name><argument_list>(<argument><expr><name>qg</name></expr></argument>, <argument><expr><name>r_alias</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// retrieve the AST reference to this edge</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>edge</name> <init>=
			<expr><call><name>cypher_ast_pattern_path_get_element</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_QueryGraphAddEdge</name><argument_list>(<argument><expr><name>qg</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>only_shortest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="line">// clones path from 'qg' into 'graph'</comment>
<function><type><name>QueryGraph</name> <modifier>*</modifier></type><name>QueryGraph_ExtractPaths</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>paths</name></decl></parameter>,
	<parameter><decl><type><name>uint</name></type> <name>n</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// validate input</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>qg</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>paths</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// create an empty query graph</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>node_count</name> <init>= <expr><call><name>QueryGraph_NodeCount</name><argument_list>(<argument><expr><name>qg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>edge_count</name> <init>= <expr><call><name>QueryGraph_EdgeCount</name><argument_list>(<argument><expr><name>qg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryGraph</name> <modifier>*</modifier></type><name>graph</name> <init>= <expr><call><name>QueryGraph_New</name><argument_list>(<argument><expr><name>node_count</name></expr></argument>, <argument><expr><name>edge_count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>graph</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_QueryGraph_ExtractPath</name><argument_list>(<argument><expr><name>qg</name></expr></argument>, <argument><expr><name>graph</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>graph</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// clones patterns from 'qg' into 'graph'</comment>
<function><type><name>QueryGraph</name> <modifier>*</modifier></type><name>QueryGraph_ExtractPatterns</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>patterns</name></decl></parameter>,
	<parameter><decl><type><name>uint</name></type> <name>n</name></decl></parameter>
)</parameter_list> <block>{<block_content>

	<comment type="line">// validate inputs</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>qg</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>patterns</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// create an empty query graph</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>node_count</name> <init>= <expr><call><name>QueryGraph_NodeCount</name><argument_list>(<argument><expr><name>qg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>edge_count</name> <init>= <expr><call><name>QueryGraph_EdgeCount</name><argument_list>(<argument><expr><name>qg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryGraph</name> <modifier>*</modifier></type><name>graph</name> <init>= <expr><call><name>QueryGraph_New</name><argument_list>(<argument><expr><name>node_count</name></expr></argument>, <argument><expr><name>edge_count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>graph</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// extract paths described by each pattern</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>pattern</name> <init>= <expr><name><name>patterns</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint</name></type> <name>npaths</name> <init>= <expr><call><name>cypher_ast_pattern_npaths</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>npaths</name></expr>;</condition> <incr><expr><name>j</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>cypher_ast_pattern_get_path</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>_QueryGraph_ExtractPath</name><argument_list>(<argument><expr><name>qg</name></expr></argument>, <argument><expr><name>graph</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<return>return <expr><name>graph</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// build a query graph from AST</comment>
<function><type><name>QueryGraph</name> <modifier>*</modifier></type><name>BuildQueryGraph</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>AST</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>node_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>edge_count</name></decl>;</decl_stmt>

	<comment type="line">// AST clauses containing path objects</comment>
	<decl_stmt><decl><type><name>cypher_astnode_type_t</name></type> <name><name>clause_types</name> <index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>CYPHER_AST_MATCH</name></expr>, <expr><name>CYPHER_AST_MERGE</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<comment type="line">// the initial node and edge arrays will be large enough to accommodate</comment>
	<comment type="line">// all AST entities (which is overkill, consider reducing)</comment>
	<expr_stmt><expr><name>node_count</name> <operator>=</operator> <name>edge_count</name> <operator>=</operator> <call><name>raxSize</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>referenced_entities</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name> <init>= <expr><call><name>QueryGraph_New</name><argument_list>(<argument><expr><name>node_count</name></expr></argument>, <argument><expr><name>edge_count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// for each relevant clause type</comment>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name>clause_type</name> <init>= <expr><name><name>clause_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<comment type="line">// collect all path objects</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>clauses</name> <init>= <expr><call><name>AST_GetTypedNodes</name><argument_list>(<argument><expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
															 <argument><expr><name>clause_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint</name></type> <name>clause_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// for each clause of the current type</comment>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>clause_count</name></expr>;</condition> <incr><expr><name>j</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><name><name>clauses</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<comment type="line">// collect path objects</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>paths</name> <init>=
				<expr><call><name>AST_GetTypedNodes</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>CYPHER_AST_PATTERN_PATH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>shortest_paths</name> <init>=
				<expr><call><name>AST_GetTypedNodes</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>CYPHER_AST_SHORTEST_PATH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="line">// differentiate between regular paths and shortest paths</comment>
			<comment type="line">// as a path can be marked as shortest</comment>
			<decl_stmt><decl><type><name>uint</name></type>  <name>path_count</name>           <init>=  <expr><call><name>array_len</name><argument_list>(<argument><expr><name>paths</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint</name></type>  <name>shortest_path_count</name>  <init>=  <expr><call><name>array_len</name><argument_list>(<argument><expr><name>shortest_paths</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name><name>only_shortest</name><index>[<expr><name>path_count</name></expr>]</index></name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>only_shortest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>path_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>uint</name></type> <name>l</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="line">// index to paths array</comment>
			<decl_stmt><decl><type><name>uint</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="line">// index to shortest paths array</comment>
			<for>for <control>(<init>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>shortest_path_count</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>shortest</name> <init>= <expr><name><name>shortest_paths</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<comment type="line">// single shortest paths are handled by a procedure</comment>
				<if_stmt><if>if<condition>(<expr><call><name>cypher_ast_shortest_path_is_single</name><argument_list>(<argument><expr><name>shortest</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

				<decl_stmt><decl><type><specifier>const</specifier> <name>cypher_astnode_t</name> <modifier>*</modifier></type><name>path</name> <init>=
					<expr><call><name>cypher_ast_shortest_path_get_path</name><argument_list>(<argument><expr><name>shortest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="line">// seek the matching path in the paths array</comment>
				<while>while<condition>(<expr><name><name>paths</name><index>[<expr><name>l</name></expr>]</index></name> <operator>!=</operator> <name>path</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>l</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
				<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>l</name> <operator>&lt;</operator> <name>path_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="line">// each shortest must find its counterpart path</comment>
				<expr_stmt><expr><name><name>only_shortest</name><index>[<expr><name>l</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>l</name><operator>++</operator></expr>;</expr_stmt> <comment type="line">// advance for next match</comment>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>shortest_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="line">// introduce each path object to the query graph</comment>
			<for>for<control>(<init><decl><type><name>uint</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>path_count</name></expr>;</condition> <incr><expr><name>k</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<expr_stmt><expr><call><name>QueryGraph_AddPath</name><argument_list>(<argument><expr><name>qg</name></expr></argument>, <argument><expr><name><name>paths</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>only_shortest</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>qg</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>QueryGraph_MergeGraphs</name>
<parameter_list>(
	<parameter><decl><type><name>QueryGraph</name> <modifier>*</modifier></type><name>to</name></decl></parameter>,
	<parameter><decl><type><name>QueryGraph</name> <modifier>*</modifier></type><name>from</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>node_count</name> <init>= <expr><call><name>QueryGraph_NodeCount</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>edge_count</name> <init>= <expr><call><name>QueryGraph_EdgeCount</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>node_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>from</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<comment type="line">// if the entity already exists in the "to" graph, do nothing</comment>
		<comment type="line">// we could have more complex logic to merge entity data, but this is not</comment>
		<comment type="line">// currently necessary as this logic only benefits toString calls like EXPLAIN</comment>
		<if_stmt><if>if<condition>(<expr><call><name>QueryGraph_GetNodeByAlias</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="line">// new entity, clone and add it</comment>
		<expr_stmt><expr><call><name>QueryGraph_AddNode</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><call><name>QGNode_Clone</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>edge_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>QGEdge</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name><name>from</name><operator>-&gt;</operator><name>edges</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<comment type="line">// if the entity already exists in the "to" graph, do nothing</comment>
		<comment type="line">// we could have more complex logic to merge entity data, but this is not</comment>
		<comment type="line">// currently necessary as this logic only benefits toString calls like EXPLAIN</comment>
		<if_stmt><if>if<condition>(<expr><call><name>QueryGraph_GetEdgeByAlias</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="line">// retrieve the edge's endpoints in the "to" graph</comment>
		<decl_stmt><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>QueryGraph_GetNodeByAlias</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>src</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>dest</name> <init>= <expr><call><name>QueryGraph_GetNodeByAlias</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// clone and add the unmatched edge</comment>
		<decl_stmt><decl><type><name>QGEdge</name> <modifier>*</modifier></type><name>clone_edge</name> <init>= <expr><call><name>QGEdge_Clone</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>QueryGraph_ConnectNodes</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>clone_edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>QGNode</name> <modifier>*</modifier></type><name>QueryGraph_GetNodeByAlias</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>node_count</name> <init>= <expr><call><name>QueryGraph_NodeCount</name><argument_list>(<argument><expr><name>qg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>node_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>qg</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>alias</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>qg</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>QGEdge</name> <modifier>*</modifier></type><name>QueryGraph_GetEdgeByAlias</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>edge_count</name> <init>= <expr><call><name>QueryGraph_EdgeCount</name><argument_list>(<argument><expr><name>qg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>edge_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>qg</name><operator>-&gt;</operator><name>edges</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>alias</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>qg</name><operator>-&gt;</operator><name>edges</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>EntityType</name></type> <name>QueryGraph_GetEntityTypeByAlias</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><call><name>QueryGraph_GetNodeByAlias</name><argument_list>(<argument><expr><name>qg</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ENTITY_NODE</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>QueryGraph_GetEdgeByAlias</name><argument_list>(<argument><expr><name>qg</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ENTITY_EDGE</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>ENTITY_UNKNOWN</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>QueryGraph_ResolveUnknownRelIDs</name>
<parameter_list>(
	<parameter><decl><type><name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// no unknown relationships - no need to updated</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>qg</name><operator>-&gt;</operator><name>unknown_reltype_ids</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Schema</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>unkown_relationships</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GraphContext</name> <modifier>*</modifier></type><name>gc</name> <init>= <expr><call><name>QueryCtx_GetGraphCtx</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>edge_count</name> <init>= <expr><call><name>QueryGraph_EdgeCount</name><argument_list>(<argument><expr><name>qg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// update edges</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>edge_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>QGEdge</name> <modifier>*</modifier></type><name>edge</name> <init>= <expr><name><name>qg</name><operator>-&gt;</operator><name>edges</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint</name></type> <name>rel_types_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>reltypeIDs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>rel_types_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name><name>edge</name><operator>-&gt;</operator><name>reltypeIDs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>GRAPH_UNKNOWN_RELATION</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>GraphContext_GetSchema</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name><name>edge</name><operator>-&gt;</operator><name>reltypes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>SCHEMA_EDGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>(<expr><name>s</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>reltypeIDs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>id</name></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>unkown_relationships</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="line">// cannot update the unkown relationship</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>qg</name><operator>-&gt;</operator><name>unknown_reltype_ids</name></name> <operator>=</operator> <name>unkown_relationships</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>QueryGraph</name> <modifier>*</modifier></type><name>QueryGraph_Clone</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type>        <name>node_count</name>  <init>=  <expr><call><name>QueryGraph_NodeCount</name><argument_list>(<argument><expr><name>qg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type>        <name>edge_count</name>  <init>=  <expr><call><name>QueryGraph_EdgeCount</name><argument_list>(<argument><expr><name>qg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryGraph</name>  <modifier>*</modifier></type><name>clone</name>      <init>=  <expr><call><name>QueryGraph_New</name><argument_list>(<argument><expr><name>node_count</name></expr></argument>, <argument><expr><name>edge_count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// clone nodes</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>node_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<comment type="line">// clones node without its edges</comment>
		<decl_stmt><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>QGNode_Clone</name><argument_list>(<argument><expr><name><name>qg</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>QueryGraph_AddNode</name><argument_list>(<argument><expr><name>clone</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="line">// clone edges</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>edge_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>QGEdge</name>  <modifier>*</modifier></type><name>e</name>     <init>=  <expr><name><name>qg</name><operator>-&gt;</operator><name>edges</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>QGNode</name>  <modifier>*</modifier></type><name>src</name>   <init>=  <expr><call><name>QueryGraph_GetNodeByAlias</name><argument_list>(<argument><expr><name>clone</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>src</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>QGNode</name>  <modifier>*</modifier></type><name>dest</name>  <init>=  <expr><call><name>QueryGraph_GetNodeByAlias</name><argument_list>(<argument><expr><name>clone</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>src</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>dest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>QGEdge</name> <modifier>*</modifier></type><name>clone_edge</name> <init>= <expr><call><name>QGEdge_Clone</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>QueryGraph_ConnectNodes</name><argument_list>(<argument><expr><name>clone</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>clone_edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>clone</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>QGNode</name> <modifier>*</modifier></type><name>QueryGraph_RemoveNode</name>
<parameter_list>(
	<parameter><decl><type><name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>,
	<parameter><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>qg</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// remove node from query graph</comment>
	<comment type="line">// remove and free all edges associated with node</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>incoming_edge_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>incoming_edges</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>incoming_edge_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>QGEdge</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>incoming_edges</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>QueryGraph_RemoveEdge</name><argument_list>(<argument><expr><name>qg</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>QGEdge_Free</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<decl_stmt><decl><type><name>uint</name></type> <name>outgoing_edge_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>outgoing_edges</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>outgoing_edge_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>QGEdge</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>outgoing_edges</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>QueryGraph_RemoveEdge</name><argument_list>(<argument><expr><name>qg</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>QGEdge_Free</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="line">// remove node from graph nodes</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>node_count</name> <init>= <expr><call><name>QueryGraph_NodeCount</name><argument_list>(<argument><expr><name>qg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>node_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name>n</name> <operator>==</operator> <name><name>qg</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>array_del_fast</name><argument_list>(<argument><expr><name><name>qg</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>QGEdge</name> <modifier>*</modifier></type><name>QueryGraph_RemoveEdge</name>
<parameter_list>(
	<parameter><decl><type><name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>,
	<parameter><decl><type><name>QGEdge</name> <modifier>*</modifier></type><name>e</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>qg</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>e</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// disconnect nodes connected by edge</comment>
	<expr_stmt><expr><call><name>QGNode_RemoveOutgoingEdge</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>src</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>QGNode_RemoveIncomingEdge</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// remove edge from query graph</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>edge_count</name> <init>= <expr><call><name>QueryGraph_EdgeCount</name><argument_list>(<argument><expr><name>qg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>edge_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name>e</name> <operator>==</operator> <name><name>qg</name><operator>-&gt;</operator><name>edges</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>array_del_fast</name><argument_list>(<argument><expr><name><name>qg</name><operator>-&gt;</operator><name>edges</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>e</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>QueryGraph</name> <modifier>*</modifier><modifier>*</modifier></type><name>QueryGraph_ConnectedComponents</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>                              <comment type="line">// current node</comment>
	<decl_stmt><decl><type><name>QGNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>q</name> <init>= <expr><call><name>array_new</name><argument_list>(<argument><expr><name>QGNode</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>    <comment type="line">// node frontier</comment>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>seen</name></decl>;</decl_stmt>                             <comment type="line">// has node been visited?</comment>
	<decl_stmt><decl><type><name>QueryGraph</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>QueryGraph_Clone</name><argument_list>(<argument><expr><name>qg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="line">// clone query graph</comment>
	<decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>visited</name></decl>;</decl_stmt>                           <comment type="line">// dictionary of visited nodes</comment>
	<decl_stmt><decl><type><name>QueryGraph</name> <modifier>*</modifier><modifier>*</modifier></type><name>connected_components</name></decl>;</decl_stmt>      <comment type="line">// list of connected components</comment>

	<comment type="line">// at least one connected component (the original graph)</comment>
	<expr_stmt><expr><name>connected_components</name> <operator>=</operator> <call><name>array_new</name><argument_list>(<argument><expr><name>QueryGraph</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// as long as there are nodes to process</comment>
	<while>while<condition>(<expr><name>true</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>visited</name> <operator>=</operator> <call><name>raxNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// get a random node and add it to the frontier</comment>
		<decl_stmt><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// as long as there are nodes in the frontier</comment>
		<while>while<condition>(<expr><call><name>array_len</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>array_pop</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="line">// mark n as visited</comment>
			<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>raxInsert</name><argument_list>(<argument><expr><name>visited</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>n</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<comment type="line">// we've already processed n</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="line">// expand node N by visiting all of its neighbors</comment>
			<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>array_len</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>outgoing_edges</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<decl_stmt><decl><type><name>QGEdge</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>outgoing_edges</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>seen</name> <operator>=</operator> <call><name>raxFind</name><argument_list>(<argument><expr><name>visited</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>e</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>,
						<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>(<expr><name>seen</name> <operator>==</operator> <name>raxNotFound</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>

			<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>array_len</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>incoming_edges</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<decl_stmt><decl><type><name>QGEdge</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>incoming_edges</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>seen</name> <operator>=</operator> <call><name>raxFind</name><argument_list>(<argument><expr><name>visited</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>e</name><operator>-&gt;</operator><name>src</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>,
						<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>src</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>(<expr><name>seen</name> <operator>==</operator> <name>raxNotFound</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>src</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></while>

		<comment type="line">// visited comprise the connected component defined by S</comment>
		<comment type="line">// remove all non-reachable nodes from current connected component.</comment>
		<comment type="line">// remove connected component from graph</comment>
		<decl_stmt><decl><type><name>QueryGraph</name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><call><name>QueryGraph_Clone</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint</name></type> <name>node_count</name> <init>= <expr><call><name>QueryGraph_NodeCount</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>node_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>reachable</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>reachable</name> <operator>=</operator> <call><name>raxFind</name><argument_list>(<argument><expr><name>visited</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>n</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>,
					<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="line">// if node is reachable, which means it is part of the</comment>
			<comment type="line">// connected component, then remove it from the graph,</comment>
			<comment type="line">// otherwise, node isn't reachable, not part of the</comment>
			<comment type="line">// connected component</comment>
			<if_stmt><if>if<condition>(<expr><name>reachable</name> <operator>!=</operator> <name>raxNotFound</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>QueryGraph_RemoveNode</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>QGNode_Free</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>QueryGraph_GetNodeByAlias</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>QueryGraph_RemoveNode</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>QGNode_Free</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name>connected_components</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// clear visited dict for next iteration</comment>
		<expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name>visited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// exit when graph is empty</comment>
		<if_stmt><if>if<condition>(<expr><call><name>QueryGraph_NodeCount</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>QueryGraph_Free</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>connected_components</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint</name></type> <name>QueryGraph_NodeCount</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>array_len</name><argument_list>(<argument><expr><name><name>qg</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// retrieve the number of edges in a QueryGraph</comment>
<function><type><name>uint</name></type> <name>QueryGraph_EdgeCount</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>array_len</name><argument_list>(<argument><expr><name><name>qg</name><operator>-&gt;</operator><name>edges</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>GrB_Matrix</name></type> <name>QueryGraph_MatrixRepresentation</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>qg</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// make a clone of the given graph as we're about to modify it</comment>
	<decl_stmt><decl><type><name>QueryGraph</name> <modifier>*</modifier></type><name>qg_clone</name> <init>= <expr><call><name>QueryGraph_Clone</name><argument_list>(<argument><expr><name>qg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// give an ID for each node, abuse of `labelID`</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>node_count</name> <init>= <expr><call><name>QueryGraph_NodeCount</name><argument_list>(<argument><expr><name>qg_clone</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>node_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>qg_clone</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>QGNode_LabelCount</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>QGNode_AddLabel</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>labelsID</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>m</name></decl>;</decl_stmt>   <comment type="line">// matrix representation of QueryGraph</comment>
	<decl_stmt><decl><type><name>GrB_Info</name></type> <name>res</name> <init>= <expr><call><name>GrB_Matrix_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><name>GrB_BOOL</name></expr></argument>, <argument><expr><name>node_count</name></expr></argument>, <argument><expr><name>node_count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// build matrix representation of query graph</comment>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>node_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>QGNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>qg_clone</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GrB_Index</name></type> <name>src</name> <init>= <expr><call><name>QGNode_GetLabelID</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint</name></type> <name>outgoing_degree</name> <init>= <expr><call><name>QGNode_OutgoingDegree</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for<control>(<init><decl><type><name>uint</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>outgoing_degree</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>QGEdge</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>outgoing_edges</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GrB_Index</name></type> <name>dest</name> <init>= <expr><call><name>QGNode_GetLabelID</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="line">// populate `m`</comment>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>GrB_Matrix_setElement_BOOL</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>QueryGraph_Free</name><argument_list>(<argument><expr><name>qg_clone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>m</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>QueryGraph_Print</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buff</name> <init>= <expr><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>node_count</name> <init>= <expr><call><name>QueryGraph_NodeCount</name><argument_list>(<argument><expr><name>qg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint</name></type> <name>edge_count</name> <init>= <expr><call><name>QueryGraph_EdgeCount</name><argument_list>(<argument><expr><name>qg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>node_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>QGNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>qg</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>QGNode_IncomeDegree</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>QGNode_OutgoingDegree</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<comment type="line">// floating node</comment>
			<expr_stmt><expr><call><name>asprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>, <argument><expr><literal type="string">"%s%s;\n"</literal></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>edge_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>QGEdge</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name><name>qg</name><operator>-&gt;</operator><name>edges</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>asprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>, <argument><expr><literal type="string">"%s%s -&gt; %s;\n"</literal></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>src</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// frees entire graph</comment>
<function><type><name>void</name></type> <name>QueryGraph_Free</name>
<parameter_list>(
	<parameter><decl><type><name>QueryGraph</name> <modifier>*</modifier></type><name>qg</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>qg</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<comment type="line">// free QueryGraph nodes</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>nodeCount</name> <init>= <expr><call><name>QueryGraph_NodeCount</name><argument_list>(<argument><expr><name>qg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nodeCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>QGNode_Free</name><argument_list>(<argument><expr><name><name>qg</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="line">// free QueryGraph edges</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>edgeCount</name> <init>= <expr><call><name>QueryGraph_EdgeCount</name><argument_list>(<argument><expr><name>qg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>edgeCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>QGEdge_Free</name><argument_list>(<argument><expr><name><name>qg</name><operator>-&gt;</operator><name>edges</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name><name>qg</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name><name>qg</name><operator>-&gt;</operator><name>edges</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>qg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

</unit>
