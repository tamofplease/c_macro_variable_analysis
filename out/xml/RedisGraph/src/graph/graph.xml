<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/src/graph/graph.c"><comment type="block">/*
 * Copyright Redis Ltd. 2018 - present
 * Licensed under your choice of the Redis Source Available License 2.0 (RSALv2) or
 * the Server Side Public License v1 (SSPLv1).
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"RG.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"graph.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/arr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/rmalloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/datablock/oo_datablock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../graph/rg_matrix/rg_matrix_iter.h"</cpp:file></cpp:include>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// Forward declarations</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>
<function_decl><type><name>void</name></type> <name>_MatrixResizeToCapacity</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RG_Matrix</name></type> <name>m</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// Synchronization functions</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_CreateRWLock</name>
<parameter_list>(
	<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// create a read write lock which favors writes</comment>
	<comment type="line">//</comment>
	<comment type="line">// consider the following locking sequence:</comment>
	<comment type="line">// T0 read lock  (acquired)</comment>
	<comment type="line">// T1 write lock (waiting)</comment>
	<comment type="line">// T2 read lock  (acquired if lock favor reads, waiting if favor writes)</comment>
	<comment type="line">//</comment>
	<comment type="line">// we don't want to cause write starvation as this can impact overall</comment>
	<comment type="line">// system performance</comment>

	<comment type="line">// specify prefer write in lock creation attributes</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
	<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

	<decl_stmt><decl><type><name>pthread_rwlockattr_t</name></type> <name>attr</name></decl> ;</decl_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pthread_rwlockattr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><name>int</name></type> <name>pref</name> <init>= <expr><name>PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP</name></expr></init></decl> ;</decl_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pthread_rwlockattr_setkind_np</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>pref</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pthread_rwlock_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>_rwlock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// acquire a lock that does not restrict access from additional reader threads</comment>
<function><type><name>void</name></type> <name>Graph_AcquireReadLock</name><parameter_list>(<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>pthread_rwlock_rdlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>_rwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// acquire a lock for exclusive access to this graph's data</comment>
<function><type><name>void</name></type> <name>Graph_AcquireWriteLock</name><parameter_list>(<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>_rwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>_writelocked</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Release the held lock</comment>
<function><type><name>void</name></type> <name>Graph_ReleaseLock</name>
<parameter_list>(
	<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// set _writelocked to false BEFORE unlocking</comment>
	<comment type="line">// if this is a reader thread no harm done,</comment>
	<comment type="line">// if this is a writer thread the writer is about to unlock so once again</comment>
	<comment type="line">// no harm done, if we set `_writelocked` to false after unlocking it is possible</comment>
	<comment type="line">// for a reader thread to be considered as writer, performing illegal access to</comment>
	<comment type="line">// underline matrices, consider a context switch after unlocking `_rwlock` but</comment>
	<comment type="line">// before setting `_writelocked` to false</comment>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>_writelocked</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>_rwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// Graph utility functions</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// return number of nodes graph can contain</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type> <name>_Graph_NodeCap</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><name><name>g</name><operator>-&gt;</operator><name>nodes</name><operator>-&gt;</operator><name>itemCap</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_CollectEdgesFromEntry</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>NodeID</name></type> <name>src</name></decl></parameter>,
	<parameter><decl><type><name>NodeID</name></type> <name>dest</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>,
	<parameter><decl><type><name>EdgeID</name></type> <name>edgeId</name></decl></parameter>,
	<parameter><decl><type><name>Edge</name> <modifier>*</modifier><modifier>*</modifier></type><name>edges</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>Edge</name></type> <name>e</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>e</name><operator>.</operator><name>relationID</name></name>  <operator>=</operator>  <name>r</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>.</operator><name>srcNodeID</name></name>   <operator>=</operator>  <name>src</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>.</operator><name>destNodeID</name></name>  <operator>=</operator>  <name>dest</name></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>SINGLE_EDGE</name><argument_list>(<argument><expr><name>edgeId</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>e</name><operator>.</operator><name>id</name></name>          <operator>=</operator>  <name>edgeId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>e</name><operator>.</operator><name>attributes</name></name>  <operator>=</operator>  <call><name>DataBlock_GetItem</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>edges</name></name></expr></argument>, <argument><expr><name>edgeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>e</name><operator>.</operator><name>attributes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><operator>*</operator><name>edges</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="line">// multiple edges connecting src to dest,</comment>
		<comment type="line">// entry is a pointer to an array of edge IDs</comment>
		<decl_stmt><decl><type><name>EdgeID</name> <modifier>*</modifier></type><name>edgeIds</name> <init>= <expr><operator>(</operator><name>EdgeID</name> <operator>*</operator><operator>)</operator><operator>(</operator><call><name>CLEAR_MSB</name><argument_list>(<argument><expr><name>edgeId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint</name></type> <name>edgeCount</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>edgeIds</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>edgeCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><name>edgeId</name>       <operator>=</operator> <name><name>edgeIds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>.</operator><name>id</name></name>         <operator>=</operator> <name>edgeId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>.</operator><name>attributes</name></name> <operator>=</operator> <call><name>DataBlock_GetItem</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>edges</name></name></expr></argument>, <argument><expr><name>edgeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>e</name><operator>.</operator><name>attributes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><operator>*</operator><name>edges</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">// Locates edges connecting src to destination.</comment>
<function><type><name>void</name></type> <name>_Graph_GetEdgesConnectingNodes</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>NodeID</name></type> <name>src</name></decl></parameter>,
	<parameter><decl><type><name>NodeID</name></type> <name>dest</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>,
	<parameter><decl><type><name>Edge</name> <modifier>*</modifier><modifier>*</modifier></type><name>edges</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>r</name>    <operator>!=</operator> <name>GRAPH_NO_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>r</name>    <operator>&lt;</operator> <call><name>Graph_RelationTypeCount</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>src</name>  <operator>&lt;</operator> <call><name>Graph_RequiredMatrixDim</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>dest</name> <operator>&lt;</operator> <call><name>Graph_RequiredMatrixDim</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// relation map, maps (src, dest, r) to edge IDs.</comment>
	<decl_stmt><decl><type><name>EdgeID</name></type>      <name>id</name>    <init>=  <expr><name>INVALID_ENTITY_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RG_Matrix</name></type>   <name>M</name>     <init>=  <expr><call><name>Graph_GetRelationMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GrB_Info</name></type>    <name>res</name>   <init>=  <expr><call><name>RG_Matrix_extractElement_UINT64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// no entry at [dest, src], src is not connected to dest with relation R</comment>
	<if_stmt><if>if<condition>(<expr><name>res</name> <operator>==</operator> <name>GrB_NO_VALUE</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>_CollectEdgesFromEntry</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>AttributeSet</name> <modifier>*</modifier></type><name>_Graph_GetEntity</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DataBlock</name> <modifier>*</modifier></type><name>entities</name></decl></parameter>, <parameter><decl><type><name>EntityID</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>DataBlock_GetItem</name><argument_list>(<argument><expr><name>entities</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// Matrix synchronization and resizing functions</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// resize given matrix, such that its number of row and columns</comment>
<comment type="line">// matches the number of nodes in the graph. Also, synchronize</comment>
<comment type="line">// matrix to execute any pending operations</comment>
<function><type><name>void</name></type> <name>_MatrixSynchronize</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>RG_Matrix</name></type> <name>m</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>GrB_Info</name></type>  <name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GrB_Index</name></type> <name>n_rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GrB_Index</name></type> <name>n_cols</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>RG_Matrix_nrows</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n_rows</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RG_Matrix_ncols</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n_cols</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type>      <name>dirty</name> <init>= <expr><call><name>RG_Matrix_isDirty</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GrB_Index</name></type> <name>dims</name>  <init>= <expr><call><name>Graph_RequiredMatrixDim</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// matrix must be resized if its dimensions missmatch required dimensions</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>require_resize</name> <init>= <expr><operator>(</operator><name>n_rows</name> <operator>!=</operator> <name>dims</name> <operator>||</operator> <name>n_cols</name> <operator>!=</operator> <name>dims</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="line">// matrix fully synced, nothing to do</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>require_resize</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RG_Matrix_isDirty</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// lock matrix</comment>
	<expr_stmt><expr><call><name>RG_Matrix_Lock</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// recheck</comment>
	<expr_stmt><expr><call><name>RG_Matrix_nrows</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n_rows</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RG_Matrix_ncols</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n_cols</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dirty</name> <operator>=</operator> <call><name>RG_Matrix_isDirty</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dims</name> <operator>=</operator> <call><name>Graph_RequiredMatrixDim</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>require_resize</name> <operator>=</operator> <operator>(</operator><name>n_rows</name> <operator>!=</operator> <name>dims</name> <operator>||</operator> <name>n_cols</name> <operator>!=</operator> <name>dims</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="line">// some other thread performed sync</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>require_resize</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>dirty</name></expr>)</condition> <block>{<block_content>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// resize if required</comment>
	<if_stmt><if>if<condition>(<expr><name>require_resize</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>RG_Matrix_resize</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// flush pending changes if dirty</comment>
	<comment type="line">// we need to call 'RG_Matrix_isDirty' again</comment>
	<comment type="line">// as 'RG_Matrix_resize' might require 'wait' for HyperSparse matrices</comment>
	<if_stmt><if>if<condition>(<expr><call><name>RG_Matrix_isDirty</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>RG_Matrix_wait</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>RG_Matrix_isDirty</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
	<comment type="line">// unlock matrix mutex</comment>
	<expr_stmt><expr><call><name>RG_Matrix_Unlock</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// resize matrix to node capacity</comment>
<function><type><name>void</name></type> <name>_MatrixResizeToCapacity</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>RG_Matrix</name></type> <name>m</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>GrB_Index</name></type> <name>nrows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GrB_Index</name></type> <name>ncols</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RG_Matrix_ncols</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ncols</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RG_Matrix_nrows</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nrows</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>GrB_Index</name></type> <name>cap</name> <init>= <expr><call><name>Graph_RequiredMatrixDim</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// this policy should only be used in a thread-safe context,</comment>
	<comment type="line">// so no locking is required</comment>
	<if_stmt><if>if<condition>(<expr><name>nrows</name> <operator>!=</operator> <name>cap</name> <operator>||</operator> <name>ncols</name> <operator>!=</operator> <name>cap</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>GrB_Info</name></type> <name>res</name> <init>= <expr><call><name>RG_Matrix_resize</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>cap</name></expr></argument>, <argument><expr><name>cap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// do not update matrices</comment>
<function><type><name>void</name></type> <name>_MatrixNOP</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>RG_Matrix</name></type> <name>matrix</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<return>return;</return>
</block_content>}</block></function>

<function><type><name>MATRIX_POLICY</name></type> <name>Graph_GetMatrixPolicy</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>MATRIX_POLICY</name></type> <name>policy</name> <init>= <expr><name>SYNC_POLICY_UNKNOWN</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyncMatrixFunc</name></type> <name>f</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>SynchronizeMatrix</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>f</name> <operator>==</operator> <name>_MatrixSynchronize</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>policy</name> <operator>=</operator> <name>SYNC_POLICY_FLUSH_RESIZE</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>f</name> <operator>==</operator> <name>_MatrixResizeToCapacity</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>policy</name> <operator>=</operator> <name>SYNC_POLICY_RESIZE</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>f</name> <operator>==</operator> <name>_MatrixNOP</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>policy</name> <operator>=</operator> <name>SYNC_POLICY_NOP</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>policy</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// define the current behavior for matrix creations and retrievals on this graph</comment>
<function><type><name>void</name></type> <name>Graph_SetMatrixPolicy</name>
<parameter_list>(
	<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>MATRIX_POLICY</name></type> <name>policy</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<switch>switch<condition>(<expr><name>policy</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>SYNC_POLICY_FLUSH_RESIZE</name></expr>:</case>
			<comment type="line">// Default behavior; forces execution of pending GraphBLAS operations</comment>
			<comment type="line">// when appropriate and sizes matrices to the current node count.</comment>
			<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>SynchronizeMatrix</name></name> <operator>=</operator> <name>_MatrixSynchronize</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SYNC_POLICY_RESIZE</name></expr>:</case>
			<comment type="line">// Bulk insertion and creation behavior; does not force pending operations</comment>
			<comment type="line">// and resizes matrices to the graph's current node capacity.</comment>
			<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>SynchronizeMatrix</name></name> <operator>=</operator> <name>_MatrixResizeToCapacity</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SYNC_POLICY_NOP</name></expr>:</case>
			<comment type="line">// Used when deleting or freeing a graph; forces no matrix updates or resizes.</comment>
			<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>SynchronizeMatrix</name></name> <operator>=</operator> <name>_MatrixNOP</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="line">// synchronize and resize all matrices in graph</comment>
<function><type><name>void</name></type> <name>Graph_ApplyAllPending</name>
<parameter_list>(
	<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>bool</name></type> <name>force_flush</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint</name></type>       <name>n</name>  <init>=  <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RG_Matrix</name></type>  <name>M</name>  <init>=  <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// backup previous sync policy</comment>
	<decl_stmt><decl><type><name>MATRIX_POLICY</name></type> <name>policy</name> <init>= <expr><call><name>Graph_GetMatrixPolicy</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// set matrix sync policy</comment>
	<expr_stmt><expr><call><name>Graph_SetMatrixPolicy</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>SYNC_POLICY_FLUSH_RESIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">//--------------------------------------------------------------------------</comment>
	<comment type="line">// sync every matrix</comment>
	<comment type="line">//--------------------------------------------------------------------------</comment>

	<comment type="line">// sync the adjacency matrix</comment>
	<expr_stmt><expr><name>M</name> <operator>=</operator> <call><name>Graph_GetAdjacencyMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RG_Matrix_wait</name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><name>force_flush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// sync node labels matrix</comment>
	<expr_stmt><expr><name>M</name> <operator>=</operator> <call><name>Graph_GetNodeLabelMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RG_Matrix_wait</name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><name>force_flush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// sync the zero matrix</comment>
	<expr_stmt><expr><name>M</name> <operator>=</operator> <call><name>Graph_GetZeroMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RG_Matrix_wait</name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><name>force_flush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// sync each label matrix</comment>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>array_len</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>labels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>M</name> <operator>=</operator> <call><name>Graph_GetLabelMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RG_Matrix_wait</name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><name>force_flush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="line">// sync each relation matrix</comment>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>array_len</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>relations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>M</name> <operator>=</operator> <call><name>Graph_GetRelationMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RG_Matrix_wait</name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><name>force_flush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="line">// restore previous matrix sync policy</comment>
	<expr_stmt><expr><call><name>Graph_SetMatrixPolicy</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>Graph_Pending</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>GrB_Info</name></type>   <name>info</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint</name></type>       <name>n</name>        <init>=  <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RG_Matrix</name></type>  <name>M</name>        <init>=  <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>       <name>pending</name>  <init>=  <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="line">//--------------------------------------------------------------------------</comment>
	<comment type="line">// see if ADJ matrix contains pending changes</comment>
	<comment type="line">//--------------------------------------------------------------------------</comment>

	<expr_stmt><expr><name>M</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>adjacency_matrix</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>RG_Matrix_pending</name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pending</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>pending</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">//--------------------------------------------------------------------------</comment>
	<comment type="line">// see if node_labels matrix contains pending changes</comment>
	<comment type="line">//--------------------------------------------------------------------------</comment>

	<expr_stmt><expr><name>M</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>node_labels</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>RG_Matrix_pending</name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pending</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>pending</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">//--------------------------------------------------------------------------</comment>
	<comment type="line">// see if the zero matrix contains pending changes</comment>
	<comment type="line">//--------------------------------------------------------------------------</comment>

	<expr_stmt><expr><name>M</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>_zero_matrix</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>RG_Matrix_pending</name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pending</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>pending</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">//--------------------------------------------------------------------------</comment>
	<comment type="line">// see if any label matrix contains pending changes</comment>
	<comment type="line">//--------------------------------------------------------------------------</comment>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>array_len</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>labels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>M</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>labels</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>RG_Matrix_pending</name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pending</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>pending</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="line">//--------------------------------------------------------------------------</comment>
	<comment type="line">// see if any relationship matrix contains pending changes</comment>
	<comment type="line">//--------------------------------------------------------------------------</comment>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>array_len</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>relations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>M</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>relations</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>RG_Matrix_pending</name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pending</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>pending</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// Graph API</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>Graph</name> <modifier>*</modifier></type><name>Graph_New</name>
<parameter_list>(
	<parameter><decl><type><name>size_t</name></type> <name>node_cap</name></decl></parameter>,
	<parameter><decl><type><name>size_t</name></type> <name>edge_cap</name></decl></parameter>
)</parameter_list> <block>{<block_content>

	<decl_stmt><decl><type><name>fpDestructor</name></type> <name>cb</name> <init>= <expr><operator>(</operator><name>fpDestructor</name><operator>)</operator><name>AttributeSet_Free</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>rm_calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Graph</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>nodes</name></name>      <operator>=</operator>  <call><name>DataBlock_New</name><argument_list>(<argument><expr><name>node_cap</name></expr></argument>, <argument><expr><name>node_cap</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttributeSet</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>edges</name></name>      <operator>=</operator>  <call><name>DataBlock_New</name><argument_list>(<argument><expr><name>edge_cap</name></expr></argument>, <argument><expr><name>edge_cap</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttributeSet</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>labels</name></name>     <operator>=</operator>  <call><name>array_new</name><argument_list>(<argument><expr><name>RG_Matrix</name></expr></argument>, <argument><expr><name>GRAPH_DEFAULT_LABEL_CAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>relations</name></name>  <operator>=</operator>  <call><name>array_new</name><argument_list>(<argument><expr><name>RG_Matrix</name></expr></argument>, <argument><expr><name>GRAPH_DEFAULT_RELATION_TYPE_CAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>GrB_Index</name></type> <name>n</name> <init>= <expr><call><name>Graph_RequiredMatrixDim</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RG_Matrix_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>node_labels</name></name></expr></argument>, <argument><expr><name>GrB_BOOL</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RG_Matrix_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>adjacency_matrix</name></name></expr></argument>, <argument><expr><name>GrB_BOOL</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RG_Matrix_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>adjacency_matrix</name><operator>-&gt;</operator><name>transposed</name></name></expr></argument>, <argument><expr><name>GrB_BOOL</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RG_Matrix_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>_zero_matrix</name></name></expr></argument>, <argument><expr><name>GrB_BOOL</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// init graph statistics</comment>
	<expr_stmt><expr><call><name>GraphStatistics_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// initialize a read-write lock scoped to the individual graph</comment>
	<expr_stmt><expr><call><name>_CreateRWLock</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>_writelocked</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="line">// force GraphBLAS updates and resize matrices to node count by default</comment>
	<expr_stmt><expr><call><name>Graph_SetMatrixPolicy</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>SYNC_POLICY_FLUSH_RESIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>g</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// All graph matrices are required to be squared NXN</comment>
<comment type="line">// where N = Graph_RequiredMatrixDim.</comment>
<function><type><specifier>inline</specifier> <name>size_t</name></type> <name>Graph_RequiredMatrixDim</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>_Graph_NodeCap</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>Graph_NodeCount</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>g</name><operator>-&gt;</operator><name>nodes</name><operator>-&gt;</operator><name>itemCount</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint</name></type> <name>Graph_DeletedNodeCount</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>DataBlock_DeletedItemsCount</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>Graph_UncompactedNodeCount</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>Graph_NodeCount</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>Graph_DeletedNodeCount</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type> <name>Graph_LabeledNodeCount</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>label_idx</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>GraphStatistics_NodeCount</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>, <argument><expr><name>label_idx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>Graph_EdgeCount</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>g</name><operator>-&gt;</operator><name>edges</name><operator>-&gt;</operator><name>itemCount</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type> <name>Graph_RelationEdgeCount</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relation_idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>GraphStatistics_EdgeCount</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>, <argument><expr><name>relation_idx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint</name></type> <name>Graph_DeletedEdgeCount</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>DataBlock_DeletedItemsCount</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>edges</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>Graph_RelationTypeCount</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>array_len</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>relations</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>Graph_LabelTypeCount</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>array_len</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>labels</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>Graph_AllocateNodes</name><parameter_list>(<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DataBlock_Accommodate</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>Graph_AllocateEdges</name><parameter_list>(<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DataBlock_Accommodate</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>edges</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>Graph_GetNode</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>NodeID</name></type> <name>id</name></decl></parameter>,
	<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>n</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>id</name></name>         <operator>=</operator> <name>id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>attributes</name></name> <operator>=</operator> <call><name>_Graph_GetEntity</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>attributes</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>Graph_GetEdge</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>EdgeID</name></type> <name>id</name></decl></parameter>,
	<parameter><decl><type><name>Edge</name> <modifier>*</modifier></type><name>e</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>e</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>id</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>edges</name><operator>-&gt;</operator><name>itemCap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>id</name></name>         <operator>=</operator> <name>id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>attributes</name></name> <operator>=</operator> <call><name>_Graph_GetEntity</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>edges</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>attributes</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>Graph_GetEdgeRelation</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>Edge</name> <modifier>*</modifier></type><name>e</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>     <name>rel</name>         <init>=  <expr><name>GRAPH_NO_RELATION</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EdgeID</name></type>  <name>id</name>          <init>=  <expr><call><name>ENTITY_GET_ID</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NodeID</name></type>  <name>srcNodeID</name>   <init>=  <expr><call><name>Edge_GetSrcNodeID</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NodeID</name></type>  <name>destNodeID</name>  <init>=  <expr><call><name>Edge_GetDestNodeID</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// search for relation mapping matrix M, where M[dest,src] == edge ID</comment>
	<decl_stmt><decl><type><name>uint</name></type> <name>n</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>relations</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>EdgeID</name></type> <name>edgeId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RG_Matrix</name></type> <name>M</name> <init>= <expr><call><name>Graph_GetRelationMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>RG_Matrix_extractElement_UINT64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>edgeId</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>srcNodeID</name></expr></argument>,
											   <argument><expr><name>destNodeID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>info</name> <operator>!=</operator> <name>GrB_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if<condition>(<expr><call><name>SINGLE_EDGE</name><argument_list>(<argument><expr><name>edgeId</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>EdgeID</name></type> <name>curEdgeID</name> <init>= <expr><name>edgeId</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><name>curEdgeID</name> <operator>==</operator> <name>id</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>Edge_SetRelationID</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rel</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="line">// multiple edges exists between src and dest</comment>
			<comment type="line">// see if given edge is one of them</comment>
			<decl_stmt><decl><type><name>EdgeID</name> <modifier>*</modifier></type><name>edges</name> <init>= <expr><operator>(</operator><name>EdgeID</name> <operator>*</operator><operator>)</operator><operator>(</operator><call><name>CLEAR_MSB</name><argument_list>(<argument><expr><name>edgeId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>edge_count</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<for>for<control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>edge_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<if_stmt><if>if<condition>(<expr><name><name>edges</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>id</name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><call><name>Edge_SetRelationID</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>rel</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="line">// we must be able to find edge relation</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>rel</name> <operator>!=</operator> <name>GRAPH_NO_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>Graph_GetEdgesConnectingNodes</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>NodeID</name></type> <name>srcID</name></decl></parameter>,
	<parameter><decl><type><name>NodeID</name></type> <name>destID</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>,
	<parameter><decl><type><name>Edge</name> <modifier>*</modifier><modifier>*</modifier></type><name>edges</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>r</name> <operator>&lt;</operator> <call><name>Graph_RelationTypeCount</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// invalid relation type specified;</comment>
	<comment type="line">// this can occur on multi-type traversals like:</comment>
	<comment type="line">// MATCH ()-[:real_type|fake_type]-&gt;()</comment>
	<if_stmt><if>if<condition>(<expr><name>r</name> <operator>==</operator> <name>GRAPH_UNKNOWN_RELATION</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RG_DEBUG</name></cpp:ifdef>
	<decl_stmt><decl><type><name>Node</name></type>  <name>srcNode</name>   <init>=  <expr><call><name>GE_NEW_NODE</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name></type>  <name>destNode</name>  <init>=  <expr><call><name>GE_NEW_NODE</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>Graph_GetNode</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>srcID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srcNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>Graph_GetNode</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>destID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>destNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if<condition>(<expr><name>r</name> <operator>!=</operator> <name>GRAPH_NO_RELATION</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_Graph_GetEdgesConnectingNodes</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>srcID</name></expr></argument>, <argument><expr><name>destID</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="line">// relation type missing, scan through each edge type</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>relationCount</name> <init>= <expr><call><name>Graph_RelationTypeCount</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>relationCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>_Graph_GetEdgesConnectingNodes</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>srcID</name></expr></argument>, <argument><expr><name>destID</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>Graph_CreateNode</name>
<parameter_list>(
	<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl></parameter>,
	<parameter><decl><type><name>LabelID</name> <modifier>*</modifier></type><name>labels</name></decl></parameter>,
	<parameter><decl><type><name>uint</name></type> <name>label_count</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>n</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>label_count</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>label_count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>labels</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>NodeID</name></type> <name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttributeSet</name> <modifier>*</modifier></type><name>set</name> <init>= <expr><call><name>DataBlock_AllocateItem</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>set</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>id</name></name>         <operator>=</operator> <name>id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>attributes</name></name> <operator>=</operator> <name>set</name></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>label_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>Graph_LabelNode</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>ENTITY_GET_ID</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>labels</name></expr></argument>, <argument><expr><name>label_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// label node with each label in 'lbls'</comment>
<function><type><name>void</name></type> <name>Graph_LabelNode</name>
<parameter_list>(
	<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,       <comment type="line">// graph to operate on</comment>
	<parameter><decl><type><name>NodeID</name></type> <name>id</name></decl></parameter>,      <comment type="line">// node ID to update</comment>
	<parameter><decl><type><name>LabelID</name> <modifier>*</modifier></type><name>lbls</name></decl></parameter>,  <comment type="line">// set to labels to associate with node</comment>
	<parameter><decl><type><name>uint</name></type> <name>lbl_count</name></decl></parameter>  <comment type="line">// number of labels</comment>
)</parameter_list> <block>{<block_content>
	<comment type="line">// validations</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>lbls</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>lbl_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>id</name> <operator>!=</operator> <name>INVALID_ENTITY_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RG_Matrix</name></type> <name>nl</name> <init>= <expr><call><name>Graph_GetNodeLabelMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>lbl_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>LabelID</name></type> <name>l</name> <init>= <expr><name><name>lbls</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RG_Matrix</name></type> <name>L</name> <init>= <expr><call><name>Graph_GetLabelMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// set matrix at position [id, id]</comment>
		<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>RG_Matrix_setElement_BOOL</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// map this label in this node's set of labels</comment>
		<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>RG_Matrix_setElement_BOOL</name><argument_list>(<argument><expr><name>nl</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// update labels statistics</comment>
		<expr_stmt><expr><call><name>GraphStatistics_IncNodeCount</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="line">// return true if node is labeled as 'l'</comment>
<function><type><name>bool</name></type> <name>Graph_IsNodeLabeled</name>
<parameter_list>(
	<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,   <comment type="line">// graph to operate on</comment>
	<parameter><decl><type><name>NodeID</name></type> <name>id</name></decl></parameter>,  <comment type="line">// node ID to inspect</comment>
	<parameter><decl><type><name>LabelID</name></type> <name>l</name></decl></parameter>   <comment type="line">// label to check for</comment>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name>  <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>id</name> <operator>!=</operator> <name>INVALID_ENTITY_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>x</name></decl>;</decl_stmt>
	<comment type="line">// consult with labels matrix</comment>
	<decl_stmt><decl><type><name>RG_Matrix</name></type> <name>nl</name> <init>= <expr><call><name>Graph_GetNodeLabelMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name> <init>= <expr><call><name>RG_Matrix_extractElement_BOOL</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>nl</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name> <operator>||</operator> <name>info</name> <operator>==</operator> <name>GrB_NO_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// dissociates each label in 'lbls' from given node</comment>
<function><type><name>void</name></type> <name>Graph_RemoveNodeLabels</name>
<parameter_list>(
	<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,       <comment type="line">// graph to operate against</comment>
	<parameter><decl><type><name>NodeID</name></type> <name>id</name></decl></parameter>,      <comment type="line">// node ID to update</comment>
	<parameter><decl><type><name>LabelID</name>  <modifier>*</modifier></type><name>lbls</name></decl></parameter>, <comment type="line">// set of labels to remove</comment>
	<parameter><decl><type><name>uint</name></type> <name>lbl_count</name></decl></parameter>  <comment type="line">// number of labels to remove</comment>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>id</name> <operator>!=</operator> <name>INVALID_ENTITY_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>lbls</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>lbl_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RG_Matrix</name></type> <name>nl</name> <init>= <expr><call><name>Graph_GetNodeLabelMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>lbl_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>LabelID</name></type>   <name>l</name> <init>= <expr><name><name>lbls</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RG_Matrix</name></type> <name>M</name> <init>= <expr><call><name>Graph_GetLabelMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// remove matrix at position [id, id]</comment>
		<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>RG_Matrix_removeElement_BOOL</name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// remove this label from node's set of labels</comment>
		<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>RG_Matrix_removeElement_BOOL</name><argument_list>(<argument><expr><name>nl</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// a label was removed from node, update statistics</comment>
		<expr_stmt><expr><call><name>GraphStatistics_DecNodeCount</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>Graph_FormConnection</name>
<parameter_list>(
	<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>NodeID</name></type> <name>src</name></decl></parameter>,
	<parameter><decl><type><name>NodeID</name></type> <name>dest</name></decl></parameter>,
	<parameter><decl><type><name>EdgeID</name></type> <name>edge_id</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>RG_Matrix</name></type>  <name>M</name>    <init>=  <expr><call><name>Graph_GetRelationMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RG_Matrix</name></type>  <name>adj</name>  <init>=  <expr><call><name>Graph_GetAdjacencyMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// rows represent source nodes, columns represent destination nodes</comment>
	<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>RG_Matrix_setElement_BOOL</name><argument_list>(<argument><expr><name>adj</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// incase of decoding it is possible to write outside of matrix bounds</comment>
	<comment type="line">// exit early</comment>
	<if_stmt><if>if<condition>(<expr><name>info</name> <operator>!=</operator> <name>GrB_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>RG_Matrix_setElement_UINT64</name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><name>edge_id</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>info</name> <operator>!=</operator> <name>GrB_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// an edge of type r has just been created, update statistics</comment>
	<expr_stmt><expr><call><name>GraphStatistics_IncEdgeCount</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>Graph_CreateEdge</name>
<parameter_list>(
	<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>NodeID</name></type> <name>src</name></decl></parameter>,
	<parameter><decl><type><name>NodeID</name></type> <name>dest</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>,
	<parameter><decl><type><name>Edge</name> <modifier>*</modifier></type><name>e</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>r</name> <operator>&lt;</operator> <call><name>Graph_RelationTypeCount</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RG_DEBUG</name></cpp:ifdef>
	<comment type="line">// make sure both src and destination nodes exists</comment>
	<decl_stmt><decl><type><name>Node</name></type> <name>node</name> <init>= <expr><call><name>GE_NEW_NODE</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>Graph_GetNode</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>Graph_GetNode</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<decl_stmt><decl><type><name>EdgeID</name></type> <name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttributeSet</name> <modifier>*</modifier></type><name>set</name> <init>= <expr><call><name>DataBlock_AllocateItem</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>edges</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>set</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>id</name></name>            <operator>=</operator>  <name>id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>attributes</name></name>    <operator>=</operator>  <name>set</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>srcNodeID</name></name>     <operator>=</operator>  <name>src</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>destNodeID</name></name>    <operator>=</operator>  <name>dest</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>relationID</name></name>    <operator>=</operator>  <name>r</name></expr>;</expr_stmt>


	<expr_stmt><expr><call><name>Graph_FormConnection</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// retrieves all either incoming or outgoing edges</comment>
<comment type="line">// to/from given node N, depending on given direction</comment>
<function><type><name>void</name></type> <name>Graph_GetNodeEdges</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,      <comment type="line">// graph to collect edges from</comment>
	<parameter><decl><type><specifier>const</specifier> <name>Node</name> <modifier>*</modifier></type><name>n</name></decl></parameter>,       <comment type="line">// either source or destination node</comment>
	<parameter><decl><type><name>GRAPH_EDGE_DIR</name></type> <name>dir</name></decl></parameter>,  <comment type="line">// edge direction -&gt;, &lt;-, &lt;-&gt;</comment>
	<parameter><decl><type><name>int</name></type> <name>edgeType</name></decl></parameter>,        <comment type="line">// relationship type</comment>
	<parameter><decl><type><name>Edge</name> <modifier>*</modifier><modifier>*</modifier></type><name>edges</name></decl></parameter>         <comment type="line">// [output] array of edges</comment>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>GrB_Type</name></type> <name>t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RG_MatrixTupleIter</name></type>   <name>it</name>       <init>=  <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RG_Matrix</name></type>            <name>M</name>        <init>=  <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RG_Matrix</name></type>            <name>TM</name>       <init>=  <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NodeID</name></type>               <name>srcID</name>    <init>=  <expr><call><name>ENTITY_GET_ID</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NodeID</name></type>               <name>destID</name>   <init>=  <expr><name>INVALID_ENTITY_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EdgeID</name></type>               <name>edgeID</name>   <init>=  <expr><name>INVALID_ENTITY_ID</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>edgeType</name> <operator>==</operator> <name>GRAPH_UNKNOWN_RELATION</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>outgoing</name> <init>= <expr><operator>(</operator><name>dir</name> <operator>==</operator> <name>GRAPH_EDGE_DIR_OUTGOING</name> <operator>||</operator>
					 <name>dir</name> <operator>==</operator> <name>GRAPH_EDGE_DIR_BOTH</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>incoming</name> <init>= <expr><operator>(</operator><name>dir</name> <operator>==</operator> <name>GRAPH_EDGE_DIR_INCOMING</name> <operator>||</operator>
					 <name>dir</name> <operator>==</operator> <name>GRAPH_EDGE_DIR_BOTH</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="line">// if a relationship type is specified,</comment>
	<comment type="line">// retrieve the appropriate relation matrix</comment>
	<comment type="line">// otherwise use the overall adjacency matrix</comment>
	<expr_stmt><expr><name>M</name> <operator>=</operator> <call><name>Graph_GetRelationMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>edgeType</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>outgoing</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>RG_Matrix_type</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><name>M</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>t</name> <operator>==</operator> <name>GrB_UINT64</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>GrB_BOOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// construct an iterator to traverse over the source node row,</comment>
		<comment type="line">// containing all outgoing edges</comment>
		<expr_stmt><expr><call><name>RG_MatrixTupleIter_AttachRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>srcID</name></expr></argument>, <argument><expr><name>srcID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>t</name> <operator>==</operator> <name>GrB_UINT64</name></expr>)</condition> <block>{<block_content>
			<while>while<condition>(<expr><call><name>RG_MatrixTupleIter_next_UINT64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>destID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>edgeID</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GrB_SUCCESS</name></expr>)</condition> <block>{<block_content>
				<comment type="line">// collect all edges (src)-&gt;(dest)</comment>
				<expr_stmt><expr><call><name>_CollectEdgesFromEntry</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>srcID</name></expr></argument>, <argument><expr><name>destID</name></expr></argument>, <argument><expr><name>edgeType</name></expr></argument>, <argument><expr><name>edgeID</name></expr></argument>, <argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<while>while<condition>(<expr><call><name>RG_MatrixTupleIter_next_BOOL</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>destID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GrB_SUCCESS</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>Graph_GetEdgesConnectingNodes</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>srcID</name></expr></argument>, <argument><expr><name>destID</name></expr></argument>, <argument><expr><name>edgeType</name></expr></argument>, <argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>RG_MatrixTupleIter_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>incoming</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// if a relationship type is specified, retrieve the appropriate</comment>
		<comment type="line">// transposed relation matrix,</comment>
		<comment type="line">// otherwise use the transposed adjacency matrix</comment>
		<expr_stmt><expr><name>TM</name> <operator>=</operator> <call><name>Graph_GetRelationMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>edgeType</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>RG_Matrix_type</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><name>M</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>t</name> <operator>==</operator> <name>GrB_UINT64</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>GrB_BOOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// construct an iterator to traverse over the source node row,</comment>
		<comment type="line">// containing all incoming edges</comment>
		<expr_stmt><expr><call><name>RG_MatrixTupleIter_AttachRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>TM</name></expr></argument>, <argument><expr><name>srcID</name></expr></argument>, <argument><expr><name>srcID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><name>t</name> <operator>==</operator> <name>GrB_UINT64</name></expr>)</condition> <block>{<block_content>
			<while>while<condition>(<expr><call><name>RG_MatrixTupleIter_next_UINT64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>destID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GrB_SUCCESS</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>RG_Matrix_extractElement_UINT64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>edgeID</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>destID</name></expr></argument>, <argument><expr><name>srcID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>(<expr><name>dir</name> <operator>==</operator> <name>GRAPH_EDGE_DIR_BOTH</name> <operator>&amp;&amp;</operator> <name>srcID</name> <operator>==</operator> <name>destID</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
				<comment type="line">// collect all edges connecting destId to srcId</comment>
				<expr_stmt><expr><call><name>_CollectEdgesFromEntry</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>destID</name></expr></argument>, <argument><expr><name>srcID</name></expr></argument>, <argument><expr><name>edgeType</name></expr></argument>, <argument><expr><name>edgeID</name></expr></argument>, <argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<while>while<condition>(<expr><call><name>RG_MatrixTupleIter_next_BOOL</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>destID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GrB_SUCCESS</name></expr>)</condition> <block>{<block_content>
				<if_stmt><if>if<condition>(<expr><name>dir</name> <operator>==</operator> <name>GRAPH_EDGE_DIR_BOTH</name> <operator>&amp;&amp;</operator> <name>srcID</name> <operator>==</operator> <name>destID</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>Graph_GetEdgesConnectingNodes</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>destID</name></expr></argument>, <argument><expr><name>srcID</name></expr></argument>, <argument><expr><name>edgeType</name></expr></argument>, <argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>RG_MatrixTupleIter_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// populate array of node's label IDs, return number of labels on node</comment>
<function><type><name>uint</name></type> <name>Graph_GetNodeLabels</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,   <comment type="line">// graph the node belongs to</comment>
	<parameter><decl><type><specifier>const</specifier> <name>Node</name> <modifier>*</modifier></type><name>n</name></decl></parameter>,    <comment type="line">// node to extract labels from</comment>
	<parameter><decl><type><name>LabelID</name> <modifier>*</modifier></type><name>labels</name></decl></parameter>,  <comment type="line">// array to populate with labels</comment>
	<parameter><decl><type><name>uint</name></type> <name>label_count</name></decl></parameter>  <comment type="line">// size of labels array</comment>
)</parameter_list> <block>{<block_content>
	<comment type="line">// validate inputs</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name>      <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>n</name>      <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>labels</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>GrB_Info</name></type> <name>res</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// GrB_Col_extract will iterate over the range of the output size</comment>
	<decl_stmt><decl><type><name>RG_Matrix</name></type> <name>M</name> <init>= <expr><call><name>Graph_GetNodeLabelMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>EntityID</name></type> <name>id</name> <init>= <expr><call><name>ENTITY_GET_ID</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RG_MatrixTupleIter</name></type> <name>iter</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>RG_MatrixTupleIter_AttachRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for<control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>label_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>GrB_Index</name></type> <name>col</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>RG_MatrixTupleIter_next_BOOL</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>col</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>labels</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>col</name></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><name>res</name> <operator>==</operator> <name>GxB_EXHAUSTED</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>RG_MatrixTupleIter_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// removes node and all of its connections within the graph</comment>
<function><type><name>void</name></type> <name>Graph_DeleteNode</name>
<parameter_list>(
	<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<comment type="line">// assumption, node is detached</comment>
 	<comment type="line">// there are no incoming nor outgoing edges leading to / from node</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>n</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RG_DEBUG</name></expr></cpp:if>
	<comment type="line">// validate assumption</comment>
	<decl_stmt><decl><type><name>Edge</name> <modifier>*</modifier></type><name>edges</name> <init>= <expr><call><name>array_new</name><argument_list>(<argument><expr><name>Edge</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Graph_GetNodeEdges</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>GRAPH_EDGE_DIR_BOTH</name></expr></argument>, <argument><expr><name>GRAPH_NO_RELATION</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>array_len</name><argument_list>(<argument><expr><name>edges</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<decl_stmt><decl><type><name>uint</name></type> <name>label_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EntityID</name></type> <name>n_id</name> <init>= <expr><call><name>ENTITY_GET_ID</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>NODE_GET_LABELS</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>label_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// update label matrices</comment>
	<if_stmt><if>if<condition>(<expr><name>label_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>Graph_RemoveNodeLabels</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>n_id</name></expr></argument>, <argument><expr><name>labels</name></expr></argument>, <argument><expr><name>label_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// remove node from datablock</comment>
	<expr_stmt><expr><call><name>DataBlock_DeleteItem</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>, <argument><expr><name>n_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// removes an edge from Graph and updates graph relevant matrices</comment>
<function><type><name>int</name></type> <name>Graph_DeleteEdge</name>
<parameter_list>(
	<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>Edge</name> <modifier>*</modifier></type><name>e</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>e</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint64_t</name></type>    <name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RG_Matrix</name></type>   <name>R</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RG_Matrix</name></type>   <name>M</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GrB_Info</name></type>    <name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EdgeID</name></type>      <name>edge_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>r</name>         <init>=  <expr><call><name>Edge_GetRelationID</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NodeID</name></type>      <name>src_id</name>    <init>=  <expr><call><name>Edge_GetSrcNodeID</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NodeID</name></type>      <name>dest_id</name>   <init>=  <expr><call><name>Edge_GetDestNodeID</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>R</name> <operator>=</operator> <call><name>Graph_GetRelationMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// test to see if edge exists</comment>
	<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>RG_Matrix_extractElement_UINT64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>edge_id</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><name>src_id</name></expr></argument>, <argument><expr><name>dest_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>info</name> <operator>!=</operator> <name>GrB_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// an edge of type r has just been deleted, update statistics</comment>
	<expr_stmt><expr><call><name>GraphStatistics_DecEdgeCount</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// single edge of type R connecting src to dest, delete entry</comment>
	<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>RG_Matrix_removeEntry</name><argument_list>(<argument><expr><name>R</name></expr></argument>, <argument><expr><name>src_id</name></expr></argument>, <argument><expr><name>dest_id</name></expr></argument>, <argument><expr><call><name>ENTITY_GET_ID</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>SINGLE_EDGE</name><argument_list>(<argument><expr><name>edge_id</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="line">// see if source is connected to destination with additional edges</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>connected</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>relationCount</name> <init>= <expr><call><name>Graph_RelationTypeCount</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>relationCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name>i</name> <operator>==</operator> <name>r</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>M</name> <operator>=</operator> <call><name>Graph_GetRelationMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>RG_Matrix_extractElement_UINT64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>src_id</name></expr></argument>, <argument><expr><name>dest_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>connected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="line">// there are no additional edges connecting source to destination</comment>
		<comment type="line">// remove edge from THE adjacency matrix</comment>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><name>connected</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>M</name> <operator>=</operator> <call><name>Graph_GetAdjacencyMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>RG_Matrix_removeElement_BOOL</name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><name>src_id</name></expr></argument>, <argument><expr><name>dest_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// free and remove edges from datablock.</comment>
	<expr_stmt><expr><call><name>DataBlock_DeleteItem</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>edges</name></name></expr></argument>, <argument><expr><call><name>ENTITY_GET_ID</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>Graph_EntityIsDeleted</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>GraphEntity</name> <modifier>*</modifier></type><name>e</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>DataBlock_ItemIsDeleted</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>attributes</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_Graph_FreeRelationMatrices</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint</name></type> <name>relationCount</name> <init>= <expr><call><name>Graph_RelationTypeCount</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>uint</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>relationCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RG_Matrix_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>relations</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="line">// update entity's attribute with given value</comment>
<function><type><name>int</name></type> <name>Graph_UpdateEntity</name>
<parameter_list>(
	<parameter><decl><type><name>GraphEntity</name> <modifier>*</modifier></type><name>ge</name></decl></parameter>,             <comment type="line">// entity yo update</comment>
	<parameter><decl><type><name>Attribute_ID</name></type> <name>attr_id</name></decl></parameter>,        <comment type="line">// attribute to update</comment>
	<parameter><decl><type><name>SIValue</name></type> <name>value</name></decl></parameter>,               <comment type="line">// value to be set</comment>
	<parameter><decl><type><name>GraphEntityType</name></type> <name>entity_type</name></decl></parameter>  <comment type="line">// type of the entity node/edge</comment>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>ge</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="line">// handle the case in which we are deleting all attributes</comment>
	<if_stmt><if>if<condition>(<expr><name>attr_id</name> <operator>==</operator> <name>ATTRIBUTE_ID_ALL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>GraphEntity_ClearAttributes</name><argument_list>(<argument><expr><name>ge</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// try to get current attribute value</comment>
	<decl_stmt><decl><type><name>SIValue</name> <modifier>*</modifier></type><name>old_value</name> <init>= <expr><call><name>GraphEntity_GetProperty</name><argument_list>(<argument><expr><name>ge</name></expr></argument>, <argument><expr><name>attr_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>old_value</name> <operator>==</operator> <name>ATTRIBUTE_NOTFOUND</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// adding a new attribute; do nothing if its value is NULL</comment>
		<if_stmt><if>if<condition>(<expr><call><name>SI_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>T_NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>GraphEntity_AddProperty</name><argument_list>(<argument><expr><name>ge</name></expr></argument>, <argument><expr><name>attr_id</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="line">// update attribute</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>GraphEntity_SetProperty</name><argument_list>(<argument><expr><name>ge</name></expr></argument>, <argument><expr><name>attr_id</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>DataBlockIterator</name> <modifier>*</modifier></type><name>Graph_ScanNodes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>DataBlock_Scan</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>DataBlockIterator</name> <modifier>*</modifier></type><name>Graph_ScanEdges</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>DataBlock_Scan</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>edges</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>Graph_AddLabel</name>
<parameter_list>(
	<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RG_Matrix</name></type> <name>m</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name>Graph_RequiredMatrixDim</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RG_Matrix_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><name>GrB_BOOL</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>labels</name></name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// adding a new label, update the stats structures to support it</comment>
	<expr_stmt><expr><call><name>GraphStatistics_IntroduceLabel</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>labelID</name> <init>= <expr><call><name>Graph_LabelTypeCount</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>labelID</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>Graph_RemoveLabel</name>
<parameter_list>(
	<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>label_id</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>label_id</name> <operator>==</operator> <call><name>Graph_LabelTypeCount</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RG_DEBUG</name></cpp:ifdef>
	<decl_stmt><decl><type><name>GrB_Index</name></type> <name>nvals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name> <init>= <expr><call><name>RG_Matrix_nvals</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nvals</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>labels</name><index>[<expr><name>label_id</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>nvals</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>RG_Matrix_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>labels</name><index>[<expr><name>label_id</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>labels</name></name> <operator>=</operator> <call><name>array_del</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>labels</name></name></expr></argument>, <argument><expr><name>label_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>Graph_AddRelationType</name>
<parameter_list>(
	<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RG_Matrix</name></type> <name>m</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name>Graph_RequiredMatrixDim</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>RG_Matrix_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><name>GrB_UINT64</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>array_append</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>relations</name></name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// adding a new relationship type, update the stats structures to support it</comment>
	<expr_stmt><expr><call><name>GraphStatistics_IntroduceRelationship</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>relationID</name> <init>= <expr><call><name>Graph_RelationTypeCount</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>relationID</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>Graph_RemoveRelation</name>
<parameter_list>(
	<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>relation_id</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>relation_id</name> <operator>==</operator> <call><name>Graph_RelationTypeCount</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RG_DEBUG</name></cpp:ifdef>
	<decl_stmt><decl><type><name>GrB_Index</name></type> <name>nvals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name> <init>= <expr><call><name>RG_Matrix_nvals</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nvals</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>relations</name><index>[<expr><name>relation_id</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>nvals</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>RG_Matrix_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>relations</name><index>[<expr><name>relation_id</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>relations</name></name> <operator>=</operator> <call><name>array_del</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>relations</name></name></expr></argument>, <argument><expr><name>relation_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>RG_Matrix</name></type> <name>Graph_GetLabelMatrix</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>label_idx</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>label_idx</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>array_len</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>labels</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// return zero matrix if label_idx is out of range</comment>
	<if_stmt><if>if<condition>(<expr><name>label_idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>Graph_GetZeroMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>RG_Matrix</name></type> <name>m</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>labels</name><index>[<expr><name>label_idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name><name>g</name><operator>-&gt;</operator><name>SynchronizeMatrix</name></name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>m</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>RG_Matrix</name></type> <name>Graph_GetRelationMatrix</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>relation_idx</name></decl></parameter>,
	<parameter><decl><type><name>bool</name></type> <name>transposed</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>relation_idx</name> <operator>==</operator> <name>GRAPH_NO_RELATION</name> <operator>||</operator>
		   <name>relation_idx</name> <operator>&lt;</operator> <call><name>Graph_RelationTypeCount</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RG_Matrix</name></type> <name>m</name> <init>= <expr><name>GrB_NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>relation_idx</name> <operator>==</operator> <name>GRAPH_NO_RELATION</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>m</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>adjacency_matrix</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>m</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>relations</name><index>[<expr><name>relation_idx</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name><name>g</name><operator>-&gt;</operator><name>SynchronizeMatrix</name></name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>transposed</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>m</name> <operator>=</operator> <call><name>RG_Matrix_getTranspose</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>m</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>RG_Matrix</name></type> <name>Graph_GetAdjacencyMatrix</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>bool</name></type> <name>transposed</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>Graph_GetRelationMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>GRAPH_NO_RELATION</name></expr></argument>, <argument><expr><name>transposed</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// returns true if relationship matrix 'r' contains multi-edge entries,</comment>
<comment type="line">// false otherwise</comment>
<function><type><name>bool</name></type> <name>Graph_RelationshipContainsMultiEdge</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>,
	<parameter><decl><type><name>bool</name></type> <name>transpose</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>Graph_RelationTypeCount</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>GrB_Index</name></type> <name>nvals</name></decl>;</decl_stmt>
	<comment type="line">// A relationship matrix contains multi-edge if nvals &lt; number of edges with type r.</comment>
	<decl_stmt><decl><type><name>RG_Matrix</name></type> <name>R</name> <init>= <expr><call><name>Graph_GetRelationMatrix</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>transpose</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RG_Matrix_nvals</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nvals</name></expr></argument>, <argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><call><name>Graph_RelationEdgeCount</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>nvals</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>RG_Matrix</name></type> <name>Graph_GetNodeLabelMatrix</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RG_Matrix</name></type> <name>m</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>node_labels</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name><name>g</name><operator>-&gt;</operator><name>SynchronizeMatrix</name></name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>m</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>RG_Matrix</name></type> <name>Graph_GetZeroMatrix</name>
<parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>RG_Matrix</name></type> <name>z</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>_zero_matrix</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name><name>g</name><operator>-&gt;</operator><name>SynchronizeMatrix</name></name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RG_DEBUG</name></expr></cpp:if>
	<comment type="line">// make sure zero matrix is indeed empty</comment>
	<decl_stmt><decl><type><name>GrB_Index</name></type> <name>nvals</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RG_Matrix_nvals</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nvals</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>nvals</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_Graph_Free</name>
<parameter_list>(
	<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
	<parameter><decl><type><name>bool</name></type> <name>is_full_graph</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// free matrices</comment>
	<decl_stmt><decl><type><name>AttributeSet</name> <modifier>*</modifier></type><name>set</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DataBlockIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>RG_Matrix_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>_zero_matrix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RG_Matrix_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>adjacency_matrix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_Graph_FreeRelationMatrices</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>relations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GraphStatistics_FreeInternals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint32_t</name></type> <name>labelCount</name> <init>= <expr><call><name>array_len</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>labels</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>labelCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RG_Matrix_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>labels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>array_free</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>labels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RG_Matrix_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>node_labels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <ternary><condition><expr><name>is_full_graph</name></expr> ?</condition><then> <expr><call><name>Graph_ScanNodes</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>DataBlock_FullScan</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<while>while<condition>(<expr><operator>(</operator><name>set</name> <operator>=</operator> <operator>(</operator><name>AttributeSet</name> <operator>*</operator><operator>)</operator><call><name>DataBlockIterator_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if<condition>(<expr><operator>*</operator><name>set</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>AttributeSet_Free</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>DataBlockIterator_Free</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <ternary><condition><expr><name>is_full_graph</name></expr> ?</condition><then> <expr><call><name>Graph_ScanEdges</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>DataBlock_FullScan</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>edges</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<while>while<condition>(<expr><operator>(</operator><name>set</name> <operator>=</operator> <call><name>DataBlockIterator_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if<condition>(<expr><operator>*</operator><name>set</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>AttributeSet_Free</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>DataBlockIterator_Free</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="line">// free blocks</comment>
	<expr_stmt><expr><call><name>DataBlock_Free</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DataBlock_Free</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>edges</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>_writelocked</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>Graph_ReleaseLock</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pthread_rwlock_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>_rwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>rm_free</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>Graph_Free</name>
<parameter_list>(
	<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>_Graph_Free</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>Graph_PartialFree</name>
<parameter_list>(
	<parameter><decl><type><name>Graph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>
)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>_Graph_Free</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
