<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" xmlns:omp="http://www.srcML.org/srcML/openmp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_sort.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_sort: sort all vectors in a matrix</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_werk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_transpose.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_ek_slice.h"</cpp:file></cpp:include>

<comment type="line">//  macros:</comment>

<comment type="line">//  GB_SORT (func)      defined as GB_sort_func_TYPE_ascend or _descend,</comment>
<comment type="line">//                      GB_msort_ISO_ascend or _descend,</comment>
<comment type="line">//                      or GB_msort_func_UDT</comment>
<comment type="line">//  GB_TYPE             bool, int8_, ... or GB_void for UDT</comment>

<comment type="line">//  GB_ADDR(A,p)        A+p for builtin, A + p * GB_SIZE otherwise</comment>
<comment type="line">//  GB_SIZE             size of each entry: sizeof (GB_TYPE) for built-in</comment>
<comment type="line">//  GB_GET(x,X,i)       x = (op-&gt;xtype) X [i]</comment>
<comment type="line">//  GB_COPY(A,i,C,k)    A [i] = C [k]</comment>
<comment type="line">//  GB_SWAP(A,i,k)      swap A [i] and A [k]</comment>
<comment type="line">//  GB_LT               compare two entries, x &lt; y</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// macros for all built-in types</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT_UDT</name></cpp:macro>         <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_ADDR</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>        <cpp:value>((A) + (i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_GET</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>A</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_TYPE x = A [i]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_COPY</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>B</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>A [i] = B [j]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SIZE</name></cpp:macro>             <cpp:value>sizeof (GB_TYPE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SWAP</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>{ GB_TYPE t = A [i] ; A [i] = A [j] ; A [j] = t ; }</cpp:value></cpp:define>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// ascending sort for built-in types</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_LT</name><parameter_list>(<parameter><type><name>less</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro>  \
    <cpp:value>less = (((a) &lt; (b)) ? true : (((a) == (b)) ? ((i) &lt; (j)) : false))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>bool</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _ascend_BOOL)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>int8_t</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _ascend_INT8)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>int16_t</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _ascend_INT16)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>int32_t</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _ascend_INT32)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>int64_t</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _ascend_INT64)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>uint8_t</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _ascend_UINT8)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>uint16_t</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _ascend_UINT16)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>uint32_t</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _ascend_UINT32)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>uint64_t</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _ascend_UINT64)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>float</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _ascend_FP32)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>double</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _ascend_FP64)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// descending sort for built-in types</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_LT</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_LT</name><parameter_list>(<parameter><type><name>less</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro>  \
    <cpp:value>less = (((a) &gt; (b)) ? true : (((a) == (b)) ? ((i) &lt; (j)) : false))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>bool</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _descend_BOOL)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>int8_t</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _descend_INT8)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>int16_t</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _descend_INT16)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>int32_t</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _descend_INT32)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>int64_t</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _descend_INT64)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>uint8_t</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _descend_UINT8)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>uint16_t</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _descend_UINT16)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>uint32_t</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _descend_UINT32)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>uint64_t</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _descend_UINT64)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>float</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _descend_FP32)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>double</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _descend_FP64)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// macros for user-defined types and when typecasting is performed </comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_ADDR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_GET</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_COPY</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_SIZE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_SWAP</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_LT</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_ADDR</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>        <cpp:value>((A) + (i) * csize)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_GET</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>A</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_void x [GB_VLA(xsize)] ;                     \
                            fcast (x, GB_ADDR (A, i), csize)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_COPY</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>B</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>memcpy (GB_ADDR (A, i), GB_ADDR (B, j), csize)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SIZE</name></cpp:macro>             <cpp:value>csize</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_TYPE</name></cpp:macro>             <cpp:value>GB_void</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SWAP</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro>                                                      \
<cpp:value>{                                                                           \
    GB_void t [GB_VLA(csize)] ;         <comment type="block">/* declare the scalar t */</comment>          \
    memcpy (t, GB_ADDR (A, i), csize) ; <comment type="block">/* t = A [i] */</comment>                     \
    GB_COPY (A, i, A, j) ;              <comment type="block">/* A [i] = A [j] */</comment>                 \
    memcpy (GB_ADDR (A, j), t, csize) ; <comment type="block">/* A [j] = t */</comment>                     \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_LT</name><parameter_list>(<parameter><type><name>less</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro>                                                 \
<cpp:value>{                                                                           \
    flt (&amp;less, a, b) ;         <comment type="block">/* less = (a &lt; b) */</comment>                        \
    if (!less)                                                              \
    {                                                                       \
        <comment type="block">/* check for equality and tie-break on index */</comment>                     \
        bool more ;                                                         \
        flt (&amp;more, b, a) ;     <comment type="block">/* more = (b &lt; a) */</comment>                        \
        less = (more) ? false : ((i) &lt; (j)) ;                               \
    }                                                                       \
}</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_SORT_UDT</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT_UDT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>GB_EVAL3 (GB(sort_), func, _UDT)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort_template.c"</cpp:file></cpp:include>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_sort</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_FREE_WORKSPACE</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_WORKSPACE</name></cpp:macro>                   \
<cpp:value>{                                           \
    GB_WERK_POP (C_ek_slicing, int64_t) ;   \
    GB_Matrix_free (&amp;T) ;                   \
}</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_FREE_ALL</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_ALL</name></cpp:macro>                         \
<cpp:value>{                                           \
    GB_FREE_WORKSPACE ;                     \
    if (!C_is_NULL) GB_phybix_free (C) ;    \
    GB_phybix_free (P) ;                    \
}</cpp:value></cpp:define>

<comment type="line">// redefine to use the revised GB_FREE_ALL above:</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_static_header.h"</cpp:file></cpp:include>

<function><type><name>GrB_Info</name></type> <name>GB_sort</name>
<parameter_list>(
    <comment type="line">// output:</comment>
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,               <comment type="line">// matrix with sorted vectors on output</comment>
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>P</name></decl></parameter>,               <comment type="line">// matrix with permutations on output</comment>
    <comment type="line">// input:</comment>
    <parameter><decl><type><name>GrB_BinaryOp</name></type> <name>op</name></decl></parameter>,            <comment type="line">// comparator for the sort</comment>
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,               <comment type="line">// matrix to sort</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>A_transpose</name></decl></parameter>,     <comment type="line">// false: sort each row, true: sort each column</comment>
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"A for GB_sort"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_BINARYOP_OK</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"op for GB_sort"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>T</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>GB_Matrix_opaque</name></name></type> <name>T_header</name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>GB_WERK_DECLARE</name> <argument_list>(<argument><expr><name>C_ek_slicing</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GB_GET_NTHREADS_MAX</name> <argument_list>(<argument><expr><name>nthreads_max</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>C_is_NULL</name> <init>= <expr><operator>(</operator><name>C</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>C_is_NULL</name> <operator>&amp;&amp;</operator> <name>P</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// either C, or P, or both must be present</comment>
        <return>return <expr><operator>(</operator><name>GrB_NULL_POINTER</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>GrB_Type</name></type> <name>atype</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Type</name></type> <name>ctype</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>C_is_NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>atype</name></expr> </then><else>: <expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Type</name></type> <name>ptype</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>P</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>GrB_INT64</name></expr> </then><else>: <expr><name><name>P</name><operator>-&gt;</operator><name>type</name></name></expr></else></ternary></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>ztype</name></name> <operator>!=</operator> <name>GrB_BOOL</name> <operator>||</operator> <name><name>op</name><operator>-&gt;</operator><name>xtype</name></name> <operator>!=</operator> <name><name>op</name><operator>-&gt;</operator><name>ytype</name></name> <operator>||</operator> <name>atype</name> <operator>!=</operator> <name>ctype</name>
        <operator>||</operator> <operator>!</operator><operator>(</operator><name>ptype</name> <operator>==</operator> <name>GrB_INT64</name> <operator>||</operator> <name>ptype</name> <operator>==</operator> <name>GrB_UINT64</name><operator>)</operator>
        <operator>||</operator> <operator>!</operator><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name>atype</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>xtype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// op must return bool, and its inputs x and y must have the same type;</comment>
        <comment type="line">// the types of A and C must match exactly; P must be INT64 or UINT64;</comment>
        <comment type="line">// A and C must be typecasted to the input type of the op.</comment>
        <return>return <expr><operator>(</operator><name>GrB_DOMAIN_MISMATCH</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>anrows</name> <init>= <expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>ancols</name> <init>= <expr><call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>C</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>anrows</name> <operator>||</operator> <call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ancols</name><operator>)</operator><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>P</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>anrows</name> <operator>||</operator> <call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ancols</name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// C and P must have the same dimensions as A</comment>
        <return>return <expr><operator>(</operator><name>GrB_DIMENSION_MISMATCH</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>A_iso</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>iso</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>sort_in_place</name> <init>= <expr><operator>(</operator><name>A</name> <operator>==</operator> <name>C</name><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <comment type="line">// free any prior content of C and P</comment>
    <expr_stmt><expr><call><name>GB_phybix_free</name> <argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sort_in_place</name></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><call><name>GB_phybix_free</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// make a copy of A, unless it is aliased with C</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>C_is_NULL</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// C is a temporary matrix, which is freed when done</comment>
        <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T_header</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>C</name> <operator>=</operator> <name>T</name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>A_transpose</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// ensure C is in sparse or hypersparse CSC format</comment>
        <if_stmt><if>if <condition>(<expr><name><name>A</name><operator>-&gt;</operator><name>is_csc</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// A is already CSC</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sort_in_place</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// A = C</comment>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_dup_worker</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// A is CSR but C must be CSC</comment>
            <if_stmt><if>if <condition>(<expr><name>sort_in_place</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// A = A'</comment>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_transpose_in_place</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <comment type="line">// C = A'</comment>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_transpose_cast</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// ensure C is in sparse or hypersparse CSR format</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>A</name><operator>-&gt;</operator><name>is_csc</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// A is already CSR</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sort_in_place</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// A = C</comment>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_dup_worker</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// A is CSC but C must be CSR</comment>
            <if_stmt><if>if <condition>(<expr><name>sort_in_place</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// A = A'</comment>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_transpose_in_place</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <comment type="line">// C = A'</comment>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_transpose_cast</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// ensure C is sparse or hypersparse</comment>
    <if_stmt><if>if <condition>(<expr><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GB_IS_FULL</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_convert_any_to_sparse</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// sort C in place</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GB_Opcode</name></type> <name>opcode</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>opcode</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>acode</name> <init>= <expr><name><name>atype</name><operator>-&gt;</operator><name>code</name></name></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>xtype</name></name> <operator>==</operator> <name>atype</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>ytype</name></name> <operator>==</operator> <name>atype</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>opcode</name> <operator>==</operator> <name>GB_LT_binop_code</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>GB_GT_binop_code</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>acode</name> <operator>&lt;</operator> <name>GB_UDT_code</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// no typecasting, using built-in &lt; or &gt; operators, builtin types</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>GB_LT_binop_code</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// ascending sort</comment>
            <switch>switch <condition>(<expr><name>acode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_BOOL_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_ascend_BOOL</name></expr></argument>   )</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <case>case <expr><name>GB_INT8_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_ascend_INT8</name></expr></argument>   )</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <case>case <expr><name>GB_INT16_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_ascend_INT16</name></expr></argument>  )</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <case>case <expr><name>GB_INT32_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_ascend_INT32</name></expr></argument>  )</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <case>case <expr><name>GB_INT64_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_ascend_INT64</name></expr></argument>  )</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <case>case <expr><name>GB_UINT8_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_ascend_UINT8</name></expr></argument>  )</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_ascend_UINT16</name></expr></argument> )</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_ascend_UINT32</name></expr></argument> )</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_ascend_UINT64</name></expr></argument> )</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <case>case <expr><name>GB_FP32_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_ascend_FP32</name></expr></argument>   )</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <case>case <expr><name>GB_FP64_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_ascend_FP64</name></expr></argument>   )</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <default>default:</default><empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></if>
        <else>else <comment type="line">// opcode == GB_GT_binop_code</comment>
        <block>{<block_content> 
            <comment type="line">// descending sort</comment>
            <switch>switch <condition>(<expr><name>acode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_BOOL_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_descend_BOOL</name></expr></argument>  )</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <case>case <expr><name>GB_INT8_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_descend_INT8</name></expr></argument>  )</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <case>case <expr><name>GB_INT16_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_descend_INT16</name></expr></argument> )</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <case>case <expr><name>GB_INT32_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_descend_INT32</name></expr></argument> )</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <case>case <expr><name>GB_INT64_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_descend_INT64</name></expr></argument> )</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <case>case <expr><name>GB_UINT8_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_descend_UINT8</name></expr></argument> )</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_descend_UINT16</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_descend_UINT32</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_descend_UINT64</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <case>case <expr><name>GB_FP32_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_descend_FP32</name></expr></argument>  )</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <case>case <expr><name>GB_FP64_code</name></expr> :</case> 
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name><argument_list>(<argument><expr><name>sort_matrix_descend_FP64</name></expr></argument>  )</argument_list></call><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <break>break ;</break>
                <default>default:</default><empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></else></if_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// typecasting, user-defined types, or unconventional operators</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><call><name>GB</name> <argument_list>(<argument><expr><name>sort_matrix_UDT</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// constuct the final indices</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>cnz</name> <init>= <expr><call><name>GB_nnz</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>cnvec</name> <init>= <expr><name><name>C</name><operator>-&gt;</operator><name>nvec</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ti</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>P</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// P is not constructed; use C-&gt;i to construct the new indices</comment>
        <expr_stmt><expr><name>Ti</name> <operator>=</operator> <name><name>C</name><operator>-&gt;</operator><name>i</name></name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// allocate P-&gt;i and use it to construct the new indices</comment>
        <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <call><name>GB_MALLOC</name> <argument_list>(<argument><expr><name>cnz</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>P</name><operator>-&gt;</operator><name>i_size</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>P</name><operator>-&gt;</operator><name>i</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// out of memory</comment>
            <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
            <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>Ti</name> <operator>=</operator> <name><name>P</name><operator>-&gt;</operator><name>i</name></name></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>C_nthreads</name></decl>, <decl><type ref="prev"/><name>C_ntasks</name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>GB_SLICE_MATRIX</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Cp</name> <init>= <expr><name><name>C</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>cvlen</name> <init>= <expr><name><name>C</name><operator>-&gt;</operator><name>vlen</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>tid</name></decl> ;</decl_stmt>
    <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>C_nthreads</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>static</omp:expr></omp:argument>,<omp:argument><omp:expr>1</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
    <for>for <control>(<init><expr><name>tid</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>tid</name> <operator>&lt;</operator> <name>C_ntasks</name></expr> ;</condition> <incr><expr><name>tid</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>kfirst</name> <init>= <expr><name><name>kfirst_Cslice</name> <index>[<expr><name>tid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>klast</name>  <init>= <expr><name><name>klast_Cslice</name>  <index>[<expr><name>tid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><name>kfirst</name></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;=</operator> <name>klast</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>pC0</name> <init>= <expr><name><name>Cp</name> <index>[<expr><name>k</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pC_start</name></decl>, <decl><type ref="prev"/><name>pC_end</name></decl> ;</decl_stmt>
            <expr_stmt><expr><call><name>GB_get_pA</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>pC_start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pC_end</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>k</name></expr></argument>,
                <argument><expr><name>kfirst</name></expr></argument>, <argument><expr><name>klast</name></expr></argument>, <argument><expr><name>pstart_Cslice</name></expr></argument>, <argument><expr><name>Cp</name></expr></argument>, <argument><expr><name>cvlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>pC</name> <init>= <expr><name>pC_start</name></expr></init></decl> ;</init> <condition><expr><name>pC</name> <operator>&lt;</operator> <name>pC_end</name></expr> ;</condition> <incr><expr><name>pC</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content> 
                <expr_stmt><expr><name><name>Ti</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>pC</name> <operator>-</operator> <name>pC0</name></expr> ;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// construct P</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>C_is_hyper</name> <init>= <expr><call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>P</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>is_csc</name></name> <operator>=</operator> <name><name>C</name><operator>-&gt;</operator><name>is_csc</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>nvec</name></name> <operator>=</operator> <name><name>C</name><operator>-&gt;</operator><name>nvec</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>=</operator> <name><name>C</name><operator>-&gt;</operator><name>nvec_nonempty</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>iso</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>vlen</name></name> <operator>=</operator> <name><name>C</name><operator>-&gt;</operator><name>vlen</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>vdim</name></name> <operator>=</operator> <name><name>C</name><operator>-&gt;</operator><name>vdim</name></name></expr> ;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>C_is_NULL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// the values of C are not needed.  The indices of C become the</comment>
            <comment type="line">// values of P, Cp becomes Pp, and Ch (if present) becomes Ph.</comment>
            <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name><name>C</name><operator>-&gt;</operator><name>i</name></name></expr> ;</expr_stmt> <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt> <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>x_size</name></name> <operator>=</operator> <name><name>C</name><operator>-&gt;</operator><name>i_size</name></name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name><name>C</name><operator>-&gt;</operator><name>p</name></name></expr> ;</expr_stmt> <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt> <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>p_size</name></name> <operator>=</operator> <name><name>C</name><operator>-&gt;</operator><name>p_size</name></name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name><name>C</name><operator>-&gt;</operator><name>h</name></name></expr> ;</expr_stmt> <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt> <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>h_size</name></name> <operator>=</operator> <name><name>C</name><operator>-&gt;</operator><name>h_size</name></name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>plen</name></name> <operator>=</operator> <name><name>C</name><operator>-&gt;</operator><name>plen</name></name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// C is required on output.  The indices of C are copied and</comment>
            <comment type="line">// become the values of P.  Cp is copied to Pp, and Ch (if present)</comment>
            <comment type="line">// is copied to Ph.</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pplen</name> <init>= <expr><call><name>GB_IMAX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>cnvec</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
            <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>plen</name></name> <operator>=</operator> <name>pplen</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <call><name>GB_MALLOC</name> <argument_list>(<argument><expr><name>cnz</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>P</name><operator>-&gt;</operator><name>x_size</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <comment type="line">// x:OK</comment>
            <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <call><name>GB_MALLOC</name> <argument_list>(<argument><expr><name>pplen</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>P</name><operator>-&gt;</operator><name>p_size</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>C_is_hyper</name></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <call><name>GB_MALLOC</name> <argument_list>(<argument><expr><name>pplen</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>P</name><operator>-&gt;</operator><name>h_size</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>P</name><operator>-&gt;</operator><name>p</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>C_is_hyper</name> <operator>&amp;&amp;</operator> <name><name>P</name><operator>-&gt;</operator><name>h</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// out of memory</comment>
                <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
                <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// copy from C to P</comment>
            <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>i</name></name></expr></argument>, <argument><expr><name>cnz</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><operator>(</operator><name>cnvec</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>C_is_hyper</name></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>cnvec</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>nvals</name></name> <operator>=</operator> <name>cnz</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>GB_MAGIC</name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// finalize the pattern of C</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>C_is_NULL</name> <operator>&amp;&amp;</operator> <name>P</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// copy P-&gt;i into C-&gt;i</comment>
        <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>i</name></name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>i</name></name></expr></argument>, <argument><expr><name>cnz</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free workspace, and comform/return result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><name>GB_FREE_WORKSPACE</name></expr> ;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>C_is_NULL</name></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C output of GB_sort (before conform)"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_conform</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C output of GB_sort"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>P</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><literal type="string">"P output of GB_sort (before conform)"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_conform</name> <argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><literal type="string">"P output of GB_sort"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
