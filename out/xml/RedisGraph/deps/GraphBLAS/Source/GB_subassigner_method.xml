<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_subassigner_method.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_subassigner_method: determine method for GB_subassign</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_subassign.h"</cpp:file></cpp:include>

<function><type><name>int</name></type> <name>GB_subassigner_method</name>           <comment type="line">// return method to use in GB_subassigner</comment>
<parameter_list>(
    <comment type="line">// outputs</comment>
    <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>C_iso_out</name></decl></parameter>,                <comment type="line">// true if C is iso on output</comment>
    <parameter><decl><type><name>GB_void</name> <modifier>*</modifier></type><name>cout</name></decl></parameter>,                  <comment type="line">// iso value of C on output</comment>
    <comment type="line">// inputs</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,             <comment type="line">// input/output matrix for results</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>C_replace</name></decl></parameter>,           <comment type="line">// C matrix descriptor</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>M</name></decl></parameter>,             <comment type="line">// optional mask for C(I,J), unused if NULL</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_comp</name></decl></parameter>,           <comment type="line">// mask descriptor</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_struct</name></decl></parameter>,         <comment type="line">// if true, use the only structure of M</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_BinaryOp</name></type> <name>accum</name></decl></parameter>,       <comment type="line">// optional accum for Z=accum(C(I,J),A)</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,             <comment type="line">// input matrix (NULL for scalar expansion)</comment>
    <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>Ikind</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>Jkind</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>scalar_expansion</name></decl></parameter>,    <comment type="line">// if true, expand scalar to A</comment>
    <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>scalar</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Type</name></type> <name>atype</name></decl></parameter>            <comment type="line">// type of A, or the type of the scalar</comment>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get all properties of C, M, and A required by this function</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_DEBUG</name></cpp:ifdef>
    <comment type="line">// empty_mask: mask not present and complemented.  This condition has</comment>
    <comment type="line">// already handled by GB_assign_prep.</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>empty_mask</name> <init>= <expr><operator>(</operator><name>M</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>Mask_comp</name></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>empty_mask</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// no_mask: mask not present and not complemented</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>no_mask</name> <init>= <expr><operator>(</operator><name>M</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>Mask_comp</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>M_is_A</name> <init>= <expr><operator>(</operator><name>M</name> <operator>==</operator> <name>A</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>M_is_bitmap</name> <init>= <expr><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>A_is_bitmap</name> <init>= <expr><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>A_as_if_full</name> <init>= <expr><call><name>GB_as_if_full</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>anz</name> <init>= <expr><call><name>GB_nnz</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <comment type="line">// these properties of C are not affected by wait(C):</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>C_is_M</name> <init>= <expr><operator>(</operator><name>C</name> <operator>==</operator> <name>M</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Type</name></type> <name>ctype</name> <init>= <expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name></expr></init></decl> ;</decl_stmt>

    <comment type="line">// these properties of C can change after wait(C):</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>C_is_empty</name> <init>= <expr><operator>(</operator><call><name>GB_nnz</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>C_is_bitmap</name> <init>= <expr><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>C_as_if_full</name> <init>= <expr><call><name>GB_as_if_full</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>C_is_full</name> <init>= <expr><call><name>GB_IS_FULL</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine the method to use</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// whole_C_matrix is true if all of C(:,:) is being assigned to</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>whole_C_matrix</name> <init>= <expr><operator>(</operator><name>Ikind</name> <operator>==</operator> <name>GB_ALL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>Jkind</name> <operator>==</operator> <name>GB_ALL</name><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>C_splat_scalar</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>   <comment type="line">// C(:,:) = x</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>C_splat_matrix</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>   <comment type="line">// C(:,:) = A</comment>

    <if_stmt><if>if <condition>(<expr><name>whole_C_matrix</name> <operator>&amp;&amp;</operator> <name>no_mask</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>accum</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// C(:,:) = x or A:  whole matrix assignment with no mask</comment>
        <if_stmt><if>if <condition>(<expr><name>scalar_expansion</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// Method 21: C(:,:) = x</comment>
            <expr_stmt><expr><name>C_splat_scalar</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// Method 24: C(:,:) = A</comment>
            <expr_stmt><expr><name>C_splat_matrix</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// check if C is competely dense:  all entries present and no pending work.</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>C_dense_update</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>C_as_if_full</name> <operator>&amp;&amp;</operator> <name>whole_C_matrix</name> <operator>&amp;&amp;</operator> <name>no_mask</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>accum</name> <operator>!=</operator> <name>NULL</name><operator>)</operator>
            <operator>&amp;&amp;</operator> <operator>(</operator><name>ctype</name> <operator>==</operator> <name><name>accum</name><operator>-&gt;</operator><name>ztype</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>ctype</name> <operator>==</operator> <name><name>accum</name><operator>-&gt;</operator><name>xtype</name></name><operator>)</operator></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// C(:,:) += x or A, where C is dense, no typecasting of C</comment>
        <expr_stmt><expr><name>C_dense_update</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// GB_assign_prep has already disabled C_replace if no mask present</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><name>no_mask</name></expr></argument>, <argument><expr><operator>!</operator><name>C_replace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// if C is empty, C_replace is effectively false and already disabled</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><name>C_is_empty</name></expr></argument>, <argument><expr><operator>!</operator><name>C_replace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// simple_mask: C(I,J)&lt;M&gt; = ... ; or C(I,J)&lt;M&gt; += ...</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>simple_mask</name> <init>= <expr><operator>(</operator><operator>!</operator><name>C_replace</name> <operator>&amp;&amp;</operator> <name>M</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>Mask_comp</name><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <comment type="line">// C_Mask_scalar: C(I,J)&lt;M&gt; = scalar or += scalar</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>C_Mask_scalar</name> <init>= <expr><operator>(</operator><name>scalar_expansion</name> <operator>&amp;&amp;</operator> <name>simple_mask</name><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <comment type="line">// C_Mask_matrix:  C(I,J)&lt;M&gt; = A or += A</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>C_Mask_matrix</name> <init>= <expr><operator>(</operator><operator>!</operator><name>scalar_expansion</name> <operator>&amp;&amp;</operator> <name>simple_mask</name><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>S_Extraction</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>method_06d</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>method_25</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>C_splat_scalar</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// Method 21: C(:,:) = x where x is a scalar; C becomes dense</comment>
        <expr_stmt><expr><name>S_Extraction</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>C_splat_matrix</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// Method 24: C(:,:) = A</comment>
        <expr_stmt><expr><name>S_Extraction</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>C_dense_update</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// Methods 22 and 23: C(:,:) += x or A where C is dense</comment>
        <expr_stmt><expr><name>S_Extraction</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>C_Mask_scalar</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// Method 05*, or 07: C(I,J)&lt;M&gt; = or += scalar; C_replace false</comment>
        <expr_stmt><expr><name>S_Extraction</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>C_Mask_matrix</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// C(I,J)&lt;M&gt; = A or += A</comment>
        <if_stmt><if>if <condition>(<expr><name>accum</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// Method 08n: C(I,J)&lt;M&gt; += A, no S.  Cannot use M or A as bitmap.</comment>
            <comment type="line">// Method 08s: C(I,J)&lt;M&gt; += A, with S.  Can use M or A as bitmap.</comment>
            <comment type="line">// if S_Extraction is true, Method 08s is used (with S).</comment>
            <comment type="line">// Method 08n is not used if any matrix is bitmap.</comment>
            <comment type="line">// If C is bitmap, GB_bitmap_assign_M_accum is used instead.</comment>
            <expr_stmt><expr><name>S_Extraction</name> <operator>=</operator> <name>M_is_bitmap</name> <operator>||</operator> <name>A_is_bitmap</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// C(I,J)&lt;M&gt; = A ;  use 06s (with S) or 06n (without S)</comment>
            <comment type="line">// method 06s (with S) is faster when nnz (A) &lt; nnz (M).</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>C_as_if_full</name> <operator>||</operator> <name>C_is_bitmap</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>whole_C_matrix</name> <operator>&amp;&amp;</operator> <name>M_is_A</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Method 06d: C&lt;A&gt; = A</comment>
                <expr_stmt><expr><name>method_06d</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                <expr_stmt><expr><name>S_Extraction</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>C_is_empty</name> <operator>&amp;&amp;</operator> <name>whole_C_matrix</name> <operator>&amp;&amp;</operator> <name>Mask_struct</name> <operator>&amp;&amp;</operator>
                <operator>(</operator><name>A_as_if_full</name> <operator>||</operator> <name>A_is_bitmap</name><operator>)</operator></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Method 25: C&lt;M,s&gt; = A, where M is structural, A is</comment>
                <comment type="line">// dense, and C starts out empty.  The pattern of C will be the</comment>
                <comment type="line">// same as M, and the subassign method is extremely simple.</comment>
                <expr_stmt><expr><name>method_25</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                <expr_stmt><expr><name>S_Extraction</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <comment type="line">// Method 06n (no S) or Method 06s (with S):</comment>
                <comment type="line">// Method 06n is not used if M or A are bitmap.  If M and A are</comment>
                <comment type="line">// aliased and Method 06d is not used, then 06s is used instead</comment>
                <comment type="line">// of 06n since M==A implies nnz(A) == nnz(M).</comment>
                <expr_stmt><expr><name>S_Extraction</name> <operator>=</operator> <name>anz</name> <operator>&lt;</operator> <call><name>GB_nnz</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>M_is_bitmap</name> <operator>||</operator> <name>A_is_bitmap</name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <comment type="line">// all other methods require S</comment>
        <expr_stmt><expr><name>S_Extraction</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//==========================================================================</comment>
    <comment type="line">// submatrix assignment C(I,J)&lt;M&gt; = accum (C(I,J),A): meta-algorithm</comment>
    <comment type="line">//==========================================================================</comment>

    <comment type="line">// There are up to 128 combinations of options, but not all must be</comment>
    <comment type="line">// implemented, because they are either identical to another method</comment>
    <comment type="line">// (C_replace is effectively false if M=NULL and Mask_comp=false), or they</comment>
    <comment type="line">// are not used (the last option, whether or not S is constructed, is</comment>
    <comment type="line">// determined here; it is not a user input).  The first 5 options are</comment>
    <comment type="line">// determined by the input.  The table below has been pruned to remove</comment>
    <comment type="line">// combinations that are not used, or equivalent to other entries in the</comment>
    <comment type="line">// table.  Only 22 unique combinations of the 128 combinations are needed,</comment>
    <comment type="line">// with additional special cases when C(:,:) is dense.</comment>

    <comment type="line">//      M           present or NULL</comment>
    <comment type="line">//      Mask_comp   true or false</comment>
    <comment type="line">//      Mask_struct structural or valued mask</comment>
    <comment type="line">//      C_replace   true or false</comment>
    <comment type="line">//      accum       present or NULL</comment>
    <comment type="line">//      A           scalar (x) or matrix (A)</comment>
    <comment type="line">//      S           constructed or not </comment>

    <comment type="line">// C(I,J)&lt;(M,comp,repl)&gt; ( = , += ) (A, scalar), (with or without S);</comment>
    <comment type="line">// I and J can be anything for any of these methods (":", colon, or list).</comment>

    <comment type="line">// See the "No work to do..." comment above:</comment>
    <comment type="line">// If M is not present, Mask_comp true, C_replace false: no work to do.</comment>
    <comment type="line">// If M is not present, Mask_comp true, C_replace true: use Method 00</comment>
    <comment type="line">// If M is not present, Mask_comp false:  C_replace is now false.</comment>

        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   cmp rpl acc A   S       method: action</comment>
        <comment type="line">//  =====================       ==============</comment>

        <comment type="line">//  -   -   x   -   -   -       21:  C = x, no S, C anything</comment>
        <comment type="line">//  -   -   x   -   A   -       24:  C = A, no S, C and A anything</comment>
        <comment type="line">//  -   -   -   +   -   -       22:  C += x, no S, C dense</comment>
        <comment type="line">//  -   -   -   +   A   -       23:  C += A, no S, C dense</comment>

        <comment type="line">//  -   -   -   -   -   S       01:  C(I,J) = x, with S</comment>
        <comment type="line">//  -   -   -   -   A   S       02:  C(I,J) = A, with S</comment>
        <comment type="line">//  -   -   -   +   -   S       03:  C(I,J) += x, with S</comment>
        <comment type="line">//  -   -   -   +   A   S       04:  C(I,J) += A, with S</comment>
        <comment type="line">//  -   -   r                        uses methods 01, 02, 03, 04</comment>
        <comment type="line">//  -   c   -                        no work to do</comment>
        <comment type="line">//  -   c   r           S       00:  C(I,J)&lt;!,repl&gt; = empty, with S</comment>

        <comment type="line">//  M   -   -   -   -   -       05d: C&lt;M&gt; = x, no S, C dense</comment>
        <comment type="line">//  M   -   -   -   -   -       05e: C&lt;M,s&gt; = x, no S, C empty</comment>
        <comment type="line">//  M   -   -   -   -   -       05f: C&lt;C,s&gt; = x, no S, C == M</comment>
        <comment type="line">//  M   -   -   -   -   -       05:  C(I,J)&lt;M&gt; = x, no S</comment>
        <comment type="line">//  A   -   -   -   A   -       06d: C&lt;A&gt; = A, no S, C dense</comment>
        <comment type="line">//  M   -   -   -   A   -       25:  C&lt;M,s&gt; = A, A dense, C empty</comment>
        <comment type="line">//  M   -   -   -   A   -       06n: C(I,J)&lt;M&gt; = A, no S</comment>
        <comment type="line">//  M   -   -   -   A   S       06s: C(I,J)&lt;M&gt; = A, with S</comment>
        <comment type="line">//  M   -   -   +   -   -       07:  C(I,J)&lt;M&gt; += x, no S</comment>
        <comment type="line">//  M   -   -   +   A   -       08n: C(I,J)&lt;M&gt; += A, no S</comment>
        <comment type="line">//  M   -   -   +   A   -       08s: C(I,J)&lt;M&gt; += A, with S</comment>
        <comment type="line">//  M   -   r   -   -   S       09:  C(I,J)&lt;M,repl&gt; = x, with S</comment>
        <comment type="line">//  M   -   r   -   A   S       10:  C(I,J)&lt;M,repl&gt; = A, with S</comment>
        <comment type="line">//  M   -   r   +   -   S       11:  C(I,J)&lt;M,repl&gt; += x, with S</comment>
        <comment type="line">//  M   -   r   +   A   S       12:  C(I,J)&lt;M,repl&gt; += A, with S</comment>

        <comment type="line">//  M   c   -   -   -   S       13:  C(I,J)&lt;!M&gt; = x, with S</comment>
        <comment type="line">//  M   c   -   -   A   S       14:  C(I,J)&lt;!M&gt; = A, with S</comment>
        <comment type="line">//  M   c   -   +   -   S       15:  C(I,J)&lt;!M&gt; += x, with S</comment>
        <comment type="line">//  M   c   -   +   A   S       16:  C(I,J)&lt;!M&gt; += A, with S</comment>
        <comment type="line">//  M   c   r   -   -   S       17:  C(I,J)&lt;!M,repl&gt; = x, with S</comment>
        <comment type="line">//  M   c   r   -   A   S       18:  C(I,J)&lt;!M,repl&gt; = A, with S</comment>
        <comment type="line">//  M   c   r   +   -   S       19:  C(I,J)&lt;!M,repl&gt; += x, with S</comment>
        <comment type="line">//  M   c   r   +   A   S       20:  C(I,J)&lt;!M,repl&gt; += A, with S</comment>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// FUTURE::: 8 simpler cases when I and J are ":" (S not needed):</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">//  M   -   -   -   A   -       06x: C(:,:)&lt;M&gt; = A</comment>
        <comment type="line">//  M   -   -   +   A   -       08x: C(:,:)&lt;M&gt; += A</comment>
        <comment type="line">//  M   -   r   -   A   -       10x: C(:,:)&lt;M,repl&gt; = A</comment>
        <comment type="line">//  M   -   r   +   A   -       12x: C(:,:)&lt;M,repl&gt; += A</comment>
        <comment type="line">//  M   c   -   -   A   -       14x: C(:,:)&lt;!M&gt; = A</comment>
        <comment type="line">//  M   c   -   +   A   -       16x: C(:,:)&lt;!M&gt; += A</comment>
        <comment type="line">//  M   c   r   -   A   -       18x: C(:,:)&lt;!M,repl&gt; = A</comment>
        <comment type="line">//  M   c   r   +   A   -       20x: C(:,:)&lt;!M,repl&gt; += A</comment>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// FUTURE::: C&lt;C,s&gt; += x   C == M, update all values, C_replace ignored</comment>
        <comment type="line">// FUTURE::: C&lt;C,s&gt; = A    C == M, A dense, C_replace ignored</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

    <comment type="line">// For the single case C(I,J)&lt;M&gt;=A, two methods can be used: 06n and 06s.</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>subassign_method</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>C_splat_scalar</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C = x where x is a scalar; C becomes full</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   cmp rpl acc A   S       method: action</comment>
        <comment type="line">//  =====================       ==============</comment>

        <comment type="line">//  -   -   x   -   -   -       21:  C = x, no S, C anything</comment>

        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>whole_C_matrix</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>           <comment type="line">// C(:,:) is modified</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>M</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>                <comment type="line">// no mask present</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>accum</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>            <comment type="line">// accum is not present</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>C_replace</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>               <comment type="line">// C_replace is effectively false</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>S_Extraction</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>            <comment type="line">// S is not used</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>scalar_expansion</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>         <comment type="line">// x is a scalar</comment>

        <comment type="line">// Method 21: C = x where x is a scalar; C becomes full</comment>
        <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_21</name></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>C_splat_matrix</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C = A</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   cmp rpl acc A   S       method: action</comment>
        <comment type="line">//  =====================       ==============</comment>

        <comment type="line">//  -   -   x   -   A   -       24:  C = A, no S, C and A anything</comment>

        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>whole_C_matrix</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>           <comment type="line">// C(:,:) is modified</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>M</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>                <comment type="line">// no mask present</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>accum</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>            <comment type="line">// accum is not present</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>C_replace</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>               <comment type="line">// C_replace is effectively false</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>S_Extraction</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>            <comment type="line">// S is not used</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>scalar_expansion</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>        <comment type="line">// A is a matrix</comment>

        <comment type="line">// Method 24: C = A</comment>
        <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_24</name></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>C_dense_update</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C += A or x where C is dense or full (and becomes full)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   cmp rpl acc A   S       method: action</comment>
        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  -   -   -   +   -   -       22:  C += x, no S, C dense</comment>
        <comment type="line">//  -   -   -   +   A   -       23:  C += A, no S, C dense</comment>

        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C_as_if_full</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>             <comment type="line">// C is dense</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>whole_C_matrix</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>           <comment type="line">// C(:,:) is modified</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>M</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>                <comment type="line">// no mask present</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>accum</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>            <comment type="line">// accum is present</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>C_replace</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>               <comment type="line">// C_replace is false</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>S_Extraction</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>            <comment type="line">// S is not used</comment>

        <if_stmt><if>if <condition>(<expr><name>scalar_expansion</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// Method 22: C(:,:) += x where C is dense or full</comment>
            <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_22</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// Method 23: C(:,:) += A where C is dense or full</comment>
            <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_23</name></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>C_Mask_scalar</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C(I,J)&lt;M&gt; = scalar or +=scalar</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   cmp rpl acc A   S       method: action</comment>
        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   -   -   -   -   -       05d: C(:,:)&lt;M&gt; = x, no S, C dense</comment>
        <comment type="line">//  M   -   -   -   -   -       05e: C(:,:)&lt;M,s&gt; = x, no S, C empty</comment>
        <comment type="line">//  M   -   -   -   -   -       05f: C(:,:)&lt;C,s&gt; = x, no S, C == M</comment>
        <comment type="line">//  M   -   -   -   -   -       05:  C(I,J)&lt;M&gt; = x, no S</comment>
        <comment type="line">//  M   -   -   +   -   -       07:  C(I,J)&lt;M&gt; += x, no S</comment>

        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>scalar_expansion</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>         <comment type="line">// A is a scalar</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>M</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>Mask_comp</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>  <comment type="line">// mask M present, not compl.</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>C_replace</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>               <comment type="line">// C_replace is false</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>S_Extraction</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>            <comment type="line">// S is not used</comment>

        <if_stmt><if>if <condition>(<expr><name>accum</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>C_is_M</name> <operator>&amp;&amp;</operator> <name>whole_C_matrix</name> <operator>&amp;&amp;</operator> <name>Mask_struct</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Method 05f: C(:,:)&lt;C,s&gt; = scalar ; no S ; C == M ; M struct</comment>
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_05f</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>C_is_empty</name> <operator>&amp;&amp;</operator> <name>whole_C_matrix</name> <operator>&amp;&amp;</operator> <name>Mask_struct</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Method 05e: C(:,:)&lt;M,s&gt; = scalar ; no S; C empty, M struct</comment>
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_05e</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>C_as_if_full</name> <operator>&amp;&amp;</operator> <name>whole_C_matrix</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Method 05d: C(:,:)&lt;M&gt; = scalar ; no S; C is dense or full;</comment>
                <comment type="line">// C becomes full.</comment>
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_05d</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <comment type="line">// Method 05: C(I,J)&lt;M&gt; = scalar ; no S</comment>
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_05</name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// Method 07: C(I,J)&lt;M&gt; += scalar ; no S</comment>
            <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_07</name></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>C_Mask_matrix</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C(I,J)&lt;M&gt; = A or += A</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   cmp rpl acc A   S       method: action</comment>
        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   -   -   +   A   -       08n:  C(I,J)&lt;M&gt; += A, no S</comment>
        <comment type="line">//  M   -   -   +   A   -       08s:  C(I,J)&lt;M&gt; += A, with S</comment>
        <comment type="line">//  A   -   -   -   A   -       06d: C&lt;A&gt; = A, no S, C dense</comment>
        <comment type="line">//  M   -   x   -   A   -       25:  C&lt;M,s&gt; = A, A dense, C empty</comment>
        <comment type="line">//  M   -   -   -   A   -       06n: C(I,J)&lt;M&gt; = A, no S</comment>
        <comment type="line">//  M   -   -   -   A   S       06s: C(I,J)&lt;M&gt; = A, with S</comment>

        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>scalar_expansion</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>        <comment type="line">// A is a matrix</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>M</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>Mask_comp</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>  <comment type="line">// mask M present, not compl.</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>C_replace</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>accum</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>S_Extraction</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Method 08s: C(I,J)&lt;M&gt; += A ; with S</comment>
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_08s</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <comment type="line">// Method 08n: C(I,J)&lt;M&gt; += A ; no S</comment>
                <comment type="line">// No matrix can be bitmap.</comment>
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_08n</name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>method_06d</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// Method 06d: C(:,:)&lt;A&gt; = A ; no S, C dense or full;</comment>
            <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_06d</name></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>(</operator><name>C_as_if_full</name> <operator>||</operator> <name>C_is_bitmap</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>whole_C_matrix</name> <operator>&amp;&amp;</operator> <name>M</name> <operator>==</operator> <name>A</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>method_25</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// Method 25: C&lt;M,struct&gt; = A, C empty; A is dense, full, or bitmap</comment>
            <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_25</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><name>S_Extraction</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// Method 06n: C(I,J)&lt;M&gt; = A ; no S</comment>
            <comment type="line">// If M or A are bitmap, this method is not used;</comment>
            <comment type="line">// 06s is used instead.</comment>
            <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_06n</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// Method 06s: C(I,J)&lt;M&gt; = A ; using S</comment>
            <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_06s</name></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>M</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// assignment using S_Extraction method, no mask M</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   cmp rpl acc A   S       method: action</comment>
        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  -   -   -   -   -   S       01:  C(I,J) = x, with S</comment>
        <comment type="line">//  -   -   -   -   A   S       02:  C(I,J) = A, with S</comment>
        <comment type="line">//  -   -   -   +   -   S       03:  C(I,J) += x, with S</comment>
        <comment type="line">//  -   -   -   +   A   S       04:  C(I,J) += A, with S</comment>

        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>Mask_comp</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>C_replace</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>S_Extraction</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>            <comment type="line">// S is used</comment>

        <if_stmt><if>if <condition>(<expr><name>scalar_expansion</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>accum</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Method 01: C(I,J) = scalar ; using S</comment>
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_01</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <comment type="line">// Method 03: C(I,J) += scalar ; using S</comment>
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_03</name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>accum</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Method 02: C(I,J) = A ; using S</comment>
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_02</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <comment type="line">// Method 04: C(I,J) += A ; using S</comment>
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_04</name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>scalar_expansion</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C(I,J)&lt;#M&gt; = scalar or += scalar ; using S</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   cmp rpl acc A   S       method: action</comment>
        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   -   r   -   -   S       09:  C(I,J)&lt;M,repl&gt; = x, with S</comment>
        <comment type="line">//  M   -   r   +   -   S       11:  C(I,J)&lt;M,repl&gt; += x, with S</comment>
        <comment type="line">//  M   c   -   -   -   S       13:  C(I,J)&lt;!M&gt; = x, with S</comment>
        <comment type="line">//  M   c   -   +   -   S       15:  C(I,J)&lt;!M&gt; += x, with S</comment>
        <comment type="line">//  M   c   r   -   -   S       17:  C(I,J)&lt;!M,repl&gt; = x, with S</comment>
        <comment type="line">//  M   c   r   +   -   S       19:  C(I,J)&lt;!M,repl&gt; += x, with S</comment>

        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>C_Mask_scalar</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C_replace</name> <operator>||</operator> <name>Mask_comp</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>S_Extraction</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>            <comment type="line">// S is used</comment>

        <if_stmt><if>if <condition>(<expr><name>accum</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Mask_comp</name> <operator>&amp;&amp;</operator> <name>C_replace</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Method 17: C(I,J)&lt;!M,repl&gt; = scalar ; using S</comment>
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_17</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>Mask_comp</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Method 13: C(I,J)&lt;!M&gt; = scalar ; using S</comment>
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_13</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else <comment type="line">// if (C_replace)</comment>
            <block>{<block_content> 
                <comment type="line">// Method 09: C(I,J)&lt;M,repl&gt; = scalar ; using S</comment>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C_replace</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_09</name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Mask_comp</name> <operator>&amp;&amp;</operator> <name>C_replace</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Method 19: C(I,J)&lt;!M,repl&gt; += scalar ; using S</comment>
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_19</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>Mask_comp</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Method 15: C(I,J)&lt;!M&gt; += scalar ; using S</comment>
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_15</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else <comment type="line">// if (C_replace)</comment>
            <block>{<block_content> 
                <comment type="line">// Method 11: C(I,J)&lt;M,repl&gt; += scalar ; using S</comment>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C_replace</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_11</name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>

        <comment type="line">//------------------------------------------------------------------</comment>
        <comment type="line">// C(I,J)&lt;#M&gt; = A or += A ; using S</comment>
        <comment type="line">//------------------------------------------------------------------</comment>

        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   cmp rpl acc A   S       method: action</comment>
        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   -   r   -   A   S       10:  C(I,J)&lt;M,repl&gt; = A, with S</comment>
        <comment type="line">//  M   -   r   +   A   S       12:  C(I,J)&lt;M,repl&gt; += A, with S</comment>
        <comment type="line">//  M   c   -   -   A   S       14:  C(I,J)&lt;!M&gt; = A, with S</comment>
        <comment type="line">//  M   c   -   +   A   S       16:  C(I,J)&lt;!M&gt; += A, with S</comment>
        <comment type="line">//  M   c   r   -   A   S       18:  C(I,J)&lt;!M,repl&gt; = A, with S</comment>
        <comment type="line">//  M   c   r   +   A   S       20:  C(I,J)&lt;!M,repl&gt; += A, with S</comment>

        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Mask_comp</name> <operator>||</operator> <name>C_replace</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>S_Extraction</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>            <comment type="line">// S is used</comment>

        <if_stmt><if>if <condition>(<expr><name>accum</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Mask_comp</name> <operator>&amp;&amp;</operator> <name>C_replace</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Method 18: C(I,J)&lt;!M,repl&gt; = A ; using S</comment>
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_18</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>Mask_comp</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Method 14: C(I,J)&lt;!M&gt; = A ; using S</comment>
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_14</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else <comment type="line">// if (C_replace)</comment>
            <block>{<block_content> 
                <comment type="line">// Method 10: C(I,J)&lt;M,repl&gt; = A ; using S</comment>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C_replace</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_10</name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Mask_comp</name> <operator>&amp;&amp;</operator> <name>C_replace</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Method 20: C(I,J)&lt;!M,repl&gt; += A ; using S</comment>
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_20</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>Mask_comp</name></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_16</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else <comment type="line">// if (C_replace)</comment>
            <block>{<block_content> 
                <comment type="line">// Method 12: C(I,J)&lt;M,repl&gt; += A ; using S</comment>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C_replace</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_12</name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine the iso property of C on output</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// For scalar expansion, or if A is iso on input, then C might be iso on</comment>
    <comment type="line">// output.  Otherwise, C is always non-iso on output.  Skip this if cout or</comment>
    <comment type="line">// C_iso_out are NULL, since that means they have already been computed.</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>iso_check</name> <init>= <expr><operator>(</operator><name>cout</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>C_iso_out</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>iso_check</name></expr>)</condition>
    <block>{<block_content>

        <decl_stmt><decl><type><name>bool</name></type> <name>A_iso</name> <init>= <expr><name>scalar_expansion</name>           <comment type="line">// all scalars are iso</comment>
            <operator>||</operator> <operator>(</operator><name>A</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>A</name><operator>-&gt;</operator><name>iso</name></name><operator>)</operator>            <comment type="line">// or A is iso</comment>
            <operator>||</operator> <operator>(</operator><name>anz</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>A_is_bitmap</name><operator>)</operator></expr></init></decl> ;</decl_stmt>     <comment type="line">// or A is effectively iso</comment>
        <if_stmt><if>if <condition>(<expr><name>A_iso</name></expr>)</condition>
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// cout = tentative iso value of C on output</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>ccode</name> <init>= <expr><name><name>ctype</name><operator>-&gt;</operator><name>code</name></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type>       <name>csize</name> <init>= <expr><name><name>ctype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>acode</name> <init>= <expr><name><name>atype</name><operator>-&gt;</operator><name>code</name></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type>       <name>asize</name> <init>= <expr><name><name>atype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>

            <comment type="line">// cout = (ctype) (scalar or A-&gt;x)</comment>
            <expr_stmt><expr><call><name>GB_cast_scalar</name> <argument_list>(<argument><expr><name>cout</name></expr></argument>, <argument><expr><name>ccode</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>scalar_expansion</name><operator>)</operator></expr> ?</condition><then> <expr><name>scalar</name></expr> </then><else>: <expr><name><name>A</name><operator>-&gt;</operator><name>x</name></name></expr></else></ternary></expr></argument>,
                <argument><expr><name>acode</name></expr></argument>, <argument><expr><name>asize</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>c_ok</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>C_is_empty</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// C is empty on input; note that C-&gt;iso might also be true,</comment>
                <comment type="line">// but this is ignored.</comment>
                <expr_stmt><expr><name>c_ok</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>C</name><operator>-&gt;</operator><name>iso</name></name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// C is iso on input; compare cout and C-&gt;x</comment>
                <expr_stmt><expr><name>c_ok</name> <operator>=</operator> <operator>(</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>cout</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>csize</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// apply the accum, if present, and compare its result with cout</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <decl_stmt><decl><type><name>bool</name></type> <name>accum_ok</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>c_ok</name> <operator>&amp;&amp;</operator> <name>accum</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>C</name><operator>-&gt;</operator><name>iso</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>C_is_empty</name></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// If C is empty, the accum is not applied.</comment>
                    <expr_stmt><expr><name>accum_ok</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content> 
                    <comment type="line">// C is iso and not empty; check the result of accum</comment>
                    <decl_stmt><decl><type><name>GxB_binary_function</name></type> <name>faccum</name> <init>= <expr><name><name>accum</name><operator>-&gt;</operator><name>binop_function</name></name></expr></init></decl> ;</decl_stmt>

                    <decl_stmt><decl><type><name>size_t</name></type> <name>xsize</name> <init>= <expr><name><name>accum</name><operator>-&gt;</operator><name>xtype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>size_t</name></type> <name>ysize</name> <init>= <expr><name><name>accum</name><operator>-&gt;</operator><name>ytype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>size_t</name></type> <name>zsize</name> <init>= <expr><name><name>accum</name><operator>-&gt;</operator><name>ztype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>

                    <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>xcode</name> <init>= <expr><name><name>accum</name><operator>-&gt;</operator><name>xtype</name><operator>-&gt;</operator><name>code</name></name></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>ycode</name> <init>= <expr><name><name>accum</name><operator>-&gt;</operator><name>ytype</name><operator>-&gt;</operator><name>code</name></name></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>zcode</name> <init>= <expr><name><name>accum</name><operator>-&gt;</operator><name>ztype</name><operator>-&gt;</operator><name>code</name></name></expr></init></decl> ;</decl_stmt>

                    <comment type="line">// x = (xtype) C-&gt;x</comment>
                    <decl_stmt><decl><type><name>GB_void</name></type> <name><name>x</name> <index>[<expr><call><name>GB_VLA</name><argument_list>(<argument><expr><name>xsize</name></expr></argument>)</argument_list></call></expr>]</index></name></decl> ;</decl_stmt>
                    <expr_stmt><expr><call><name>GB_cast_scalar</name> <argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>xcode</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>ccode</name></expr></argument>, <argument><expr><name>csize</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

                    <comment type="line">// y = (ytype) (scalar or A-&gt;x)</comment>
                    <decl_stmt><decl><type><name>GB_void</name></type> <name><name>y</name> <index>[<expr><call><name>GB_VLA</name><argument_list>(<argument><expr><name>ysize</name></expr></argument>)</argument_list></call></expr>]</index></name></decl> ;</decl_stmt>
                    <expr_stmt><expr><call><name>GB_cast_scalar</name> <argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>ycode</name></expr></argument>,
                        <argument><expr><ternary><condition><expr><operator>(</operator><name>scalar_expansion</name><operator>)</operator></expr> ?</condition><then> <expr><name>scalar</name></expr> </then><else>: <expr><name><name>A</name><operator>-&gt;</operator><name>x</name></name></expr></else></ternary></expr></argument>, <argument><expr><name>acode</name></expr></argument>, <argument><expr><name>asize</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

                    <comment type="line">// z = x + y</comment>
                    <decl_stmt><decl><type><name>GB_void</name></type> <name><name>z</name> <index>[<expr><call><name>GB_VLA</name><argument_list>(<argument><expr><name>zsize</name></expr></argument>)</argument_list></call></expr>]</index></name></decl> ;</decl_stmt>
                    <expr_stmt><expr><call><name>faccum</name> <argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

                    <comment type="line">// c = (ctype) z</comment>
                    <decl_stmt><decl><type><name>GB_void</name></type> <name><name>c</name> <index>[<expr><call><name>GB_VLA</name><argument_list>(<argument><expr><name>csize</name></expr></argument>)</argument_list></call></expr>]</index></name></decl> ;</decl_stmt>
                    <expr_stmt><expr><call><name>GB_cast_scalar</name> <argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ccode</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>zcode</name></expr></argument>, <argument><expr><name>zsize</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

                    <comment type="line">// compare c and cout</comment>
                    <expr_stmt><expr><name>accum_ok</name> <operator>=</operator> <operator>(</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>cout</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>csize</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <switch>switch <condition>(<expr><name>subassign_method</name></expr>)</condition>
            <block>{<block_content>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// C_out is iso if C_in empty, or C_in iso and cin == scalar</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <case>case <expr><name>GB_SUBASSIGN_METHOD_01</name></expr> :</case>   <comment type="line">// C(I,J) = scalar</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_05</name></expr> :</case>   <comment type="line">// C(I,J)&lt;M&gt; = scalar</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_13</name></expr> :</case>   <comment type="line">// C(I,J)&lt;!M&gt; = scalar</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_05d</name></expr> :</case>  <comment type="line">// C(:,:)&lt;M&gt; = scalar ; C dense</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_09</name></expr> :</case>   <comment type="line">// C(I,J)&lt;M,replace&gt; = scalar</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_17</name></expr> :</case>   <comment type="line">// C(I,J)&lt;!M,replace&gt; = scalar</comment>
                    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>C_iso_out</name><operator>)</operator> <operator>=</operator> <name>c_ok</name></expr> ;</expr_stmt>
                    <break>break ;</break>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// C_out is iso if C_in empty, or C_in iso and cin == a</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <case>case <expr><name>GB_SUBASSIGN_METHOD_02</name></expr> :</case>   <comment type="line">// C(I,J) = A</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_06s</name></expr> :</case>  <comment type="line">// C(I,J)&lt;M&gt; = A ; with S</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_14</name></expr> :</case>   <comment type="line">// C(I,J)&lt;!M&gt; = A</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_10</name></expr> :</case>   <comment type="line">// C(I,J)&lt;M,replace&gt; = A</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_18</name></expr> :</case>   <comment type="line">// C(I,J)&lt;!M,replace&gt; = A</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_06d</name></expr> :</case>  <comment type="line">// C(:,:)&lt;A&gt; = A ; C is dense</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_06n</name></expr> :</case>  <comment type="line">// C(I,J)&lt;M&gt; = A ; no S</comment>
                    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>C_iso_out</name><operator>)</operator> <operator>=</operator> <name>c_ok</name></expr> ;</expr_stmt>
                    <break>break ;</break>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// C_out is always iso, regardless of C_in</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <case>case <expr><name>GB_SUBASSIGN_METHOD_21</name></expr> :</case>   <comment type="line">// C(:,:) = scalar</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_05e</name></expr> :</case>  <comment type="line">// C(:,:)&lt;M,struct&gt;=x ; C empty</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_05f</name></expr> :</case>  <comment type="line">// C(:,:)&lt;C,struct&gt;=scalar</comment>
                    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>C_iso_out</name><operator>)</operator> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>       <comment type="line">// scalars are always iso</comment>
                    <break>break ;</break>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// C_out is iso if A is iso, regardless of C_in</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <case>case <expr><name>GB_SUBASSIGN_METHOD_24</name></expr> :</case>   <comment type="line">// C = A</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_25</name></expr> :</case>   <comment type="line">// C(:,:)&lt;M,str&gt; = A ; C empty</comment>
                    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>C_iso_out</name><operator>)</operator> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>       <comment type="line">// A is iso (see above)</comment>
                    <break>break ;</break>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// C_out is iso if C_in empty, or C_in iso and cin == cin+scalar</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <case>case <expr><name>GB_SUBASSIGN_METHOD_03</name></expr> :</case>   <comment type="line">// C(I,J) += scalar</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_07</name></expr> :</case>   <comment type="line">// C(I,J)&lt;M&gt; += scalar</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_15</name></expr> :</case>   <comment type="line">// C(I,J)&lt;!M&gt; += scalar</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_22</name></expr> :</case>   <comment type="line">// C += scalar ; C is dense</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_11</name></expr> :</case>   <comment type="line">// C(I,J)&lt;M,replace&gt; += scalar</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_19</name></expr> :</case>   <comment type="line">// C(I,J)&lt;!M,replace&gt; += scalar</comment>
                    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>C_iso_out</name><operator>)</operator> <operator>=</operator> <name>accum_ok</name></expr> ;</expr_stmt>
                    <break>break ;</break>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// C_out is iso if C_in empty, or C_in and A iso and cin==cin+a</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <case>case <expr><name>GB_SUBASSIGN_METHOD_12</name></expr> :</case>   <comment type="line">// C(I,J)&lt;M,replace&gt; += A</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_20</name></expr> :</case>   <comment type="line">// C(I,J)&lt;!M,replace&gt; += A</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_04</name></expr> :</case>   <comment type="line">// C(I,J) += A</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_08s</name></expr> :</case>  <comment type="line">// C(I,J)&lt;M&gt; += A, with S</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_16</name></expr> :</case>   <comment type="line">// C(I,J)&lt;!M&gt; += A </comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_23</name></expr> :</case>   <comment type="line">// C += A ; C is dense</comment>
                <case>case <expr><name>GB_SUBASSIGN_METHOD_08n</name></expr> :</case>  <comment type="line">// C(I,J)&lt;M&gt; += A, no S</comment>
                    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>C_iso_out</name><operator>)</operator> <operator>=</operator> <name>accum_ok</name></expr> ;</expr_stmt>
                    <break>break ;</break>

                <default>default :</default><empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// A is non-iso, so C is non-iso on output, and cout is not</comment>
            <comment type="line">// computed</comment>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>C_iso_out</name><operator>)</operator> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine if the subassign method can handle this case for bitmaps</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_USE_BITMAP_IF</name><parameter_list>(<parameter><type><name>condition</name></type></parameter>)</parameter_list></cpp:macro> \
        <cpp:value>if (condition) subassign_method = GB_SUBASSIGN_METHOD_BITMAP ;</cpp:value></cpp:define>

    <switch>switch <condition>(<expr><name>subassign_method</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// scalar assignent methods</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_01</name></expr> :</case>   <comment type="line">// C(I,J) = scalar</comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_03</name></expr> :</case>   <comment type="line">// C(I,J) += scalar</comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_05</name></expr> :</case>   <comment type="line">// C(I,J)&lt;M&gt; = scalar</comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_07</name></expr> :</case>   <comment type="line">// C(I,J)&lt;M&gt; += scalar</comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_13</name></expr> :</case>   <comment type="line">// C(I,J)&lt;!M&gt; = scalar</comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_15</name></expr> :</case>   <comment type="line">// C(I,J)&lt;!M&gt; += scalar</comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_21</name></expr> :</case>   <comment type="line">// C(:,:) = scalar</comment>
            <comment type="line">// M can have any sparsity structure, including bitmap</comment>
            <expr_stmt><expr><call><name>GB_USE_BITMAP_IF</name> <argument_list>(<argument><expr><name>C_is_bitmap</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_05d</name></expr> :</case>  <comment type="line">// C(:,:)&lt;M&gt; = scalar ; C is dense</comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_05e</name></expr> :</case>  <comment type="line">// C(:,:)&lt;M,struct&gt; = scalar ; C empty</comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_05f</name></expr> :</case>  <comment type="line">// C(:,:)&lt;C,struct&gt; = scalar</comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_22</name></expr> :</case>   <comment type="line">// C += scalar ; C is dense</comment>
            <comment type="line">// C and M can have any sparsity pattern, including bitmap</comment>
            <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_09</name></expr> :</case>   <comment type="line">// C(I,J)&lt;M,replace&gt; = scalar</comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_11</name></expr> :</case>   <comment type="line">// C(I,J)&lt;M,replace&gt; += scalar</comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_17</name></expr> :</case>   <comment type="line">// C(I,J)&lt;!M,replace&gt; = scalar</comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_19</name></expr> :</case>   <comment type="line">// C(I,J)&lt;!M,replace&gt; += scalar</comment>
            <comment type="line">// M can have any sparsity structure, including bitmap</comment>
            <expr_stmt><expr><call><name>GB_USE_BITMAP_IF</name> <argument_list>(<argument><expr><name>C_is_bitmap</name> <operator>||</operator> <name>C_is_full</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// matrix assignent methods</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// GB_accum_mask may use any of these methods, with I and J as GB_ALL.</comment>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_02</name></expr> :</case>   <comment type="line">// C(I,J) = A</comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_06s</name></expr> :</case>  <comment type="line">// C(I,J)&lt;M&gt; = A ; with S</comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_14</name></expr> :</case>   <comment type="line">// C(I,J)&lt;!M&gt; = A</comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_10</name></expr> :</case>   <comment type="line">// C(I,J)&lt;M,replace&gt; = A</comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_18</name></expr> :</case>   <comment type="line">// C(I,J)&lt;!M,replace&gt; = A</comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_12</name></expr> :</case>   <comment type="line">// C(I,J)&lt;M,replace&gt; += A</comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_20</name></expr> :</case>   <comment type="line">// C(I,J)&lt;!M,replace&gt; += A</comment>
            <comment type="line">// M can have any sparsity structure, including bitmap</comment>
            <expr_stmt><expr><call><name>GB_USE_BITMAP_IF</name> <argument_list>(<argument><expr><name>C_is_bitmap</name> <operator>||</operator> <name>C_is_full</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_04</name></expr> :</case>   <comment type="line">// C(I,J) += A</comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_08s</name></expr> :</case>  <comment type="line">// C(I,J)&lt;M&gt; += A, with S</comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_16</name></expr> :</case>   <comment type="line">// C(I,J)&lt;!M&gt; += A </comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_24</name></expr> :</case>   <comment type="line">// C = A</comment>
            <comment type="line">// M can have any sparsity structure, including bitmap</comment>
            <expr_stmt><expr><call><name>GB_USE_BITMAP_IF</name> <argument_list>(<argument><expr><name>C_is_bitmap</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_06d</name></expr> :</case>  <comment type="line">// C(:,:)&lt;A&gt; = A ; C is dense</comment>
        <case>case <expr><name>GB_SUBASSIGN_METHOD_23</name></expr> :</case>   <comment type="line">// C += A ; C is dense</comment>
            <comment type="line">// C, M, and A can have any sparsity structure, including bitmap</comment>
            <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_25</name></expr> :</case>   <comment type="line">// C(:,:)&lt;M,struct&gt; = A ; C empty</comment>
            <comment type="line">// C, M, and A can have any sparsity structure, including bitmap,</comment>
            <comment type="line">// but if M is bitmap or full, use bitmap assignment instead.</comment>
            <expr_stmt><expr><call><name>GB_USE_BITMAP_IF</name> <argument_list>(<argument><expr><name>M_is_bitmap</name> <operator>||</operator> <call><name>GB_IS_FULL</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_06n</name></expr> :</case>  <comment type="line">// C(I,J)&lt;M&gt; = A ; no S</comment>
            <comment type="line">// If M or A are bitmap, Method 06s is used instead of 06n.</comment>
            <expr_stmt><expr><call><name>GB_USE_BITMAP_IF</name> <argument_list>(<argument><expr><name>C_is_bitmap</name> <operator>||</operator> <name>C_is_full</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>M_is_bitmap</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>A_is_bitmap</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_08n</name></expr> :</case>  <comment type="line">// C(I,J)&lt;M&gt; += A, no S</comment>
            <comment type="line">// Method 08s is used instead of 08n if M or A are bitmap.</comment>
            <expr_stmt><expr><call><name>GB_USE_BITMAP_IF</name> <argument_list>(<argument><expr><name>C_is_bitmap</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>M_is_bitmap</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>A_is_bitmap</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <break>break ;</break>

        <comment type="line">// case GB_SUBASSIGN_METHOD_BITMAP:</comment>
        <default>default :</default><empty_stmt>;</empty_stmt>
            <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_BITMAP</name></expr> ;</expr_stmt>
    </block_content>}</block></switch>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// return result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <return>return <expr><operator>(</operator><name>subassign_method</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
