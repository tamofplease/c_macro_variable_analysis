<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_AxB_colscale.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_AxB_colscale: C = A*D where D is diagonal</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_mxm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_binop.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_apply.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_ek_slice.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_stringify.h"</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GBCUDA_DEV</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_binop__include.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_unused.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_WORKSPACE</name></cpp:macro>                   \
<cpp:value>{                                           \
    GB_WERK_POP (A_ek_slicing, int64_t) ;   \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_ALL</name></cpp:macro>                 \
<cpp:value>{                                   \
    GB_FREE_WORKSPACE ;             \
    GB_phybix_free (C) ;            \
}</cpp:value></cpp:define>

<function><type><name>GrB_Info</name></type> <name>GB_AxB_colscale</name>            <comment type="line">// C = A*D, column scale with diagonal D</comment>
<parameter_list>(
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,                   <comment type="line">// output matrix, static header</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,             <comment type="line">// input matrix</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>D</name></decl></parameter>,             <comment type="line">// diagonal input matrix</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Semiring</name></type> <name>semiring</name></decl></parameter>,    <comment type="line">// semiring that defines C=A*D</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>flipxy</name></decl></parameter>,              <comment type="line">// if true, do z=fmult(b,a) vs fmult(a,b)</comment>
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>static_header</name></name> <operator>||</operator> <name>GBNSTATIC</name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"A for colscale A*D"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>D</name></expr></argument>, <argument><expr><literal type="string">"D for colscale A*D"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_JUMBLED</name> <argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_SEMIRING_OK</name> <argument_list>(<argument><expr><name>semiring</name></expr></argument>, <argument><expr><literal type="string">"semiring for numeric A*D"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>vdim</name></name> <operator>==</operator> <name><name>D</name><operator>-&gt;</operator><name>vlen</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_is_diagonal</name> <argument_list>(<argument><expr><name>D</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>        <comment type="line">// TODO: ok for now</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_IS_FULL</name> <argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_WERK_DECLARE</name> <argument_list>(<argument><expr><name>A_ek_slicing</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(%s=%s*%s) "</literal></expr></argument>,
        <argument><expr><call><name>GB_sparsity_char_matrix</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>,    <comment type="line">// C has the sparsity structure of A</comment>
        <argument><expr><call><name>GB_sparsity_char_matrix</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>GB_sparsity_char_matrix</name> <argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get the semiring operators</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_BinaryOp</name></type> <name>mult</name> <init>= <expr><name><name>semiring</name><operator>-&gt;</operator><name>multiply</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Type</name></type> <name>ztype</name> <init>= <expr><name><name>mult</name><operator>-&gt;</operator><name>ztype</name></name></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>ztype</name> <operator>==</operator> <name><name>semiring</name><operator>-&gt;</operator><name>add</name><operator>-&gt;</operator><name>op</name><operator>-&gt;</operator><name>ztype</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>GB_Opcode</name></type> <name>opcode</name> <init>= <expr><name><name>mult</name><operator>-&gt;</operator><name>opcode</name></name></expr></init></decl> ;</decl_stmt>
    <comment type="line">// GB_reduce_to_vector does not use GB_AxB_colscale:</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>mult</name><operator>-&gt;</operator><name>binop_function</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>opcode</name> <operator>==</operator> <name>GB_FIRST_binop_code</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>GB_SECOND_binop_code</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine if C is iso (ignore the monoid since it isn't used)</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>size_t</name></type> <name>zsize</name> <init>= <expr><name><name>ztype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_void</name></type> <name><name>cscalar</name> <index>[<expr><call><name>GB_VLA</name><argument_list>(<argument><expr><name>zsize</name></expr></argument>)</argument_list></call></expr>]</index></name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>C_iso</name> <init>= <expr><call><name>GB_iso_AxB</name> <argument_list>(<argument><expr><name>cscalar</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>D</name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>vdim</name></name></expr></argument>, <argument><expr><name>semiring</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_DEBUGIFY_DEFN</name></cpp:ifdef>
    <expr_stmt><expr><call><name>GB_debugify_mxm</name> <argument_list>(<argument><expr><name>C_iso</name></expr></argument>, <argument><expr><call><name>GB_sparsity</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ztype</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
        <argument><expr><name>semiring</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>D</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// copy the pattern of A into C</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// allocate C-&gt;x but do not initialize it</comment>
    <comment type="line">// set C-&gt;iso = C_iso   OK</comment>
    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_dup_worker</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>C_iso</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ztype</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>GB_void</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Cx</name> <init>= <expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// C = A*D, column scale, compute numerical values</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><call><name>GB_OPCODE_IS_POSITIONAL</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// apply a positional operator: convert C=A*D to C=op(A)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// determine unary operator to compute C=A*D</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>flipxy</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <decl_stmt><decl><type><name>GrB_UnaryOp</name></type> <name>op</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>ztype</name> <operator>==</operator> <name>GrB_INT64</name></expr>)</condition>
        <block>{<block_content>
            <switch>switch <condition>(<expr><name>opcode</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// first_op(A,D) becomes position_op(A)</comment>
                <case>case <expr><name>GB_FIRSTI_binop_code</name></expr>   :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONI_INT64</name></expr> ;</expr_stmt> <break>break;</break>
                <case>case <expr><name>GB_FIRSTJ_binop_code</name></expr>   :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONJ_INT64</name></expr> ;</expr_stmt> <break>break;</break>
                <case>case <expr><name>GB_FIRSTI1_binop_code</name></expr>  :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONI1_INT64</name></expr>;</expr_stmt> <break>break;</break>
                <case>case <expr><name>GB_FIRSTJ1_binop_code</name></expr>  :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONJ1_INT64</name></expr>;</expr_stmt> <break>break;</break>
                <comment type="line">// second_op(A,D) becomes position_j(A)</comment>
                <case>case <expr><name>GB_SECONDI_binop_code</name></expr>  :</case> 
                <case>case <expr><name>GB_SECONDJ_binop_code</name></expr>  :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONJ_INT64</name></expr> ;</expr_stmt> <break>break;</break>
                <case>case <expr><name>GB_SECONDI1_binop_code</name></expr> :</case> 
                <case>case <expr><name>GB_SECONDJ1_binop_code</name></expr> :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONJ1_INT64</name></expr>;</expr_stmt> <break>break;</break>
                <default>default:</default>  <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <switch>switch <condition>(<expr><name>opcode</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// first_op(A,D) becomes position_op(A)</comment>
                <case>case <expr><name>GB_FIRSTI_binop_code</name></expr>   :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONI_INT32</name></expr> ;</expr_stmt> <break>break;</break>
                <case>case <expr><name>GB_FIRSTJ_binop_code</name></expr>   :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONJ_INT32</name></expr> ;</expr_stmt> <break>break;</break>
                <case>case <expr><name>GB_FIRSTI1_binop_code</name></expr>  :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONI1_INT32</name></expr>;</expr_stmt> <break>break;</break>
                <case>case <expr><name>GB_FIRSTJ1_binop_code</name></expr>  :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONJ1_INT32</name></expr>;</expr_stmt> <break>break;</break>
                <comment type="line">// second_op(A,D) becomes position_j(A)</comment>
                <case>case <expr><name>GB_SECONDI_binop_code</name></expr>  :</case> 
                <case>case <expr><name>GB_SECONDJ_binop_code</name></expr>  :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONJ_INT32</name></expr> ;</expr_stmt> <break>break;</break>
                <case>case <expr><name>GB_SECONDI1_binop_code</name></expr> :</case> 
                <case>case <expr><name>GB_SECONDJ1_binop_code</name></expr> :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONJ1_INT32</name></expr>;</expr_stmt> <break>break;</break>
                <default>default:</default>  <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_apply_op</name> <argument_list>(<argument><expr><name>Cx</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>GB_NON_ISO</name></expr></argument>,
            <argument><expr><operator>(</operator><name>GB_Operator</name><operator>)</operator> <name>op</name></expr></argument>,   <comment type="line">// positional op</comment>
            <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"colscale positional: C = A*D output"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>C_iso</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C is iso; pattern already computed above</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(iso colscale) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>Cx</name></expr></argument>, <argument><expr><name>cscalar</name></expr></argument>, <argument><expr><name>zsize</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C is non iso</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// determine if the values are accessed</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><name>bool</name></type> <name>op_is_first</name>  <init>= <expr><operator>(</operator><name>opcode</name> <operator>==</operator> <name>GB_FIRST_binop_code</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>op_is_second</name> <init>= <expr><operator>(</operator><name>opcode</name> <operator>==</operator> <name>GB_SECOND_binop_code</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>op_is_pair</name>   <init>= <expr><operator>(</operator><name>opcode</name> <operator>==</operator> <name>GB_PAIR_binop_code</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>A_is_pattern</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>D_is_pattern</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>op_is_pair</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>flipxy</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// z = fmult (b,a) will be computed</comment>
            <expr_stmt><expr><name>A_is_pattern</name> <operator>=</operator> <name>op_is_first</name>  <operator>||</operator> <name>op_is_pair</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>D_is_pattern</name> <operator>=</operator> <name>op_is_second</name> <operator>||</operator> <name>op_is_pair</name></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><operator>!</operator><name>A_is_pattern</name></expr></argument>,
                <argument><expr><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>mult</name><operator>-&gt;</operator><name>ytype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><operator>!</operator><name>D_is_pattern</name></expr></argument>,
                <argument><expr><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name><name>D</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>mult</name><operator>-&gt;</operator><name>xtype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// z = fmult (a,b) will be computed</comment>
            <expr_stmt><expr><name>A_is_pattern</name> <operator>=</operator> <name>op_is_second</name> <operator>||</operator> <name>op_is_pair</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>D_is_pattern</name> <operator>=</operator> <name>op_is_first</name>  <operator>||</operator> <name>op_is_pair</name></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><operator>!</operator><name>A_is_pattern</name></expr></argument>,
                <argument><expr><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>mult</name><operator>-&gt;</operator><name>xtype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><operator>!</operator><name>D_is_pattern</name></expr></argument>,
                <argument><expr><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name><name>D</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>mult</name><operator>-&gt;</operator><name>ytype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// determine the number of threads to use</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><call><name>GB_GET_NTHREADS_MAX</name> <argument_list>(<argument><expr><name>nthreads_max</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// slice the entries for each task</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><name>int</name></type> <name>A_nthreads</name></decl>, <decl><type ref="prev"/><name>A_ntasks</name></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>GB_SLICE_MATRIX</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>

        <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GBCUDA_DEV</name></cpp:ifndef>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// define the worker for the switch factory</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_AxD</name><parameter_list>(<parameter><type><name>mult</name></type></parameter>,<parameter><type><name>xname</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GB (_AxD_ ## mult ## xname)</cpp:value></cpp:define>

            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BINOP_WORKER</name><parameter_list>(<parameter><type><name>mult</name></type></parameter>,<parameter><type><name>xname</name></type></parameter>)</parameter_list></cpp:macro>                             \
            <cpp:value>{                                                               \
                info = GB_AxD(mult,xname) (C, A, D,                         \
                    A_ek_slicing, A_ntasks, A_nthreads) ;                   \
                done = (info != GrB_NO_VALUE) ;                             \
            }                                                               \
            break ;</cpp:value></cpp:define>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// launch the switch factory</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>xcode</name></decl>, <decl><type ref="prev"/><name>ycode</name></decl>, <decl><type ref="prev"/><name>zcode</name></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>GB_binop_builtin</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>A_is_pattern</name></expr></argument>, <argument><expr><name><name>D</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>D_is_pattern</name></expr></argument>,
                <argument><expr><name>mult</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opcode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xcode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ycode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zcode</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// C=A*D, colscale with built-in operator</comment>
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BINOP_IS_SEMIRING_MULTIPLIER</name></cpp:macro></cpp:define>
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_NO_PAIR</name></cpp:macro></cpp:define>
                <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_binop_factory.c"</cpp:file></cpp:include>
                <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_BINOP_IS_SEMIRING_MULTIPLIER</name></cpp:undef>
            </block_content>}</block></if></if_stmt>

        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition>
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// C = A*D, column scale, with typecasting or user-defined operator</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// get operators, functions, workspace, contents of A, D, and C</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <expr_stmt><expr><call><name>GB_BURBLE_MATRIX</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"(generic C=A*D colscale) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <decl_stmt><decl><type><name>GxB_binary_function</name></type> <name>fmult</name> <init>= <expr><name><name>mult</name><operator>-&gt;</operator><name>binop_function</name></name></expr></init></decl> ;</decl_stmt>

            <decl_stmt><decl><type><name>size_t</name></type> <name>csize</name> <init>= <expr><name><name>C</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>asize</name> <init>= <expr><ternary><condition><expr><name>A_is_pattern</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>A</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>size</name></name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>dsize</name> <init>= <expr><ternary><condition><expr><name>D_is_pattern</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>D</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>size</name></name></expr></else></ternary></expr></init></decl> ;</decl_stmt>

            <decl_stmt><decl><type><name>size_t</name></type> <name>xsize</name> <init>= <expr><name><name>mult</name><operator>-&gt;</operator><name>xtype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>ysize</name> <init>= <expr><name><name>mult</name><operator>-&gt;</operator><name>ytype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>

            <comment type="line">// scalar workspace: because of typecasting, the x/y types need not</comment>
            <comment type="line">// be the same as the size of the A and D types.</comment>
            <comment type="line">// flipxy false: aij = (xtype) A(i,j) and djj = (ytype) D(j,j)</comment>
            <comment type="line">// flipxy true:  aij = (ytype) A(i,j) and djj = (xtype) D(j,j)</comment>
            <decl_stmt><decl><type><name>size_t</name></type> <name>aij_size</name> <init>= <expr><ternary><condition><expr><name>flipxy</name></expr> ?</condition><then> <expr><name>ysize</name></expr> </then><else>: <expr><name>xsize</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>djj_size</name> <init>= <expr><ternary><condition><expr><name>flipxy</name></expr> ?</condition><then> <expr><name>xsize</name></expr> </then><else>: <expr><name>ysize</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>

            <decl_stmt><decl><type><name>GB_cast_function</name></type> <name>cast_A</name></decl>, <decl><type ref="prev"/><name>cast_D</name></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>flipxy</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// A is typecasted to y, and D is typecasted to x</comment>
                <expr_stmt><expr><name>cast_A</name> <operator>=</operator> <ternary><condition><expr><name>A_is_pattern</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
                         <expr><call><name>GB_cast_factory</name> <argument_list>(<argument><expr><name><name>mult</name><operator>-&gt;</operator><name>ytype</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
                <expr_stmt><expr><name>cast_D</name> <operator>=</operator> <ternary><condition><expr><name>D_is_pattern</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
                         <expr><call><name>GB_cast_factory</name> <argument_list>(<argument><expr><name><name>mult</name><operator>-&gt;</operator><name>xtype</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>D</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <comment type="line">// A is typecasted to x, and D is typecasted to y</comment>
                <expr_stmt><expr><name>cast_A</name> <operator>=</operator> <ternary><condition><expr><name>A_is_pattern</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
                         <expr><call><name>GB_cast_factory</name> <argument_list>(<argument><expr><name><name>mult</name><operator>-&gt;</operator><name>xtype</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
                <expr_stmt><expr><name>cast_D</name> <operator>=</operator> <ternary><condition><expr><name>D_is_pattern</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
                         <expr><call><name>GB_cast_factory</name> <argument_list>(<argument><expr><name><name>mult</name><operator>-&gt;</operator><name>ytype</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>D</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// C = A*D via function pointers, and typecasting</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <comment type="line">// aij = A(i,j), located in Ax [pA]</comment>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_A_IS_PATTERN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_GETA</name><parameter_list>(<parameter><type><name>aij</name></type></parameter>,<parameter><type><name>Ax</name></type></parameter>,<parameter><type><name>pA</name></type></parameter>,<parameter><type><name>A_iso</name></type></parameter>)</parameter_list></cpp:macro>                            \
                <cpp:value>GB_void aij [GB_VLA(aij_size)] ;                        \
                if (!A_is_pattern)                                      \
                {                                                       \
                    cast_A (aij, Ax +(A_iso ? 0:(pA)*asize), asize) ;   \
                }</cpp:value></cpp:define>

            <comment type="line">// dji = D(j,j), located in Dx [j]</comment>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_B_IS_PATTERN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_GETB</name><parameter_list>(<parameter><type><name>djj</name></type></parameter>,<parameter><type><name>Dx</name></type></parameter>,<parameter><type><name>j</name></type></parameter>,<parameter><type><name>D_iso</name></type></parameter>)</parameter_list></cpp:macro>                             \
                <cpp:value>GB_void djj [GB_VLA(djj_size)] ;                        \
                if (!D_is_pattern)                                      \
                {                                                       \
                    cast_D (djj, Dx +(D_iso ? 0:(j)*dsize), dsize) ;    \
                }</cpp:value></cpp:define>

            <comment type="line">// address of Cx [p]</comment>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CX</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Cx +((p)*csize)</cpp:value></cpp:define>

            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_ATYPE</name></cpp:macro> <cpp:value>GB_void</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BTYPE</name></cpp:macro> <cpp:value>GB_void</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CTYPE</name></cpp:macro> <cpp:value>GB_void</cpp:value></cpp:define>

            <comment type="line">// no vectorization</comment>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_PRAGMA_SIMD_VECTORIZE</name></cpp:macro> <cpp:value>;</cpp:value></cpp:define>

            <if_stmt><if>if <condition>(<expr><name>flipxy</name></expr>)</condition>
            <block>{<block_content> 
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BINOP</name><parameter_list>(<parameter><type><name>z</name></type></parameter>,<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fmult (z,y,x)</cpp:value></cpp:define>
                <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_colscale_template.c"</cpp:file></cpp:include>
                <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_BINOP</name></cpp:undef>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BINOP</name><parameter_list>(<parameter><type><name>z</name></type></parameter>,<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fmult (z,x,y)</cpp:value></cpp:define>
                <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_colscale_template.c"</cpp:file></cpp:include>
                <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_BINOP</name></cpp:undef>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free workspace and return result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"colscale: C = A*D output"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><name>GB_FREE_WORKSPACE</name></expr> ;</expr_stmt>
    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
