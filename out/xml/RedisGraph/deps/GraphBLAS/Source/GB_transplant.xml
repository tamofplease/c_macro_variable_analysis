<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_transplant.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_transplant: replace contents of one matrix with another</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// Transplant A into C, and then free A.  If any part of A is shallow, or if A</comment>
<comment type="line">// must be typecasted, a deep copy is made into C.  Prior content of C is</comment>
<comment type="line">// ignored.  Then A is freed, except for any shallow components of A which are</comment>
<comment type="line">// left untouched (after unlinking them from A).  The resulting matrix C is not</comment>
<comment type="line">// shallow.  This function is not user-callable.  The new type of C (ctype)</comment>
<comment type="line">// must be compatible with A-&gt;type.</comment>

<comment type="line">// C-&gt;hyper_switch, C-&gt;bitmap_switch, C-&gt;sparsity_control, and C-&gt;static_header</comment>
<comment type="line">// are not modified by the transplant.</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_ALL</name></cpp:macro>                 \
<cpp:value>{                                   \
    GB_phybix_free (C) ;            \
    GB_Matrix_free (Ahandle) ;      \
}</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB.h"</cpp:file></cpp:include>

<function><type><name>GrB_Info</name></type> <name>GB_transplant</name>          <comment type="line">// transplant one matrix into another</comment>
<parameter_list>(
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,               <comment type="line">// output matrix to overwrite with A</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Type</name></type> <name>ctype</name></decl></parameter>,       <comment type="line">// new type of C</comment>
    <parameter><decl><type><name>GrB_Matrix</name> <modifier>*</modifier></type><name>Ahandle</name></decl></parameter>,        <comment type="line">// input matrix to copy from and free</comment>
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Ahandle</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>A</name> <init>= <expr><operator>*</operator><name>Ahandle</name></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_aliased</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"A before transplant"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_ZOMBIES_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>    <comment type="line">// zombies in A transplanted into C</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>    <comment type="line">// if A is jumbled, then C is jumbled</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_PENDING_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>    <comment type="line">// pending tuples n A transplanted into C</comment>

    <comment type="line">// C is about to be cleared, any pending work is OK</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_TYPE_OK</name> <argument_list>(<argument><expr><name>ctype</name></expr></argument>, <argument><expr><literal type="string">"new type for C"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_PENDING_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_ZOMBIES_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// the ctype and A-&gt;type must be compatible.  C-&gt;type is ignored</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name>ctype</name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>avdim</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>vdim</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>avlen</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>vlen</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>A_iso</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>iso</name></name></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine the number of threads to use</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>anvals</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>nvals</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>anz</name> <init>= <expr><call><name>GB_nnz_held</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>anvec</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>nvec</name></name></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>GB_GET_NTHREADS_MAX</name> <argument_list>(<argument><expr><name>nthreads_max</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nthreads</name> <init>= <expr><call><name>GB_nthreads</name> <argument_list>(<argument><expr><name>anz</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// clear C and transplant the type, size, format, and pending tuples</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// free all content of C</comment>
    <expr_stmt><expr><call><name>GB_phybix_free</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_JUMBLED</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// It is now safe to change the type and dimension of C</comment>
    <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>ctype</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>is_csc</name></name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>is_csc</name></name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>vlen</name></name> <operator>=</operator> <name>avlen</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>vdim</name></name> <operator>=</operator> <name>avdim</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>nvec_nonempty</name></name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>iso</name></name> <operator>=</operator> <name>A_iso</name></expr> ;</expr_stmt>        <comment type="line">// OK:transplant</comment>

    <comment type="line">// C is not shallow, and has no content yet</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_is_shallow</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>p</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>h</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>b</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>i</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>Y</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>Pending</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// determine if C should be constructed as a bitmap or full matrix</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>C_is_hyper</name> <init>= <expr><call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>C_is_bitmap</name> <init>= <expr><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>C_is_full</name> <init>= <expr><call><name>GB_as_if_full</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>C_is_bitmap</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>C_is_hyper</name></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// transplant A-&gt;Y into C-&gt;Y</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>C_is_hyper</name> <operator>&amp;&amp;</operator> <name><name>A</name><operator>-&gt;</operator><name>Y</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>A</name><operator>-&gt;</operator><name>Y_shallow</name></name> <operator>||</operator> <call><name>GB_is_shallow</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// A-&gt;Y is shallow, so create a deep copy for C</comment>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_dup</name> <argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>Y</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// A-&gt;Y is not shallow, so transplant it into C</comment>
            <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>Y</name></name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>Y</name></name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>Y</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>Y_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>Y_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// transplant pending tuples from A to C</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>Pending</name></name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>Pending</name></name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>Pending</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// allocate new space for C-&gt;b, C-&gt;i, and C-&gt;x if A is shallow</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// C-&gt;b is allocated only if A-&gt;b exists and is shallow.</comment>
    <comment type="line">// C-&gt;i is not allocated if C is full or bitmap.</comment>
    <comment type="line">// C-&gt;x is allocated if A-&gt;x is shallow, or if the type is changing</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>allocate_Cb</name> <init>= <expr><operator>(</operator><name><name>A</name><operator>-&gt;</operator><name>b_shallow</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>C_is_bitmap</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>allocate_Ci</name> <init>= <expr><operator>(</operator><name><name>A</name><operator>-&gt;</operator><name>i_shallow</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><operator>(</operator><name>C_is_full</name> <operator>||</operator> <name>C_is_bitmap</name><operator>)</operator><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>allocate_Cx</name> <init>= <expr><operator>(</operator><name><name>A</name><operator>-&gt;</operator><name>x_shallow</name></name> <operator>||</operator> <name><name>C</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name><name>A</name><operator>-&gt;</operator><name>type</name></name><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <comment type="line">// allocate new components if needed</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>ok</name> <init>= <expr><name>true</name></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>allocate_Cb</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// allocate new C-&gt;b component</comment>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <call><name>GB_MALLOC</name> <argument_list>(<argument><expr><name>anz</name></expr></argument>, <argument><expr><name>int8_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>b_size</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>ok</name> <operator>=</operator> <name>ok</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>b</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>allocate_Ci</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// allocate new C-&gt;i component</comment>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <call><name>GB_MALLOC</name> <argument_list>(<argument><expr><name>anz</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>i_size</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>ok</name> <operator>=</operator> <name>ok</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>i</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>allocate_Cx</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// allocate new C-&gt;x component; use calloc if C is bitmap</comment>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <call><name>GB_XALLOC</name> <argument_list>(<argument><expr><name>C_is_bitmap</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>, <argument><expr><name>anz</name></expr></argument>, <comment type="line">// x:OK</comment>
            <argument><expr><name><name>C</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>x_size</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>ok</name> <operator>=</operator> <name>ok</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>x</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// out of memory</comment>
        <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
        <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// transplant or copy A-&gt;x numerical values</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>ASSERT_TYPE_OK</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><literal type="string">"target C-&gt;type for values"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_TYPE_OK</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><literal type="string">"source A-&gt;type for values"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// types match</comment>
        <if_stmt><if>if <condition>(<expr><name><name>A</name><operator>-&gt;</operator><name>x_shallow</name></name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// A is shallow so make a deep copy; no typecast needed</comment>
            <expr_stmt><expr><call><name>GB_cast_matrix</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// OK to move pointers instead</comment>
            <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>x</name></name></expr> ;</expr_stmt> <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>x_size</name></name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>x_size</name></name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// types differ, must typecast from A to C.</comment>
        <expr_stmt><expr><call><name>GB_cast_matrix</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>A</name><operator>-&gt;</operator><name>x_shallow</name></name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><call><name>GB_FREE</name> <argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>A</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>x_size</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>x</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>     <comment type="line">// has been freed or removed</comment>
    <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>x_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>x_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// transplant A-&gt;p vector pointers and A-&gt;h hyperlist</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>C_is_full</name> <operator>||</operator> <name>C_is_bitmap</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C is full or bitmap: C-&gt;p and C-&gt;h do not exist</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>plen</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>nvec</name></name> <operator>=</operator> <name>avdim</name></expr> ;</expr_stmt>

        <comment type="line">// free any non-shallow A-&gt;p and A-&gt;h content of A</comment>
        <expr_stmt><expr><call><name>GB_phy_free</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>A</name><operator>-&gt;</operator><name>p_shallow</name></name> <operator>||</operator> <name><name>A</name><operator>-&gt;</operator><name>h_shallow</name></name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// A-&gt;p or A-&gt;h are shallow copies another matrix; make a deep copy</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><name>int</name></type> <name>nth</name> <init>= <expr><call><name>GB_nthreads</name> <argument_list>(<argument><expr><name>anvec</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>A</name><operator>-&gt;</operator><name>h</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// A is hypersparse, create new C-&gt;p and C-&gt;h</comment>
            <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>plen</name></name> <operator>=</operator> <call><name>GB_IMAX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>anvec</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>nvec</name></name> <operator>=</operator> <name>anvec</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <call><name>GB_MALLOC</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>plen</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>p_size</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <call><name>GB_MALLOC</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>plen</name></name></expr></argument>  , <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>h_size</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>C</name><operator>-&gt;</operator><name>p</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>C</name><operator>-&gt;</operator><name>h</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// out of memory</comment>
                <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
                <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// copy A-&gt;p and A-&gt;h into the newly created C-&gt;p and C-&gt;h</comment>
            <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><operator>(</operator><name>anvec</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>h</name></name></expr></argument>,  <argument><expr><name>anvec</name>    <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// A is sparse, create new C-&gt;p</comment>
            <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>plen</name></name> <operator>=</operator> <name>avdim</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>nvec</name></name> <operator>=</operator> <name>avdim</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <call><name>GB_MALLOC</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>plen</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>p_size</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>C</name><operator>-&gt;</operator><name>p</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// out of memory</comment>
                <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
                <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// copy A-&gt;p into the newly created C-&gt;p</comment>
            <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><operator>(</operator><name>avdim</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">// free any non-shallow A-&gt;p and A-&gt;h content of A</comment>
        <expr_stmt><expr><call><name>GB_phy_free</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// both A-&gt;p and A-&gt;h are not shallow: quick transplant into C</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// Quick transplant of A-&gt;p and A-&gt;h into C.  This works for both</comment>
        <comment type="line">// sparse and hypersparse cases.</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>p</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>h</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>p</name></name></expr> ;</expr_stmt> <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>p_size</name></name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>p_size</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>h</name></name></expr> ;</expr_stmt> <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>h_size</name></name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>h_size</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>plen</name></name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>plen</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>nvec</name></name> <operator>=</operator> <name>anvec</name></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// A-&gt;p and A-&gt;h have been freed or removed from A</comment>
    <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>p_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>h_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>p_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>h_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>

    <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>nvals</name></name> <operator>=</operator> <name>anvals</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>GB_MAGIC</name></expr> ;</expr_stmt>           <comment type="line">// C is now initialized</comment>
    <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>GB_MAGIC2</name></expr> ;</expr_stmt>          <comment type="line">// A is now invalid</comment>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// transplant or copy A-&gt;i row indices</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>C_is_full</name> <operator>||</operator> <name>C_is_bitmap</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C is full or bitmap</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// C is full or bitmap; C-&gt;i stays NULL</comment>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>A</name><operator>-&gt;</operator><name>i_shallow</name></name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// A-&gt;i is a shallow copy of another matrix, so we need a deep copy</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// copy A-&gt;i into C-&gt;i</comment>
        <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>i</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>i</name></name></expr></argument>, <argument><expr><name>anz</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nthreads</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>i_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// A-&gt;i is not shallow, so just transplant the pointer from A to C</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>i</name></name></expr> ;</expr_stmt> <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>i_size</name></name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>i_size</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>i_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>i_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>nzombies</name></name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>nzombies</name></name></expr> ;</expr_stmt>     <comment type="line">// zombies may have been transplanted into C</comment>
    <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>jumbled</name></name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>jumbled</name></name></expr> ;</expr_stmt>       <comment type="line">// C is jumbled if A is jumbled</comment>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// transplant or copy A-&gt;b bitmap</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>C_is_bitmap</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// A is not bitmap; A-&gt;b does not exist</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// C is not bitmap; C-&gt;b stays NULL</comment>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>A</name><operator>-&gt;</operator><name>b_shallow</name></name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// A-&gt;b is a shallow copy of another matrix, so we need a deep copy</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// copy A-&gt;b into C-&gt;b</comment>
        <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>anz</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int8_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nthreads</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>b_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// A-&gt;b is not shallow, so just transplant the pointer from A to C</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>b</name></name></expr> ;</expr_stmt> <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>b_size</name></name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>b_size</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>b_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>b_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free A and return result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_Matrix_free</name> <argument_list>(<argument><expr><name>Ahandle</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C after transplant"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
