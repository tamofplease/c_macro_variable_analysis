<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_serialize.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_serialize: compress and serialize a GrB_Matrix into a blob</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// A parallel compression method for a GrB_Matrix.  The input matrix may have</comment>
<comment type="line">// shallow components; the output is unaffected by this.  The output blob is</comment>
<comment type="line">// allocated on output (for GxB_Matrix_serialize) or used pre-allocated on</comment>
<comment type="line">// input (for GrB_Matrix_serialize).  This method also does a dry run to</comment>
<comment type="line">// estimate the size of the blob for GrB_Matrix_serializeSize.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_serialize.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_WORKSPACE</name></cpp:macro>                       \
<cpp:value>{                                               \
    GB_FREE (&amp;Ap_Sblocks, Ap_Sblocks_size) ;    \
    GB_FREE (&amp;Ah_Sblocks, Ah_Sblocks_size) ;    \
    GB_FREE (&amp;Ab_Sblocks, Ab_Sblocks_size) ;    \
    GB_FREE (&amp;Ai_Sblocks, Ai_Sblocks_size) ;    \
    GB_FREE (&amp;Ax_Sblocks, Ax_Sblocks_size) ;    \
    GB_serialize_free_blocks (&amp;Ap_Blocks, Ap_Blocks_size, Ap_nblocks, Context);\
    GB_serialize_free_blocks (&amp;Ah_Blocks, Ah_Blocks_size, Ah_nblocks, Context);\
    GB_serialize_free_blocks (&amp;Ab_Blocks, Ab_Blocks_size, Ab_nblocks, Context);\
    GB_serialize_free_blocks (&amp;Ai_Blocks, Ai_Blocks_size, Ai_nblocks, Context);\
    GB_serialize_free_blocks (&amp;Ax_Blocks, Ax_Blocks_size, Ax_nblocks, Context);\
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_ALL</name></cpp:macro>                             \
<cpp:value>{                                               \
    GB_FREE_WORKSPACE ;                         \
    if (!preallocated_blob)                     \
    {                                           \
        GB_FREE (&amp;blob, blob_size_allocated) ;  \
    }                                           \
}</cpp:value></cpp:define>

<function><type><name>GrB_Info</name></type> <name>GB_serialize</name>               <comment type="line">// serialize a matrix into a blob</comment>
<parameter_list>(
    <comment type="line">// output:</comment>
    <parameter><decl><type><name>GB_void</name> <modifier>*</modifier><modifier>*</modifier></type><name>blob_handle</name></decl></parameter>,          <comment type="line">// serialized matrix, allocated on output</comment>
                                    <comment type="line">// for GxB_Matrix_serialize, or provided by</comment>
                                    <comment type="line">// GrB_Matrix_serialize.  NULL for</comment>
                                    <comment type="line">// GrB_Matrix_serialize_size.</comment>
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>blob_size_handle</name></decl></parameter>,       <comment type="line">// size of the blob</comment>
    <comment type="line">// input:</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,             <comment type="line">// matrix to serialize</comment>
    <parameter><decl><type><name>int32_t</name></type> <name>method</name></decl></parameter>,                 <comment type="line">// method to use</comment>
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>blob_size_handle</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"A for serialize"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine what serialization to do</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GB_void</name> <modifier>*</modifier></type><name>blob</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>blob_size_allocated</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>dryrun</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>preallocated_blob</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>blob_handle</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// for GrB_Matrix_serializeSize:  the blob is not provided on input,</comment>
        <comment type="line">// and not allocated.  Just compute an upper bound only.</comment>
        <expr_stmt><expr><name>dryrun</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>*</operator><name>blob_handle</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// for GrB_Matrix_serialize:  the blob is already allocated by the user</comment>
        <comment type="line">// and provided on input.  Fill the blob, and return the blob size as</comment>
        <comment type="line">// the # of bytes written to the blob.</comment>
        <expr_stmt><expr><name>preallocated_blob</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>blob</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>blob_handle</name><operator>)</operator></expr> ;</expr_stmt>
        <expr_stmt><expr><name>blob_size_allocated</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>blob_size_handle</name><operator>)</operator></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <comment type="line">// for GxB_Matrix_serialize:  the blob is not allocated yet. Allocate</comment>
        <comment type="line">// it and return it below, and return the blob size.</comment>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>blob_size_handle</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>

    <decl_stmt><decl><type><name>GB_blocks</name> <modifier>*</modifier></type><name>Ap_Blocks</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ap_Blocks_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_blocks</name> <modifier>*</modifier></type><name>Ah_Blocks</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ah_Blocks_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_blocks</name> <modifier>*</modifier></type><name>Ab_Blocks</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ab_Blocks_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_blocks</name> <modifier>*</modifier></type><name>Ai_Blocks</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ai_Blocks_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_blocks</name> <modifier>*</modifier></type><name>Ax_Blocks</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ax_Blocks_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>Ap_Sblocks</name> <init>= <expr><name>NULL</name></expr></init></decl>  ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ap_Sblocks_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>Ah_Sblocks</name> <init>= <expr><name>NULL</name></expr></init></decl>  ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ah_Sblocks_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>Ab_Sblocks</name> <init>= <expr><name>NULL</name></expr></init></decl>  ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ab_Sblocks_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>Ai_Sblocks</name> <init>= <expr><name>NULL</name></expr></init></decl>  ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ai_Sblocks_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>Ax_Sblocks</name> <init>= <expr><name>NULL</name></expr></init></decl>  ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ax_Sblocks_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>Ap_nblocks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>      ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ap_compressed_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>Ah_nblocks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>      ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ah_compressed_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>Ab_nblocks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>      ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ab_compressed_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>Ai_nblocks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>      ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ai_compressed_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>Ax_nblocks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>      ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ax_compressed_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// ensure all pending work is finished</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_wait</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"A to serialize"</literal></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine maximum # of threads</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_GET_NTHREADS_MAX</name> <argument_list>(<argument><expr><name>nthreads_max</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// parse the method</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int32_t</name></type> <name>algo</name></decl>, <decl><type ref="prev"/><name>level</name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>GB_serialize_method</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>algo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>level</name></expr></argument>, <argument><expr><name>method</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><name>method</name> <operator>=</operator> <name>algo</name> <operator>+</operator> <name>level</name></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(compression: %s%s%s%s:%d) "</literal></expr></argument>,
        <argument><expr><ternary><condition><expr><operator>(</operator><name>algo</name> <operator>==</operator> <name>GxB_COMPRESSION_NONE</name> <operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"none"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
        <argument><expr><ternary><condition><expr><operator>(</operator><name>algo</name> <operator>==</operator> <name>GxB_COMPRESSION_LZ4</name>  <operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"LZ4"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
        <argument><expr><ternary><condition><expr><operator>(</operator><name>algo</name> <operator>==</operator> <name>GxB_COMPRESSION_LZ4HC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"LZ4HC"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
        <argument><expr><ternary><condition><expr><operator>(</operator><name>algo</name> <operator>==</operator> <name>GxB_COMPRESSION_ZSTD</name> <operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"ZSTD"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
        <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get the content of the matrix</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int32_t</name></type> <name>version</name> <init>= <expr><name>GxB_IMPLEMENTATION</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>vlen</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>vlen</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>vdim</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>vdim</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nvec</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>nvec</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nvals</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>nvals</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nvec_nonempty</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>nvec_nonempty</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>sparsity</name> <init>= <expr><call><name>GB_sparsity</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>iso</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>iso</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>hyper_switch</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>hyper_switch</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>bitmap_switch</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>bitmap_switch</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>sparsity_control</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>sparsity_control</name></name></expr></init></decl> ;</decl_stmt>
    <comment type="line">// the matrix has no pending work</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>Pending</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>nzombies</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name><name>A</name><operator>-&gt;</operator><name>jumbled</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>GrB_Type</name></type> <name>atype</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>typesize</name> <init>= <expr><name><name>atype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>typecode</name> <init>= <expr><operator>(</operator><name>int32_t</name><operator>)</operator> <operator>(</operator><name><name>atype</name><operator>-&gt;</operator><name>code</name></name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>anz</name> <init>= <expr><call><name>GB_nnz</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>anz_held</name> <init>= <expr><call><name>GB_nnz_held</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <comment type="line">// determine the uncompressed sizes of Ap, Ah, Ab, Ai, and Ax</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>Ap_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>Ah_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>Ab_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>Ai_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>Ax_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <switch>switch <condition>(<expr><name>sparsity</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>GxB_HYPERSPARSE</name></expr> :</case> 
            <expr_stmt><expr><name>Ah_len</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>GrB_Index</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nvec</name></expr> ;</expr_stmt>
            <comment type="line">// fall through to the sparse case</comment>
        <case>case <expr><name>GxB_SPARSE</name></expr> :</case>
            <expr_stmt><expr><name>Ap_len</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>GrB_Index</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>nvec</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr> ;</expr_stmt>
            <expr_stmt><expr><name>Ai_len</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>GrB_Index</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>anz</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>Ax_len</name> <operator>=</operator> <name>typesize</name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>iso</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>anz</name></expr></else></ternary><operator>)</operator></expr> ;</expr_stmt>
            <break>break ;</break>
        <case>case <expr><name>GxB_BITMAP</name></expr> :</case> 
            <expr_stmt><expr><name>Ab_len</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int8_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>anz_held</name></expr> ;</expr_stmt>
            <comment type="line">// fall through to the full case</comment>
        <case>case <expr><name>GxB_FULL</name></expr> :</case> 
            <expr_stmt><expr><name>Ax_len</name> <operator>=</operator> <name>typesize</name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>iso</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>anz_held</name></expr></else></ternary><operator>)</operator></expr> ;</expr_stmt>
            <break>break ;</break>
        <default>default:</default> <empty_stmt>;</empty_stmt>
    </block_content>}</block></switch>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// compress each array (Ap, Ah, Ab, Ai, and Ax)</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// For the dryrun case, this just computes A[phbix]_compressed_size as an</comment>
    <comment type="line">// upper bound on each array size when compressed, and A[phbix]_nblocks.</comment>

    <decl_stmt><decl><type><name>int32_t</name></type> <name>Ap_method</name></decl>, <decl><type ref="prev"/><name>Ah_method</name></decl>, <decl><type ref="prev"/><name>Ab_method</name></decl>, <decl><type ref="prev"/><name>Ai_method</name></decl>, <decl><type ref="prev"/><name>Ax_method</name></decl> ;</decl_stmt>

    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_serialize_array</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Ap_Blocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ap_Blocks_size</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>Ap_Sblocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ap_Sblocks_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ap_nblocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ap_method</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>Ap_compressed_size</name></expr></argument>, <argument><expr><name>dryrun</name></expr></argument>,
        <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name><name>A</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>Ap_len</name></expr></argument>, <argument><expr><name>method</name></expr></argument>, <argument><expr><name>algo</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_serialize_array</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Ah_Blocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ah_Blocks_size</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>Ah_Sblocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ah_Sblocks_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ah_nblocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ah_method</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>Ah_compressed_size</name></expr></argument>, <argument><expr><name>dryrun</name></expr></argument>,
        <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name><name>A</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>Ah_len</name></expr></argument>, <argument><expr><name>method</name></expr></argument>, <argument><expr><name>algo</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_serialize_array</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Ab_Blocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ab_Blocks_size</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>Ab_Sblocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ab_Sblocks_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ab_nblocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ab_method</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>Ab_compressed_size</name></expr></argument>, <argument><expr><name>dryrun</name></expr></argument>,
        <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name><name>A</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>Ab_len</name></expr></argument>, <argument><expr><name>method</name></expr></argument>, <argument><expr><name>algo</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_serialize_array</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Ai_Blocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ai_Blocks_size</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>Ai_Sblocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ai_Sblocks_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ai_nblocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ai_method</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>Ai_compressed_size</name></expr></argument>, <argument><expr><name>dryrun</name></expr></argument>,
        <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name><name>A</name><operator>-&gt;</operator><name>i</name></name></expr></argument>, <argument><expr><name>Ai_len</name></expr></argument>, <argument><expr><name>method</name></expr></argument>, <argument><expr><name>algo</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_serialize_array</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Ax_Blocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ax_Blocks_size</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>Ax_Sblocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ax_Sblocks_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ax_nblocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ax_method</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>Ax_compressed_size</name></expr></argument>, <argument><expr><name>dryrun</name></expr></argument>,
        <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name><name>A</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>Ax_len</name></expr></argument>, <argument><expr><name>method</name></expr></argument>, <argument><expr><name>algo</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine the size of the blob</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>size_t</name></type> <name>s</name> <init>=
        <comment type="line">// header information</comment>
        <expr><name>GB_BLOB_HEADER_SIZE</name>
        <comment type="line">// Sblocks for each array</comment>
        <operator>+</operator> <name>Ap_nblocks</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof>     <comment type="line">// Ap_Sblocks [1:Ap_nblocks]</comment>
        <operator>+</operator> <name>Ah_nblocks</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof>     <comment type="line">// Ah_Sblocks [1:Ah_nblocks]</comment>
        <operator>+</operator> <name>Ab_nblocks</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof>     <comment type="line">// Ab_Sblocks [1:Ab_nblocks]</comment>
        <operator>+</operator> <name>Ai_nblocks</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof>     <comment type="line">// Ai_Sblocks [1:Ai_nblocks]</comment>
        <operator>+</operator> <name>Ax_nblocks</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof>     <comment type="line">// Ax_Sblocks [1:Ax_nblocks]</comment>
        <comment type="line">// type_name for user-defined types</comment>
        <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>typecode</name> <operator>==</operator> <name>GB_UDT_code</name><operator>)</operator></expr> ?</condition><then> <expr><name>GxB_MAX_NAME_LEN</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <comment type="line">// size of compressed arrays Ap, Ah, Ab, Ai, and Ax in the blob</comment>
    <expr_stmt><expr><name>s</name> <operator>+=</operator> <name>Ap_compressed_size</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>+=</operator> <name>Ah_compressed_size</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>+=</operator> <name>Ab_compressed_size</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>+=</operator> <name>Ai_compressed_size</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>+=</operator> <name>Ax_compressed_size</name></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// return the upper bound estimate of the blob size, for dryrun</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>dryrun</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// GrB_Matrix_serializeSize: this is an upper bound on the required</comment>
        <comment type="line">// size of the blob, not the actual size.</comment>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>blob_size_handle</name><operator>)</operator> <operator>=</operator> <name>s</name></expr> ;</expr_stmt>
        <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// allocate the blob</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>size_t</name></type> <name>blob_size_required</name> <init>= <expr><name>s</name></expr></init></decl> ;</decl_stmt>     <comment type="line">// the exact size required</comment>

    <if_stmt><if>if <condition>(<expr><name>preallocated_blob</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// GrB_Matrix_serialize passes in a preallocated blob.</comment>
        <comment type="line">// Check if it is large enough for the actual blob, of size s.</comment>
        <if_stmt><if>if <condition>(<expr><name>blob_size_allocated</name> <operator>&lt;</operator> <name>blob_size_required</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// blob too small.  The required minimum size of the blob</comment>
            <comment type="line">// (blob_size_required) could be returned to the caller.</comment>
            <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
            <return>return <expr><operator>(</operator><name>GrB_INSUFFICIENT_SPACE</name><operator>)</operator></expr> ;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// GxB_Matrix_serialize: allocate the block.  The memory pool may</comment>
        <comment type="line">// increase the blob from size blob_size_required bytes to</comment>
        <comment type="line">// blob_size_allocated.</comment>
        <expr_stmt><expr><name>blob</name> <operator>=</operator> <call><name>GB_MALLOC</name> <argument_list>(<argument><expr><name>blob_size_required</name></expr></argument>, <argument><expr><name>GB_void</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blob_size_allocated</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>blob</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// out of memory</comment>
            <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
            <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>blob_size_allocated</name> <operator>&gt;=</operator> <name>blob_size_required</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// write the header and type_name into the blob</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// 160 bytes, plus 128 bytes for user-defined types</comment>

    <expr_stmt><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>sparsity_iso_csc</name> <init>= <expr><operator>(</operator><literal type="number">4</literal> <operator>*</operator> <name>sparsity</name><operator>)</operator> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>iso</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
        <operator>(</operator><ternary><condition><expr><name><name>A</name><operator>-&gt;</operator><name>is_csc</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>blob_size_required</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>typecode</name></expr></argument>, <argument><expr><name>int32_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>version</name></expr></argument>, <argument><expr><name>int32_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>vlen</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>vdim</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>nvec</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>nvec_nonempty</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>typesize</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>Ap_len</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>Ah_len</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>Ab_len</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>Ai_len</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>Ax_len</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>hyper_switch</name></expr></argument>, <argument><expr><name>float</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>bitmap_switch</name></expr></argument>, <argument><expr><name>float</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>sparsity_control</name></expr></argument>, <argument><expr><name>int32_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>sparsity_iso_csc</name></expr></argument>, <argument><expr><name>int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>Ap_nblocks</name></expr></argument>, <argument><expr><name>int32_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>Ap_method</name></expr></argument>, <argument><expr><name>int32_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>Ah_nblocks</name></expr></argument>, <argument><expr><name>int32_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>Ah_method</name></expr></argument>, <argument><expr><name>int32_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>Ab_nblocks</name></expr></argument>, <argument><expr><name>int32_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>Ab_method</name></expr></argument>, <argument><expr><name>int32_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>Ai_nblocks</name></expr></argument>, <argument><expr><name>int32_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>Ai_method</name></expr></argument>, <argument><expr><name>int32_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>Ax_nblocks</name></expr></argument>, <argument><expr><name>int32_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <expr_stmt><expr><call><name>GB_BLOB_WRITE</name> <argument_list>(<argument><expr><name>Ax_method</name></expr></argument>, <argument><expr><name>int32_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// 128 bytes, if present</comment>
    <if_stmt><if>if <condition>(<expr><name>typecode</name> <operator>==</operator> <name>GB_UDT_code</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// only copy the type_name for user-defined types</comment>
        <expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>blob</name> <operator>+</operator> <name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>GxB_MAX_NAME_LEN</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_COMPILER_GCC</name></expr></cpp:if>
        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>__GNUC__</name> <operator>&gt;</operator> <literal type="number">5</literal><operator>)</operator></expr></cpp:if>
        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>GCC</name> <name>diagnostic</name> <name>ignored</name> <cpp:literal>"-Wstringop-truncation"</cpp:literal></cpp:pragma>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>blob</name> <operator>+</operator> <name>s</name><operator>)</operator></expr></argument>, <argument><expr><name><name>atype</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>GxB_MAX_NAME_LEN</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>s</name> <operator>+=</operator> <name>GxB_MAX_NAME_LEN</name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// copy the compressed arrays into the blob</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// 8 * (# blocks for Ap, Ah, Ab, Ai, Ax)</comment>
    <expr_stmt><expr><call><name>GB_BLOB_WRITES</name> <argument_list>(<argument><expr><name>Ap_Sblocks</name></expr></argument>, <argument><expr><name>Ap_nblocks</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITES</name> <argument_list>(<argument><expr><name>Ah_Sblocks</name></expr></argument>, <argument><expr><name>Ah_nblocks</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITES</name> <argument_list>(<argument><expr><name>Ab_Sblocks</name></expr></argument>, <argument><expr><name>Ab_nblocks</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITES</name> <argument_list>(<argument><expr><name>Ai_Sblocks</name></expr></argument>, <argument><expr><name>Ai_nblocks</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BLOB_WRITES</name> <argument_list>(<argument><expr><name>Ax_Sblocks</name></expr></argument>, <argument><expr><name>Ax_nblocks</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GB_serialize_to_blob</name> <argument_list>(<argument><expr><name>blob</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>Ap_Blocks</name></expr></argument>, <argument><expr><name>Ap_Sblocks</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>Ap_nblocks</name></expr></argument>,
        <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_serialize_to_blob</name> <argument_list>(<argument><expr><name>blob</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>Ah_Blocks</name></expr></argument>, <argument><expr><name>Ah_Sblocks</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>Ah_nblocks</name></expr></argument>,
        <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_serialize_to_blob</name> <argument_list>(<argument><expr><name>blob</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>Ab_Blocks</name></expr></argument>, <argument><expr><name>Ab_Sblocks</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>Ab_nblocks</name></expr></argument>,
        <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_serialize_to_blob</name> <argument_list>(<argument><expr><name>blob</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>Ai_Blocks</name></expr></argument>, <argument><expr><name>Ai_Sblocks</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>Ai_nblocks</name></expr></argument>,
        <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_serialize_to_blob</name> <argument_list>(<argument><expr><name>blob</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>Ax_Blocks</name></expr></argument>, <argument><expr><name>Ax_Sblocks</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>Ax_nblocks</name></expr></argument>,
        <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>s</name> <operator>==</operator> <name>blob_size_required</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free workspace and return result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>preallocated_blob</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// GxB_Matrix_serialize: giving the blob to the user; remove it from</comment>
        <comment type="line">// the list of malloc'd blocks</comment>
        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_MEMDUMP</name></cpp:ifdef>
        <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"removing blob %p size %ld from memtable\n"</literal></expr></argument>, <argument><expr><name>blob</name></expr></argument>,
            <argument><expr><name>blob_size_allocated</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>GB_Global_memtable_remove</name> <argument_list>(<argument><expr><name>blob</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>blob_handle</name><operator>)</operator> <operator>=</operator> <name>blob</name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Return the required size of the blob to the user, not the actual</comment>
    <comment type="line">// allocated space of the blob.  The latter may be larger because of the</comment>
    <comment type="line">// memory pool.</comment>

    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>blob_size_handle</name><operator>)</operator> <operator>=</operator> <name>blob_size_required</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name>GB_FREE_WORKSPACE</name></expr> ;</expr_stmt>
    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
