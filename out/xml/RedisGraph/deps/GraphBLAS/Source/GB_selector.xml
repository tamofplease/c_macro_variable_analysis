<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" xmlns:omp="http://www.srcML.org/srcML/openmp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_selector.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_selector:  select entries from a matrix</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// GB_selector does the work for GB_select and the GxB_*select methods.  It</comment>
<comment type="line">// also deletes zombies for GB_wait using the NONZOMBIE operator, and deletes</comment>
<comment type="line">// entries outside a smaller matrix for GxB_*resize.</comment>

<comment type="line">// TODO: GB_selector does not exploit the mask.</comment>

<comment type="line">// If C is NULL on input, A is modified in-place.</comment>
<comment type="line">// Otherwise, C is an uninitialized static header.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_select.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_ek_slice.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sel__include.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_scalar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_transpose.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_WORKSPACE</name></cpp:macro>                   \
<cpp:value>{                                           \
    GB_FREE_WORK (&amp;Zp, Zp_size) ;           \
    GB_WERK_POP (Work, int64_t) ;           \
    GB_WERK_POP (A_ek_slicing, int64_t) ;   \
    GB_FREE (&amp;Cp, Cp_size) ;                \
    GB_FREE (&amp;Ch, Ch_size) ;                \
    GB_FREE (&amp;Ci, Ci_size) ;                \
    GB_FREE (&amp;Cx, Cx_size) ;                \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_ALL</name></cpp:macro>                         \
<cpp:value>{                                           \
    GB_phybix_free (C) ;                    \
    GB_FREE_WORKSPACE ;                     \
}</cpp:value></cpp:define>

<function><type><name>GrB_Info</name></type> <name>GB_selector</name>
<parameter_list>(
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,               <comment type="line">// output matrix, NULL or existing header</comment>
    <parameter><decl><type><name>GB_Opcode</name></type> <name>opcode</name></decl></parameter>,           <comment type="line">// selector opcode</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GB_Operator</name></type> <name>op</name></decl></parameter>,       <comment type="line">// user operator, NULL for resize/nonzombie</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>flipij</name></decl></parameter>,          <comment type="line">// if true, flip i and j for user operator</comment>
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,               <comment type="line">// input matrix</comment>
    <parameter><decl><type><name>int64_t</name></type> <name>ithunk</name></decl></parameter>,             <comment type="line">// (int64_t) Thunk, if Thunk is NULL</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Scalar</name></type> <name>Thunk</name></decl></parameter>,     <comment type="line">// optional input for select operator</comment>
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT_OP_OK_OR_NULL</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"selectop/idxunop for GB_selector"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_SCALAR_OK_OR_NULL</name> <argument_list>(<argument><expr><name>Thunk</name></expr></argument>, <argument><expr><literal type="string">"Thunk for GB_selector"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IS_SELECTOP_CODE</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GB_IS_INDEXUNARYOP_CODE</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"A input for GB_selector"</literal></expr></argument>, <argument><expr><call><name>GB_FLIP</name> <argument_list>(<argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <comment type="line">// positional selector (tril, triu, diag, offdiag, resize, rowindex, ...):</comment>
    <comment type="line">// can't be jumbled.  nonzombie, entry-valued op, user op: jumbled OK</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><call><name>GB_OPCODE_IS_POSITIONAL</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>!</operator><call><name>GB_JUMBLED</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>C</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>static_header</name></name> <operator>||</operator> <name>GBNSTATIC</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// declare workspace</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>in_place_A</name> <init>= <expr><operator>(</operator><name>C</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></init></decl> ;</decl_stmt> <comment type="line">// GrB_wait and GB_resize only</comment>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Zp</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Zp_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>GB_WERK_DECLARE</name> <argument_list>(<argument><expr><name>Work</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Wfirst</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Wlast</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Cp_kfirst</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>GB_WERK_DECLARE</name> <argument_list>(<argument><expr><name>A_ek_slicing</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>avlen</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>vlen</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>avdim</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>vdim</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>A_iso</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>iso</name></name></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Cp</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Cp_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ch</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ch_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ci</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ci_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_void</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Cx</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Cx_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get Thunk</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// The scalar value of Thunk has already been typecasted to an integer</comment>
    <comment type="line">// (int64_t ithunk).</comment>

    <comment type="line">// It is also now typecast to the same type as A (to the scalar athunk)</comment>
    <comment type="line">// which is required for GxB_SelectOps, and to the op-&gt;ytype (the scalar</comment>
    <comment type="line">// ythunk) for GrB_IndexUnaryOps.</comment>

    <comment type="line">// If Thunk is NULL, or has no entry, it is treated as a scalar value</comment>
    <comment type="line">// of zero.</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>asize</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>GB_Type_code</name></type> <name>acode</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>GrB_Type</name></type> <name>ytype</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>xtype</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>ycode</name> <init>= <expr><name>GB_ignore_code</name></expr></init></decl>, <decl><type ref="prev"/><name>xcode</name> <init>= <expr><name>GB_ignore_code</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>ysize</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>xsize</name> <init>= <expr><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>op</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>ytype</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// get the type of the thunk input of the operator</comment>
            <expr_stmt><expr><name>ytype</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>ytype</name></name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>ycode</name> <operator>=</operator> <name><name>ytype</name><operator>-&gt;</operator><name>code</name></name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>ysize</name> <operator>=</operator> <name><name>ytype</name><operator>-&gt;</operator><name>size</name></name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>xtype</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// get the type of the A input of the operator</comment>
            <expr_stmt><expr><name>xtype</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>xtype</name></name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>xcode</name> <operator>=</operator> <name><name>xtype</name><operator>-&gt;</operator><name>code</name></name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>xsize</name> <operator>=</operator> <name><name>xtype</name><operator>-&gt;</operator><name>size</name></name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// athunk = (A-&gt;type) Thunk, for selectop thunk comparators only</comment>
    <decl_stmt><decl><type><name>GB_void</name></type> <name><name>athunk</name> <index>[<expr><call><name>GB_VLA</name><argument_list>(<argument><expr><name>asize</name></expr></argument>)</argument_list></call></expr>]</index></name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>athunk</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>asize</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// ythunk = (op-&gt;ytype) Thunk, for idxnunop</comment>
    <decl_stmt><decl><type><name>GB_void</name></type> <name><name>ythunk</name> <index>[<expr><call><name>GB_VLA</name><argument_list>(<argument><expr><name>ysize</name></expr></argument>)</argument_list></call></expr>]</index></name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>ythunk</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ysize</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>op_is_selectop</name> <init>= <expr><call><name>GB_IS_SELECTOP_CODE</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>op_is_idxunop</name>  <init>= <expr><call><name>GB_IS_INDEXUNARYOP_CODE</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>op_is_positional</name> <init>= <expr><call><name>GB_OPCODE_IS_POSITIONAL</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>Thunk</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Thunk is passed to GB_selector only if it is non-empty</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_nnz</name> <argument_list>(<argument><expr><operator>(</operator><name>GrB_Matrix</name><operator>)</operator> <name>Thunk</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>GB_Type_code</name></type> <name>tcode</name> <init>= <expr><name><name>Thunk</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>op_is_selectop</name> <operator>&amp;&amp;</operator> <name>opcode</name> <operator>!=</operator> <name>GB_USER_selop_code</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// athunk = (atype) Thunk, for built-in GxB_SelectOps only</comment>
            <expr_stmt><expr><call><name>GB_cast_scalar</name> <argument_list>(<argument><expr><name>athunk</name></expr></argument>, <argument><expr><name>acode</name></expr></argument>, <argument><expr><name><name>Thunk</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>tcode</name></expr></argument>, <argument><expr><name>asize</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>ytype</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// ythunk = (op-&gt;ytype) Thunk</comment>
            <expr_stmt><expr><call><name>GB_cast_scalar</name> <argument_list>(<argument><expr><name>ythunk</name></expr></argument>, <argument><expr><name>ycode</name></expr></argument>, <argument><expr><name><name>Thunk</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>tcode</name></expr></argument>, <argument><expr><name>ysize</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// handle iso case for built-in select ops that depend only on the value</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>op_is_select_valued</name> <init>=
        <expr><name>opcode</name> <operator>&gt;=</operator> <name>GB_NONZERO_selop_code</name> <operator>&amp;&amp;</operator> <name>opcode</name> <operator>&lt;=</operator> <name>GB_LE_THUNK_selop_code</name></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>op_is_idxunop_valued</name> <init>=
        <expr><name>opcode</name> <operator>&gt;=</operator> <name>GB_VALUENE_idxunop_code</name> <operator>&amp;&amp;</operator> <name>opcode</name> <operator>&lt;=</operator> <name>GB_VALUELE_idxunop_code</name></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>A_iso</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>op_is_select_valued</name> <operator>||</operator> <name>op_is_idxunop_valued</name><operator>)</operator></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">// select op is NONZERO, EQ_ZERO, GT_ZERO, GE_ZERO, LT_ZERO, LE_ZERO,</comment>
        <comment type="line">// EQ_THUNK, GT_THUNK, GE_THUNK, LT_THUNK, or LE_THUNK, or the idxunop</comment>
        <comment type="line">// VALUE* operators.  All of these select/idxunop ops depend only on</comment>
        <comment type="line">// the value of A(i,j).  Since A is iso, either all entries in A will</comment>
        <comment type="line">// be copied to C and thus C can be created as a shallow copy of A, or</comment>
        <comment type="line">// no entries from A will be copied to C and thus C is an empty matrix.</comment>
        <comment type="line">// The select factory is not needed, except to check the iso value via</comment>
        <comment type="line">// GB_bitmap_selector.</comment>

        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>in_place_A</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>static_header</name></name> <operator>||</operator> <name>GBNSTATIC</name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">// construct a scalar containing the iso scalar of A</comment>

        <comment type="line">// xscalar = (op-&gt;xtype) A-&gt;x for idxunops</comment>
        <decl_stmt><decl><type><name>GB_void</name></type> <name><name>xscalar</name> <index>[<expr><call><name>GB_VLA</name><argument_list>(<argument><expr><name>xsize</name></expr></argument>)</argument_list></call></expr>]</index></name></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>xscalar</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>xsize</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <decl_stmt><decl><type><name><name>struct</name> <name>GB_Scalar_opaque</name></name></type> <name>S_header</name></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>GrB_Scalar</name></type> <name>S</name></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>op_is_select_valued</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// wrap the iso-value of A in the scalar S, with no typecasting</comment>
            <expr_stmt><expr><name>S</name> <operator>=</operator> <call><name>GB_Scalar_wrap</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>S_header</name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// wrap the iso-value of A in the scalar S, typecasted to xtype</comment>
            <comment type="line">// xscalar = (op-&gt;xtype) A-&gt;x</comment>
            <expr_stmt><expr><call><name>GB_cast_scalar</name> <argument_list>(<argument><expr><name>xscalar</name></expr></argument>, <argument><expr><name>xcode</name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>acode</name></expr></argument>, <argument><expr><name>asize</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>S</name> <operator>=</operator> <call><name>GB_Scalar_wrap</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>S_header</name></expr></argument>, <argument><expr><name>xtype</name></expr></argument>, <argument><expr><name>xscalar</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>S</name><operator>-&gt;</operator><name>iso</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>    <comment type="line">// but ensure S is not iso</comment>
        <expr_stmt><expr><call><name>ASSERT_SCALAR_OK</name> <argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><literal type="string">"iso scalar wrap"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">// apply the select operator to the iso scalar S</comment>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_bitmap_selector</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
            <argument><expr><operator>(</operator><name>GrB_Matrix</name><operator>)</operator> <name>S</name></expr></argument>, <argument><expr><name>ithunk</name></expr></argument>, <argument><expr><name>athunk</name></expr></argument>, <argument><expr><name>ythunk</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C from iso scalar test"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>C_empty</name> <init>= <expr><operator>(</operator><call><name>GB_nnz</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>GB_phybix_free</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">// check if C has 0 or 1 entry</comment>
        <if_stmt><if>if <condition>(<expr><name>C_empty</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// C is an empty matrix</comment>
            <return>return <expr><operator>(</operator><call><name>GB_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>C</name></expr></argument>, <comment type="line">// existing header</comment>
                <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>avlen</name></expr></argument>, <argument><expr><name>avdim</name></expr></argument>, <argument><expr><name>GB_Ap_calloc</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                <argument><expr><name>GxB_SPARSE</name> <operator>+</operator> <name>GxB_HYPERSPARSE</name></expr></argument>, <argument><expr><call><name>GB_Global_hyper_switch_get</name> <argument_list>( )</argument_list></call></expr></argument>,
                <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// C is a shallow copy of A with all the same entries as A</comment>
            <comment type="line">// set C-&gt;iso = A-&gt;iso  OK</comment>
            <return>return <expr><operator>(</operator><call><name>GB_shallow_copy</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// now if A is iso, the following operators still need to be handled:</comment>

    <comment type="line">//      GB_TRIL_selop_code        : use GB_sel__tril_iso</comment>
    <comment type="line">//      GB_TRIU_selop_code        : use GB_sel__triu_iso</comment>
    <comment type="line">//      GB_DIAG_selop_code        : use GB_sel__diag_iso</comment>
    <comment type="line">//      GB_OFFDIAG_selop_code     : use GB_sel__offdiag_iso</comment>
    <comment type="line">//      GB_NONZOMBIE_selop_code   : use GB_sel__nonzombie_iso</comment>
    <comment type="line">//      GB_USER_selop_code        : use GB_sel__user_iso</comment>
    <comment type="line">//      GB_ROWINDEX_idxunop_code  : use GB_sel__rowindex_iso</comment>
    <comment type="line">//      GB_ROWLE_idxunop_code     : use GB_sel__rowle_iso</comment>
    <comment type="line">//      GB_ROWGT_idxunop_code     : use GB_sel__rowle_iso</comment>
    <comment type="line">//      all other idxunop         : use GB_sel__idxunop_iso</comment>

    <comment type="line">// column selectors are handled below:</comment>
    <comment type="line">//      GB_COLINDEX_idxunop_code  : </comment>
    <comment type="line">//      GB_COLLE_idxunop_code     : </comment>
    <comment type="line">//      GB_COLGT_idxunop_code     : </comment>

    <comment type="line">// Except for GB_USER_selop_code and idxunop, the GB_sel__*_iso methods do</comment>
    <comment type="line">// not access the values of A and C, just the pattern.</comment>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// handle the bitmap/as-if-full case</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>use_bitmap_selector</name></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>GB_NONZOMBIE_selop_code</name> <operator>||</operator> <name>in_place_A</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// GB_bitmap_selector does not support the nonzombie opcode, nor does</comment>
        <comment type="line">// it support operating on A in place.  For the NONZOMBIE operator, A</comment>
        <comment type="line">// will never be bitmap.</comment>
        <expr_stmt><expr><name>use_bitmap_selector</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>GB_DIAG_selop_code</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// GB_bitmap_selector supports the DIAG operator, but it is currently</comment>
        <comment type="line">// not efficient (GB_bitmap_selector should return a sparse diagonal</comment>
        <comment type="line">// matrix, not bitmap).  So use the sparse case if A is not bitmap,</comment>
        <comment type="line">// since the sparse case below does not support the bitmap case.</comment>
        <expr_stmt><expr><name>use_bitmap_selector</name> <operator>=</operator> <call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <comment type="line">// For bitmap, full, or as-if-full matrices (sparse/hypersparse with</comment>
        <comment type="line">// all entries present, not jumbled, no zombies, and no pending</comment>
        <comment type="line">// tuples), use the bitmap selector for all other operators (TRIL,</comment>
        <comment type="line">// TRIU, OFFDIAG, NONZERO, EQ*, GT*, GE*, LT*, LE*, and user-defined</comment>
        <comment type="line">// operators).</comment>
        <expr_stmt><expr><name>use_bitmap_selector</name> <operator>=</operator> <call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GB_as_if_full</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine if C is iso for a non-iso A</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>C_iso</name> <init>= <expr><name>A_iso</name> <operator>||</operator>                       <comment type="line">// C iso value is Ax [0]</comment>
        <operator>(</operator><name>opcode</name> <operator>==</operator> <name>GB_EQ_ZERO_selop_code</name><operator>)</operator> <operator>||</operator>        <comment type="line">// C iso value is zero</comment>
        <operator>(</operator><name>opcode</name> <operator>==</operator> <name>GB_EQ_THUNK_selop_code</name><operator>)</operator> <operator>||</operator>       <comment type="line">// C iso value is thunk</comment>
        <operator>(</operator><name>opcode</name> <operator>==</operator> <name>GB_NONZERO_selop_code</name> <operator>&amp;&amp;</operator>
         <name>acode</name> <operator>==</operator> <name>GB_BOOL_code</name><operator>)</operator></expr></init></decl> ;</decl_stmt>               <comment type="line">// C iso value is true</comment>

    <if_stmt><if>if <condition>(<expr><name>C_iso</name></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><call><name>GB_BURBLE_MATRIX</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"(iso select) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//==========================================================================</comment>
    <comment type="line">// bitmap/full case</comment>
    <comment type="line">//==========================================================================</comment>

    <if_stmt><if>if <condition>(<expr><name>use_bitmap_selector</name></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><call><name>GB_BURBLE_MATRIX</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"(bitmap select) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>static_header</name></name> <operator>||</operator> <name>GBNSTATIC</name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <return>return <expr><operator>(</operator><call><name>GB_bitmap_selector</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>C_iso</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>op</name></expr></argument>,                  
            <argument><expr><name>flipij</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>ithunk</name></expr></argument>, <argument><expr><name>athunk</name></expr></argument>, <argument><expr><name>ythunk</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//==========================================================================</comment>
    <comment type="line">// sparse/hypersparse case</comment>
    <comment type="line">//==========================================================================</comment>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine the max number of threads to use</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_GET_NTHREADS_MAX</name> <argument_list>(<argument><expr><name>nthreads_max</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get A: sparse, hypersparse, or full</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// the case when A is bitmap is always handled above by GB_bitmap_selector</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ap</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ap_size</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>p_size</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ah</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>h</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ai</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>i</name></name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ai_size</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>i_size</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_void</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ax</name> <init>= <expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name><name>A</name><operator>-&gt;</operator><name>x</name></name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ax_size</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>x_size</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>anvec</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>nvec</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>A_jumbled</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>jumbled</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>A_is_hyper</name> <init>= <expr><operator>(</operator><name>Ah</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <comment type="line">//==========================================================================</comment>
    <comment type="line">// column selector</comment>
    <comment type="line">//==========================================================================</comment>

    <comment type="line">// The column selectors can be done in a single pass.</comment>

    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>GB_COLINDEX_idxunop_code</name> <operator>||</operator>
        <name>opcode</name> <operator>==</operator> <name>GB_COLLE_idxunop_code</name> <operator>||</operator>
        <name>opcode</name> <operator>==</operator> <name>GB_COLGT_idxunop_code</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// find column j in A</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"A for col selector"</literal></expr></argument>, <argument><expr><call><name>GB_FLIP</name> <argument_list>(<argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nth</name> <init>= <expr><name>nthreads_max</name></expr></init></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>in_place_A</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>static_header</name></name> <operator>||</operator> <name>GBNSTATIC</name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <decl_stmt><decl><type><name>int64_t</name></type> <name>j</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>opcode</name> <operator>==</operator> <name>GB_COLINDEX_idxunop_code</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><operator>-</operator><name>ithunk</name><operator>)</operator></expr> </then><else>: <expr><name>ithunk</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>

        <decl_stmt><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// j is outside the range of columns of A</comment>
            <expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name>avdim</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// j is outside the range of columns of A</comment>
            <expr_stmt><expr><name>k</name> <operator>=</operator> <name>anvec</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>A_is_hyper</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// find the column j in the hyperlist of A</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>kright</name> <init>= <expr><name>anvec</name><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <expr_stmt><expr><call><name>GB_SPLIT_BINARY_SEARCH</name> <argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><name>Ah</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>kright</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <comment type="line">// if found is true the Ah [k] == j</comment>
            <comment type="line">// if found is false, then Ah [0..k-1] &lt; j and Ah [k..anvec-1] &gt; j</comment>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// j appears as the jth column in A; found is always true</comment>
            <expr_stmt><expr><name>k</name> <operator>=</operator> <name>j</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// determine the # of entries and # of vectors in C</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><name>int64_t</name></type> <name>pstart</name> <init>= <expr><name><name>Ap</name> <index>[<expr><name>k</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>pend</name> <init>= <expr><ternary><condition><expr><name>found</name></expr> ?</condition><then> <expr><name><name>Ap</name> <index>[<expr><name>k</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><name>pstart</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>ajnz</name> <init>= <expr><name>pend</name> <operator>-</operator> <name>pstart</name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>cnz</name></decl>, <decl><type ref="prev"/><name>cnvec</name></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>anz</name> <init>= <expr><name><name>Ap</name> <index>[<expr><name>anvec</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>GB_COLINDEX_idxunop_code</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// COLINDEX: delete column j:  C = A (:, [0:j-1 j+1:end])</comment>
            <expr_stmt><expr><name>cnz</name> <operator>=</operator> <name>anz</name> <operator>-</operator> <name>ajnz</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>cnvec</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>A_is_hyper</name> <operator>&amp;&amp;</operator> <name>found</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>anvec</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><name>anvec</name></expr></else></ternary></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>GB_COLLE_idxunop_code</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// COLLE: C = A (:, 0:j)</comment>
            <expr_stmt><expr><name>cnz</name> <operator>=</operator> <name>pend</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>cnvec</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>A_is_hyper</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><name>found</name></expr> ?</condition><then> <expr><operator>(</operator><name>k</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><name>k</name></expr></else></ternary><operator>)</operator></expr> </then><else>: <expr><name>anvec</name></expr></else></ternary></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else <comment type="line">// (opcode == GB_COLGT_idxunop_code)</comment>
        <block>{<block_content> 
            <comment type="line">// COLGT: C = A (:, j+1:end)</comment>
            <expr_stmt><expr><name>cnz</name> <operator>=</operator> <name>anz</name> <operator>-</operator> <name>pend</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>cnvec</name> <operator>=</operator> <name>anvec</name> <operator>-</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>A_is_hyper</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><name>found</name></expr> ?</condition><then> <expr><operator>(</operator><name>k</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><name>k</name></expr></else></ternary><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>cnz</name> <operator>==</operator> <name>anz</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// C is the same as A: return it a pure shallow copy</comment>
            <return>return <expr><operator>(</operator><call><name>GB_shallow_copy</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>cnz</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// return C as empty</comment>
            <return>return <expr><operator>(</operator><call><name>GB_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>C</name></expr></argument>, <comment type="line">// auto (sparse or hyper), existing header</comment>
                <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>avlen</name></expr></argument>, <argument><expr><name>avdim</name></expr></argument>, <argument><expr><name>GB_Ap_calloc</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                <argument><expr><name>GxB_HYPERSPARSE</name></expr></argument>, <argument><expr><call><name>GB_Global_hyper_switch_get</name> <argument_list>( )</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// allocate C</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><name>int</name></type> <name>sparsity</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>A_is_hyper</name><operator>)</operator></expr> ?</condition><then> <expr><name>GxB_HYPERSPARSE</name></expr> </then><else>: <expr><name>GxB_SPARSE</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_new_bix</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>C</name></expr></argument>, <comment type="line">// sparse or hyper (from A), existing header</comment>
            <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>avlen</name></expr></argument>, <argument><expr><name>avdim</name></expr></argument>, <argument><expr><name>GB_Ap_malloc</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>sparsity</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
            <argument><expr><name><name>A</name><operator>-&gt;</operator><name>hyper_switch</name></name></expr></argument>, <argument><expr><name>cnvec</name></expr></argument>, <argument><expr><name>cnz</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nth2</name> <init>= <expr><call><name>GB_nthreads</name> <argument_list>(<argument><expr><name>cnvec</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

        <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Cp</name> <init>= <expr><name><name>C</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ch</name> <init>= <expr><name><name>C</name><operator>-&gt;</operator><name>h</name></name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ci</name> <init>= <expr><name><name>C</name><operator>-&gt;</operator><name>i</name></name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>GB_void</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Cx</name> <init>= <expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>kk</name></decl> ;</decl_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// construct C</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <if_stmt><if>if <condition>(<expr><name>A_iso</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// Cx [0] = Ax [0]</comment>
            <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>Cx</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>asize</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>GB_COLINDEX_idxunop_code</name></expr>)</condition>
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// COLINDEX: delete the column j</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <if_stmt><if>if <condition>(<expr><name>A_is_hyper</name></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <comment type="line">// Cp [0:k-1] = Ap [0:k-1]</comment>
                <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Cp</name></expr></argument>, <argument><expr><name>Ap</name></expr></argument>, <argument><expr><name>k</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <comment type="line">// Cp [k:cnvec] = Ap [k+1:anvec] - ajnz</comment>
                <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nth2</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
                <for>for <control>(<init><expr><name>kk</name> <operator>=</operator> <name>k</name></expr> ;</init> <condition><expr><name>kk</name> <operator>&lt;=</operator> <name>cnvec</name></expr> ;</condition> <incr><expr><name>kk</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content> 
                    <expr_stmt><expr><name><name>Cp</name> <index>[<expr><name>kk</name></expr>]</index></name> <operator>=</operator> <name><name>Ap</name> <index>[<expr><name>kk</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name>ajnz</name></expr> ;</expr_stmt>
                </block_content>}</block></for>
                <comment type="line">// Ch [0:k-1] = Ah [0:k-1]</comment>
                <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Ch</name></expr></argument>, <argument><expr><name>Ah</name></expr></argument>, <argument><expr><name>k</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <comment type="line">// Ch [k:cnvec-1] = Ah [k+1:anvec-1]</comment>
                <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Ch</name> <operator>+</operator> <name>k</name></expr></argument>, <argument><expr><name>Ah</name> <operator>+</operator> <operator>(</operator><name>k</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>cnvec</name><operator>-</operator><name>k</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                    <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <comment type="line">// Cp [0:k] = Ap [0:k]</comment>
                <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Cp</name></expr></argument>, <argument><expr><name>Ap</name></expr></argument>, <argument><expr><operator>(</operator><name>k</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <comment type="line">// Cp [k+1:anvec] = Ap [k+1:anvec] - ajnz</comment>
                <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nth2</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
                <for>for <control>(<init><expr><name>kk</name> <operator>=</operator> <name>k</name><operator>+</operator><literal type="number">1</literal></expr> ;</init> <condition><expr><name>kk</name> <operator>&lt;=</operator> <name>cnvec</name></expr> ;</condition> <incr><expr><name>kk</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content> 
                    <expr_stmt><expr><name><name>Cp</name> <index>[<expr><name>kk</name></expr>]</index></name> <operator>=</operator> <name><name>Ap</name> <index>[<expr><name>kk</name></expr>]</index></name> <operator>-</operator> <name>ajnz</name></expr> ;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></else></if_stmt>
            <comment type="line">// Ci [0:pstart-1] = Ai [0:pstart-1]</comment>
            <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Ci</name></expr></argument>, <argument><expr><name>Ai</name></expr></argument>, <argument><expr><name>pstart</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <comment type="line">// Ci [pstart:cnz-1] = Ai [pend:anz-1]</comment>
            <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Ci</name> <operator>+</operator> <name>pstart</name></expr></argument>, <argument><expr><name>Ai</name> <operator>+</operator> <name>pend</name></expr></argument>,
                <argument><expr><operator>(</operator><name>cnz</name> <operator>-</operator> <name>pstart</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>A_iso</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Cx [0:pstart-1] = Ax [0:pstart-1]</comment>
                <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Cx</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pstart</name> <operator>*</operator> <name>asize</name></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <comment type="line">// Cx [pstart:cnz-1] = Ax [pend:anz-1]</comment>
                <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Cx</name> <operator>+</operator> <name>pstart</name> <operator>*</operator> <name>asize</name></expr></argument>, <argument><expr><name>Ax</name> <operator>+</operator> <name>pend</name> <operator>*</operator> <name>asize</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>cnz</name> <operator>-</operator> <name>pstart</name><operator>)</operator> <operator>*</operator> <name>asize</name></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>

        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>GB_COLLE_idxunop_code</name></expr>)</condition>
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// COLLE: C = A (:, 0:j)</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <if_stmt><if>if <condition>(<expr><name>A_is_hyper</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Cp [0:cnvec] = Ap [0:cnvec]</comment>
                <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Cp</name></expr></argument>, <argument><expr><name>Ap</name></expr></argument>, <argument><expr><operator>(</operator><name>cnvec</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <comment type="line">// Ch [0:cnvec-1] = Ah [0:cnvec-1]</comment>
                <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Ch</name></expr></argument>, <argument><expr><name>Ah</name></expr></argument>, <argument><expr><operator>(</operator><name>cnvec</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="line">// Cp [0:k+1] = Ap [0:k+1]</comment>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Cp</name></expr></argument>, <argument><expr><name>Ap</name></expr></argument>, <argument><expr><operator>(</operator><name>k</name><operator>+</operator><literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <comment type="line">// Cp [k+2:cnvec] = cnz</comment>
                <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nth2</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
                <for>for <control>(<init><expr><name>kk</name> <operator>=</operator> <name>k</name><operator>+</operator><literal type="number">2</literal></expr> ;</init> <condition><expr><name>kk</name> <operator>&lt;=</operator> <name>cnvec</name></expr> ;</condition> <incr><expr><name>kk</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content> 
                    <expr_stmt><expr><name><name>Cp</name> <index>[<expr><name>kk</name></expr>]</index></name> <operator>=</operator> <name>cnz</name></expr> ;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></else></if_stmt>
            <comment type="line">// Ci [0:cnz-1] = Ai [0:cnz-1]</comment>
            <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Ci</name></expr></argument>, <argument><expr><name>Ai</name></expr></argument>, <argument><expr><name>cnz</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>A_iso</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Cx [0:cnz-1] = Ax [0:cnz-1]</comment>
                <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Cx</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>cnz</name> <operator>*</operator> <name>asize</name></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>

        </block_content>}</block></if>
        <else>else <comment type="line">// (opcode == GB_COLGT_idxunop_code)</comment>
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// COLGT: C = A (:, j+1:end)</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <if_stmt><if>if <condition>(<expr><name>A_is_hyper</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Cp [0:cnvec] = Ap [k+found:anvec] - pend</comment>
                <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nth2</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
                <for>for <control>(<init><expr><name>kk</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>kk</name> <operator>&lt;=</operator> <name>cnvec</name></expr> ;</condition> <incr><expr><name>kk</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content> 
                    <expr_stmt><expr><name><name>Cp</name> <index>[<expr><name>kk</name></expr>]</index></name> <operator>=</operator> <name><name>Ap</name> <index>[<expr><name>kk</name> <operator>+</operator> <name>k</name> <operator>+</operator> <name>found</name></expr>]</index></name> <operator>-</operator> <name>pend</name></expr> ;</expr_stmt>
                </block_content>}</block></for>
                <comment type="line">// Ch [0:cnvec-1] = Ah [k+found:anvec-1]</comment>
                <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Ch</name></expr></argument>, <argument><expr><name>Ah</name> <operator>+</operator> <name>k</name> <operator>+</operator> <name>found</name></expr></argument>, <argument><expr><name>cnvec</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <comment type="line">// Cp [0:k] = 0</comment>
                <expr_stmt><expr><call><name>GB_memset</name> <argument_list>(<argument><expr><name>Cp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>k</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <comment type="line">// Cp [k+1:cnvec] = Ap [k+1:cnvec] - pend</comment>
                <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nth2</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
                <for>for <control>(<init><expr><name>kk</name> <operator>=</operator> <name>k</name><operator>+</operator><literal type="number">1</literal></expr> ;</init> <condition><expr><name>kk</name> <operator>&lt;=</operator> <name>cnvec</name></expr> ;</condition> <incr><expr><name>kk</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content> 
                    <expr_stmt><expr><name><name>Cp</name> <index>[<expr><name>kk</name></expr>]</index></name> <operator>=</operator> <name><name>Ap</name> <index>[<expr><name>kk</name></expr>]</index></name> <operator>-</operator> <name>pend</name></expr> ;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></else></if_stmt>
            <comment type="line">// Ci [0:cnz-1] = Ai [pend:anz-1]</comment>
            <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Ci</name></expr></argument>, <argument><expr><name>Ai</name> <operator>+</operator> <name>pend</name></expr></argument>, <argument><expr><name>cnz</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>A_iso</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Cx [0:cnz-1] = Ax [pend:anz-1]</comment>
                <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Cx</name></expr></argument>, <argument><expr><name>Ax</name> <operator>+</operator> <name>pend</name> <operator>*</operator> <name>asize</name></expr></argument>, <argument><expr><name>cnz</name> <operator>*</operator> <name>asize</name></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// finalize the matrix, free workspace, and return result</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>nvec</name></name> <operator>=</operator> <name>cnvec</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>GB_MAGIC</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>jumbled</name></name> <operator>=</operator> <name>A_jumbled</name></expr> ;</expr_stmt>    <comment type="line">// C is jumbled if A is jumbled</comment>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>iso</name></name> <operator>=</operator> <name>C_iso</name></expr> ;</expr_stmt>            <comment type="line">// OK: burble already done above</comment>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>nvals</name></name> <operator>=</operator> <name><name>Cp</name> <index>[<expr><name>cnvec</name></expr>]</index></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>=</operator> <call><name>GB_nvec_nonempty</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C output for GB_selector (column select)"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//==========================================================================</comment>
    <comment type="line">// all other select/idxunop operators</comment>
    <comment type="line">//==========================================================================</comment>

    <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_FREE_ALL</name></cpp:undef>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_ALL</name></cpp:macro>                         \
    <cpp:value>{                                           \
        GB_phybix_free (C) ;                    \
        GB_FREE_WORKSPACE ;                     \
    }</cpp:value></cpp:define>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// allocate the new vector pointers of C</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>cnz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>cplen</name> <init>= <expr><call><name>GB_IMAX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>anvec</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <expr_stmt><expr><name>Cp</name> <operator>=</operator> <call><name>GB_CALLOC</name> <argument_list>(<argument><expr><name>cplen</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Cp_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>Cp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// out of memory</comment>
        <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// slice the entries for each task</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>A_ntasks</name></decl>, <decl><type ref="prev"/><name>A_nthreads</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>work</name> <init>= <expr><literal type="number">8</literal><operator>*</operator><name>anvec</name>
        <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>opcode</name> <operator>==</operator> <name>GB_DIAG_selop_code</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>GB_nnz_held</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>GB_SLICE_MATRIX_WORK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>work</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// allocate workspace for each task</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_WERK_PUSH</name> <argument_list>(<argument><expr><name>Work</name></expr></argument>, <argument><expr><literal type="number">3</literal><operator>*</operator><name>A_ntasks</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>Work</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// out of memory</comment>
        <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
        <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>Wfirst</name>    <operator>=</operator> <name>Work</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name>Wlast</name>     <operator>=</operator> <name>Work</name> <operator>+</operator> <name>A_ntasks</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name>Cp_kfirst</name> <operator>=</operator> <name>Work</name> <operator>+</operator> <name>A_ntasks</name> <operator>*</operator> <literal type="number">2</literal></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// allocate workspace for phase1</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// phase1 counts the number of live entries in each vector of A.  The</comment>
    <comment type="line">// result is computed in Cp, where Cp [k] is the number of live entries in</comment>
    <comment type="line">// the kth vector of A.  Zp [k] is the location of the A(i,k) entry, for</comment>
    <comment type="line">// positional operators.</comment>

    <if_stmt><if>if <condition>(<expr><name>op_is_positional</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// allocate Zp</comment>
        <expr_stmt><expr><name>Zp</name> <operator>=</operator> <call><name>GB_MALLOC_WORK</name> <argument_list>(<argument><expr><name>cplen</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Zp_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>Zp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// out of memory</comment>
            <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
            <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// phase1: count the live entries in each column</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// define the worker for the switch factory</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SELECT_PHASE1</name></cpp:macro></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_sel1</name><parameter_list>(<parameter><type><name>opname</name></type></parameter>,<parameter><type><name>aname</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GB (_sel_phase1_ ## opname ## aname)</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SEL_WORKER</name><parameter_list>(<parameter><type><name>opname</name></type></parameter>,<parameter><type><name>aname</name></type></parameter>,<parameter><type><name>atype</name></type></parameter>)</parameter_list></cpp:macro>                               \
    <cpp:value>{                                                                       \
        GB_sel1 (opname, aname) (Zp, Cp, Wfirst, Wlast, A,                  \
            flipij, ithunk, (atype *) athunk, ythunk, op,                   \
            A_ek_slicing, A_ntasks, A_nthreads) ;                           \
    }                                                                       \
    break ;</cpp:value></cpp:define>

    <comment type="line">// launch the switch factory</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>GB_Type_code</name></type> <name>typecode</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>A_iso</name><operator>)</operator></expr> ?</condition><then> <expr><name>GB_ignore_code</name></expr> </then><else>: <expr><name>acode</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_select_factory.c"</cpp:file></cpp:include>

    <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_SELECT_PHASE1</name></cpp:undef>
    <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_SEL_WORKER</name></cpp:undef>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// cumulative sum of Cp and compute Cp_kfirst</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>C_nvec_nonempty</name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>GB_ek_slice_merge2</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>C_nvec_nonempty</name></expr></argument>, <argument><expr><name>Cp_kfirst</name></expr></argument>, <argument><expr><name>Cp</name></expr></argument>, <argument><expr><name>anvec</name></expr></argument>,
        <argument><expr><name>Wfirst</name></expr></argument>, <argument><expr><name>Wlast</name></expr></argument>, <argument><expr><name>A_ek_slicing</name></expr></argument>, <argument><expr><name>A_ntasks</name></expr></argument>, <argument><expr><name>A_nthreads</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// allocate new space for the compacted Ci and Cx</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><name>cnz</name> <operator>=</operator> <name><name>Cp</name> <index>[<expr><name>anvec</name></expr>]</index></name></expr> ;</expr_stmt>
    <expr_stmt><expr><name>cnz</name> <operator>=</operator> <call><name>GB_IMAX</name> <argument_list>(<argument><expr><name>cnz</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><name>Ci</name> <operator>=</operator> <call><name>GB_MALLOC</name> <argument_list>(<argument><expr><name>cnz</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ci_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <comment type="line">// use calloc since C is sparse, not bitmap</comment>
    <expr_stmt><expr><name>Cx</name> <operator>=</operator> <operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <call><name>GB_XALLOC</name> <argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>C_iso</name></expr></argument>, <argument><expr><name>cnz</name></expr></argument>, <argument><expr><name>asize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Cx_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <comment type="line">// x:OK</comment>
    <if_stmt><if>if <condition>(<expr><name>Ci</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>Cx</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// out of memory</comment>
        <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
        <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// set the iso value of C</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>C_iso</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// The pattern of C is computed by the worker below, for the DIAG,</comment>
        <comment type="line">// OFFDIAG, TRIL, TRIU, NONZOMBIE, and USER select operators.</comment>
        <expr_stmt><expr><call><name>GB_iso_select</name> <argument_list>(<argument><expr><name>Cx</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>athunk</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>acode</name></expr></argument>, <argument><expr><name>asize</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// phase2: select the entries</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// define the worker for the switch factory</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SELECT_PHASE2</name></cpp:macro></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_sel2</name><parameter_list>(<parameter><type><name>opname</name></type></parameter>,<parameter><type><name>aname</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GB (_sel_phase2_ ## opname ## aname)</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SEL_WORKER</name><parameter_list>(<parameter><type><name>opname</name></type></parameter>,<parameter><type><name>aname</name></type></parameter>,<parameter><type><name>atype</name></type></parameter>)</parameter_list></cpp:macro>                               \
    <cpp:value>{                                                                       \
        GB_sel2 (opname, aname) (Ci, (atype *) Cx, Zp, Cp, Cp_kfirst, A,    \
            flipij, ithunk, (atype *) athunk, ythunk, op,                   \
            A_ek_slicing, A_ntasks, A_nthreads) ;                           \
    }                                                                       \
    break ;</cpp:value></cpp:define>

    <comment type="line">// launch the switch factory</comment>
    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_select_factory.c"</cpp:file></cpp:include>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// create the result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>in_place_A</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// transplant Cp, Ci, Cx back into A</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// TODO: this is not parallel: use GB_hyper_prune</comment>
        <if_stmt><if>if <condition>(<expr><name><name>A</name><operator>-&gt;</operator><name>h</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>C_nvec_nonempty</name> <operator>&lt;</operator> <name>anvec</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// prune empty vectors from Ah and Ap</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>cnvec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>anvec</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>Cp</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>&lt;</operator> <name><name>Cp</name> <index>[<expr><name>k</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><name><name>Ah</name> <index>[<expr><name>cnvec</name></expr>]</index></name> <operator>=</operator> <name><name>Ah</name> <index>[<expr><name>k</name></expr>]</index></name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>Ap</name> <index>[<expr><name>cnvec</name></expr>]</index></name> <operator>=</operator> <name><name>Cp</name> <index>[<expr><name>k</name></expr>]</index></name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>cnvec</name><operator>++</operator></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><name><name>Ap</name> <index>[<expr><name>cnvec</name></expr>]</index></name> <operator>=</operator> <name><name>Cp</name> <index>[<expr><name>anvec</name></expr>]</index></name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>nvec</name></name> <operator>=</operator> <name>cnvec</name></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>nvec</name></name> <operator>==</operator> <name>C_nvec_nonempty</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_FREE</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Cp</name></expr></argument>, <argument><expr><name>Cp_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <comment type="line">// the A-&gt;Y hyper_hash is now invalid</comment>
            <expr_stmt><expr><call><name>GB_hyper_hash_free</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// free the old A-&gt;p and transplant in Cp as the new A-&gt;p</comment>
            <expr_stmt><expr><call><name>GB_FREE</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Ap</name></expr></argument>, <argument><expr><name>Ap_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>Cp</name></expr> ;</expr_stmt> <expr_stmt><expr><name>Cp</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt> <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>p_size</name></name> <operator>=</operator> <name>Cp_size</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>plen</name></name> <operator>=</operator> <name>cplen</name></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Cp</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <expr_stmt><expr><call><name>GB_FREE</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Ai</name></expr></argument>, <argument><expr><name>Ai_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_FREE</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Ax</name></expr></argument>, <argument><expr><name>Ax_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <name>Ci</name></expr> ;</expr_stmt> <expr_stmt><expr><name>Ci</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt> <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>i_size</name></name> <operator>=</operator> <name>Ci_size</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name>Cx</name></expr> ;</expr_stmt> <expr_stmt><expr><name>Cx</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt> <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>x_size</name></name> <operator>=</operator> <name>Cx_size</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>=</operator> <name>C_nvec_nonempty</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>jumbled</name></name> <operator>=</operator> <name>A_jumbled</name></expr> ;</expr_stmt>        <comment type="line">// A remains jumbled (in-place select)</comment>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>iso</name></name> <operator>=</operator> <name>C_iso</name></expr> ;</expr_stmt>                <comment type="line">// OK: burble already done above</comment>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>nvals</name></name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>p</name> <index>[<expr><name><name>A</name><operator>-&gt;</operator><name>nvec</name></name></expr>]</index></name></expr> ;</expr_stmt>

        <comment type="line">// the NONZOMBIE opcode may have removed all zombies, but A-&gt;nzombie</comment>
        <comment type="line">// is still nonzero.  It is set to zero in GB_wait.</comment>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"A output for GB_selector"</literal></expr></argument>, <argument><expr><call><name>GB_FLIP</name> <argument_list>(<argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// create C and transplant Cp, Ch, Ci, Cx into C</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><name>int</name></type> <name>sparsity</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>A_is_hyper</name><operator>)</operator></expr> ?</condition><then> <expr><name>GxB_HYPERSPARSE</name></expr> </then><else>: <expr><name>GxB_SPARSE</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>static_header</name></name> <operator>||</operator> <name>GBNSTATIC</name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>GB_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>C</name></expr></argument>, <comment type="line">// sparse or hyper (from A), existing header</comment>
            <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>avlen</name></expr></argument>, <argument><expr><name>avdim</name></expr></argument>, <argument><expr><name>GB_Ap_null</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
            <argument><expr><name>sparsity</name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>hyper_switch</name></name></expr></argument>, <argument><expr><name>anvec</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>A</name><operator>-&gt;</operator><name>h</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// A and C are hypersparse: copy non-empty vectors from Ah to Ch</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <expr_stmt><expr><name>Ch</name> <operator>=</operator> <call><name>GB_MALLOC</name> <argument_list>(<argument><expr><name>anvec</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ch_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>Ch</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// out of memory</comment>
                <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
                <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// TODO: do in parallel: use GB_hyper_prune</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>cnvec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>anvec</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>Cp</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>&lt;</operator> <name><name>Cp</name> <index>[<expr><name>k</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><name><name>Ch</name> <index>[<expr><name>cnvec</name></expr>]</index></name> <operator>=</operator> <name><name>Ah</name> <index>[<expr><name>k</name></expr>]</index></name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>Cp</name> <index>[<expr><name>cnvec</name></expr>]</index></name> <operator>=</operator> <name><name>Cp</name> <index>[<expr><name>k</name></expr>]</index></name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>cnvec</name><operator>++</operator></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><name><name>Cp</name> <index>[<expr><name>cnvec</name></expr>]</index></name> <operator>=</operator> <name><name>Cp</name> <index>[<expr><name>anvec</name></expr>]</index></name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>nvec</name></name> <operator>=</operator> <name>cnvec</name></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>nvec</name></name> <operator>==</operator> <name>C_nvec_nonempty</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// note that C-&gt;Y is not yet constructed</comment>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>Cp</name></expr> ;</expr_stmt> <expr_stmt><expr><name>Cp</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt> <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>p_size</name></name> <operator>=</operator> <name>Cp_size</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name>Ch</name></expr> ;</expr_stmt> <expr_stmt><expr><name>Ch</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt> <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>h_size</name></name> <operator>=</operator> <name>Ch_size</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <name>Ci</name></expr> ;</expr_stmt> <expr_stmt><expr><name>Ci</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt> <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>i_size</name></name> <operator>=</operator> <name>Ci_size</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name>Cx</name></expr> ;</expr_stmt> <expr_stmt><expr><name>Cx</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt> <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>x_size</name></name> <operator>=</operator> <name>Cx_size</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>plen</name></name> <operator>=</operator> <name>cplen</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>GB_MAGIC</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>=</operator> <name>C_nvec_nonempty</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>jumbled</name></name> <operator>=</operator> <name>A_jumbled</name></expr> ;</expr_stmt>    <comment type="line">// C is jumbled if A is jumbled</comment>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>iso</name></name> <operator>=</operator> <name>C_iso</name></expr> ;</expr_stmt>            <comment type="line">// OK: burble already done above</comment>
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>nvals</name></name> <operator>=</operator> <name><name>C</name><operator>-&gt;</operator><name>p</name> <index>[<expr><name><name>C</name><operator>-&gt;</operator><name>nvec</name></name></expr>]</index></name></expr> ;</expr_stmt>

        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C output for GB_selector"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free workspace and return result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><name>GB_FREE_WORKSPACE</name></expr> ;</expr_stmt>
    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
