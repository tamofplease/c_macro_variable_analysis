<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_Monoid_new.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_Monoid_new: create a GrB_Monoid</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// Create a monoid with an operator, (optionally) an identity value, and</comment>
<comment type="line">// (optionally) a terminal value.  If using a built-in operator, a duplicate</comment>
<comment type="line">// boolean operator is first replaced with its unique equivalent.  If the</comment>
<comment type="line">// operator is built-in and corresponds to a known monoid, then the identity</comment>
<comment type="line">// value and terminal value provided on input are silently ignored, and the</comment>
<comment type="line">// known values are used instead.  This is to allow the use of the hard-coded</comment>
<comment type="line">// functions for built-in monoids.</comment>

<comment type="line">// User-defined monoids may have a NULL terminal value, which denotes that the</comment>
<comment type="line">// monoid does not have a terminal value.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_binop.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_Monoid_new.h"</cpp:file></cpp:include>

<function><type><name>GrB_Info</name></type> <name>GB_Monoid_new</name>          <comment type="line">// create a monoid</comment>
<parameter_list>(
    <parameter><decl><type><name>GrB_Monoid</name> <modifier>*</modifier></type><name>monoid</name></decl></parameter>,         <comment type="line">// handle of monoid to create</comment>
    <parameter><decl><type><name>GrB_BinaryOp</name></type> <name>op</name></decl></parameter>,            <comment type="line">// binary operator of the monoid</comment>
    <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>identity</name></decl></parameter>,       <comment type="line">// identity value, if any</comment>
    <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>terminal</name></decl></parameter>,       <comment type="line">// terminal value, if any (may be NULL)</comment>
    <parameter><decl><type><name>GB_Type_code</name></type> <name>idcode</name></decl></parameter>,        <comment type="line">// identity and terminal type code</comment>
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_RETURN_IF_NULL</name> <argument_list>(<argument><expr><name>monoid</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>monoid</name><operator>)</operator> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_RETURN_IF_NULL</name> <argument_list>(<argument><expr><name>identity</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_RETURN_IF_NULL_OR_FAULTY</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT_BINARYOP_OK</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"op for monoid"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>idcode</name> <operator>&lt;=</operator> <name>GB_UDT_code</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// rename built-in binary operators</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// If the user requests the creation of a monoid based on a duplicate</comment>
    <comment type="line">// built-in binary operator, the unique boolean operator is used instead.</comment>
    <comment type="line">// See also GB_boolean_rename, which does this for opcodes, not operators.</comment>

    <expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>GB_boolean_rename_op</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_BINARYOP_OK</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"revised op"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// continue checking inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// check operator types; all must be identical, and the operator cannot</comment>
    <comment type="line">// be positional</comment>
    <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>xtype</name></name> <operator>!=</operator> <name><name>op</name><operator>-&gt;</operator><name>ztype</name></name> <operator>||</operator> <name><name>op</name><operator>-&gt;</operator><name>ytype</name></name> <operator>!=</operator> <name><name>op</name><operator>-&gt;</operator><name>ztype</name></name> <operator>||</operator>
        <call><name>GB_OP_IS_POSITIONAL</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content> 
        <return>return <expr><operator>(</operator><name>GrB_DOMAIN_MISMATCH</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// The idcode must match the monoid-&gt;op-&gt;ztype-&gt;code for built-in types,</comment>
    <comment type="line">// and this can be rigourously checked.  For all user-defined types,</comment>
    <comment type="line">// identity is a mere void * pointer, and its actual type cannot be</comment>
    <comment type="line">// compared with the input op-&gt;ztype parameter.  Only the type code,</comment>
    <comment type="line">// GB_UDT_code, can be checked to see if it matches.  In</comment>
    <comment type="line">// that case, all that is known is that identity is a void * pointer that</comment>
    <comment type="line">// points to something; it must a scalar of the proper user-defined type.</comment>

    <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>zcode</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>ztype</name><operator>-&gt;</operator><name>code</name></name></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>idcode</name> <operator>!=</operator> <name>zcode</name></expr>)</condition>
    <block>{<block_content> 
        <return>return <expr><operator>(</operator><name>GrB_DOMAIN_MISMATCH</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// create the monoid</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// allocate the monoid</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>header_size</name></decl> ;</decl_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>monoid</name><operator>)</operator> <operator>=</operator> <call><name>GB_MALLOC</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr>struct <name>GB_Monoid_opaque</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>monoid</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// out of memory</comment>
        <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// initialize the monoid</comment>
    <decl_stmt><decl><type><name>GrB_Monoid</name></type> <name>mon</name> <init>= <expr><operator>*</operator><name>monoid</name></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><name><name>mon</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>GB_MAGIC</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>mon</name><operator>-&gt;</operator><name>header_size</name></name> <operator>=</operator> <name>header_size</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>mon</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>op</name></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>zsize</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>ztype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><name><name>mon</name><operator>-&gt;</operator><name>identity</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>                  <comment type="line">// defined below (if present)</comment>
    <expr_stmt><expr><name><name>mon</name><operator>-&gt;</operator><name>terminal</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>                  <comment type="line">// defined below (if present)</comment>
    <expr_stmt><expr><name><name>mon</name><operator>-&gt;</operator><name>identity_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>mon</name><operator>-&gt;</operator><name>terminal_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// allocation of identity and terminal values</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// allocate the identity value</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_ALLOC_IDENTITY</name></cpp:macro>                                               \
    <cpp:value>{                                                                       \
        mon-&gt;identity = GB_MALLOC (zsize, GB_void, &amp;(mon-&gt;identity_size)) ; \
        if (mon-&gt;identity == NULL)                                          \
        {                                                                   \
            <comment type="block">/* out of memory */</comment>                                             \
            GB_FREE (&amp;(mon-&gt;terminal), mon-&gt;terminal_size) ;                \
            GB_FREE (monoid, header_size) ;                                 \
            return (GrB_OUT_OF_MEMORY) ;                                    \
        }                                                                   \
    }</cpp:value></cpp:define>

    <comment type="line">// allocate the terminal value</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_ALLOC_TERMINAL</name></cpp:macro>                                               \
    <cpp:value>{                                                                       \
        mon-&gt;terminal = GB_MALLOC (zsize, GB_void, &amp;(mon-&gt;terminal_size)) ; \
        if (mon-&gt;terminal == NULL)                                          \
        {                                                                   \
            <comment type="block">/* out of memory */</comment>                                             \
            GB_FREE (&amp;(mon-&gt;identity), mon-&gt;identity_size) ;                \
            GB_FREE (monoid, header_size) ;                                 \
            return (GrB_OUT_OF_MEMORY) ;                                    \
        }                                                                   \
    }</cpp:value></cpp:define>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// create a user-defined monoid based on a known built-in monoid</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>

    <comment type="line">// If the user requests the creation of a monoid based on a built-in</comment>
    <comment type="line">// operator that corresponds to known built-in monoid, the identity and</comment>
    <comment type="line">// terminal values provided by the user to GrB_Monoid_new are ignored,</comment>
    <comment type="line">// since these are all handled by the same hard-coded functions as the</comment>
    <comment type="line">// built-in monoids based on the same operator.</comment>

    <comment type="line">// All of the monoids created in the switch statement below have non-NULL</comment>
    <comment type="line">// identity values; some have terminal values and some do not.</comment>

    <comment type="line">// create a monoid with both an identity and a terminal value,</comment>
    <comment type="line">// based on a built-in operator that is a known monoid</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IT</name><parameter_list>(<parameter><type><name>ztype</name></type></parameter>,<parameter><type><name>identity_value</name></type></parameter>,<parameter><type><name>terminal_value</name></type></parameter>)</parameter_list></cpp:macro>                      \
    <cpp:value>{                                                                       \
        GB_ALLOC_TERMINAL ;                                                 \
        GB_ALLOC_IDENTITY ;                                                 \
        ztype *identity = (ztype *) mon-&gt;identity ;                         \
        ztype *terminal = (ztype *) mon-&gt;terminal ;                         \
        (*identity) = identity_value ;                                      \
        (*terminal) = terminal_value ;                                      \
        done = true ;                                                       \
    }                                                                       \
    break ;</cpp:value></cpp:define>

    <comment type="line">// create a monoid with just an identity but no terminal value,</comment>
    <comment type="line">// based on a built-in operator that is a known monoid</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IN</name><parameter_list>(<parameter><type><name>ztype</name></type></parameter>,<parameter><type><name>identity_value</name></type></parameter>)</parameter_list></cpp:macro>                                     \
    <cpp:value>{                                                                       \
        GB_ALLOC_IDENTITY ;                                                 \
        ztype *identity = (ztype *) mon-&gt;identity ;                         \
        (*identity) = identity_value ;                                      \
        done = true ;                                                       \
    }                                                                       \
    break ;</cpp:value></cpp:define>

    <switch>switch <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>opcode</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>GB_MIN_binop_code</name></expr> :</case> 

            <comment type="line">// MIN monoid:  identity is +inf, terminal is -inf</comment>
            <comment type="line">// note there is no MIN monoid for complex types</comment>
            <switch>switch <condition>(<expr><name>zcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_IT</name> <argument_list>(<argument>int8_t</argument>  , <argument>INT8_MAX</argument>  , <argument>INT8_MIN</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_IT</name> <argument_list>(<argument>int16_t</argument> , <argument>INT16_MAX</argument> , <argument>INT16_MIN</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_IT</name> <argument_list>(<argument>int32_t</argument> , <argument>INT32_MAX</argument> , <argument>INT32_MIN</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_IT</name> <argument_list>(<argument>int64_t</argument> , <argument>INT64_MAX</argument> , <argument>INT64_MIN</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_IT</name> <argument_list>(<argument>uint8_t</argument> , <argument>UINT8_MAX</argument> , <argument><literal type="number">0</literal></argument>         )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_IT</name> <argument_list>(<argument>uint16_t</argument>, <argument>UINT16_MAX</argument>, <argument><literal type="number">0</literal></argument>         )</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_IT</name> <argument_list>(<argument>uint32_t</argument>, <argument>UINT32_MAX</argument>, <argument><literal type="number">0</literal></argument>         )</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_IT</name> <argument_list>(<argument>uint64_t</argument>, <argument>UINT64_MAX</argument>, <argument><literal type="number">0</literal></argument>         )</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_IT</name> <argument_list>(<argument>float</argument>   , <argument>INFINITY</argument>  , <argument>-INFINITY</argument> )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_IT</name> <argument_list>(<argument>double</argument>  , <argument>((double)  INFINITY)</argument>  ,
                                                       <argument>((double) -INFINITY)</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <case>case <expr><name>GB_MAX_binop_code</name></expr> :</case> 

            <comment type="line">// MAX monoid:  identity is -inf, terminal is +inf</comment>
            <comment type="line">// note there is no MAX monoid for complex types</comment>
            <switch>switch <condition>(<expr><name>zcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_IT</name> <argument_list>(<argument>int8_t</argument>  , <argument>INT8_MIN</argument>  , <argument>INT8_MAX</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_IT</name> <argument_list>(<argument>int16_t</argument> , <argument>INT16_MIN</argument> , <argument>INT16_MAX</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_IT</name> <argument_list>(<argument>int32_t</argument> , <argument>INT32_MIN</argument> , <argument>INT32_MAX</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_IT</name> <argument_list>(<argument>int64_t</argument> , <argument>INT64_MIN</argument> , <argument>INT64_MAX</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_IT</name> <argument_list>(<argument>uint8_t</argument> , <argument><literal type="number">0</literal></argument>         , <argument>UINT8_MAX</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_IT</name> <argument_list>(<argument>uint16_t</argument>, <argument><literal type="number">0</literal></argument>         , <argument>UINT16_MAX</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_IT</name> <argument_list>(<argument>uint32_t</argument>, <argument><literal type="number">0</literal></argument>         , <argument>UINT32_MAX</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_IT</name> <argument_list>(<argument>uint64_t</argument>, <argument><literal type="number">0</literal></argument>         , <argument>UINT64_MAX</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_IT</name> <argument_list>(<argument>float</argument>   , <argument>-INFINITY</argument> , <argument>INFINITY</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_IT</name> <argument_list>(<argument>double</argument>  , <argument>((double) -INFINITY)</argument>  ,
                                                       <argument>((double)  INFINITY)</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <case>case <expr><name>GB_PLUS_binop_code</name></expr> :</case> 

            <comment type="line">// PLUS monoid:  identity is zero, no terminal value</comment>
            <switch>switch <condition>(<expr><name>zcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_IN</name> <argument_list>(<argument>int8_t</argument>  , <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_IN</name> <argument_list>(<argument>int16_t</argument> , <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_IN</name> <argument_list>(<argument>int32_t</argument> , <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_IN</name> <argument_list>(<argument>int64_t</argument> , <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_IN</name> <argument_list>(<argument>uint8_t</argument> , <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_IN</name> <argument_list>(<argument>uint16_t</argument>, <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_IN</name> <argument_list>(<argument>uint32_t</argument>, <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_IN</name> <argument_list>(<argument>uint64_t</argument>, <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_IN</name> <argument_list>(<argument>float</argument>   , <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_IN</name> <argument_list>(<argument>double</argument>  , <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_IN</name> <argument_list>(<argument>GxB_FC32_t</argument>, <argument>GxB_CMPLXF(<literal type="number">0</literal>,<literal type="number">0</literal>)</argument> )</argument_list></macro>
                <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_IN</name> <argument_list>(<argument>GxB_FC64_t</argument>, <argument>GxB_CMPLX(<literal type="number">0</literal>,<literal type="number">0</literal>)</argument> )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <case>case <expr><name>GB_TIMES_binop_code</name></expr> :</case> 

            <comment type="line">// TIMES monoid:  identity is 1, no terminal value</comment>
            <switch>switch <condition>(<expr><name>zcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_IN</name> <argument_list>(<argument>int8_t</argument>  , <argument><literal type="number">1</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_IN</name> <argument_list>(<argument>int16_t</argument> , <argument><literal type="number">1</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_IN</name> <argument_list>(<argument>int32_t</argument> , <argument><literal type="number">1</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_IN</name> <argument_list>(<argument>int64_t</argument> , <argument><literal type="number">1</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_IN</name> <argument_list>(<argument>uint8_t</argument> , <argument><literal type="number">1</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_IN</name> <argument_list>(<argument>uint16_t</argument>, <argument><literal type="number">1</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_IN</name> <argument_list>(<argument>uint32_t</argument>, <argument><literal type="number">1</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_IN</name> <argument_list>(<argument>uint64_t</argument>, <argument><literal type="number">1</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_IN</name> <argument_list>(<argument>float</argument>   , <argument><literal type="number">1</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_IN</name> <argument_list>(<argument>double</argument>  , <argument><literal type="number">1</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_IN</name> <argument_list>(<argument>GxB_FC32_t</argument>, <argument>GxB_CMPLXF(<literal type="number">1</literal>,<literal type="number">0</literal>)</argument> )</argument_list></macro>
                <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_IN</name> <argument_list>(<argument>GxB_FC64_t</argument>, <argument>GxB_CMPLX(<literal type="number">1</literal>,<literal type="number">0</literal>)</argument> )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <case>case <expr><name>GB_ANY_binop_code</name></expr> :</case> 

            <comment type="line">// ANY monoid:  identity is anything, terminal value is anything</comment>
            <switch>switch <condition>(<expr><name>zcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> <macro><name>GB_IT</name> <argument_list>(<argument>bool</argument>    , <argument><literal type="number">0</literal></argument>, <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_IT</name> <argument_list>(<argument>int8_t</argument>  , <argument><literal type="number">0</literal></argument>, <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_IT</name> <argument_list>(<argument>int16_t</argument> , <argument><literal type="number">0</literal></argument>, <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_IT</name> <argument_list>(<argument>int32_t</argument> , <argument><literal type="number">0</literal></argument>, <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_IT</name> <argument_list>(<argument>int64_t</argument> , <argument><literal type="number">0</literal></argument>, <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_IT</name> <argument_list>(<argument>uint8_t</argument> , <argument><literal type="number">0</literal></argument>, <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_IT</name> <argument_list>(<argument>uint16_t</argument>, <argument><literal type="number">0</literal></argument>, <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_IT</name> <argument_list>(<argument>uint32_t</argument>, <argument><literal type="number">0</literal></argument>, <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_IT</name> <argument_list>(<argument>uint64_t</argument>, <argument><literal type="number">0</literal></argument>, <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_IT</name> <argument_list>(<argument>float</argument>   , <argument><literal type="number">0</literal></argument>, <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_IT</name> <argument_list>(<argument>double</argument>  , <argument><literal type="number">0</literal></argument>, <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_FC32_code</name></expr>   :</case> 
                    <macro><name>GB_IT</name> <argument_list>(<argument>GxB_FC32_t</argument>, <argument>GxB_CMPLXF(<literal type="number">0</literal>,<literal type="number">0</literal>)</argument>, <argument>GxB_CMPLXF(<literal type="number">0</literal>,<literal type="number">0</literal>)</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FC64_code</name></expr>   :</case> 
                    <macro><name>GB_IT</name> <argument_list>(<argument>GxB_FC64_t</argument>, <argument>GxB_CMPLX(<literal type="number">0</literal>,<literal type="number">0</literal>)</argument>, <argument>GxB_CMPLX(<literal type="number">0</literal>,<literal type="number">0</literal>)</argument>)</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <case>case <expr><name>GB_LOR_binop_code</name></expr> :</case> 

            <comment type="line">// boolean OR monoid:  identity is false, terminal is true</comment>
            <if_stmt><if>if <condition>(<expr><name>zcode</name> <operator>==</operator> <name>GB_BOOL_code</name></expr>)</condition><block type="pseudo"><block_content> <macro><name>GB_IT</name> <argument_list>(<argument>bool</argument>, <argument>false</argument>, <argument>true</argument>)</argument_list></macro>

        <case>case <expr><name>GB_LAND_binop_code</name></expr> :</case> 

            <comment type="line">// boolean AND monoid:  identity is true, terminal is false</comment>
            <if_stmt><if>if <condition>(<expr><name>zcode</name> <operator>==</operator> <name>GB_BOOL_code</name></expr>)</condition><block type="pseudo"><block_content> <macro><name>GB_IT</name> <argument_list>(<argument>bool</argument>, <argument>true</argument>, <argument>false</argument>)</argument_list></macro>

        <case>case <expr><name>GB_LXOR_binop_code</name></expr> :</case> 

            <comment type="line">// boolean XOR monoid:  identity is false, no terminal value</comment>
            <if_stmt><if>if <condition>(<expr><name>zcode</name> <operator>==</operator> <name>GB_BOOL_code</name></expr>)</condition><block type="pseudo"><block_content> <macro><name>GB_IN</name> <argument_list>(<argument>bool</argument>, <argument>false</argument>)</argument_list></macro>

        <case>case <expr><name>GB_EQ_binop_code</name></expr> :</case> 

            <comment type="line">// boolean EQ monoid:  identity is true, no terminal value</comment>
            <if_stmt><if>if <condition>(<expr><name>zcode</name> <operator>==</operator> <name>GB_BOOL_code</name></expr>)</condition><block type="pseudo"><block_content> <macro><name>GB_IN</name> <argument_list>(<argument>bool</argument>, <argument>true</argument>)</argument_list></macro>

        <case>case <expr><name>GB_BOR_binop_code</name></expr>      :</case> 

            <comment type="line">// BOR monoids (bitwise or):</comment>
            <switch>switch <condition>(<expr><name>zcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_IT</name> <argument_list>(<argument>uint8_t</argument> , <argument><literal type="number">0</literal></argument>, <argument><literal type="number">0xFF</literal></argument>               )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_IT</name> <argument_list>(<argument>uint16_t</argument>, <argument><literal type="number">0</literal></argument>, <argument><literal type="number">0xFFFF</literal></argument>             )</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_IT</name> <argument_list>(<argument>uint32_t</argument>, <argument><literal type="number">0</literal></argument>, <argument><literal type="number">0xFFFFFFFF</literal></argument>         )</argument_list></macro> 
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_IT</name> <argument_list>(<argument>uint64_t</argument>, <argument><literal type="number">0</literal></argument>, <argument><literal type="number">0xFFFFFFFFFFFFFFFF</literal></argument> )</argument_list></macro> 
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
            <break>break ;</break>

        <case>case <expr><name>GB_BAND_binop_code</name></expr>     :</case> 

            <comment type="line">// BAND monoids (bitwise and):</comment>
            <switch>switch <condition>(<expr><name>zcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_IT</name> <argument_list>(<argument>uint8_t</argument> , <argument><literal type="number">0xFF</literal></argument>              , <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_IT</name> <argument_list>(<argument>uint16_t</argument>, <argument><literal type="number">0xFFFF</literal></argument>            , <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_IT</name> <argument_list>(<argument>uint32_t</argument>, <argument><literal type="number">0xFFFFFFFF</literal></argument>        , <argument><literal type="number">0</literal></argument> )</argument_list></macro> 
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_IT</name> <argument_list>(<argument>uint64_t</argument>, <argument><literal type="number">0xFFFFFFFFFFFFFFFF</literal></argument>, <argument><literal type="number">0</literal></argument> )</argument_list></macro> 
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <case>case <expr><name>GB_BXOR_binop_code</name></expr>     :</case> 

            <comment type="line">// BXOR monoids (bitwise xor): not terminal</comment>
            <switch>switch <condition>(<expr><name>zcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_IN</name> <argument_list>(<argument>uint8_t</argument> , <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_IN</name> <argument_list>(<argument>uint16_t</argument>, <argument><literal type="number">0</literal></argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_IN</name> <argument_list>(<argument>uint32_t</argument>, <argument><literal type="number">0</literal></argument> )</argument_list></macro> 
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_IN</name> <argument_list>(<argument>uint64_t</argument>, <argument><literal type="number">0</literal></argument> )</argument_list></macro> 
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <case>case <expr><name>GB_BXNOR_binop_code</name></expr>    :</case> 

            <comment type="line">// BXNOR monoids (bitwise xnor): not terminal</comment>
            <switch>switch <condition>(<expr><name>zcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_IN</name> <argument_list>(<argument>uint8_t</argument> , <argument><literal type="number">0xFF</literal></argument>               )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_IN</name> <argument_list>(<argument>uint16_t</argument>, <argument><literal type="number">0xFFFF</literal></argument>             )</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_IN</name> <argument_list>(<argument>uint32_t</argument>, <argument><literal type="number">0xFFFFFFFF</literal></argument>         )</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_IN</name> <argument_list>(<argument>uint64_t</argument>, <argument><literal type="number">0xFFFFFFFFFFFFFFFF</literal></argument> )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <default>default :</default> <empty_stmt>;</empty_stmt>

            <comment type="line">// monoid identity and terminal value defined below</comment>
    </block_content>}</block></switch>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// user-defined operators or unknown monoids</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// The monoid is based on a user-defined operator, or on a built-in</comment>
    <comment type="line">// operator that is not a known monoid.  Use the identity and terminal</comment>
    <comment type="line">// values provided on input.</comment>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// create the monoid identity value</comment>
        <expr_stmt><expr><name>GB_ALLOC_IDENTITY</name></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name><name>mon</name><operator>-&gt;</operator><name>identity</name></name></expr></argument>, <argument><expr><name>identity</name></expr></argument>, <argument><expr><name>zsize</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>terminal</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// create the monoid terminal value</comment>
            <expr_stmt><expr><name>GB_ALLOC_TERMINAL</name></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name><name>mon</name><operator>-&gt;</operator><name>terminal</name></name></expr></argument>, <argument><expr><name>terminal</name></expr></argument>, <argument><expr><name>zsize</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ASSERT_MONOID_OK</name> <argument_list>(<argument><expr><name>mon</name></expr></argument>, <argument><expr><literal type="string">"new monoid"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
