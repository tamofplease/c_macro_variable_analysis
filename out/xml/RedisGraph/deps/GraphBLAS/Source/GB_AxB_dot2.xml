<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_AxB_dot2.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_AxB_dot2: compute C&lt;#M&gt;=A'*B, C is bitmap, or C&lt;#M&gt;=A*B (C bitmap/full)</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// This method always constructs C as bitmap; it then converts C to sparse or</comment>
<comment type="line">// hyper if A or B are hypersparse.  The C&lt;M&gt;=A'*B dot product when C is sparse</comment>
<comment type="line">// is computed by GB_AxB_dot3.  This method handles the case when C is bitmap.</comment>

<comment type="line">// If A_not_transposed is true, then C=A*B is computed for GB_AxB_saxpy.  A is</comment>
<comment type="line">// bitmap or full, and the dot product method accesses A with a different</comment>
<comment type="line">// stride than when computing C=A'*B.</comment>

<comment type="line">// TODO:  this is slower than it could be if A and B are both bitmap/full, when</comment>
<comment type="line">// A-&gt;vlen is large.  This is because the inner loop is a simple full/bitmap</comment>
<comment type="line">// dot product, across the entire input vectors.  No tiling is used, so cache</comment>
<comment type="line">// performance is not as good as it could be.  For large problems, C=(A')*B is</comment>
<comment type="line">// faster with the saxpy3 method, as compared to this method with C=A'*B.</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_ALL</name></cpp:macro>                         \
<cpp:value>{                                           \
    GB_Matrix_free (&amp;M2) ;                  \
    GB_Matrix_free (&amp;A2) ;                  \
    GB_Matrix_free (&amp;B2) ;                  \
    GB_WERK_POP (M_ek_slicing, int64_t) ;   \
    GB_WERK_POP (B_slice, int64_t) ;        \
    GB_WERK_POP (A_slice, int64_t) ;        \
}</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_mxm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_subref.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_ek_slice.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_bitmap_assign_methods.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_stringify.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB__include1.h"</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GBCUDA_DEV</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB__include2.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>GB_PUBLIC</name>
<name>GrB_Info</name></type> <name>GB_AxB_dot2</name>                <comment type="line">// C=A'*B or C&lt;#M&gt;=A'*B, dot product method</comment>
<parameter_list>(
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,                   <comment type="line">// output matrix, static header</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>C_iso</name></decl></parameter>,               <comment type="line">// true if C is iso</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GB_void</name> <modifier>*</modifier></type><name>cscalar</name></decl></parameter>,         <comment type="line">// iso value of C</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>M_in</name></decl></parameter>,          <comment type="line">// mask matrix for C&lt;#M&gt;=A'*B, may be NULL</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_comp</name></decl></parameter>,           <comment type="line">// if true, use !M</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_struct</name></decl></parameter>,         <comment type="line">// if true, use the only structure of M</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>A_not_transposed</name></decl></parameter>,    <comment type="line">// if true, C=A*B, else C=A'*B</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A_in</name></decl></parameter>,          <comment type="line">// input matrix</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>B_in</name></decl></parameter>,          <comment type="line">// input matrix</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Semiring</name></type> <name>semiring</name></decl></parameter>,    <comment type="line">// semiring that defines C=A*B</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>flipxy</name></decl></parameter>,              <comment type="line">// if true, do z=fmult(b,a) vs fmult(a,b)</comment>
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl> ;</decl_stmt>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>static_header</name></name> <operator>||</operator> <name>GBNSTATIC</name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK_OR_NULL</name> <argument_list>(<argument><expr><name>M_in</name></expr></argument>, <argument><expr><literal type="string">"M for dot A'*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A_in</name></expr></argument>, <argument><expr><literal type="string">"A for dot A'*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>B_in</name></expr></argument>, <argument><expr><literal type="string">"B for dot A'*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>M_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>M_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>M_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>A_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_JUMBLED</name> <argument_list>(<argument><expr><name>A_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>A_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>B_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_JUMBLED</name> <argument_list>(<argument><expr><name>B_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>B_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT_SEMIRING_OK</name> <argument_list>(<argument><expr><name>semiring</name></expr></argument>, <argument><expr><literal type="string">"semiring for numeric A'*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>GB_Matrix_opaque</name></name></type> <name>A2_header</name></decl>, <decl><type ref="prev"/><name>B2_header</name></decl>, <decl><type ref="prev"/><name>M2_header</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>M</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>M2</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>A2</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>B2</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>A</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>B</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>GB_WERK_DECLARE</name> <argument_list>(<argument><expr><name>A_slice</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_WERK_DECLARE</name> <argument_list>(<argument><expr><name>B_slice</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_WERK_DECLARE</name> <argument_list>(<argument><expr><name>M_ek_slicing</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// GB_AxB_saxpy punts to this dot2 method for for C=A*B, and in this case,</comment>
    <comment type="line">// A is bitmap or full, and B is hypersparse or sparse</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>A_is_full</name> <init>= <expr><call><name>GB_as_if_full</name> <argument_list>(<argument><expr><name>A_in</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>B_is_full</name> <init>= <expr><call><name>GB_as_if_full</name> <argument_list>(<argument><expr><name>B_in</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>A_bitmap_or_full</name> <init>= <expr><operator>(</operator><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>A_in</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>A_is_full</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>B_bitmap_or_full</name> <init>= <expr><operator>(</operator><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>B_in</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>B_is_full</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><name>A_not_transposed</name></expr></argument>,
        <argument><expr><operator>(</operator><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>A_in</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GB_IS_FULL</name> <argument_list>(<argument><expr><name>A_in</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>(</operator><call><name>GB_IS_SPARSE</name> <argument_list>(<argument><expr><name>B_in</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>B_in</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// construct hyper_shallow versions of A and B, if hypersparse</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// If A_in is hypersparse, a new sparse matrix A is constructed with</comment>
    <comment type="line">// A-&gt;vdim = A_in-&gt;nvec and the same vlen as A_in, and then the</comment>
    <comment type="line">// hyper_shallow C-&gt;vlen will equal A-&gt;vdim &lt; cvlen_final.</comment>

    <comment type="line">// If B_in is hypersparse, a new sparse matrix B is constructed with</comment>
    <comment type="line">// B-&gt;vdim = B_in-&gt;nvec and the same vlen as B_in, and then the</comment>
    <comment type="line">// hyper_shallow C-&gt;vdim will equal B-&gt;vdim &lt; cvdim_final.</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>cvlen_final</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>A_not_transposed</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>A_in</name><operator>-&gt;</operator><name>vlen</name></name></expr> </then><else>: <expr><name><name>A_in</name><operator>-&gt;</operator><name>vdim</name></name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>cvdim_final</name> <init>= <expr><name><name>B_in</name><operator>-&gt;</operator><name>vdim</name></name></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>A_in</name><operator>-&gt;</operator><name>vlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>A_is_hyper</name> <init>= <expr><call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>A_in</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>B_is_hyper</name> <init>= <expr><call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>B_in</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>A_or_B_hyper</name> <init>= <expr><name>A_is_hyper</name> <operator>||</operator> <name>B_is_hyper</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Index</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ah</name> <init>= <expr><operator>(</operator><name>GrB_Index</name> <operator>*</operator><operator>)</operator> <name><name>A_in</name><operator>-&gt;</operator><name>h</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Index</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Bh</name> <init>= <expr><operator>(</operator><name>GrB_Index</name> <operator>*</operator><operator>)</operator> <name><name>B_in</name><operator>-&gt;</operator><name>h</name></name></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>A_is_hyper</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// A = hypershallow version of A_in</comment>
        <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>A2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>A2_header</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>A</name> <operator>=</operator> <call><name>GB_hyper_shallow</name> <argument_list>(<argument><expr><name>A2</name></expr></argument>, <argument><expr><name>A_in</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <comment type="line">// use A_in as-is</comment>
        <expr_stmt><expr><name>A</name> <operator>=</operator> <name>A_in</name></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>B_is_hyper</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// B = hypershallow version of B_in</comment>
        <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>B2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>B2_header</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>B</name> <operator>=</operator> <call><name>GB_hyper_shallow</name> <argument_list>(<argument><expr><name>B2</name></expr></argument>, <argument><expr><name>B_in</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <comment type="line">// use B_in as-is</comment>
        <expr_stmt><expr><name>B</name> <operator>=</operator> <name>B_in</name></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><name>A_not_transposed</name></expr></argument>, <argument><expr><operator>!</operator><name>A_is_hyper</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>A</name> <operator>==</operator> <name>A_in</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>A_is_sparse</name> <init>= <expr><call><name>GB_IS_SPARSE</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>B_is_sparse</name> <init>= <expr><call><name>GB_IS_SPARSE</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine the size of C</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>cnvec</name> <init>= <expr><name><name>B</name><operator>-&gt;</operator><name>nvec</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>cvlen</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>A_not_transposed</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>A</name><operator>-&gt;</operator><name>vlen</name></name></expr> </then><else>: <expr><name><name>A</name><operator>-&gt;</operator><name>vdim</name></name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>cvdim</name> <init>= <expr><name><name>B</name><operator>-&gt;</operator><name>vdim</name></name></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>cnz</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>ok</name> <init>= <expr><call><name>GB_int64_multiply</name> <argument_list>(<argument><expr><operator>(</operator><name>GrB_Index</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>cnz</name><operator>)</operator></expr></argument>, <argument><expr><name>cvlen</name></expr></argument>, <argument><expr><name>cvdim</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// extract the submask if A or B are hypersparse </comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>A_or_B_hyper</name> <operator>&amp;&amp;</operator> <name>M_in</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// M2 = M_in (Ah, Bh), where M2 has a static header</comment>
        <comment type="line">// if Mask_struct then M2 is extracted as iso</comment>
        <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>M2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>M2_header</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subref</name> <argument_list>(<argument><expr><name>M2</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name><name>M_in</name><operator>-&gt;</operator><name>is_csc</name></name></expr></argument>, <argument><expr><name>M_in</name></expr></argument>,
            <argument><expr><ternary><condition><expr><operator>(</operator><name>A_is_hyper</name><operator>)</operator></expr> ?</condition><then> <expr><name>Ah</name></expr> </then><else>: <expr><name>GrB_ALL</name></expr></else></ternary></expr></argument>, <argument><expr><name>cvlen</name></expr></argument>,
            <argument><expr><ternary><condition><expr><operator>(</operator><name>B_is_hyper</name><operator>)</operator></expr> ?</condition><then> <expr><name>Bh</name></expr> </then><else>: <expr><name>GrB_ALL</name></expr></else></ternary></expr></argument>, <argument><expr><name>cvdim</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>M</name> <operator>=</operator> <name>M2</name></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK_OR_NULL</name> <argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><literal type="string">"M submask dot A'*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <comment type="line">// use the mask as-is</comment>
        <expr_stmt><expr><name>M</name> <operator>=</operator> <name>M_in</name></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine the number of threads to use</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>naslice</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nbslice</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>anvec</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>A_not_transposed</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>A</name><operator>-&gt;</operator><name>vlen</name></name></expr> </then><else>: <expr><name><name>A</name><operator>-&gt;</operator><name>nvec</name></name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>anz</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator> <call><name>GB_nnz_held</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>bnvec</name> <init>= <expr><name><name>B</name><operator>-&gt;</operator><name>nvec</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>bnz</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator> <call><name>GB_nnz_held</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>double</name></type> <name>work</name></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>A_bitmap_or_full</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>B_bitmap_or_full</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// A is bitmap/full, B is sparse/hyper; only B is scanned</comment>
        <expr_stmt><expr><name>work</name> <operator>=</operator> <name>bnz</name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><name>A_bitmap_or_full</name> <operator>&amp;&amp;</operator> <name>B_bitmap_or_full</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// A is sparse/hyper, B is bitmap/full; only A is scanned</comment>
        <expr_stmt><expr><name>work</name> <operator>=</operator> <name>anz</name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>A_bitmap_or_full</name> <operator>&amp;&amp;</operator> <name>B_bitmap_or_full</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// All of A and B are scanned (unless the mask is present)</comment>
        <expr_stmt><expr><name>work</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>cnz</name><operator>)</operator> <operator>*</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name><name>B</name><operator>-&gt;</operator><name>vlen</name></name><operator>)</operator></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <comment type="line">// In this case, most of both A and B are scanned.  This is a very</comment>
        <comment type="line">// rough estimate of the work required.</comment>
        <expr_stmt><expr><name>work</name> <operator>=</operator> <literal type="number">10</literal> <operator>*</operator> <operator>(</operator><name>anz</name> <operator>+</operator> <name>bnz</name><operator>)</operator></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>GB_GET_NTHREADS_MAX</name> <argument_list>(<argument><expr><name>nthreads_max</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nthreads</name> <init>= <expr><call><name>GB_nthreads</name> <argument_list>(<argument><expr><name>work</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_NTASKS_PER_THREAD</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>

    <if_stmt><if>if <condition>(<expr><name>nthreads</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// do the entire computation with a single thread</comment>
        <expr_stmt><expr><name>naslice</name> <operator>=</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
        <expr_stmt><expr><name>nbslice</name> <operator>=</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// determine number of slices for A' and B</comment>
        <if_stmt><if>if <condition>(<expr><name>bnvec</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// C and B are single vectors</comment>
            <expr_stmt><expr><name>naslice</name> <operator>=</operator> <name>GB_NTASKS_PER_THREAD</name> <operator>*</operator> <name>nthreads</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>nbslice</name> <operator>=</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>anvec</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>bnvec</name> <operator>==</operator> <literal type="number">0</literal>
            <operator>||</operator> <name>bnvec</name> <operator>&gt;</operator> <name>GB_NTASKS_PER_THREAD</name> <operator>*</operator> <name>nthreads</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// A is a single vector, or B is empty, or B is large: just slice B</comment>
            <expr_stmt><expr><name>naslice</name> <operator>=</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
            <expr_stmt><expr><name>nbslice</name> <operator>=</operator> <name>GB_NTASKS_PER_THREAD</name> <operator>*</operator> <name>nthreads</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// slice B into individual vectors</comment>
            <expr_stmt><expr><name>nbslice</name> <operator>=</operator> <name>bnvec</name></expr> ;</expr_stmt>

            <comment type="line">// slice A' to get a total of about 16*nthreads tasks</comment>
            <expr_stmt><expr><name>naslice</name> <operator>=</operator> <operator>(</operator><name>GB_NTASKS_PER_THREAD</name> <operator>*</operator> <name>nthreads</name><operator>)</operator> <operator>/</operator> <name>nbslice</name></expr> ;</expr_stmt>

            <comment type="line">// but do not slice A too finely</comment>
            <expr_stmt><expr><name>naslice</name> <operator>=</operator> <call><name>GB_IMIN</name> <argument_list>(<argument><expr><name>naslice</name></expr></argument>, <argument><expr><name>anvec</name><operator>/</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>naslice</name> <operator>=</operator> <call><name>GB_IMAX</name> <argument_list>(<argument><expr><name>naslice</name></expr></argument>, <argument><expr><name>nthreads</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(nthreads: %d naslice %g nbslice %g) "</literal></expr></argument>, <argument><expr><name>nthreads</name></expr></argument>,
        <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>naslice</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>nbslice</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get the semiring operators</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_BinaryOp</name></type> <name>mult</name> <init>= <expr><name><name>semiring</name><operator>-&gt;</operator><name>multiply</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Monoid</name></type> <name>add</name> <init>= <expr><name><name>semiring</name><operator>-&gt;</operator><name>add</name></name></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>mult</name><operator>-&gt;</operator><name>ztype</name></name> <operator>==</operator> <name><name>add</name><operator>-&gt;</operator><name>op</name><operator>-&gt;</operator><name>ztype</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>A_is_pattern</name></decl>, <decl><type ref="prev"/><name>B_is_pattern</name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>GB_binop_pattern</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>A_is_pattern</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>B_is_pattern</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>, <argument><expr><name><name>mult</name><operator>-&gt;</operator><name>opcode</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// allocate workspace and slice A and B</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// A and B can have any sparsity: full, bitmap, sparse, or hypersparse.</comment>
    <comment type="line">// C is always created as bitmap</comment>

    <expr_stmt><expr><call><name>GB_WERK_PUSH</name> <argument_list>(<argument><expr><name>A_slice</name></expr></argument>, <argument><expr><name>naslice</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_WERK_PUSH</name> <argument_list>(<argument><expr><name>B_slice</name></expr></argument>, <argument><expr><name>nbslice</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>A_slice</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>B_slice</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><name>ok</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// out of memory</comment>
        <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
        <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>GB_pslice</name> <argument_list>(<argument><expr><name>A_slice</name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>anvec</name></expr></argument>, <argument><expr><name>naslice</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_pslice</name> <argument_list>(<argument><expr><name>B_slice</name></expr></argument>, <argument><expr><name><name>B</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>bnvec</name></expr></argument>, <argument><expr><name>nbslice</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// allocate C</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// if M is sparse/hyper, then calloc C-&gt;b; otherwise use malloc</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>M_is_sparse_or_hyper</name> <init>= <expr><operator>(</operator><name>M</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>(</operator><call><name>GB_IS_SPARSE</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Type</name></type> <name>ctype</name> <init>= <expr><name><name>add</name><operator>-&gt;</operator><name>op</name><operator>-&gt;</operator><name>ztype</name></name></expr></init></decl> ;</decl_stmt>

    <comment type="line">// determine the sparsity of C</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>C_sparsity</name> <init>= <expr><name>GxB_BITMAP</name></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>M</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// no mask is present so C can be bitmap or full</comment>
        <if_stmt><if>if <condition>(<expr><name>A_is_full</name> <operator>&amp;&amp;</operator> <name>B_is_full</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// C = A*B or A'*B, both A and B full: C is full</comment>
            <expr_stmt><expr><name>C_sparsity</name> <operator>=</operator> <name>GxB_FULL</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>A_is_full</name> <operator>&amp;&amp;</operator> <name>B_is_sparse</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// C = A*B or A'*B, where A is full and B sparse</comment>
            <if_stmt><if>if <condition>(<expr><name><name>B</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><name><name>B</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>=</operator> <call><name>GB_nvec_nonempty</name> <argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="line">// C is full if all vectors of B are present</comment>
            <expr_stmt><expr><name>C_sparsity</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>B</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>==</operator> <name><name>B</name><operator>-&gt;</operator><name>vdim</name></name><operator>)</operator></expr> ?</condition><then>
                <expr><name>GxB_FULL</name></expr> </then><else>: <expr><name>GxB_BITMAP</name></expr></else></ternary></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>A_is_sparse</name> <operator>&amp;&amp;</operator> <name>B_is_full</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// C = A'*B, where A is sparse and B is full</comment>
            <if_stmt><if>if <condition>(<expr><name><name>A</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// A-&gt;nvec_nonempty is used to select the method </comment>
                <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>=</operator> <call><name>GB_nvec_nonempty</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="line">// C is full if all vectors of A are present</comment>
            <expr_stmt><expr><name>C_sparsity</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>A</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>==</operator> <name><name>A</name><operator>-&gt;</operator><name>vdim</name></name><operator>)</operator></expr> ?</condition><then>
                <expr><name>GxB_FULL</name></expr> </then><else>: <expr><name>GxB_BITMAP</name></expr></else></ternary></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>M_in</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(dot %s = %s%s*%s) "</literal></expr></argument>,
            <argument><expr><call><name>GB_sparsity_char</name> <argument_list>(<argument><expr><name>C_sparsity</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>GB_sparsity_char_matrix</name> <argument_list>(<argument><expr><name>A_in</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><ternary><condition><expr><name>A_not_transposed</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"'"</literal></expr></else></ternary></expr></argument>,
            <argument><expr><call><name>GB_sparsity_char_matrix</name> <argument_list>(<argument><expr><name>B_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(dot %s%s%s%s%s = %s%s*%s) "</literal></expr></argument>,
            <argument><expr><call><name>GB_sparsity_char</name> <argument_list>(<argument><expr><name>C_sparsity</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><ternary><condition><expr><name>Mask_struct</name></expr> ?</condition><then> <expr><literal type="string">"{"</literal></expr> </then><else>: <expr><literal type="string">"&lt;"</literal></expr></else></ternary></expr></argument>,
            <argument><expr><ternary><condition><expr><name>Mask_comp</name></expr> ?</condition><then> <expr><literal type="string">"!"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
            <argument><expr><call><name>GB_sparsity_char_matrix</name> <argument_list>(<argument><expr><name>M_in</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><ternary><condition><expr><name>Mask_struct</name></expr> ?</condition><then> <expr><literal type="string">"}"</literal></expr> </then><else>: <expr><literal type="string">"&gt;"</literal></expr></else></ternary></expr></argument>,
            <argument><expr><call><name>GB_sparsity_char_matrix</name> <argument_list>(<argument><expr><name>A_in</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><ternary><condition><expr><name>A_not_transposed</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"'"</literal></expr></else></ternary></expr></argument>,
            <argument><expr><call><name>GB_sparsity_char_matrix</name> <argument_list>(<argument><expr><name>B_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// set C-&gt;iso = C_iso</comment>
    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_new_bix</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>C</name></expr></argument>, <comment type="line">// bitmap/full, existing header</comment>
        <argument><expr><name>ctype</name></expr></argument>, <argument><expr><name>cvlen</name></expr></argument>, <argument><expr><name>cvdim</name></expr></argument>, <argument><expr><name>GB_Ap_malloc</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>C_sparsity</name></expr></argument>,
        <argument><expr><name>M_is_sparse_or_hyper</name></expr></argument>, <argument><expr><name><name>B</name><operator>-&gt;</operator><name>hyper_switch</name></name></expr></argument>, <argument><expr><name>cnvec</name></expr></argument>, <argument><expr><name>cnz</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>C_iso</name></expr></argument>,
        <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_DEBUGIFY_DEFN</name></cpp:ifdef>
    <expr_stmt><expr><call><name>GB_debugify_mxm</name> <argument_list>(<argument><expr><name>C_iso</name></expr></argument>, <argument><expr><name>C_sparsity</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>, <argument><expr><name>M</name></expr></argument>,
        <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>semiring</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// if M is sparse/hyper, scatter it into the C bitmap</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>M_is_sparse_or_hyper</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// FUTURE:: could just set Cb [pC] = 2 since Cb has just been calloc'd.</comment>
        <comment type="line">// However, in the future, this method might be able to modify C on</comment>
        <comment type="line">// input, in which case C-&gt;b will not be all zero.</comment>

        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C_sparsity</name> <operator>==</operator> <name>GxB_BITMAP</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>M_ntasks</name></decl>, <decl><type ref="prev"/><name>M_nthreads</name></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>GB_SLICE_MATRIX</name> <argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">// Cb [pC] += 2 for each entry M(i,j) in the mask</comment>
        <expr_stmt><expr><call><name>GB_bitmap_M_scatter</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
            <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>GB_ALL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>GB_ALL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
            <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>GB_ASSIGN</name></expr></argument>, <argument><expr><name>GB_BITMAP_M_SCATTER_PLUS_2</name></expr></argument>,
            <argument><expr><name>M_ek_slicing</name></expr></argument>, <argument><expr><name>M_ntasks</name></expr></argument>, <argument><expr><name>M_nthreads</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <comment type="line">// the bitmap of C now contains:</comment>
        <comment type="line">//  Cb (i,j) = 0:   cij not present, mij zero</comment>
        <comment type="line">//  Cb (i,j) = 1:   cij present, mij zero           (not used yet)</comment>
        <comment type="line">//  Cb (i,j) = 2:   cij not present, mij 1</comment>
        <comment type="line">//  Cb (i,j) = 3:   cij present, mij 1              (not used yet)</comment>
        <expr_stmt><expr><call><name>GB_WERK_POP</name> <argument_list>(<argument><expr><name>M_ek_slicing</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// C&lt;#&gt;=A'*B, computing each entry with a dot product, via builtin semiring</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>C_iso</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C is iso; compute the pattern of C&lt;#&gt;=A'*B with the any_pair semiring</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(iso dot2) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>cscalar</name></expr></argument>, <argument><expr><name><name>ctype</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>info</name> <operator>=</operator> <call><call><name>GB</name> <argument_list>(<argument><expr><name>_Adot2B__any_pair_iso</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>,
            <argument><expr><name>A_not_transposed</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>A_slice</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>B_slice</name></expr></argument>,
            <argument><expr><name>nthreads</name></expr></argument>, <argument><expr><name>naslice</name></expr></argument>, <argument><expr><name>nbslice</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>info</name> <operator>!=</operator> <name>GrB_NO_VALUE</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C is non-iso</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>

        <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GBCUDA_DEV</name></cpp:ifndef>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// define the worker for the switch factory</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_Adot2B</name><parameter_list>(<parameter><type><name>add</name></type></parameter>,<parameter><type><name>mult</name></type></parameter>,<parameter><type><name>xname</name></type></parameter>)</parameter_list></cpp:macro> \
                <cpp:value>GB (_Adot2B_ ## add ## mult ## xname)</cpp:value></cpp:define>

            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_AxB_WORKER</name><parameter_list>(<parameter><type><name>add</name></type></parameter>,<parameter><type><name>mult</name></type></parameter>,<parameter><type><name>xname</name></type></parameter>)</parameter_list></cpp:macro>                           \
            <cpp:value>{                                                               \
                info = GB_Adot2B (add,mult,xname) (C, M, Mask_comp,         \
                    Mask_struct, A_not_transposed, A, A_slice,              \
                    B, B_slice, nthreads, naslice, nbslice) ;               \
                done = (info != GrB_NO_VALUE) ;                             \
            }                                                               \
            break ;</cpp:value></cpp:define>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// launch the switch factory</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <decl_stmt><decl><type><name>GB_Opcode</name></type> <name>mult_binop_code</name></decl>, <decl><type ref="prev"/><name>add_binop_code</name></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>xcode</name></decl>, <decl><type ref="prev"/><name>ycode</name></decl>, <decl><type ref="prev"/><name>zcode</name></decl> ;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>GB_AxB_semiring_builtin</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>A_is_pattern</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>B_is_pattern</name></expr></argument>,
                <argument><expr><name>semiring</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mult_binop_code</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>add_binop_code</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xcode</name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name>ycode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zcode</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content> 
                <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_factory.c"</cpp:file></cpp:include>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name> <operator>||</operator> <name>info</name> <operator>==</operator> <name>GrB_NO_VALUE</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C = A'*B or A*B, using the dot product method, with typecasting</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition>
        <block>{<block_content> 
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_DOT2_GENERIC</name></cpp:macro></cpp:define>
            <expr_stmt><expr><call><name>GB_BURBLE_MATRIX</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"(generic C%s=A%s*B, C %s) "</literal></expr></argument>,
                <argument><expr><ternary><condition><expr><operator>(</operator><name>M</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><name>Mask_comp</name></expr> ?</condition><then> <expr><literal type="string">"&lt;!M&gt;"</literal></expr> </then><else>: <expr><literal type="string">"&lt;M&gt;"</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></argument>,
                <argument><expr><ternary><condition><expr><name>A_not_transposed</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"'"</literal></expr></else></ternary></expr></argument>,
                <argument><expr><ternary><condition><expr><operator>(</operator><name>C_sparsity</name> <operator>==</operator> <name>GxB_BITMAP</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"bitmap"</literal></expr> </then><else>: <expr><literal type="string">"full"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot_generic.c"</cpp:file></cpp:include>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free workspace</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>GB_MAGIC</name></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"dot2: result C, before expand"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// convert C to sparse/hyper if A or B are hypersparse on input</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>A_or_B_hyper</name></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_bitmap_expand_to_hyper</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>cvlen_final</name></expr></argument>, <argument><expr><name>cvdim_final</name></expr></argument>,
            <argument><expr><name>A_in</name></expr></argument>, <argument><expr><name>B_in</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// return result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"dot2: result C, after expand"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_ZOMBIES_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_JUMBLED</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
