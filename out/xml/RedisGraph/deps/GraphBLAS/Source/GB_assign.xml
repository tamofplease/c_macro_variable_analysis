<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_assign.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_assign: submatrix assignment: C&lt;M&gt;(Rows,Cols) = accum (C(Rows,Cols),A)</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// submatrix assignment: C&lt;M&gt;(Rows,Cols) = accum (C(Rows,Cols),A)</comment>

<comment type="line">// All GrB_*_assign operations rely on this function.</comment>

<comment type="line">// Only one of the bool parameters: scalar_expansion, col_assign, and</comment>
<comment type="line">// row_assign can be true.  If all are false, this function does the work for</comment>
<comment type="line">// GrB_Matrix_assign and GrB_Vector_assign.</comment>

<comment type="line">// If scalar_expansion is true, this function performs scalar assignment (the</comment>
<comment type="line">// GrB_Matrix_assign_TYPE and GrB_Vector_assign_TYPE functions) in which case</comment>
<comment type="line">// the input matrix A is ignored (it is NULL), and the scalar is used instead.</comment>

<comment type="line">// If col_assign is true, this function does the work for GrB_Col_assign.</comment>
<comment type="line">// If row_assign is true, this function does the work for GrB_Row_assign.</comment>

<comment type="line">// Compare with GB_subassign, which uses M and C_replace differently</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_ALL</name></cpp:macro>                 \
<cpp:value>{                                   \
    GB_Matrix_free (&amp;C2) ;          \
    GB_Matrix_free (&amp;M2) ;          \
    GB_Matrix_free (&amp;A2) ;          \
    GB_Matrix_free (&amp;SubMask) ;     \
    GB_FREE_WORK (&amp;I2, I2_size) ;   \
    GB_FREE_WORK (&amp;J2, J2_size) ;   \
}</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_assign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_assign_zombie.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_subassign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_subref.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_bitmap_assign.h"</cpp:file></cpp:include>

<function><type><name>GrB_Info</name></type> <name>GB_assign</name>                  <comment type="line">// C&lt;M&gt;(Rows,Cols) += A or A'</comment>
<parameter_list>(
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C_in</name></decl></parameter>,                <comment type="line">// input/output matrix for results</comment>
    <parameter><decl><type><name>bool</name></type> <name>C_replace</name></decl></parameter>,                 <comment type="line">// descriptor for C</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>M_in</name></decl></parameter>,          <comment type="line">// optional mask for C</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_comp</name></decl></parameter>,           <comment type="line">// true if mask is complemented</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_struct</name></decl></parameter>,         <comment type="line">// if true, use the only structure of M</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>M_transpose</name></decl></parameter>,         <comment type="line">// true if the mask should be transposed</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_BinaryOp</name></type> <name>accum</name></decl></parameter>,       <comment type="line">// optional accum for accum(C,T)</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A_in</name></decl></parameter>,          <comment type="line">// input matrix</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>A_transpose</name></decl></parameter>,         <comment type="line">// true if A is transposed</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Index</name> <modifier>*</modifier></type><name>Rows</name></decl></parameter>,          <comment type="line">// row indices</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Index</name></type> <name>nRows_in</name></decl></parameter>,       <comment type="line">// number of row indices</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Index</name> <modifier>*</modifier></type><name>Cols</name></decl></parameter>,          <comment type="line">// column indices</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Index</name></type> <name>nCols_in</name></decl></parameter>,       <comment type="line">// number of column indices</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>scalar_expansion</name></decl></parameter>,    <comment type="line">// if true, expand scalar to A</comment>
    <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>scalar</name></decl></parameter>,             <comment type="line">// scalar to be expanded</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GB_Type_code</name></type> <name>scalar_code</name></decl></parameter>, <comment type="line">// type code of scalar to expand</comment>
    <parameter><decl><type><name>int</name></type> <name>assign_kind</name></decl></parameter>,                <comment type="line">// row assign, col assign, or assign</comment>
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check and prep inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>C</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>           <comment type="line">// C_in or C2</comment>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>M</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>           <comment type="line">// M_in or M2</comment>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>A</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>           <comment type="line">// A_in or A2</comment>
    <decl_stmt><decl><type><name>GrB_Index</name> <modifier>*</modifier></type><name>I</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>           <comment type="line">// Rows, Cols, or I2</comment>
    <decl_stmt><decl><type><name>GrB_Index</name> <modifier>*</modifier></type><name>J</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>           <comment type="line">// Rows, Cols, or J2</comment>

    <comment type="line">// temporary matrices and arrays</comment>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>C2</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>M2</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>A2</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>SubMask</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>GB_Matrix_opaque</name></name></type> <name>C2_header</name></decl>, <decl><type ref="prev"/><name>M2_header</name></decl>, <decl><type ref="prev"/><name>A2_header</name></decl>, <decl><type ref="prev"/><name>MT_header</name></decl>,
        <decl><type ref="prev"/><name>AT_header</name></decl>, <decl><type ref="prev"/><name>SubMask_header</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Index</name> <modifier>*</modifier></type><name>I2</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>I2_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Index</name> <modifier>*</modifier></type><name>J2</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>J2_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>GrB_Type</name></type> <name>atype</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>ni</name></decl>, <decl><type ref="prev"/><name>nj</name></decl>, <decl><type ref="prev"/><name>nI</name></decl>, <decl><type ref="prev"/><name>nJ</name></decl>, <decl><type ref="prev"/><name><name>Icolon</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>Jcolon</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>Ikind</name></decl>, <decl><type ref="prev"/><name>Jkind</name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C_in</name></expr></argument>, <argument><expr><literal type="string">"C_in for assign"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>subassign_method</name></decl> ;</decl_stmt>

    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_assign_prep</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>M</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>A</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subassign_method</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>C2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>M2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>A2</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>C2_header</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>M2_header</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>A2_header</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>MT_header</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>AT_header</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>I</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>I2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>I2_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ni</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nI</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>J2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>J2_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nJ</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>atype</name></expr></argument>, <argument><expr><name>C_in</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>C_replace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>assign_kind</name></expr></argument>,
        <argument><expr><name>M_in</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>M_transpose</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>,
        <argument><expr><name>A_in</name></expr></argument>, <argument><expr><name>A_transpose</name></expr></argument>, <argument><expr><name>Rows</name></expr></argument>, <argument><expr><name>nRows_in</name></expr></argument>, <argument><expr><name>Cols</name></expr></argument>, <argument><expr><name>nCols_in</name></expr></argument>,
        <argument><expr><name>scalar_expansion</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>scalar_code</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"initial C for assign"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK_OR_NULL</name> <argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><literal type="string">"initial M for assign"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>subassign_method</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// GB_assign_prep has handled the entire assignment itself</comment>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C_in</name></expr></argument>, <argument><expr><literal type="string">"QUICK : Final C for assign"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C</name> <operator>==</operator> <name>C_in</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine if the final C_replace phase is needed</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// whole_submatrix is true if C(:,:)=A is being computed (the submatrix is</comment>
    <comment type="line">// all of C), or all that the operation can modify for row/col assign.</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>whole_submatrix</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>whole_C_matrix</name> <init>= <expr><operator>(</operator><name>Ikind</name> <operator>==</operator> <name>GB_ALL</name> <operator>&amp;&amp;</operator> <name>Jkind</name> <operator>==</operator> <name>GB_ALL</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>assign_kind</name> <operator>==</operator> <name>GB_ROW_ASSIGN</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// C(i,:) = ... row assignment to the entire row</comment>
        <expr_stmt><expr><name>whole_submatrix</name> <operator>=</operator> <operator>(</operator><name>Jkind</name> <operator>==</operator> <name>GB_ALL</name><operator>)</operator></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>assign_kind</name> <operator>==</operator> <name>GB_COL_ASSIGN</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// C(:,j) = ... col assignment to the entire column</comment>
        <expr_stmt><expr><name>whole_submatrix</name> <operator>=</operator> <operator>(</operator><name>Ikind</name> <operator>==</operator> <name>GB_ALL</name><operator>)</operator></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <comment type="line">// C(:,:) = ... matrix assignment to the entire matrix</comment>
        <expr_stmt><expr><name>whole_submatrix</name> <operator>=</operator> <name>whole_C_matrix</name></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// Mask_is_same is true if SubMask == M (:,:)</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>Mask_is_same</name> <init>= <expr><operator>(</operator><name>M</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>whole_submatrix</name><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <comment type="line">// C_replace_phase is true if a final pass over all of C is required</comment>
    <comment type="line">// to delete entries outside the C(I,J) submatrix.</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>C_replace_phase</name> <init>= <expr><operator>(</operator><name>C_replace</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>Mask_is_same</name><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GB_IS_FULL</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <name>C_replace_phase</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// GB_subassigner_method might not select the bitmap assignment</comment>
        <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <name>GB_SUBASSIGN_METHOD_BITMAP</name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// do the assignment</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>subassign_method</name> <operator>==</operator> <name>GB_SUBASSIGN_METHOD_BITMAP</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// use GB_bitmap_assign directly</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// GB_bitmap_assign does not need to create the SubMask, and it also</comment>
        <comment type="line">// handles the C_replace_phase itself.  C is bitmap, or is converted to</comment>
        <comment type="line">// bitmap by GB_bitmap_assign, before the assignment.  For the C = A</comment>
        <comment type="line">// and C = scalar assignment, C may be returned in any sparsity</comment>
        <comment type="line">// structure, but otherwise C is returned as bitmap.</comment>

        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_bitmap_assign</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>C_replace</name></expr></argument>,
            <argument><expr><name>I</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
            <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>A</name></expr></argument>,
            <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>, <argument><expr><name>assign_kind</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// use GB_subassigner</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// C, M, and A can have any sparsity structure.  C is typically not</comment>
        <comment type="line">// bitmap, except for a few methods (see GB_subassigner_method for</comment>
        <comment type="line">// a list).</comment>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// extract the SubMask = M (I,J) if needed</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <if_stmt><if>if <condition>(<expr><name>Mask_is_same</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// the mask M is the same for GB_assign and GB_subassign.  Either</comment>
            <comment type="line">// both masks are NULL, or SubMask = M (:,:), and the two masks</comment>
            <comment type="line">// are equivalent.</comment>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// C(I,J)&lt;M&gt; = A or accum (C(I,J),A) via GB_subassigner</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassigner</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>subassign_method</name></expr></argument>, <argument><expr><name>C_replace</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>A</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>scalar_expansion</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        </block_content>}</block></if>
        <else>else
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// extract the SubMask</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><literal type="string">"big mask"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>SubMask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SubMask_header</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <decl_stmt><decl><type><specifier>const</specifier> <name>GrB_Index</name> <modifier>*</modifier></type><name>I_SubMask</name> <init>= <expr><name>I</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>int64_t</name></type> <name>ni_SubMask</name> <init>= <expr><name>ni</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>GrB_Index</name> <modifier>*</modifier></type><name>J_SubMask</name> <init>= <expr><name>J</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>int64_t</name></type> <name>nj_SubMask</name> <init>= <expr><name>nj</name></expr></init></decl> ;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>assign_kind</name> <operator>==</operator> <name>GB_ROW_ASSIGN</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// SubMask = M (:,J)</comment>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>M</name><operator>-&gt;</operator><name>vlen</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>M</name><operator>-&gt;</operator><name>vdim</name></name> <operator>==</operator> <name><name>C</name><operator>-&gt;</operator><name>vdim</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><name>I_SubMask</name> <operator>=</operator> <name>GrB_ALL</name></expr> ;</expr_stmt>
                <expr_stmt><expr><name>ni_SubMask</name> <operator>=</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>assign_kind</name> <operator>==</operator> <name>GB_COL_ASSIGN</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// SubMask = M (I,:)</comment>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>M</name><operator>-&gt;</operator><name>vlen</name></name> <operator>==</operator> <name><name>C</name><operator>-&gt;</operator><name>vlen</name></name> <operator>&amp;&amp;</operator> <name><name>M</name><operator>-&gt;</operator><name>vdim</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><name>J_SubMask</name> <operator>=</operator> <name>GrB_ALL</name></expr> ;</expr_stmt>
                <expr_stmt><expr><name>nj_SubMask</name> <operator>=</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else <comment type="line">// assign_kind == GB_ASSIGN</comment>
            <block>{<block_content> 
                <comment type="line">// SubMask = M (I,J)</comment>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>M</name><operator>-&gt;</operator><name>vlen</name></name> <operator>==</operator> <name><name>C</name><operator>-&gt;</operator><name>vlen</name></name> <operator>&amp;&amp;</operator> <name><name>M</name><operator>-&gt;</operator><name>vdim</name></name> <operator>==</operator> <name><name>C</name><operator>-&gt;</operator><name>vdim</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="line">// if Mask_struct is true then SubMask is extracted as iso</comment>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subref</name> <argument_list>(<argument><expr><name>SubMask</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>,
                <argument><expr><name>true</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>I_SubMask</name></expr></argument>, <argument><expr><name>ni_SubMask</name></expr></argument>, <argument><expr><name>J_SubMask</name></expr></argument>, <argument><expr><name>nj_SubMask</name></expr></argument>,
                <argument><expr><name>false</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <comment type="line">// GB_subref can return a jumbled result</comment>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>SubMask</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>SubMask</name></expr></argument>, <argument><expr><literal type="string">"extracted SubMask"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// C(I,J)&lt;SubMask&gt; = A or accum (C(I,J),A) via GB_subassigner</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <comment type="line">// Determine the method again since SubMask is not M.  No need to</comment>
            <comment type="line">// recompute C_iso_out and cout for the iso case, since no change</comment>
            <comment type="line">// of method as a result of the SubMask will change the iso propery</comment>
            <comment type="line">// of C on output.</comment>

            <expr_stmt><expr><name>subassign_method</name> <operator>=</operator> <call><name>GB_subassigner_method</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>C_replace</name></expr></argument>, <argument><expr><name>SubMask</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>A</name></expr></argument>,
                <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>scalar_expansion</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassigner</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>subassign_method</name></expr></argument>, <argument><expr><name>C_replace</name></expr></argument>,
                <argument><expr><name>SubMask</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>A</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>scalar_expansion</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <expr_stmt><expr><call><name>GB_Matrix_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>SubMask</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// examine C outside the C(I,J) submatrix</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <if_stmt><if>if <condition>(<expr><name>C_replace_phase</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// If C_replace is true and M(i,j)=0 for any entry outside the</comment>
            <comment type="line">// C(I,J) submatrix, then that entry must be deleted.  This phase</comment>
            <comment type="line">// is very costly but it is what the GraphBLAS Specification</comment>
            <comment type="line">// requires.  This phase is skipped if C_replace is false.</comment>

            <comment type="line">// This case can only occur if the mask is present (either</comment>
            <comment type="line">// complemented or not).  If the mask is not present, then it is</comment>
            <comment type="line">// not complemented (see the "quick return" case above).  So if</comment>
            <comment type="line">// there is no mask matrix, M(I,J)=1 is true, so C_replace has no</comment>
            <comment type="line">// effect outside the C(I,J) submatrix.</comment>

            <comment type="line">// Also, if whole_submatrix is true, then there is nothing outside</comment>
            <comment type="line">// the C(I,J) submatrix to modify, so this phase is skipped if</comment>
            <comment type="line">// whole_submatrix is true.</comment>

            <comment type="line">// This code requires C and M not to be aliased to each other.</comment>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>M</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_aliased</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>   <comment type="line">// NO ALIAS C==M in C_replace_phase</comment>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>whole_submatrix</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_IS_FULL</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C for C-replace-phase"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><literal type="string">"M for C-replace-phase"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// assemble any pending tuples</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <expr_stmt><expr><call><name>GB_MATRIX_WAIT_IF_PENDING</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C cleaned up for C-replace-phase"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// delete entries outside C(I,J) for which M(i,j) is false</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <comment type="line">// C must be sparse or hypersparse</comment>
            <expr_stmt><expr><call><name>GB_ENSURE_SPARSE</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>assign_kind</name> <operator>==</operator> <name>GB_COL_ASSIGN</name></expr>)</condition>
            <block>{<block_content> 

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// vector assignment, examine all of M but just C(:,j)</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <comment type="line">// M is a single column so it is never hypersparse</comment>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>nJ</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>M</name><operator>-&gt;</operator><name>vlen</name></name> <operator>==</operator> <name><name>C</name><operator>-&gt;</operator><name>vlen</name></name> <operator>&amp;&amp;</operator> <name><name>M</name><operator>-&gt;</operator><name>vdim</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>M</name><operator>-&gt;</operator><name>h</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>j</name> <init>= <expr><call><name>GB_ijlist</name> <argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"assign zombies outside C(I,j) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_MATRIX_WAIT</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_hyper_hash_build</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_assign_zombie3</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>,
                    <argument><expr><name>j</name></expr></argument>, <argument><expr><name>I</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>assign_kind</name> <operator>==</operator> <name>GB_ROW_ASSIGN</name></expr>)</condition>
            <block>{<block_content> 

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// index assignment, examine just C(i,:) and M</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <comment type="line">// GrB_Row_assign: only examine C(i,:)</comment>
                <comment type="line">// M s a single row with vlen == 1 and the same vdim as C</comment>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>nI</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>M</name><operator>-&gt;</operator><name>vlen</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>M</name><operator>-&gt;</operator><name>vdim</name></name> <operator>==</operator> <name><name>C</name><operator>-&gt;</operator><name>vdim</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><call><name>GB_ijlist</name> <argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"assign zombies outside C(i,J) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_MATRIX_WAIT_IF_JUMBLED</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_MATRIX_WAIT</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_hyper_hash_build</name> <argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_assign_zombie4</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>,
                    <argument><expr><name>i</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// Matrix/vector assignment: examine all of C and M</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <comment type="line">// M has the same size as C</comment>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>M</name><operator>-&gt;</operator><name>vlen</name></name> <operator>==</operator> <name><name>C</name><operator>-&gt;</operator><name>vlen</name></name> <operator>&amp;&amp;</operator> <name><name>M</name><operator>-&gt;</operator><name>vdim</name></name> <operator>==</operator> <name><name>C</name><operator>-&gt;</operator><name>vdim</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"assign zombies outside C(I,J) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_MATRIX_WAIT</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_hyper_hash_build</name> <argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_assign_zombie5</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>,
                    <argument><expr><name>I</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C for C-replace-phase done"</literal></expr></argument>, <argument><expr><call><name>GB_FLIP</name> <argument_list>(<argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// transplant C2 back into C_in</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>C</name> <operator>==</operator> <name>C2</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// Transplant the content of C2 into C_in and free C2.  Zombies and</comment>
        <comment type="line">// pending tuples can be transplanted from C2 into C_in, and if C2 is</comment>
        <comment type="line">// jumbled, C_in becomes jumbled too.</comment>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_transplant</name> <argument_list>(<argument><expr><name>C_in</name></expr></argument>, <argument><expr><name><name>C_in</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>C2</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free workspace, finalize C, and return result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C_in</name></expr></argument>, <argument><expr><literal type="string">"C to conform"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_conform</name> <argument_list>(<argument><expr><name>C_in</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C_in</name></expr></argument>, <argument><expr><literal type="string">"Final C for assign"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
    <return>return <expr><operator>(</operator><call><name>GB_block</name> <argument_list>(<argument><expr><name>C_in</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
