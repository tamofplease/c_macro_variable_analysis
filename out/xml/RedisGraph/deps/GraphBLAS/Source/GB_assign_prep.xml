<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_assign_prep.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_assign_prep: check and prepare inputs for GB_assign and GB_subassign</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// GB_assign_prep checks the inputs for GB_assign and GB_subassign.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_subassign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_bitmap_assign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_assign_zombie.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_subassign_methods.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_transpose.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_subref.h"</cpp:file></cpp:include>

<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_FREE_ALL</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_ALL</name></cpp:macro>                 \
<cpp:value>{                                   \
    GB_Matrix_free (&amp;C2) ;          \
    GB_Matrix_free (&amp;A2) ;          \
    GB_Matrix_free (&amp;AT) ;          \
    GB_Matrix_free (&amp;M2) ;          \
    GB_Matrix_free (&amp;MT) ;          \
    GB_FREE_WORK (&amp;I2, I2_size) ;   \
    GB_FREE_WORK (&amp;J2, J2_size) ;   \
    GB_FREE_WORK (&amp;I2k, I2k_size) ; \
    GB_FREE_WORK (&amp;J2k, J2k_size) ; \
}</cpp:value></cpp:define>

<comment type="line">// redefine to use the revised GB_FREE_ALL above:</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_static_header.h"</cpp:file></cpp:include>

<function><type><name>GrB_Info</name></type> <name>GB_assign_prep</name>
<parameter_list>(
    <comment type="line">// output:</comment>
    <parameter><decl><type><name>GrB_Matrix</name> <modifier>*</modifier></type><name>Chandle</name></decl></parameter>,            <comment type="line">// C_in, or C2 if C is aliased to M or A</comment>
    <parameter><decl><type><name>GrB_Matrix</name> <modifier>*</modifier></type><name>Mhandle</name></decl></parameter>,            <comment type="line">// M_in, or a modified version M2</comment>
    <parameter><decl><type><name>GrB_Matrix</name> <modifier>*</modifier></type><name>Ahandle</name></decl></parameter>,            <comment type="line">// A_in, or a modified version A2</comment>
    <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>subassign_method</name></decl></parameter>,          <comment type="line">// subassign method to use</comment>

    <comment type="line">// modified versions of the matrices C, M, and A:</comment>
    <parameter><decl><type><name>GrB_Matrix</name> <modifier>*</modifier></type><name>C2_handle</name></decl></parameter>,          <comment type="line">// NULL, or a copy of C</comment>
    <parameter><decl><type><name>GrB_Matrix</name> <modifier>*</modifier></type><name>M2_handle</name></decl></parameter>,          <comment type="line">// NULL, or a temporary matrix</comment>
    <parameter><decl><type><name>GrB_Matrix</name> <modifier>*</modifier></type><name>A2_handle</name></decl></parameter>,          <comment type="line">// NULL, or a temporary matrix</comment>

    <comment type="line">// static headers for C2, M2, A2, MT and AT</comment>
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C2_header_handle</name></decl></parameter>,
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>M2_header_handle</name></decl></parameter>,
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>A2_header_handle</name></decl></parameter>,
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>MT_header_handle</name></decl></parameter>,
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>AT_header_handle</name></decl></parameter>,

    <comment type="line">// modified versions of the Rows/Cols lists, and their analysis:</comment>
    <parameter><decl><type><name>GrB_Index</name> <modifier>*</modifier><modifier>*</modifier></type><name>I_handle</name></decl></parameter>,           <comment type="line">// Rows, Cols, or a modified copy I2</comment>
    <parameter><decl><type><name>GrB_Index</name> <modifier>*</modifier><modifier>*</modifier></type><name>I2_handle</name></decl></parameter>,          <comment type="line">// NULL, or sorted/pruned Rows or Cols</comment>
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>I2_size_handle</name></decl></parameter>,
    <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>ni_handle</name></decl></parameter>,
    <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>nI_handle</name></decl></parameter>,
    <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>Ikind_handle</name></decl></parameter>,
    <parameter><decl><type><name>int64_t</name></type> <name><name>Icolon</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name></decl></parameter>,

    <parameter><decl><type><name>GrB_Index</name> <modifier>*</modifier><modifier>*</modifier></type><name>J_handle</name></decl></parameter>,           <comment type="line">// Rows, Cols, or a modified copy J2</comment>
    <parameter><decl><type><name>GrB_Index</name> <modifier>*</modifier><modifier>*</modifier></type><name>J2_handle</name></decl></parameter>,          <comment type="line">// NULL, or sorted/pruned Rows or Cols</comment>
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>J2_size_handle</name></decl></parameter>,
    <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>nj_handle</name></decl></parameter>,
    <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>nJ_handle</name></decl></parameter>,
    <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>Jkind_handle</name></decl></parameter>,
    <parameter><decl><type><name>int64_t</name></type> <name><name>Jcolon</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name></decl></parameter>,

    <parameter><decl><type><name>GrB_Type</name> <modifier>*</modifier></type><name>atype_handle</name></decl></parameter>,         <comment type="line">// type of A or the scalar</comment>

    <comment type="line">// input/output</comment>
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C_in</name></decl></parameter>,                <comment type="line">// input/output matrix for results</comment>
    <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>C_replace</name></decl></parameter>,                <comment type="line">// descriptor for C</comment>
    <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>assign_kind</name></decl></parameter>,               <comment type="line">// row/col assign, assign, or subassign</comment>

    <comment type="line">// input</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>M_in</name></decl></parameter>,          <comment type="line">// optional mask for C</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_comp</name></decl></parameter>,           <comment type="line">// true if mask is complemented</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_struct</name></decl></parameter>,         <comment type="line">// if true, use the only structure of M</comment>
    <parameter><decl><type><name>bool</name></type> <name>M_transpose</name></decl></parameter>,               <comment type="line">// true if the mask should be transposed</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_BinaryOp</name></type> <name>accum</name></decl></parameter>,       <comment type="line">// optional accum for accum(C,T)</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A_in</name></decl></parameter>,          <comment type="line">// input matrix</comment>
    <parameter><decl><type><name>bool</name></type> <name>A_transpose</name></decl></parameter>,               <comment type="line">// true if A is transposed</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Index</name> <modifier>*</modifier></type><name>Rows</name></decl></parameter>,          <comment type="line">// row indices</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Index</name></type> <name>nRows_in</name></decl></parameter>,       <comment type="line">// number of row indices</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Index</name> <modifier>*</modifier></type><name>Cols</name></decl></parameter>,          <comment type="line">// column indices</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Index</name></type> <name>nCols_in</name></decl></parameter>,       <comment type="line">// number of column indices</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>scalar_expansion</name></decl></parameter>,    <comment type="line">// if true, expand scalar to A</comment>
    <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>scalar</name></decl></parameter>,             <comment type="line">// scalar to be expanded</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GB_Type_code</name></type> <name>scode</name></decl></parameter>,       <comment type="line">// type code of scalar to expand</comment>
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>GB_RETURN_IF_FAULTY_OR_POSITIONAL</name> <argument_list>(<argument><expr><name>accum</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_RETURN_IF_NULL</name> <argument_list>(<argument><expr><name>Rows</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_RETURN_IF_NULL</name> <argument_list>(<argument><expr><name>Cols</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>C</name> <init>= <expr><name>C_in</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>M</name> <init>= <expr><name>M_in</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>A</name> <init>= <expr><name>A_in</name></expr></init></decl> ;</decl_stmt>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C input for GB_assign_prep"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_is_shallow</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK_OR_NULL</name> <argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><literal type="string">"M for GB_assign_prep"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_BINARYOP_OK_OR_NULL</name> <argument_list>(<argument><expr><name>accum</name></expr></argument>, <argument><expr><literal type="string">"accum for GB_assign_prep"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>scode</name> <operator>&lt;=</operator> <name>GB_UDT_code</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>C2</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>M2</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>A2</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>MT</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>AT</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>GrB_Index</name> <modifier>*</modifier></type><name>I2</name>  <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>I2_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Index</name> <modifier>*</modifier></type><name>J2</name>  <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>J2_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Index</name> <modifier>*</modifier></type><name>I2k</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>I2k_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Index</name> <modifier>*</modifier></type><name>J2k</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>J2k_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>atype_handle</name><operator>)</operator> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>Chandle</name><operator>)</operator> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>Mhandle</name><operator>)</operator> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>Ahandle</name><operator>)</operator> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>C2_handle</name><operator>)</operator> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>A2_handle</name><operator>)</operator> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>M2_handle</name><operator>)</operator> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>I_handle</name><operator>)</operator> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt> 
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>I2_handle</name><operator>)</operator> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>I2_size_handle</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>ni_handle</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>nI_handle</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>Ikind_handle</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>J_handle</name><operator>)</operator> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>J2_handle</name><operator>)</operator> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>J2_size_handle</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>nj_handle</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>nJ_handle</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>Jkind_handle</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine the type of A or the scalar</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Type</name></type> <name>atype</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Type</name></type> <name>ctype</name> <init>= <expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>scalar_expansion</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// for scalar expansion, the NULL pointer case has been already checked</comment>
        <comment type="line">// for user-defined types, and can't be NULL for built-in types.</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>scalar</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>A</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>assign_kind</name><operator>)</operator> <operator>==</operator> <name>GB_ASSIGN</name> <operator>||</operator> <operator>(</operator><operator>*</operator><name>assign_kind</name><operator>)</operator> <operator>==</operator> <name>GB_SUBASSIGN</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>atype</name> <operator>=</operator> <call><name>GB_code_type</name> <argument_list>(<argument><expr><name>scode</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <comment type="line">// GrB_*assign, not scalar:  The user's input matrix has been checked.</comment>
        <comment type="line">// The pointer to the scalar is NULL.</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>scalar</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>A</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"A for GB_assign_prep"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>atype</name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// delete any lingering zombies and assemble any pending tuples</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// zombies and pending tuples in C or OK, but not M or A</comment>
    <expr_stmt><expr><call><name>GB_MATRIX_WAIT_IF_PENDING_OR_ZOMBIES</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_MATRIX_WAIT_IF_PENDING_OR_ZOMBIES</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// some kernels allow for M and A to be jumbled</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// C can have any kind of pending work</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_ZOMBIES_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_PENDING_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check domains of C, M, A, and accum</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// GB_compatible is not used since most of it is slightly different here</comment>
    <if_stmt><if>if <condition>(<expr><name>accum</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// C&lt;M&gt;(Rows,Cols) = accum (C(Rows,Cols),A), or</comment>
        <comment type="line">// C(Rows,Cols)&lt;M&gt; = accum (C(Rows,Cols),A)</comment>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_BinaryOp_compatible</name> <argument_list>(<argument><expr><name>accum</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>,
            <argument><expr><ternary><condition><expr><operator>(</operator><name>scalar_expansion</name><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>atype</name></expr></else></ternary></expr></argument>,
            <argument><expr><ternary><condition><expr><operator>(</operator><name>scalar_expansion</name><operator>)</operator></expr> ?</condition><then> <expr><name>scode</name></expr> </then><else>: <expr><name>GB_ignore_code</name></expr></else></ternary></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// C&lt;M&gt;(Rows,Cols) = T, so C and T must be compatible.</comment>
    <comment type="line">// also C&lt;M&gt;(Rows,Cols) = accum(C,T) for entries in T but not C</comment>
    <if_stmt><if>if <condition>(<expr><name>scalar_expansion</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GB_code_compatible</name> <argument_list>(<argument><expr><name><name>ctype</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name>scode</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DOMAIN_MISMATCH</name></expr></argument>, <argument><expr><literal type="string">"Input scalar of type [%s]\n"</literal>
                <literal type="string">"cannot be typecast to output of type [%s]"</literal></expr></argument>,
                <argument><expr><call><name>GB_code_string</name> <argument_list>(<argument><expr><name>scode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ctype</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name>ctype</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DOMAIN_MISMATCH</name></expr></argument>, <argument><expr><literal type="string">"Input of type [%s]\n"</literal>
                <literal type="string">"cannot be typecast to output of type [%s]"</literal></expr></argument>,
                <argument><expr><name><name>atype</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>atype</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>M</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>Mask_struct</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// M is typecast to boolean</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name><name>M</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>GrB_BOOL</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DOMAIN_MISMATCH</name></expr></argument>,
                <argument><expr><literal type="string">"M of type [%s] cannot be typecast to boolean"</literal></expr></argument>, <argument><expr><name><name>M</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine the properites of the Rows and Cols index lists</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>nRows</name></decl>, <decl><type ref="prev"/><name>nCols</name></decl>, <decl><type ref="prev"/><name><name>RowColon</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>ColColon</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>RowsKind</name></decl>, <decl><type ref="prev"/><name>ColsKind</name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>GB_ijlength</name> <argument_list>(<argument><expr><name>Rows</name></expr></argument>, <argument><expr><name>nRows_in</name></expr></argument>, <argument><expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>nRows</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>RowsKind</name></expr></argument>, <argument><expr><name>RowColon</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_ijlength</name> <argument_list>(<argument><expr><name>Cols</name></expr></argument>, <argument><expr><name>nCols_in</name></expr></argument>, <argument><expr><call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>nCols</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ColsKind</name></expr></argument>, <argument><expr><name>ColColon</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check the dimensions of M</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>M</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// check the mask: size depends on the method</comment>

        <switch>switch <condition>(<expr><operator>*</operator><name>assign_kind</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_ROW_ASSIGN</name></expr> :</case> 
            <block>{<block_content>
                <comment type="line">// GrB_Row_assign:</comment>
                <comment type="line">// M is a column vector the same size as one row of C</comment>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>nRows</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>scalar_expansion</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_VECTOR_OK</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DIMENSION_MISMATCH</name></expr></argument>, <argument><expr><literal type="string">"Mask vector m length"</literal>
                        <literal type="string">" is "</literal> <name>GBd</name> <literal type="string">"; must match the number of columns of C ("</literal>
                        <name>GBd</name> <literal type="string">")"</literal></expr></argument>, <argument><expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break ;</break>

            <case>case <expr><name>GB_COL_ASSIGN</name></expr> :</case> 
            <block>{<block_content>
                <comment type="line">// GrB_Col_assign:</comment>
                <comment type="line">// M is a column vector the same size as one column of C</comment>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>nCols</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>scalar_expansion</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_VECTOR_OK</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DIMENSION_MISMATCH</name></expr></argument>, <argument><expr><literal type="string">"Mask vector m length"</literal>
                        <literal type="string">" is "</literal> <name>GBd</name> <literal type="string">"; must match the number of rows of C ("</literal>
                        <name>GBd</name> <literal type="string">")"</literal></expr></argument>, <argument><expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break ;</break>

            <case>case <expr><name>GB_ASSIGN</name></expr> :</case> 
            <block>{<block_content>
                <comment type="line">// GrB_Matrix_assign, GrB_Vector_assign, and scalar variants: M</comment>
                <comment type="line">// is a matrix the same size as C for entire matrix (or vector)</comment>
                <comment type="line">// assignment, where A is either a matrix or a scalar</comment>
                <if_stmt><if>if <condition>(<expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>||</operator>
                    <call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DIMENSION_MISMATCH</name></expr></argument>, <argument><expr><literal type="string">"Mask M is "</literal> <name>GBd</name> <literal type="string">"-by-"</literal>
                        <name>GBd</name> <literal type="string">"; "</literal> <literal type="string">"must match result C ("</literal> <name>GBd</name> <literal type="string">"-by-"</literal> <name>GBd</name> <literal type="string">")"</literal></expr></argument>,
                        <argument><expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break ;</break>

            <case>case <expr><name>GB_SUBASSIGN</name></expr> :</case> 
            <block>{<block_content>
                <comment type="line">// GxB_subassign: M is a matrix the same size as C(Rows,Cols)</comment>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>mnrows</name> <init>= <expr><ternary><condition><expr><name>M_transpose</name></expr> ?</condition><then> <expr><call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>mncols</name> <init>= <expr><ternary><condition><expr><name>M_transpose</name></expr> ?</condition><then> <expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>mnrows</name> <operator>!=</operator> <name>nRows</name> <operator>||</operator> <name>mncols</name> <operator>!=</operator> <name>nCols</name></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DIMENSION_MISMATCH</name></expr></argument>,
                        <argument><expr><literal type="string">"M is "</literal> <name>GBd</name> <literal type="string">"-by-"</literal> <name>GBd</name> <literal type="string">"%s, "</literal>
                        <literal type="string">"must match size of result C(I,J): "</literal> <name>GBd</name> <literal type="string">"-by-"</literal> <name>GBd</name> <literal type="string">""</literal></expr></argument>,
                        <argument><expr><name>mnrows</name></expr></argument>, <argument><expr><name>mncols</name></expr></argument>, <argument><expr><ternary><condition><expr><name>M_transpose</name></expr> ?</condition><then> <expr><literal type="string">" (transposed)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                        <argument><expr><name>nRows</name></expr></argument>, <argument><expr><name>nCols</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break ;</break>

            <default>default:</default>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>GB_DEAD_CODE</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check the dimensions of A</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>scalar_expansion</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>anrows</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>A_transpose</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>ancols</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>A_transpose</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>nRows</name> <operator>!=</operator> <name>anrows</name> <operator>||</operator> <name>nCols</name> <operator>!=</operator> <name>ancols</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DIMENSION_MISMATCH</name></expr></argument>,
                <argument><expr><literal type="string">"Dimensions not compatible:\n"</literal>
                <literal type="string">"C(Rows,Cols) is "</literal> <name>GBd</name> <literal type="string">"-by-"</literal> <name>GBd</name> <literal type="string">"\n"</literal>
                <literal type="string">"input is "</literal> <name>GBd</name> <literal type="string">"-by-"</literal> <name>GBd</name> <literal type="string">"%s"</literal></expr></argument>,
                <argument><expr><name>nRows</name></expr></argument>, <argument><expr><name>nCols</name></expr></argument>, <argument><expr><name>anrows</name></expr></argument>, <argument><expr><name>ancols</name></expr></argument>,
                <argument><expr><ternary><condition><expr><name>A_transpose</name></expr> ?</condition><then> <expr><literal type="string">" (transposed)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// handle the CSR/CSC format of C:</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// GrB_Row_assign, GxB_Row_subassign: A is always a vector in CSC format,</comment>
    <comment type="line">// and A_transpose is always true.  If C is in CSC format then A_transpose</comment>
    <comment type="line">// remains true, and the n-by-1 vector A is transposed below into a 1-by-n</comment>
    <comment type="line">// hypersparse CSC matrix.  If C is in CSR format then A_transpose becomes</comment>
    <comment type="line">// false, and the assignment does not need to transpose A.  It remains in</comment>
    <comment type="line">// CSC format but has the correct vector length and dimension for the</comment>
    <comment type="line">// CSR/CSC-agnostic assignment.</comment>

    <comment type="line">// GrB_Col_assign, GxB_Col_subassign: A is always a vector in CSC format,</comment>
    <comment type="line">// and A_transpose is always false.  If C is in CSC format then A_transpose</comment>
    <comment type="line">// remains false, and the assignment does not need to transpose A.  If C is</comment>
    <comment type="line">// in CSR format then A_transpose becomes true, and the the n-by-1 vector A</comment>
    <comment type="line">// is transposed below into a 1-by-n hypersparse CSC matrix.  The CSC</comment>
    <comment type="line">// format is ignored by the CSR/CSC-agnostic assignment.</comment>

    <comment type="line">// GrB_Vector_assign, GxB_Vector_subassign:  both A and C are always in CSC</comment>
    <comment type="line">// format, and A_transpose is always false, and doesn't change below.</comment>

    <comment type="line">// GrB_Matrix_assign, GxB_Matrix_subassign:  A and C can be in any format,</comment>
    <comment type="line">// and A_transpose can be true or false, depending on the descriptor.  If</comment>
    <comment type="line">// the CSR/CSC formats of A and C are the same, then A_transpose remains</comment>
    <comment type="line">// as-is.  If they differ, then A_transpose is flipped.  Then the CSR-CSC</comment>
    <comment type="line">// agnostic assignment proceeds.</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>C_is_csc</name> <init>= <expr><name><name>C</name><operator>-&gt;</operator><name>is_csc</name></name></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>scalar_expansion</name> <operator>&amp;&amp;</operator> <name>C_is_csc</name> <operator>!=</operator> <name><name>A</name><operator>-&gt;</operator><name>is_csc</name></name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// Flip the sense of A_transpose</comment>
        <expr_stmt><expr><name>A_transpose</name> <operator>=</operator> <operator>!</operator><name>A_transpose</name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// get the I and J index lists</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>Ikind</name></decl>, <decl><type ref="prev"/><name>Jkind</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>GrB_Index</name> <modifier>*</modifier></type><name>I</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>J</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>ni</name></decl>, <decl><type ref="prev"/><name>nj</name></decl>, <decl><type ref="prev"/><name>nI</name></decl>, <decl><type ref="prev"/><name>nJ</name></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>C_is_csc</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// C is in CSC format</comment>
        <expr_stmt><expr><name>I</name>      <operator>=</operator> <name>Rows</name></expr>     ;</expr_stmt>     <expr_stmt><expr><name>J</name>      <operator>=</operator> <name>Cols</name></expr>     ;</expr_stmt>
        <expr_stmt><expr><name>ni</name>     <operator>=</operator> <name>nRows_in</name></expr> ;</expr_stmt>     <expr_stmt><expr><name>nj</name>     <operator>=</operator> <name>nCols_in</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Ikind</name>  <operator>=</operator> <name>RowsKind</name></expr> ;</expr_stmt>     <expr_stmt><expr><name>Jkind</name>  <operator>=</operator> <name>ColsKind</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>nI</name>     <operator>=</operator> <name>nRows</name></expr>    ;</expr_stmt>     <expr_stmt><expr><name>nJ</name>     <operator>=</operator> <name>nCols</name></expr>    ;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>RowColon</name></expr></argument>, <argument><expr><literal type="number">3</literal> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>Jcolon</name></expr></argument>, <argument><expr><name>ColColon</name></expr></argument>, <argument><expr><literal type="number">3</literal> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <comment type="line">// C is in CSR format</comment>
        <expr_stmt><expr><name>I</name>       <operator>=</operator> <name>Cols</name></expr>     ;</expr_stmt>    <expr_stmt><expr><name>J</name>       <operator>=</operator> <name>Rows</name></expr>     ;</expr_stmt>
        <expr_stmt><expr><name>ni</name>      <operator>=</operator> <name>nCols_in</name></expr> ;</expr_stmt>    <expr_stmt><expr><name>nj</name>      <operator>=</operator> <name>nRows_in</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Ikind</name>   <operator>=</operator> <name>ColsKind</name></expr> ;</expr_stmt>    <expr_stmt><expr><name>Jkind</name>   <operator>=</operator> <name>RowsKind</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>nI</name>      <operator>=</operator> <name>nCols</name></expr>    ;</expr_stmt>    <expr_stmt><expr><name>nJ</name>      <operator>=</operator> <name>nRows</name></expr>    ;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>ColColon</name></expr></argument>, <argument><expr><literal type="number">3</literal> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>Jcolon</name></expr></argument>, <argument><expr><name>RowColon</name></expr></argument>, <argument><expr><literal type="number">3</literal> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <comment type="line">// flip the sense of row/col assign</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>assign_kind</name><operator>)</operator> <operator>==</operator> <name>GB_ROW_ASSIGN</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// assignment to vector j = J [0], which is Rows [0]</comment>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>assign_kind</name><operator>)</operator> <operator>=</operator> <name>GB_COL_ASSIGN</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>*</operator><name>assign_kind</name><operator>)</operator> <operator>==</operator> <name>GB_COL_ASSIGN</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// assignment to index i = I [0], which is Cols [0]</comment>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>assign_kind</name><operator>)</operator> <operator>=</operator> <name>GB_ROW_ASSIGN</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// J is now a list of vectors in the range 0:C-&gt;vdim-1</comment>
    <comment type="line">// I is now a list of indices in the range 0:C-&gt;vlen-1</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>whole_C_matrix</name> <init>= <expr><operator>(</operator><name>Ikind</name> <operator>==</operator> <name>GB_ALL</name> <operator>&amp;&amp;</operator> <name>Jkind</name> <operator>==</operator> <name>GB_ALL</name><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// quick return if an empty mask is complemented</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>C_is_bitmap</name> <init>= <expr><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>C_sparsity_control</name> <init>= <expr><call><name>GB_sparsity_control</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>sparsity_control</name></name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>vdim</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>C_may_be_bitmap</name> <init>= <expr><operator>(</operator><name>C_sparsity_control</name> <operator>&amp;</operator> <name>GxB_BITMAP</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>use_bitmap_assign</name> <init>= <expr><operator>(</operator><name>C_is_bitmap</name> <operator>||</operator>
        <operator>(</operator><operator>(</operator><operator>*</operator><name>C_replace</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>GB_IS_FULL</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>C_may_be_bitmap</name><operator>)</operator><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <comment type="line">// an empty mask occurs when M is not present, but complemented</comment>

    <if_stmt><if>if <condition>(<expr><name>M</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>Mask_comp</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C&lt;!,replace or !replace&gt;(I,J) = anything</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// The mask M is empty, and complemented, and thus M(i,j)=0 for all i</comment>
        <comment type="line">// and j.  The result does not depend on A or accum.  The output C is</comment>
        <comment type="line">// either untouched (if C_replace is false) or cleared (if C_replace is</comment>
        <comment type="line">// true).  However, the GrB_Row_assign and GrB_Col_assign only clear</comment>
        <comment type="line">// their specific row or column of C, respectively.  GB_subassign only</comment>
        <comment type="line">// clears C(I,J).  GrB_assign clears all of C.</comment>

        <comment type="line">// M is NULL so C and M cannot be the same, and A is ignored so</comment>
        <comment type="line">// it doesn't matter whether or not C == A.  Thus C is not aliased</comment>
        <comment type="line">// to the inputs.</comment>

        <comment type="line">// This condition is like GB_RETURN_IF_QUICK_MASK(...), except that</comment>
        <comment type="line">// the action taken by C_replace is different for row/col assign</comment>
        <comment type="line">// and subassign.</comment>

        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>C_replace</name></expr>)</condition>
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// C&lt;!,replace&gt;(I,J) = anything</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C for quick mask"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <comment type="line">// to clear the whole C matrix: assign and subassign are the same</comment>

            <switch>switch <condition>(<expr><ternary><condition><expr><name>whole_C_matrix</name></expr> ?</condition><then> <expr><name>GB_ASSIGN</name></expr> </then><else>: <expr><operator>(</operator><operator>*</operator><name>assign_kind</name><operator>)</operator></expr></else></ternary></expr>)</condition>
            <block>{<block_content>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// row assign: delete all entries in C(i,:)</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <case>case <expr><name>GB_ROW_ASSIGN</name></expr> :</case> 
                <block>{<block_content>
                    <comment type="line">// delete all entries in each vector with index i</comment>
                    <expr_stmt><expr><call><name>GB_MATRIX_WAIT_IF_PENDING</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>use_bitmap_assign</name></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// neither A nor the scalar are used, so convert this</comment>
                        <comment type="line">// to a scalar assignment (the scalar is not used)</comment>
                        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"bitmap C(i,:)=zombie "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <decl_stmt><decl><type><name>int</name></type> <name>scalar_unused</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_bitmap_assign</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <comment type="block">/* C_replace: */</comment> <argument><expr><name>true</name></expr></argument>,
                            <argument><expr><name>I</name></expr></argument>,    <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>GB_LIST</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <comment type="line">// I</comment>
                            <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>GB_ALL</name></expr></argument>,  <argument><expr><name>NULL</name></expr></argument>, <comment type="line">// J</comment>
                            <comment type="block">/* no M: */</comment> <argument><expr><name>NULL</name></expr></argument>,
                            <comment type="block">/* Mask_comp: */</comment> <argument><expr><name>true</name></expr></argument>,
                            <comment type="block">/* Mask_struct: ignored */</comment> <argument><expr><name>false</name></expr></argument>,
                            <comment type="block">/* no accum: */</comment> <argument><expr><name>NULL</name></expr></argument>,
                            <comment type="block">/* no A: */</comment> <argument><expr><name>NULL</name></expr></argument>,
                            <comment type="block">/* scalar: */</comment> <argument><expr><operator>&amp;</operator><name>scalar_unused</name></expr></argument>, <argument><expr><name>GrB_INT32</name></expr></argument>,
                            <argument><expr><name>GB_ROW_ASSIGN</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content> 
                        <expr_stmt><expr><call><name>GB_MATRIX_WAIT_IF_JUMBLED</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_ENSURE_SPARSE</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"C(i,:)=zombie "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_assign_zombie2</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name><name>I</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block>
                <break>break ;</break>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// col assign: delete all entries in C(:,j)</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <case>case <expr><name>GB_COL_ASSIGN</name></expr> :</case> 
                <block>{<block_content>
                    <expr_stmt><expr><call><name>GB_MATRIX_WAIT_IF_PENDING</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>use_bitmap_assign</name></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// neither A nor the scalar are used, so convert this</comment>
                        <comment type="line">// to a scalar assignment (the scalar is not used)</comment>
                        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"bitmap C(:,j)=zombie "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <decl_stmt><decl><type><name>int</name></type> <name>scalar_unused</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_bitmap_assign</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <comment type="block">/* C_replace: */</comment> <argument><expr><name>true</name></expr></argument>,
                            <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>GB_ALL</name></expr></argument>,  <argument><expr><name>NULL</name></expr></argument>, <comment type="line">// I</comment>
                            <argument><expr><name>J</name></expr></argument>,    <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>GB_LIST</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <comment type="line">// J</comment>
                            <comment type="block">/* no M: */</comment> <argument><expr><name>NULL</name></expr></argument>,
                            <comment type="block">/* Mask_comp: */</comment> <argument><expr><name>true</name></expr></argument>,
                            <comment type="block">/* Mask_struct: ignored */</comment> <argument><expr><name>false</name></expr></argument>,
                            <comment type="block">/* no accum: */</comment> <argument><expr><name>NULL</name></expr></argument>,
                            <comment type="block">/* no A: */</comment> <argument><expr><name>NULL</name></expr></argument>,
                            <comment type="block">/* scalar: */</comment> <argument><expr><operator>&amp;</operator><name>scalar_unused</name></expr></argument>, <argument><expr><name>GrB_INT32</name></expr></argument>,
                            <argument><expr><name>GB_COL_ASSIGN</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content> 
                        <expr_stmt><expr><call><name>GB_ENSURE_SPARSE</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"C(:,j)=zombie "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_hyper_hash_build</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_assign_zombie1</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name><name>J</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block>
                <break>break ;</break>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// assign: delete all entries in C</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <case>case <expr><name>GB_ASSIGN</name></expr> :</case> 
                <block>{<block_content>
                    <comment type="line">// C&lt;!&gt;=anything since result does not depend on computing</comment>
                    <comment type="line">// Z.  Since C_replace is true, all of C is cleared.  This</comment>
                    <comment type="line">// is the same as the GB_RETURN_IF_QUICK_MASK macro.</comment>
                    <comment type="line">// GB_clear either converts C to an empty sparse/hyper</comment>
                    <comment type="line">// matrix, or to a bitmap matrix with no entries, depending</comment>
                    <comment type="line">// on its sparsity control setting.</comment>
                    <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(clear C) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_clear</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block>
                <break>break ;</break>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// subassign: delete all entries in C(I,J)</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <case>case <expr><name>GB_SUBASSIGN</name></expr> :</case> 
                <block>{<block_content>
                    <expr_stmt><expr><call><name>GB_MATRIX_WAIT_IF_PENDING</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>use_bitmap_assign</name></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// neither A nor the scalar are used, so convert this</comment>
                        <comment type="line">// to a scalar assignment (the scalar is not used)</comment>
                        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"bitmap C(I,J)=zombie "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <decl_stmt><decl><type><name>int</name></type> <name>scalar_unused</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_bitmap_assign</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <comment type="block">/* C_replace: */</comment> <argument><expr><name>true</name></expr></argument>,
                            <argument><expr><name>I</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>,
                            <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                            <comment type="block">/* no M: */</comment> <argument><expr><name>NULL</name></expr></argument>,
                            <comment type="block">/* Mask_comp: */</comment> <argument><expr><name>true</name></expr></argument>,
                            <comment type="block">/* Mask_struct: ignored */</comment> <argument><expr><name>false</name></expr></argument>,
                            <comment type="block">/* no accum: */</comment> <argument><expr><name>NULL</name></expr></argument>,
                            <comment type="block">/* no A: */</comment> <argument><expr><name>NULL</name></expr></argument>,
                            <comment type="block">/* scalar: */</comment> <argument><expr><operator>&amp;</operator><name>scalar_unused</name></expr></argument>, <argument><expr><name>GrB_INT32</name></expr></argument>,
                            <argument><expr><name>GB_SUBASSIGN</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content> 
                        <comment type="line">// Method 00: C(I,J) = empty, using S</comment>
                        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"C(I,J)=zombie "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_ENSURE_SPARSE</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_zombie</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                            <argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>,
                            <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block>
                <break>break ;</break>

                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// finalize C if blocking mode is enabled, and return result</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"Final C for assign, quick mask"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>subassign_method</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
        <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C</name> <operator>==</operator> <name>C_in</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>Chandle</name><operator>)</operator> <operator>=</operator> <name>C</name></expr> ;</expr_stmt>
        <return>return <expr><operator>(</operator><call><name>GB_block</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// disable C_replace if no mask present</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>no_mask</name> <init>= <expr><operator>(</operator><name>M</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>Mask_comp</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>no_mask</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// no_mask:  mask is not present, and not complemented</comment>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>C_replace</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// The mask is not present and not complemented.  In this case,</comment>
            <comment type="line">// C_replace is effectively false for subassign.  Disable it, since</comment>
            <comment type="line">// it can force pending tuples to be assembled.</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(no mask: C_replace effectively false) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>C_replace</name><operator>)</operator> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// delete pending tuples for C(:,:) = x and C(:,:) = A</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>whole_C_matrix</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// If the assignment is C&lt;M&gt;(:,:) = ... then convert the assignment</comment>
        <comment type="line">// into a subassign.</comment>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>assign_kind</name><operator>)</operator> <operator>=</operator> <name>GB_SUBASSIGN</name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>whole_C_matrix</name> <operator>&amp;&amp;</operator> <name>no_mask</name> <operator>&amp;&amp;</operator> <name>accum</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C(:,:) = x or A:  whole matrix assignment with no mask</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// C_replace is already effectively false (see no_mask condition above)</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>C_replace</name><operator>)</operator> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>GB_aliased</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>A</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>A_transpose</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>scalar_expansion</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// C = C, with C and A aliased, no transpose, no mask, no accum</comment>
            <comment type="line">// operator, both I and J are ":", Mask_comp false.  C is not</comment>
            <comment type="line">// modified at all, and there's no work to do except to check for</comment>
            <comment type="line">// blocking mode.  The iso property of C is unchanged.</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(no-op) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>subassign_method</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
            <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C</name> <operator>==</operator> <name>C_in</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>Chandle</name><operator>)</operator> <operator>=</operator> <name>C</name></expr> ;</expr_stmt>
            <return>return <expr><operator>(</operator><call><name>GB_block</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// free pending tuples early but do not clear C.  If it is</comment>
        <comment type="line">// already dense then its pattern can be reused.</comment>
        <expr_stmt><expr><call><name>GB_Pending_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>Pending</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// transpose A if requested</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// GrB_Row_assign and GrB_Col_assign pass A as a typecasted vector,</comment>
    <comment type="line">// which is then quickly transposed to a hypersparse matrix.</comment>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C here in GB_assign_prep"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>scalar_expansion</name> <operator>&amp;&amp;</operator> <name>A_transpose</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// AT = A', with no typecasting</comment>
        <comment type="line">// TODO: if accum is present and it does not depend on the values of</comment>
        <comment type="line">// A,  construct AT as iso.</comment>
        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(A transpose) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>AT</name></expr></argument>, <argument><expr><name>AT_header_handle</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_transpose_cast</name> <argument_list>(<argument><expr><name>AT</name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>C_is_csc</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_MATRIX_WAIT</name> <argument_list>(<argument><expr><name>AT</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>       <comment type="line">// A cannot be jumbled</comment>
        <expr_stmt><expr><name>A</name> <operator>=</operator> <name>AT</name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// transpose the mask if requested</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// the mask for G*B_Col_*assign and G*B_Row_*assign is a GrB_Vector in CSC</comment>
    <comment type="line">// form, which is quickly transposed to a hypersparse matrix, if needed.</comment>
    <comment type="line">// G*B_Vector_*assign always has a CSC mask and CSC C matrix, since both</comment>
    <comment type="line">// are GrB_Vectors.</comment>

    <if_stmt><if>if <condition>(<expr><name>M</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>M</name><operator>-&gt;</operator><name>is_csc</name></name> <operator>!=</operator> <name>C_is_csc</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// either G*B_Row_*assign and G*B_Col_*assign when matrix C is in</comment>
            <comment type="line">// CSR format, and or G*B_Matrix_assign when the format of the</comment>
            <comment type="line">// matrices C and M differ.</comment>
            <expr_stmt><expr><name>M_transpose</name> <operator>=</operator> <operator>!</operator><name>M_transpose</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>M_transpose</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// MT = M' to conform M to the same CSR/CSC format as C,</comment>
            <comment type="line">// and typecast to boolean.</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(M transpose) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>MT</name></expr></argument>, <argument><expr><name>MT_header_handle</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_transpose_cast</name> <argument_list>(<argument><expr><name>MT</name></expr></argument>, <argument><expr><name>GrB_BOOL</name></expr></argument>, <argument><expr><name>C_is_csc</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>,
                <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_MATRIX_WAIT</name> <argument_list>(<argument><expr><name>MT</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>       <comment type="line">// M cannot be jumbled</comment>
            <expr_stmt><expr><name>M</name> <operator>=</operator> <name>MT</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine the properties of I and J</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// If the descriptor says that A must be transposed, it has already been</comment>
    <comment type="line">// transposed in the caller.  Thus C(I,J), A, and M (if present) all</comment>
    <comment type="line">// have the same size: length(I)-by-length(J)</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>I_unsorted</name></decl>, <decl><type ref="prev"/><name>I_has_dupl</name></decl>, <decl><type ref="prev"/><name>I_contig</name></decl>, <decl><type ref="prev"/><name>J_unsorted</name></decl>, <decl><type ref="prev"/><name>J_has_dupl</name></decl>, <decl><type ref="prev"/><name>J_contig</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>imin</name></decl>, <decl><type ref="prev"/><name>imax</name></decl>, <decl><type ref="prev"/><name>jmin</name></decl>, <decl><type ref="prev"/><name>jmax</name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_ijproperties</name> <argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>vlen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name>I_unsorted</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>I_has_dupl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>I_contig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>imin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>imax</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_ijproperties</name> <argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>vdim</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name>J_unsorted</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>J_has_dupl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>J_contig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jmin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jmax</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// sort I and J and remove duplicates, if needed</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// If I or J are explicit lists, and either of are unsorted or are sorted</comment>
    <comment type="line">// but have duplicate entries, then both I and J are sorted and their</comment>
    <comment type="line">// duplicates are removed.  A and M are adjusted accordingly.  Removing</comment>
    <comment type="line">// duplicates decreases the length of I and J.</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>I_unsorted_or_has_dupl</name> <init>= <expr><operator>(</operator><name>I_unsorted</name> <operator>||</operator> <name>I_has_dupl</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>J_unsorted_or_has_dupl</name> <init>= <expr><operator>(</operator><name>J_unsorted</name> <operator>||</operator> <name>J_has_dupl</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>presort</name> <init>= <expr><name>I_unsorted_or_has_dupl</name> <operator>||</operator> <name>J_unsorted_or_has_dupl</name></expr></init></decl> ;</decl_stmt>

    <comment type="line">// This pre-sort of I and J is required for the parallel assignment.</comment>
    <comment type="line">// Otherwise, multiple threads may attempt to modify the same part of C.</comment>
    <comment type="line">// This could cause a race condition, if one thread flags a zombie at the</comment>
    <comment type="line">// same time another thread is using that index in a binary search.  If the</comment>
    <comment type="line">// 2nd thread finds either zombie/not-zombie, this is fine, but the</comment>
    <comment type="line">// modification would have to be atomic.  Atomic read/write is slow, so to</comment>
    <comment type="line">// avoid the use of atomics, the index lists I and J are sorted and all</comment>
    <comment type="line">// duplicates are removed.</comment>

    <comment type="line">// A side benefit of this pre-sort is that it ensures that the results of</comment>
    <comment type="line">// GrB_assign and GxB_subassign are completely defined if I and J have</comment>
    <comment type="line">// duplicates.  The definition of this pre-sort is given below.</comment>

    <comment type="block">/*
        function C = subassign (C, I, J, A)
        % submatrix assignment with pre-sort of I and J; and remove duplicates

        % delete duplicates from I, keeping the last one seen
        [I2 I2k] = sort (I) ;
        Idupl = [(I2 (1:end-1) == I2 (2:end)), false] ;
        I2  = I2  (~Idupl) ;
        I2k = I2k (~Idupl) ;
        assert (isequal (I2, unique (I)))

        % delete duplicates from J, keeping the last one seen
        [J2 J2k] = sort (J) ;
        Jdupl = [(J2 (1:end-1) == J2 (2:end)), false] ;
        J2  = J2  (~Jdupl) ;
        J2k = J2k (~Jdupl) ;
        assert (isequal (J2, unique (J)))

        % do the submatrix assignment, with no duplicates in I2 or J2
        C (I2,J2) = A (I2k,J2k) ;
    */</comment>

    <comment type="line">// With this subassign script, the result returned by GB_subassigner</comment>
    <comment type="line">// matches the following behavior:</comment>

    <comment type="block">/*
        C4 = C ;
        C4 (I,J) = A ;
        C3 = subassign (C, I, J, A) ;
        assert (isequal (C4, C3)) ;
    */</comment>

    <comment type="line">// That is, the pre-sort of I, J, and A has no effect on the final C.</comment>

    <comment type="line">// The pre-sort itself takes additional work and memory space, but it may</comment>
    <comment type="line">// actually improve the performance since it makes the data access of C</comment>
    <comment type="line">// more regular, even in the sequential case.</comment>

    <if_stmt><if>if <condition>(<expr><name>presort</name></expr>)</condition>
    <block>{<block_content>

        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Ikind</name> <operator>==</operator> <name>GB_LIST</name> <operator>||</operator> <name>Jkind</name> <operator>==</operator> <name>GB_LIST</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>whole_C_matrix</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>I_unsorted_or_has_dupl</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// I2 = sort I and remove duplicates</comment>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Ikind</name> <operator>==</operator> <name>GB_LIST</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_ijsort</name> <argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ni</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>I2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>I2_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>I2k</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>I2k_size</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// Recheck the length and properties of the new I2.  This may</comment>
            <comment type="line">// convert I2 to GB_ALL or GB_RANGE, after I2 has been sorted.</comment>
            <expr_stmt><expr><call><name>GB_ijlength</name> <argument_list>(<argument><expr><name>I2</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>vlen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nI</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_ijproperties</name> <argument_list>(<argument><expr><name>I2</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>vlen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name>I_unsorted</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>I_has_dupl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>I_contig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>imin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>imax</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator> <operator>(</operator><name>I_unsorted</name> <operator>||</operator> <name>I_has_dupl</name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>I</name> <operator>=</operator> <name>I2</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>J_unsorted_or_has_dupl</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// J2 = sort J and remove duplicates</comment>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Jkind</name> <operator>==</operator> <name>GB_LIST</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_ijsort</name> <argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>J2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>J2_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>J2k</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>J2k_size</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// Recheck the length and properties of the new J2.  This may</comment>
            <comment type="line">// convert J2 to GB_ALL or GB_RANGE, after J2 has been sorted.</comment>
            <expr_stmt><expr><call><name>GB_ijlength</name> <argument_list>(<argument><expr><name>J2</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>vdim</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nJ</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_ijproperties</name> <argument_list>(<argument><expr><name>J2</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>vdim</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name>J_unsorted</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>J_has_dupl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>J_contig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jmin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jmax</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator> <operator>(</operator><name>J_unsorted</name> <operator>||</operator> <name>J_has_dupl</name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>J</name> <operator>=</operator> <name>J2</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// inverse index lists to create the A2 and M2 submatrices:</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>GrB_Index</name> <modifier>*</modifier></type><name>Iinv</name> <init>= <expr><ternary><condition><expr><name>I_unsorted_or_has_dupl</name></expr> ?</condition><then> <expr><name>I2k</name></expr> </then><else>: <expr><name>GrB_ALL</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>GrB_Index</name> <modifier>*</modifier></type><name>Jinv</name> <init>= <expr><ternary><condition><expr><name>J_unsorted_or_has_dupl</name></expr> ?</condition><then> <expr><name>J2k</name></expr> </then><else>: <expr><name>GrB_ALL</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>scalar_expansion</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// A2 = A (Iinv, Jinv)</comment>
            <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>A2</name></expr></argument>, <argument><expr><name>A2_header_handle</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subref</name> <argument_list>(<argument><expr><name>A2</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,  <comment type="line">// TODO::: make A if accum is PAIR</comment>
                <argument><expr><name><name>A</name><operator>-&gt;</operator><name>is_csc</name></name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Iinv</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>Jinv</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <comment type="line">// GB_subref can return a jumbled result</comment>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>A2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>A</name> <operator>==</operator> <name>AT</name></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><call><name>GB_Matrix_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>AT</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><name>AT</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>A</name> <operator>=</operator> <name>A2</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>M</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>assign_kind</name><operator>)</operator> <operator>==</operator> <name>GB_SUBASSIGN</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// M2 = M (Iinv, Jinv)</comment>
            <comment type="line">// if Mask_struct then M2 is extracted as iso</comment>
            <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M2_header_handle</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subref</name> <argument_list>(<argument><expr><name>M2</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>,
                <argument><expr><name><name>M</name><operator>-&gt;</operator><name>is_csc</name></name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Iinv</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>Jinv</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <comment type="line">// GB_subref can return a jumbled result</comment>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>M2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>M</name> <operator>==</operator> <name>MT</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>GB_Matrix_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>MT</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><name>MT</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>M</name> <operator>=</operator> <name>M2</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>GB_FREE_WORK</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>I2k</name></expr></argument>, <argument><expr><name>I2k_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_FREE_WORK</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>J2k</name></expr></argument>, <argument><expr><name>J2k_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// I and J are now sorted, with no duplicate entries.  They are either</comment>
    <comment type="line">// GB_ALL, GB_RANGE, or GB_STRIDE, which are intrinsically sorted with no</comment>
    <comment type="line">// duplicates, or they are explicit GB_LISTs with sorted entries and no</comment>
    <comment type="line">// duplicates.</comment>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>I_unsorted</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>I_has_dupl</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>J_unsorted</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>J_has_dupl</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check for early C_replace</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// C(:,:)&lt;any mask, replace&gt; = A or x</comment>

    <comment type="line">// C_replace_may_be_done_early is true if the C_replace action can take</comment>
    <comment type="line">// place now.  If true, the final C does not depend on the contents of</comment>
    <comment type="line">// C on input.  If bitmap assigment might be done, delay the clearing of</comment>
    <comment type="line">// C since it would be faster to set its bitmap to all zero later on,</comment>
    <comment type="line">// instead of freeing it and reallocating it.</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>C_replace_may_be_done_early</name> <init>= <expr><operator>(</operator><name>whole_C_matrix</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>C_replace</name><operator>)</operator>
        <operator>&amp;&amp;</operator> <name>accum</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>use_bitmap_assign</name><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <comment type="line">// If the entire C(:,:) is being assigned to, and if no accum operator is</comment>
    <comment type="line">// present, then the matrix can be cleared of all entries now, and then</comment>
    <comment type="line">// C_replace can be set false.  Clearing C now speeds up the assignment</comment>
    <comment type="line">// since the wait on C can be skipped, below.  It also simplifies the</comment>
    <comment type="line">// kernels.  If S is constructed, it is just an empty matrix.</comment>

    <comment type="line">// By clearing C now and setting C_replace to false, the following methods</comment>
    <comment type="line">// are used: 09 becomes 05, 10 becomes 06n or 06s, 17 becomes 13, and 18</comment>
    <comment type="line">// becomes 14.  The S matrix for methods 06s, 13, and 14 is still created,</comment>
    <comment type="line">// but it is very fast to construct and traverse since C is empty.  Method</comment>
    <comment type="line">// 00 can be skipped since C is already empty (see "quick" case below).</comment>

        <comment type="line">// prior time             new  time           action</comment>
        <comment type="line">// ----- ----             ---  ----           ------</comment>

        <comment type="line">// 00:  O(S)              nothing, O(1)       C already cleared</comment>

        <comment type="line">// 09:  O(M+S)            05:  O(M)           C&lt;M&gt; = x, no S</comment>

        <comment type="line">// 10:  O((A+S)*log(m))   06n: O(M*(log(a))   C&lt;M&gt; = A, no S</comment>
        <comment type="line">//                        06s: O(A*(log(m))   C&lt;M&gt; = A, with S</comment>

        <comment type="line">// 17:  O(m*n)            13:  O(m*n)         C&lt;!M&gt; = x, with S</comment>

        <comment type="line">// 18:  O(A*log(m))       14:  O(A*log(m))    C&lt;!M&gt; = A, with S</comment>

        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   cmp rpl acc A   S       method: action</comment>
        <comment type="line">//  =====================       ==============</comment>

        <comment type="line">//  M   -   -   -   -   -       05:  C(I,J)&lt;M&gt; = x, no S</comment>
        <comment type="line">//  M   -   -   -   A   -       06n: C(I,J)&lt;M&gt; = A, no S</comment>
        <comment type="line">//  M   -   -   -   A   S       06s: C(I,J)&lt;M&gt; = A, with S</comment>

        <comment type="line">//  M   -   r   -   -   S       09:  C(I,J)&lt;M,repl&gt; = x, with S</comment>
        <comment type="line">//  M   -   r   -   A   S       10:  C(I,J)&lt;M,repl&gt; = A, with S</comment>

        <comment type="line">//  M   c   -   -   -   S       13:  C(I,J)&lt;!M&gt; = x, with S</comment>
        <comment type="line">//  M   c   -   -   A   S       14:  C(I,J)&lt;!M&gt; = A, with S</comment>

        <comment type="line">//  M   c   r   -   -   S       17:  C(I,J)&lt;!M,repl&gt; = x, with S</comment>
        <comment type="line">//  M   c   r   -   A   S       18:  C(I,J)&lt;!M,repl&gt; = A, with S</comment>

        <comment type="line">// Methods 09, 10, 17, and 18 are now used only if C(I,J) is a</comment>
        <comment type="line">// submatrix of C, and not for the whole_C_matrix case.</comment>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// make a copy Z = C if C is aliased to A or M</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// TODO: bitmap assign can handle C==M and C==A aliasing in some cases</comment>

    <comment type="line">// If C is aliased to A and/or M, a copy of C typically must be made.</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>C_aliased</name> <init>= <expr><call><name>GB_aliased</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>A</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GB_aliased</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <comment type="line">// However, if C == M is aliased, M is structural and not complemented, I</comment>
    <comment type="line">// and J are both ":", and scalar assignment is being done, then the alias</comment>
    <comment type="line">// of C and M can be exploited.  The assignment is C&lt;C,s&gt;=scalar.</comment>
    <comment type="line">// C&lt;C,s&gt;+=scalar might be exploited in the future.</comment>
    <comment type="line">// C_replace is effectively false.</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>C_exploit_alias_with_M</name> <init>=
        <expr><operator>(</operator><operator>(</operator><name>C</name> <operator>==</operator> <name>M</name><operator>)</operator>               <comment type="line">// C is exactly aliased with M</comment>
        <operator>&amp;&amp;</operator> <name>Mask_struct</name>          <comment type="line">// mask is structural</comment>
        <operator>&amp;&amp;</operator> <operator>!</operator><name>Mask_comp</name>           <comment type="line">// and not complemented</comment>
        <operator>&amp;&amp;</operator> <name>whole_C_matrix</name>       <comment type="line">// C(:,:) is being assigned to</comment>
        <operator>&amp;&amp;</operator> <operator>(</operator><name>accum</name> <operator>==</operator> <name>NULL</name><operator>)</operator>      <comment type="line">// no accum (accum can be handled in the future)</comment>
        <operator>&amp;&amp;</operator> <name>scalar_expansion</name><operator>)</operator></expr></init></decl> ;</decl_stmt>  <comment type="line">// C&lt;C,s&gt; = scalar assignment</comment>

    <comment type="line">// GB_assign cannot tolerate any alias with the input mask,</comment>
    <comment type="line">// if the C_replace phase will be performed.</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>C_replace</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>assign_kind</name><operator>)</operator> <operator>!=</operator> <name>GB_SUBASSIGN</name><operator>)</operator></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// the C_replace phase requires C and M_in not to be aliased</comment>
        <expr_stmt><expr><name>C_aliased</name> <operator>=</operator> <name>C_aliased</name> <operator>||</operator> <call><name>GB_aliased</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>M_in</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>C_exploit_alias_with_M</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// C&lt;C,s&gt;=scalar, and C_replace can be ignored.</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C_aliased</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>            <comment type="line">// C is aliased with M, but this is OK</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_aliased</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>   <comment type="line">// A is not present so C != A</comment>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>C_replace</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(C_replace ignored) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>C_replace</name><operator>)</operator> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>C_aliased</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// C is aliased with M or A: make a copy of C to assign into</comment>
        <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>C2</name></expr></argument>, <argument><expr><name>C2_header_handle</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>C_replace_may_be_done_early</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// Instead of duplicating C, create a new empty matrix C2.</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>sparsity</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>h</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>GxB_HYPERSPARSE</name></expr> </then><else>: <expr><name>GxB_SPARSE</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>C2</name></expr></argument>, <comment type="line">// sparse or hyper, existing header</comment>
                <argument><expr><name>ctype</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>vlen</name></name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>vdim</name></name></expr></argument>, <argument><expr><name>GB_Ap_calloc</name></expr></argument>, <argument><expr><name>C_is_csc</name></expr></argument>,
                <argument><expr><name>sparsity</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>hyper_switch</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(C alias cleared; C_replace early) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>C_replace</name><operator>)</operator> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// finish any computations in C, but leave it jumbled</comment>
            <comment type="line">// TODO:: keep zombies in C</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(%sC alias: duplicate) "</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>C</name><operator>-&gt;</operator><name>iso</name></name></expr> ?</condition><then> <expr><literal type="string">"iso "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_MATRIX_WAIT_IF_PENDING_OR_ZOMBIES</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <comment type="line">// C2 = duplicate of C, which must be freed when done</comment>
            <comment type="line">// set C2-&gt;iso = C-&gt;iso OK</comment>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_dup_worker</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>C2</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>iso</name></name></expr></argument>, <argument><expr><name>C</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <comment type="line">// C2 must be transplanted back into C when done</comment>
        <expr_stmt><expr><name>C</name> <operator>=</operator> <name>C2</name></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>static_header</name></name> <operator>||</operator> <name>GBNSTATIC</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// C is not aliased, but check if it can be cleared early</comment>
        <if_stmt><if>if <condition>(<expr><name>C_replace_may_be_done_early</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// Clear C early.</comment>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_clear</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(C(:,:)&lt;any mask&gt;: C_replace early) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>C_replace</name><operator>)</operator> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="line">// the assignment operates on C in-place</comment>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// disable C_replace if C is empty</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>C_is_empty</name> <init>= <expr><operator>(</operator><call><name>GB_nnz</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>C_is_empty</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// C is completely empty.  C_replace is irrelevant so set it to false.</comment>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>C_replace</name><operator>)</operator> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine the initial subassign method to use (prior to wait)</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// This decision can change if wait(C) is done.</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>C_iso_out</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>csize</name> <init>= <expr><name><name>ctype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_void</name></type> <name><name>cout</name> <index>[<expr><call><name>GB_VLA</name><argument_list>(<argument><expr><name>csize</name></expr></argument>)</argument_list></call></expr>]</index></name></decl> ;</decl_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>subassign_method</name><operator>)</operator> <operator>=</operator> <call><name>GB_subassigner_method</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>C_iso_out</name></expr></argument>, <argument><expr><name>cout</name></expr></argument>, <argument><expr><name>C</name></expr></argument>,
        <argument><expr><operator>(</operator><operator>*</operator><name>C_replace</name><operator>)</operator></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>,
        <argument><expr><name>scalar_expansion</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check compatibilty of prior pending tuples</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// The action: ( delete ) can only delete a live entry in the pattern.  It</comment>
    <comment type="line">// cannot delete a pending tuple; pending tuples cannot become zombies.</comment>
    <comment type="line">// Thus, if this assignment has the potential for creating zombies, all</comment>
    <comment type="line">// prior pending tuples must be assembled now.  They thus become live</comment>
    <comment type="line">// entries in the pattern of C, so that this GB_subassigner can</comment>
    <comment type="line">// (potentially) turn them into zombies via action: ( delete ).</comment>

    <comment type="line">// If accum is NULL, the operation is C(I,J) = A, or C(I,J)&lt;M&gt; = A.  If A</comment>
    <comment type="line">// has any implicit zeros at all, or if M is present, then the</comment>
    <comment type="line">// action: ( delete ) is possible.  This action is taken when an entry is</comment>
    <comment type="line">// found in C but not A.  It is thus not possible to check A in advance if</comment>
    <comment type="line">// an entry in C must be deleted.  If an entry does not appear in C but</comment>
    <comment type="line">// appears as a pending tuple, deleting it would require a scan of all the</comment>
    <comment type="line">// pending tuples in C.  This is costly, and simply assembling all pending</comment>
    <comment type="line">// tuples first is faster.</comment>

    <comment type="line">// The action: ( insert ) adds additional pending tuples.  All pending</comment>
    <comment type="line">// tuples will be assembled sometime later on, using a single pending</comment>
    <comment type="line">// operator, and thus the current accum operator must match the prior</comment>
    <comment type="line">// pending operator.  If the operators do not match, then all prior pending</comment>
    <comment type="line">// tuples must be assembled now, so that this GB_subassigner can</comment>
    <comment type="line">// (potentially) insert new pending tuples whose pending operator is accum.</comment>

    <comment type="line">// These tests are conservative because it is possible that this</comment>
    <comment type="line">// GxB_subassign will not need to use action: ( insert ).</comment>

    <comment type="line">// In the discussion below, let SECOND_Ctype denote the SECOND operator</comment>
    <comment type="line">// z=f(x,y) whose ztype, xtype, and ytype matches the type of C.</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>wait</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>C</name><operator>-&gt;</operator><name>Pending</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// no pending tuples currently exist</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// If any new pending tuples are added, their pending operator is</comment>
        <comment type="line">// accum, or the implicit SECOND_Ctype operator if accum is NULL.</comment>
        <comment type="line">// The type of any pending tuples will become ctype.</comment>
        <comment type="line">// Prior zombies have no effect on this decision.</comment>

        <expr_stmt><expr><name>wait</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// prior pending tuples exist: check if action: ( delete ) can occur</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// action: ( delete ) can only operate on entries in the pattern by</comment>
        <comment type="line">// turning them into zombies.  It cannot delete prior pending tuples.</comment>
        <comment type="line">// Thus all prior pending tuples must be assembled first if</comment>
        <comment type="line">// action: ( delete ) can occur.</comment>

        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>C_replace</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// C_replace must use the action: ( delete )</comment>
            <expr_stmt><expr><name>wait</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>accum</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// This GxB_subassign can potentially use action: ( delete ), and</comment>
            <comment type="line">// thus prior pending tuples must be assembled first.  However, if</comment>
            <comment type="line">// A is completely dense, then C(I,J)=A cannot delete any entries</comment>
            <comment type="line">// from C.</comment>
            <if_stmt><if>if <condition>(<expr><name>scalar_expansion</name> <operator>||</operator> <call><name>GB_is_dense</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// A is a scalar or dense matrix, so entries cannot be deleted</comment>
                <expr_stmt><expr><name>wait</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <comment type="line">// A is sparse.  action: ( delete ) might occur.</comment>
                <expr_stmt><expr><name>wait</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// check if pending operator is compatible</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>wait</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// ( delete ) will not occur, but new pending tuples may be added</comment>
            <comment type="line">// via the action: ( insert ).  Check if the accum operator is the</comment>
            <comment type="line">// same as the prior pending operator and ensure the types are</comment>
            <comment type="line">// the same.</comment>

            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>Pending</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>Pending</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <expr_stmt><expr><name>wait</name> <operator>=</operator>
                <comment type="line">// entries in A are copied directly into the list of pending</comment>
                <comment type="line">// tuples for C, with no typecasting.  The type of the prior</comment>
                <comment type="line">// pending tuples must match the type of A.  If the types do</comment>
                <comment type="line">// not match, prior updates must be assembled first.</comment>
                <operator>(</operator><name>atype</name> <operator>!=</operator> <name><name>C</name><operator>-&gt;</operator><name>Pending</name><operator>-&gt;</operator><name>type</name></name><operator>)</operator>
                <comment type="line">// also wait if the pending operator has changed.</comment>
                <operator>||</operator> <operator>!</operator><operator>(</operator><operator>(</operator><name>accum</name> <operator>==</operator> <name><name>C</name><operator>-&gt;</operator><name>Pending</name><operator>-&gt;</operator><name>op</name></name><operator>)</operator>
                    <operator>||</operator> <operator>(</operator><call><name>GB_op_is_second</name> <argument_list>(<argument><expr><name>accum</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                        <call><name>GB_op_is_second</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>Pending</name><operator>-&gt;</operator><name>op</name></name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator>
                <comment type="line">// also wait if the iso property of C changes.</comment>
                <operator>||</operator> <operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>iso</name></name> <operator>!=</operator> <name>C_iso_out</name><operator>)</operator></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// wait on the matrix, if required</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>wait</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Prior computations are not compatible with this assignment, so all</comment>
        <comment type="line">// prior work must be finished.  This potentially costly.</comment>
        <comment type="line">// delete any lingering zombies and assemble any pending tuples</comment>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C before wait"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_MATRIX_WAIT</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">// GB_wait may have deleted all the zombies in C, so check again if C</comment>
        <comment type="line">// is empty.  If so, C_replace is irrelevant so set it false</comment>
        <expr_stmt><expr><name>C_is_empty</name> <operator>=</operator> <operator>(</operator><call><name>GB_nnz</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>C_is_empty</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><operator>*</operator><name>C_replace</name><operator>)</operator> <operator>=</operator> <name>false</name></expr> ;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// C has changed so recompute the subassigner method</comment>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>subassign_method</name><operator>)</operator> <operator>=</operator> <call><name>GB_subassigner_method</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>C_iso_out</name></expr></argument>, <argument><expr><name>cout</name></expr></argument>, <argument><expr><name>C</name></expr></argument>,
            <argument><expr><operator>(</operator><operator>*</operator><name>C_replace</name><operator>)</operator></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>,
            <argument><expr><name>scalar_expansion</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C before subassign"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_BINARYOP_OK_OR_NULL</name> <argument_list>(<argument><expr><name>accum</name></expr></argument>, <argument><expr><literal type="string">"accum for assign"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>C_iso_out</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(C iso assign) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// keep track of the current accum operator</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// If accum is NULL and pending tuples are added, they will be assembled</comment>
    <comment type="line">// sometime later (not here) using the implied SECOND_Ctype operator.  This</comment>
    <comment type="line">// GB_subassigner operation corresponds to C(I,J)=A or C(I,J)&lt;M&gt;=A.</comment>
    <comment type="line">// Subsequent calls to GrB_setElement, and subsequent calls to GrB_assign</comment>
    <comment type="line">// or GxB_subassign with an explict SECOND_Ctype operator, may create</comment>
    <comment type="line">// additional pending tuples and add them to the list without requiring</comment>
    <comment type="line">// that they be assembled first.</comment>

    <comment type="line">// If accum is non-NULL, then all prior pending tuples have the same</comment>
    <comment type="line">// pending operator as this accum.  If that prior operator was the implicit</comment>
    <comment type="line">// SECOND_Ctype and those pending tuples still exist, then this accum</comment>
    <comment type="line">// operator is the explicit SECOND_ctype operator.  The implicit</comment>
    <comment type="line">// SECOND_Ctype operator is replaced with the current accum, which is the</comment>
    <comment type="line">// explicit SECOND_Ctype operator.</comment>

    <comment type="line">// If C is iso, the pending op is effectively the implicit SECOND_Ctype op.</comment>

    <if_stmt><if>if <condition>(<expr><name><name>C</name><operator>-&gt;</operator><name>Pending</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>Pending</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>C_iso_out</name><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>accum</name></expr></else></ternary></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// convert C to its final iso property</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name><name>C</name><operator>-&gt;</operator><name>iso</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>C_iso_out</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// C is iso on input, but non-iso on output; expand the iso value</comment>
        <comment type="line">// into all of C-&gt;x</comment>
        <comment type="line">// set C-&gt;iso = false    OK</comment>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_convert_any_to_non_iso</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>C</name><operator>-&gt;</operator><name>iso</name></name> <operator>&amp;&amp;</operator> <name>C_iso_out</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// C is non-iso on input, but iso on output</comment>
        <comment type="line">// copy the cout scalar into C-&gt;x</comment>
        <comment type="line">// set C-&gt;iso = true    OK</comment>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_convert_any_to_iso</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>cout</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>C</name><operator>-&gt;</operator><name>iso</name></name> <operator>&amp;&amp;</operator> <name>C_iso_out</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// the iso status of C is unchanged; set its new iso value</comment>
        <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>cout</name></expr></argument>, <argument><expr><name>csize</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C output from GB_assign_prep"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// return results</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>Chandle</name><operator>)</operator> <operator>=</operator> <name>C</name></expr> ;</expr_stmt>            <comment type="line">// C is C_in or C2</comment>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>Mhandle</name><operator>)</operator> <operator>=</operator> <name>M</name></expr> ;</expr_stmt>            <comment type="line">// M is M_in or M2</comment>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>Ahandle</name><operator>)</operator> <operator>=</operator> <name>A</name></expr> ;</expr_stmt>            <comment type="line">// A is A_in or A2</comment>

    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>C2_handle</name><operator>)</operator> <operator>=</operator> <name>C2</name></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>M2_handle</name><operator>)</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>MT</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>MT</name></expr> </then><else>: <expr><name>M2</name></expr></else></ternary></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>A2_handle</name><operator>)</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>AT</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>AT</name></expr> </then><else>: <expr><name>A2</name></expr></else></ternary></expr> ;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>atype_handle</name><operator>)</operator> <operator>=</operator> <name>atype</name></expr> ;</expr_stmt>

    <comment type="line">// modified versions of the Rows/Cols lists, and their analysis:</comment>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>I_handle</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>GrB_Index</name> <operator>*</operator><operator>)</operator> <name>I</name></expr> ;</expr_stmt>     <comment type="line">// either Rows, Cols, or I2</comment>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>I2_handle</name><operator>)</operator> <operator>=</operator> <name>I2</name></expr> ;</expr_stmt>         <comment type="line">// temporary sorted copy of Rows or Cols list</comment>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>I2_size_handle</name><operator>)</operator> <operator>=</operator> <name>I2_size</name></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>ni_handle</name><operator>)</operator> <operator>=</operator> <name>ni</name></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>nI_handle</name><operator>)</operator> <operator>=</operator> <name>nI</name></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>Ikind_handle</name><operator>)</operator> <operator>=</operator> <name>Ikind</name></expr> ;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>J_handle</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>GrB_Index</name> <operator>*</operator><operator>)</operator> <name>J</name></expr> ;</expr_stmt>     <comment type="line">// either Rows, Cols, or J2</comment>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>J2_handle</name><operator>)</operator> <operator>=</operator> <name>J2</name></expr> ;</expr_stmt>         <comment type="line">// temporary sorted copy of Rows or Cols list</comment>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>J2_size_handle</name><operator>)</operator> <operator>=</operator> <name>J2_size</name></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>nj_handle</name><operator>)</operator> <operator>=</operator> <name>nj</name></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>nJ_handle</name><operator>)</operator> <operator>=</operator> <name>nJ</name></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>Jkind_handle</name><operator>)</operator> <operator>=</operator> <name>Jkind</name></expr> ;</expr_stmt>

    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
