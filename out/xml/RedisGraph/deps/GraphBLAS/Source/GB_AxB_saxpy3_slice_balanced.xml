<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" xmlns:omp="http://www.srcML.org/srcML/openmp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_AxB_saxpy3_slice_balanced.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_AxB_saxpy3_slice_balanced: construct balanced tasks for GB_AxB_saxpy3</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// If the mask is present but must be discarded, this function returns</comment>
<comment type="line">// GrB_NO_VALUE, to indicate that the analysis was terminated early.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy3.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_unused.h"</cpp:file></cpp:include>

<comment type="line">// control parameters for generating parallel tasks</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_NTASKS_PER_THREAD</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_COSTLY</name></cpp:macro> <cpp:value>1.2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FINE_WORK</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MWORK_ALPHA</name></cpp:macro> <cpp:value>0.01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MWORK_BETA</name></cpp:macro> <cpp:value>0.10</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_WORKSPACE</name></cpp:macro>                   \
<cpp:value>{                                           \
    GB_WERK_POP (Fine_fl, int64_t) ;        \
    GB_WERK_POP (Fine_slice, int64_t) ;     \
    GB_WERK_POP (Coarse_Work, int64_t) ;    \
    GB_WERK_POP (Coarse_initial, int64_t) ; \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_ALL</name></cpp:macro>                                 \
<cpp:value>{                                                   \
    GB_FREE_WORKSPACE ;                             \
    GB_FREE_WORK (&amp;SaxpyTasks, SaxpyTasks_size) ;   \
}</cpp:value></cpp:define>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_hash_table_size</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// flmax is the max flop count for computing A*B(:,j), for any vector j that</comment>
<comment type="line">// this task computes.  If the mask M is present, flmax also includes the</comment>
<comment type="line">// number of entries in M(:,j).  GB_hash_table_size determines the hash table</comment>
<comment type="line">// size for this task, which is twice the smallest power of 2 larger than</comment>
<comment type="line">// flmax.  If flmax is large enough, the hash_size is returned as cvlen, so</comment>
<comment type="line">// that Gustavson's method will be used instead of the Hash method.</comment>

<comment type="line">// By default, Gustavson vs Hash is selected automatically.  AxB_method can be</comment>
<comment type="line">// selected via the descriptor or a global setting, as the non-default</comment>
<comment type="line">// GxB_AxB_GUSTAVSON or GxB_AxB_HASH settings, to enforce the selection of</comment>
<comment type="line">// either of those methods.  However, if Hash is selected but the hash table</comment>
<comment type="line">// equals or exceeds cvlen, then Gustavson's method is used instead.</comment>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int64_t</name></type> <name>GB_hash_table_size</name>
<parameter_list>(
    <parameter><decl><type><name>int64_t</name></type> <name>flmax</name></decl></parameter>,      <comment type="line">// max flop count for any vector computed by this task</comment>
    <parameter><decl><type><name>int64_t</name></type> <name>cvlen</name></decl></parameter>,      <comment type="line">// vector length of C</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Desc_Value</name></type> <name>AxB_method</name></decl></parameter>     <comment type="line">// Default, Gustavson, or Hash</comment>
)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>hash_size</name></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>AxB_method</name> <operator>==</operator> <name>GxB_AxB_GUSTAVSON</name> <operator>||</operator> <name>flmax</name> <operator>&gt;=</operator> <name>cvlen</name><operator>/</operator><literal type="number">2</literal></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// use Gustavson if selected explicitly or if flmax is large</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><name>hash_size</name> <operator>=</operator> <name>cvlen</name></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// flmax is small; consider hash vs Gustavson</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// hash_size = 2 * (smallest power of 2 &gt;= flmax)</comment>
        <expr_stmt><expr><name>hash_size</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <literal type="number">2</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><call><name>GB_FLOOR_LOG2</name> <argument_list>(<argument><expr><name>flmax</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr> ;</expr_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>use_Gustavson</name></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>AxB_method</name> <operator>==</operator> <name>GxB_AxB_HASH</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// always use Hash method, unless the hash_size &gt;= cvlen</comment>
            <expr_stmt><expr><name>use_Gustavson</name> <operator>=</operator> <operator>(</operator><name>hash_size</name> <operator>&gt;=</operator> <name>cvlen</name><operator>)</operator></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// default: auto selection:</comment>
            <comment type="line">// use Gustavson's method if hash_size is too big</comment>
            <expr_stmt><expr><name>use_Gustavson</name> <operator>=</operator> <operator>(</operator><name>hash_size</name> <operator>&gt;=</operator> <name>cvlen</name><operator>/</operator><literal type="number">12</literal><operator>)</operator></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>use_Gustavson</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>hash_size</name> <operator>=</operator> <name>cvlen</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// return result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <return>return <expr><operator>(</operator><name>hash_size</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_create_coarse_task: create a single coarse task</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// Compute the max flop count for any vector in a coarse task, determine the</comment>
<comment type="line">// hash table size, and construct the coarse task.</comment>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>GB_create_coarse_task</name>
<parameter_list>(
    <parameter><decl><type><name>int64_t</name></type> <name>kfirst</name></decl></parameter>,     <comment type="line">// coarse task consists of vectors kfirst:klast</comment>
    <parameter><decl><type><name>int64_t</name></type> <name>klast</name></decl></parameter>,
    <parameter><decl><type><name>GB_saxpy3task_struct</name> <modifier>*</modifier></type><name>SaxpyTasks</name></decl></parameter>,
    <parameter><decl><type><name>int</name></type> <name>taskid</name></decl></parameter>,         <comment type="line">// taskid for this coarse task</comment>
    <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>Bflops</name></decl></parameter>,    <comment type="line">// size bnvec; cum sum of flop counts for vectors of B</comment>
    <parameter><decl><type><name>int64_t</name></type> <name>cvlen</name></decl></parameter>,      <comment type="line">// vector length of B and C</comment>
    <parameter><decl><type><name>double</name></type> <name>chunk</name></decl></parameter>,
    <parameter><decl><type><name>int</name></type> <name>nthreads_max</name></decl></parameter>,
    <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>Coarse_Work</name></decl></parameter>,   <comment type="line">// workspace for parallel reduction for flop count</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Desc_Value</name></type> <name>AxB_method</name></decl></parameter>     <comment type="line">// Default, Gustavson, or Hash</comment>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// find the max # of flops for any vector in this task</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>nk</name> <init>= <expr><name>klast</name> <operator>-</operator> <name>kfirst</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nth</name> <init>= <expr><call><name>GB_nthreads</name> <argument_list>(<argument><expr><name>nk</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <comment type="line">// each thread finds the max flop count for a subset of the vectors</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>tid</name></decl> ;</decl_stmt>
    <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nth</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>static</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
    <for>for <control>(<init><expr><name>tid</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>tid</name> <operator>&lt;</operator> <name>nth</name></expr> ;</condition> <incr><expr><name>tid</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>my_flmax</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>istart</name></decl>, <decl><type ref="prev"/><name>iend</name></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>GB_PARTITION</name> <argument_list>(<argument><expr><name>istart</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>nk</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name>istart</name></expr></init></decl> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>iend</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content> 
            <decl_stmt><decl><type><name>int64_t</name></type> <name>kk</name> <init>= <expr><name>kfirst</name> <operator>+</operator> <name>i</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>fl</name> <init>= <expr><name><name>Bflops</name> <index>[<expr><name>kk</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>Bflops</name> <index>[<expr><name>kk</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <expr_stmt><expr><name>my_flmax</name> <operator>=</operator> <call><name>GB_IMAX</name> <argument_list>(<argument><expr><name>my_flmax</name></expr></argument>, <argument><expr><name>fl</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>Coarse_Work</name> <index>[<expr><name>tid</name></expr>]</index></name> <operator>=</operator> <name>my_flmax</name></expr> ;</expr_stmt>
    </block_content>}</block></for>

    <comment type="line">// combine results from each thread</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>flmax</name> <init>= <expr><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
    <for>for <control>(<init><expr><name>tid</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>tid</name> <operator>&lt;</operator> <name>nth</name></expr> ;</condition> <incr><expr><name>tid</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content> 
        <expr_stmt><expr><name>flmax</name> <operator>=</operator> <call><name>GB_IMAX</name> <argument_list>(<argument><expr><name>flmax</name></expr></argument>, <argument><expr><name><name>Coarse_Work</name> <index>[<expr><name>tid</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></for>

    <comment type="line">// check the parallel computation</comment>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>flmax2</name> <init>= <expr><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>kk</name> <init>= <expr><name>kfirst</name></expr></init></decl> ;</init> <condition><expr><name>kk</name> <operator>&lt;=</operator> <name>klast</name></expr> ;</condition> <incr><expr><name>kk</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>fl</name> <init>= <expr><name><name>Bflops</name> <index>[<expr><name>kk</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>Bflops</name> <index>[<expr><name>kk</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
        <expr_stmt><expr><name>flmax2</name> <operator>=</operator> <call><name>GB_IMAX</name> <argument_list>(<argument><expr><name>flmax2</name></expr></argument>, <argument><expr><name>fl</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>flmax</name> <operator>==</operator> <name>flmax2</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// define the coarse task</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>start</name>  <operator>=</operator> <name>kfirst</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>end</name>    <operator>=</operator> <name>klast</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>vector</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>hsize</name>  <operator>=</operator> <call><name>GB_hash_table_size</name> <argument_list>(<argument><expr><name>flmax</name></expr></argument>, <argument><expr><name>cvlen</name></expr></argument>, <argument><expr><name>AxB_method</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>Hi</name>     <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>      <comment type="line">// assigned later</comment>
    <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>Hf</name>     <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>      <comment type="line">// assigned later</comment>
    <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>Hx</name>     <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>      <comment type="line">// assigned later</comment>
    <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>my_cjnz</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>        <comment type="line">// for fine tasks only </comment>
    <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>leader</name>  <operator>=</operator> <name>taskid</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>team_size</name> <operator>=</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_AxB_saxpy3_slice_balanced: create balanced tasks for saxpy3</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GrB_Info</name></type> <name>GB_AxB_saxpy3_slice_balanced</name>
<parameter_list>(
    <comment type="line">// inputs</comment>
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,                   <comment type="line">// output matrix</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>M</name></decl></parameter>,             <comment type="line">// optional mask matrix</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_comp</name></decl></parameter>,           <comment type="line">// if true, use !M</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,             <comment type="line">// input matrix A</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>B</name></decl></parameter>,             <comment type="line">// input matrix B</comment>
    <parameter><decl><type><name>GrB_Desc_Value</name></type> <name>AxB_method</name></decl></parameter>,      <comment type="line">// Default, Gustavson, or Hash</comment>
    <comment type="line">// outputs</comment>
    <parameter><decl><type><name>GB_saxpy3task_struct</name> <modifier>*</modifier><modifier>*</modifier></type><name>SaxpyTasks_handle</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>SaxpyTasks_size_handle</name></decl></parameter>,
    <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>apply_mask</name></decl></parameter>,               <comment type="line">// if true, apply M during sapxy3</comment>
    <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>M_in_place</name></decl></parameter>,               <comment type="line">// if true, use M in-place</comment>
    <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ntasks</name></decl></parameter>,                    <comment type="line">// # of tasks created (coarse and fine)</comment>
    <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nfine</name></decl></parameter>,                     <comment type="line">// # of fine tasks created</comment>
    <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nthreads</name></decl></parameter>,                  <comment type="line">// # of threads to use</comment>
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl> ;</decl_stmt>

    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>apply_mask</name><operator>)</operator> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>M_in_place</name><operator>)</operator> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>ntasks</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>nfine</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>nthreads</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK_OR_NULL</name> <argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><literal type="string">"M for saxpy3_slice_balanced A*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"A for saxpy3_slice_balanced A*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><literal type="string">"B for saxpy3_slice_balanced A*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine the # of threads to use</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_GET_NTHREADS_MAX</name> <argument_list>(<argument><expr><name>nthreads_max</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><name>chunk</name> <operator>=</operator> <name>chunk</name> <operator>*</operator> <literal type="number">8</literal></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// define result and workspace</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GB_saxpy3task_struct</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>SaxpyTasks</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>SaxpyTasks_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>

    <expr_stmt><expr><call><name>GB_WERK_DECLARE</name> <argument_list>(<argument><expr><name>Coarse_initial</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <comment type="line">// initial coarse tasks</comment>
    <expr_stmt><expr><call><name>GB_WERK_DECLARE</name> <argument_list>(<argument><expr><name>Coarse_Work</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>    <comment type="line">// workspace for flop counts</comment>
    <expr_stmt><expr><call><name>GB_WERK_DECLARE</name> <argument_list>(<argument><expr><name>Fine_slice</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_WERK_DECLARE</name> <argument_list>(<argument><expr><name>Fine_fl</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>        <comment type="line">// size max(nnz(B(:,j)))</comment>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get A, and B</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ap</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ah</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>h</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>avlen</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>vlen</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>A_is_hyper</name> <init>= <expr><call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>A_Yp</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>A_Yi</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>A_Yx</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>A_hash_bits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>A_is_hyper</name></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>, <argument><expr><literal type="string">"A-&gt;Y hyper_hash"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>A_Yp</name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>Y</name><operator>-&gt;</operator><name>p</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>A_Yi</name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>Y</name><operator>-&gt;</operator><name>i</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>A_Yx</name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>Y</name><operator>-&gt;</operator><name>x</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>A_hash_bits</name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>Y</name><operator>-&gt;</operator><name>vdim</name></name> <operator>-</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Bp</name> <init>= <expr><name><name>B</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Bh</name> <init>= <expr><name><name>B</name><operator>-&gt;</operator><name>h</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int8_t</name>  <modifier>*</modifier><specifier>restrict</specifier></type> <name>Bb</name> <init>= <expr><name><name>B</name><operator>-&gt;</operator><name>b</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Bi</name> <init>= <expr><name><name>B</name><operator>-&gt;</operator><name>i</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>bvdim</name> <init>= <expr><name><name>B</name><operator>-&gt;</operator><name>vdim</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>bnz</name> <init>= <expr><call><name>GB_nnz_held</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>bnvec</name> <init>= <expr><name><name>B</name><operator>-&gt;</operator><name>nvec</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>bvlen</name> <init>= <expr><name><name>B</name><operator>-&gt;</operator><name>vlen</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>B_is_hyper</name> <init>= <expr><call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>cvlen</name> <init>= <expr><name>avlen</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>cvdim</name> <init>= <expr><name>bvdim</name></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// compute flop counts for each vector of B and C</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>Mwork</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Bflops</name> <init>= <expr><name><name>C</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl> ;</decl_stmt>    <comment type="line">// use C-&gt;p as workspace for Bflops</comment>
    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_AxB_saxpy3_flopcount</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Mwork</name></expr></argument>, <argument><expr><name>Bflops</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>,
        <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>total_flops</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>Bflops</name> <index>[<expr><name>bnvec</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>axbflops</name> <init>= <expr><name>total_flops</name> <operator>-</operator> <name>Mwork</name></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"axbwork %g "</literal></expr></argument>, <argument><expr><name>axbflops</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>Mwork</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"mwork %g "</literal></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>Mwork</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine if the mask M should be applied, or done later</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>M</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// M is not present </comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>apply_mask</name><operator>)</operator> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GB_as_if_full</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// M is present and full, bitmap, or sparse/hyper with all entries</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// Choose all-hash or all-Gustavson tasks, and apply M during saxpy3.</comment>

        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>apply_mask</name><operator>)</operator> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>

        <comment type="line">// The work for M has not yet been added Bflops.</comment>
        <comment type="line">// Each vector M(:,j) has cvlen entries.</comment>
        <expr_stmt><expr><name>Mwork</name> <operator>=</operator> <name>cvlen</name> <operator>*</operator> <name>cvdim</name></expr> ;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>AxB_method</name> <operator>==</operator> <name>GxB_AxB_HASH</name> <operator>||</operator> <name>AxB_method</name> <operator>==</operator> <name>GxB_AxB_GUSTAVSON</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>axbflops</name> <operator>&lt;</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>Mwork</name> <operator>*</operator> <name>GB_MWORK_BETA</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// The mask is too costly to scatter into the Hf workspace.</comment>
                <comment type="line">// Leave it in place and use all-hash tasks.</comment>
                <expr_stmt><expr><name>AxB_method</name> <operator>=</operator> <name>GxB_AxB_HASH</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <comment type="line">// Scatter M into Hf and use all-Gustavson tasks.</comment>
                <expr_stmt><expr><name>AxB_method</name> <operator>=</operator> <name>GxB_AxB_GUSTAVSON</name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>AxB_method</name> <operator>==</operator> <name>GxB_AxB_HASH</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// Use the hash method for all tasks (except for those tasks which</comment>
            <comment type="line">// require a hash table size &gt;= cvlen; those tasks use Gustavson).</comment>
            <comment type="line">// Do not scatter the mask into the Hf hash workspace.  The work</comment>
            <comment type="line">// for the mask is not accounted for in Bflops, so the hash tables</comment>
            <comment type="line">// can be small.</comment>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>M_in_place</name><operator>)</operator> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(use mask in-place) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// Use the Gustavson method for all tasks, and scatter M into the</comment>
            <comment type="line">// fine Gustavson workspace.  The work for M is not yet in the</comment>
            <comment type="line">// Bflops cumulative sum.  Add it now.</comment>
            <macro><name>ASSERT</name> <argument_list>(<argument>AxB_method == GxB_AxB_GUSTAVSON</argument>)</argument_list></macro>
            <decl_stmt><decl><type><name>int</name></type> <name>nth</name> <init>= <expr><call><name>GB_nthreads</name> <argument_list>(<argument><expr><name>bnvec</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>kk</name></decl> ;</decl_stmt>
            <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nth</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>static</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
            <for>for <control>(<init><expr><name>kk</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>kk</name> <operator>&lt;=</operator> <name>bnvec</name></expr> ;</condition> <incr><expr><name>kk</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content> 
                <expr_stmt><expr><name><name>Bflops</name> <index>[<expr><name>kk</name></expr>]</index></name> <operator>+=</operator> <name>cvlen</name> <operator>*</operator> <operator>(</operator><name>kk</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr> ;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><name>total_flops</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>Bflops</name> <index>[<expr><name>bnvec</name></expr>]</index></name></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(use mask) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>axbflops</name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>Mwork</name> <operator>*</operator> <name>GB_MWORK_ALPHA</name><operator>)</operator></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// M is costly to use; apply it after C=A*B</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// Do not use M during the computation of A*B.  Instead, compute C=A*B</comment>
        <comment type="line">// and then apply the mask later.  Tell the caller that the mask should</comment>
        <comment type="line">// not be applied, so that it will be applied later in GB_mxm.</comment>

        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>apply_mask</name><operator>)</operator> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(discard mask) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
        <return>return <expr><operator>(</operator><name>GrB_NO_VALUE</name><operator>)</operator></expr> ;</return>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// use M during saxpy3</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>apply_mask</name><operator>)</operator> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(use mask) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine # of threads and # of initial coarse tasks</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>nthreads</name><operator>)</operator> <operator>=</operator> <call><name>GB_nthreads</name> <argument_list>(<argument><expr><name>total_flops</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ntasks_initial</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><operator>*</operator><name>nthreads</name><operator>)</operator> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>:
        <expr><operator>(</operator><name>GB_NTASKS_PER_THREAD</name> <operator>*</operator> <operator>(</operator><operator>*</operator><name>nthreads</name><operator>)</operator><operator>)</operator></expr></else></ternary></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// give preference to Gustavson when using few threads</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>AxB_method</name> <operator>==</operator> <name>GxB_AxB_HASH</name> <operator>||</operator> <name>AxB_method</name> <operator>==</operator> <name>GxB_AxB_GUSTAVSON</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Unless a specific method has been explicitly requested, see if</comment>
        <comment type="line">// Gustavson should be used.</comment>
        <comment type="line">// Matrix-vector has a maximum intensity of 1, so this heuristic only</comment>
        <comment type="line">// applies to GrB_mxm.</comment>
        <decl_stmt><decl><type><name>double</name></type> <name>abnz</name> <init>= <expr><call><name>GB_nnz</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>GB_nnz</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>workspace</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator> <name>ntasks_initial</name> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>cvlen</name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>intensity</name> <init>= <expr><name>total_flops</name> <operator>/</operator> <name>abnz</name></expr></init></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(intensity: %0.3g workspace/(nnz(A)+nnz(B)): %0.3g"</literal></expr></argument>,
            <argument><expr><name>intensity</name></expr></argument>, <argument><expr><name>workspace</name> <operator>/</operator> <name>abnz</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>*</operator><name>nthreads</name><operator>)</operator> <operator>&lt;=</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name>intensity</name> <operator>&gt;=</operator> <literal type="number">8</literal>  <operator>&amp;&amp;</operator> <name>workspace</name> <operator>&lt;</operator> <name>abnz</name><operator>)</operator>
        <operator>||</operator>  <operator>(</operator>                    <name>intensity</name> <operator>&gt;=</operator> <literal type="number">16</literal> <operator>&amp;&amp;</operator> <name>workspace</name> <operator>&lt;</operator> <name>abnz</name><operator>)</operator></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// work intensity is large, and Gustvason workspace is modest;</comment>
            <comment type="line">// use Gustavson for all tasks</comment>
            <expr_stmt><expr><name>AxB_method</name> <operator>=</operator> <name>GxB_AxB_GUSTAVSON</name></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">": all Gustvason) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// use default task creation: mix of Hash and Gustavson</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">") "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine target task size</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>double</name></type> <name>target_task_size</name> <init>= <expr><name>total_flops</name> <operator>/</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>ntasks_initial</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><name>target_task_size</name> <operator>=</operator> <call><name>GB_IMAX</name> <argument_list>(<argument><expr><name>target_task_size</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>target_fine_size</name> <init>= <expr><name>target_task_size</name> <operator>/</operator> <name>GB_FINE_WORK</name></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><name>target_fine_size</name> <operator>=</operator> <call><name>GB_IMAX</name> <argument_list>(<argument><expr><name>target_fine_size</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>very_costly</name> <init>= <expr><call><name>GB_Global_hack_get</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>       <comment type="line">// modified for testing</comment>
    <if_stmt><if>if <condition>(<expr><name>very_costly</name> <operator>&lt;=</operator> <name>GxB_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>very_costly</name> <operator>=</operator> <literal type="number">8</literal></expr> ;</expr_stmt></block_content></block></if></if_stmt>   <comment type="line">// default is 8</comment>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine # of parallel tasks</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>ncoarse</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>       <comment type="line">// # of coarse tasks</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_bjnz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>      <comment type="line">// max (nnz (B (:,j))) of fine tasks</comment>

    <comment type="line">// FUTURE: also use ultra-fine tasks that compute A(i1:i2,k)*B(k,j)</comment>

    <if_stmt><if>if <condition>(<expr><name>ntasks_initial</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// construct initial coarse tasks</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><call><name>GB_WERK_PUSH</name> <argument_list>(<argument><expr><name>Coarse_initial</name></expr></argument>, <argument><expr><name>ntasks_initial</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>Coarse_initial</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// out of memory</comment>
            <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
            <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>GB_pslice</name> <argument_list>(<argument><expr><name>Coarse_initial</name></expr></argument>, <argument><expr><name>Bflops</name></expr></argument>, <argument><expr><name>bnvec</name></expr></argument>, <argument><expr><name>ntasks_initial</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// split the work into coarse and fine tasks</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>taskid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>taskid</name> <operator>&lt;</operator> <name>ntasks_initial</name></expr> ;</condition> <incr><expr><name>taskid</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="line">// get the initial coarse task</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>kfirst</name> <init>= <expr><name><name>Coarse_initial</name> <index>[<expr><name>taskid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>klast</name>  <init>= <expr><name><name>Coarse_initial</name> <index>[<expr><name>taskid</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>task_ncols</name> <init>= <expr><name>klast</name> <operator>-</operator> <name>kfirst</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type> <name>task_flops</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name><name>Bflops</name> <index>[<expr><name>klast</name></expr>]</index></name> <operator>-</operator> <name><name>Bflops</name> <index>[<expr><name>kfirst</name></expr>]</index></name><operator>)</operator></expr></init></decl> ;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>task_ncols</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// This coarse task is empty, having been squeezed out by</comment>
                <comment type="line">// costly vectors in adjacent coarse tasks.</comment>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>task_flops</name> <operator>&gt;</operator> <name>very_costly</name> <operator>*</operator> <name>GB_COSTLY</name> <operator>*</operator> <name>target_task_size</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// This coarse task is too costly, because it contains one or</comment>
                <comment type="line">// more costly vectors.  Split its vectors into a mixture of</comment>
                <comment type="line">// coarse and fine tasks.</comment>

                <decl_stmt><decl><type><name>int64_t</name></type> <name>kcoarse_start</name> <init>= <expr><name>kfirst</name></expr></init></decl> ;</decl_stmt>

                <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>kk</name> <init>= <expr><name>kfirst</name></expr></init></decl> ;</init> <condition><expr><name>kk</name> <operator>&lt;</operator> <name>klast</name></expr> ;</condition> <incr><expr><name>kk</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <comment type="line">// jflops = # of flops to compute a single vector A*B(:,j)</comment>
                    <comment type="line">// where j == GBH (Bh, kk)</comment>
                    <decl_stmt><decl><type><name>double</name></type> <name>jflops</name> <init>= <expr><name><name>Bflops</name> <index>[<expr><name>kk</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>Bflops</name> <index>[<expr><name>kk</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                    <comment type="line">// bjnz = nnz (B (:,j))</comment>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>bjnz</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>Bp</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>bvlen</name></expr> </then><else>: <expr><operator>(</operator><name><name>Bp</name> <index>[<expr><name>kk</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>Bp</name> <index>[<expr><name>kk</name></expr>]</index></name><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>jflops</name> <operator>&gt;</operator> <name>GB_COSTLY</name> <operator>*</operator> <name>target_task_size</name> <operator>&amp;&amp;</operator> <name>bjnz</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// A*B(:,j) is costly; split it into 2 or more fine</comment>
                        <comment type="line">// tasks.  First flush the prior coarse task, if any.</comment>
                        <if_stmt><if>if <condition>(<expr><name>kcoarse_start</name> <operator>&lt;</operator> <name>kk</name></expr>)</condition>
                        <block>{<block_content> 
                            <comment type="line">// vectors kcoarse_start to kk-1 form a single</comment>
                            <comment type="line">// coarse task</comment>
                            <expr_stmt><expr><name>ncoarse</name><operator>++</operator></expr> ;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

                        <comment type="line">// next coarse task (if any) starts at kk+1</comment>
                        <expr_stmt><expr><name>kcoarse_start</name> <operator>=</operator> <name>kk</name><operator>+</operator><literal type="number">1</literal></expr> ;</expr_stmt>

                        <comment type="line">// vectors kk will be split into multiple fine tasks</comment>
                        <expr_stmt><expr><name>max_bjnz</name> <operator>=</operator> <call><name>GB_IMAX</name> <argument_list>(<argument><expr><name>max_bjnz</name></expr></argument>, <argument><expr><name>bjnz</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <decl_stmt><decl><type><name>int</name></type> <name>team_size</name> <init>= <expr><call><name>ceil</name> <argument_list>(<argument><expr><name>jflops</name> <operator>/</operator> <name>target_fine_size</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>nfine</name><operator>)</operator> <operator>+=</operator> <name>team_size</name></expr> ;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>

                <comment type="line">// flush the last coarse task, if any</comment>
                <if_stmt><if>if <condition>(<expr><name>kcoarse_start</name> <operator>&lt;</operator> <name>klast</name></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// vectors kcoarse_start to klast-1 form a single</comment>
                    <comment type="line">// coarse task</comment>
                    <expr_stmt><expr><name>ncoarse</name><operator>++</operator></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>

            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <comment type="line">// This coarse task is OK as-is.</comment>
                <expr_stmt><expr><name>ncoarse</name><operator>++</operator></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// entire computation in a single fine or coarse task</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// use a single coarse task for now, but convert it later to a single</comment>
        <comment type="line">// fine hash task if the hash method is used</comment>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>nfine</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
        <expr_stmt><expr><name>ncoarse</name> <operator>=</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>ntasks</name><operator>)</operator> <operator>=</operator> <name>ncoarse</name> <operator>+</operator> <operator>(</operator><operator>*</operator><name>nfine</name><operator>)</operator></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// allocate the tasks, and workspace to construct fine tasks</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><name>SaxpyTasks</name> <operator>=</operator> <call><name>GB_MALLOC_WORK</name> <argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>ntasks</name><operator>)</operator></expr></argument>, <argument><expr><name>GB_saxpy3task_struct</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>SaxpyTasks_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_WERK_PUSH</name> <argument_list>(<argument><expr><name>Coarse_Work</name></expr></argument>, <argument><expr><name>nthreads_max</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>max_bjnz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// also allocate workspace to construct fine tasks</comment>
        <expr_stmt><expr><call><name>GB_WERK_PUSH</name> <argument_list>(<argument><expr><name>Fine_slice</name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>ntasks</name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <comment type="line">// Fine_fl will only fit on the Werk stack if max_bjnz is small,</comment>
        <comment type="line">// but try anyway, in case it fits.  It is placed at the top of the</comment>
        <comment type="line">// Werk stack.</comment>
        <expr_stmt><expr><call><name>GB_WERK_PUSH</name> <argument_list>(<argument><expr><name>Fine_fl</name></expr></argument>, <argument><expr><name>max_bjnz</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>SaxpyTasks</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>Coarse_Work</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <operator>(</operator><name>max_bjnz</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>Fine_slice</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>Fine_fl</name> <operator>==</operator> <name>NULL</name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// out of memory</comment>
        <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
        <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// clear SaxpyTasks</comment>
    <expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>SaxpyTasks</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SaxpyTasks_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// create the tasks</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>ntasks_initial</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// create the coarse and fine tasks</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><name>int</name></type> <name>nf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>            <comment type="line">// fine tasks have task id 0:nfine-1</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>nc</name> <init>= <expr><operator>(</operator><operator>*</operator><name>nfine</name><operator>)</operator></expr></init></decl> ;</decl_stmt>     <comment type="line">// coarse task ids are nfine:ntasks-1</comment>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>taskid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>taskid</name> <operator>&lt;</operator> <name>ntasks_initial</name></expr> ;</condition> <incr><expr><name>taskid</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="line">// get the initial coarse task</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>kfirst</name> <init>= <expr><name><name>Coarse_initial</name> <index>[<expr><name>taskid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>klast</name>  <init>= <expr><name><name>Coarse_initial</name> <index>[<expr><name>taskid</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>task_ncols</name> <init>= <expr><name>klast</name> <operator>-</operator> <name>kfirst</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type> <name>task_flops</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name><name>Bflops</name> <index>[<expr><name>klast</name></expr>]</index></name> <operator>-</operator> <name><name>Bflops</name> <index>[<expr><name>kfirst</name></expr>]</index></name><operator>)</operator></expr></init></decl> ;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>task_ncols</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// This coarse task is empty, having been squeezed out by</comment>
                <comment type="line">// costly vectors in adjacent coarse tasks.</comment>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>task_flops</name> <operator>&gt;</operator> <name>very_costly</name> <operator>*</operator> <name>GB_COSTLY</name> <operator>*</operator> <name>target_task_size</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// This coarse task is too costly, because it contains one or</comment>
                <comment type="line">// more costly vectors.  Split its vectors into a mixture of</comment>
                <comment type="line">// coarse and fine tasks.</comment>

                <decl_stmt><decl><type><name>int64_t</name></type> <name>kcoarse_start</name> <init>= <expr><name>kfirst</name></expr></init></decl> ;</decl_stmt>

                <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>kk</name> <init>= <expr><name>kfirst</name></expr></init></decl> ;</init> <condition><expr><name>kk</name> <operator>&lt;</operator> <name>klast</name></expr> ;</condition> <incr><expr><name>kk</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <comment type="line">// jflops = # of flops to compute a single vector A*B(:,j)</comment>
                    <decl_stmt><decl><type><name>double</name></type> <name>jflops</name> <init>= <expr><name><name>Bflops</name> <index>[<expr><name>kk</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>Bflops</name> <index>[<expr><name>kk</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                    <comment type="line">// bjnz = nnz (B (:,j))</comment>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>bjnz</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>Bp</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>bvlen</name></expr> </then><else>: <expr><operator>(</operator><name><name>Bp</name> <index>[<expr><name>kk</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>Bp</name> <index>[<expr><name>kk</name></expr>]</index></name><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>jflops</name> <operator>&gt;</operator> <name>GB_COSTLY</name> <operator>*</operator> <name>target_task_size</name> <operator>&amp;&amp;</operator> <name>bjnz</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// A*B(:,j) is costly; split it into 2 or more fine</comment>
                        <comment type="line">// tasks.  First flush the prior coarse task, if any.</comment>
                        <if_stmt><if>if <condition>(<expr><name>kcoarse_start</name> <operator>&lt;</operator> <name>kk</name></expr>)</condition>
                        <block>{<block_content> 
                            <comment type="line">// kcoarse_start:kk-1 form a single coarse task</comment>
                            <expr_stmt><expr><call><name>GB_create_coarse_task</name> <argument_list>(<argument><expr><name>kcoarse_start</name></expr></argument>, <argument><expr><name>kk</name><operator>-</operator><literal type="number">1</literal></expr></argument>,
                                <argument><expr><name>SaxpyTasks</name></expr></argument>, <argument><expr><name>nc</name><operator>++</operator></expr></argument>, <argument><expr><name>Bflops</name></expr></argument>, <argument><expr><name>cvlen</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>,
                                <argument><expr><name>nthreads_max</name></expr></argument>, <argument><expr><name>Coarse_Work</name></expr></argument>, <argument><expr><name>AxB_method</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

                        <comment type="line">// next coarse task (if any) starts at kk+1</comment>
                        <expr_stmt><expr><name>kcoarse_start</name> <operator>=</operator> <name>kk</name><operator>+</operator><literal type="number">1</literal></expr> ;</expr_stmt>

                        <comment type="line">// count the work for each entry B(k,j).  Do not</comment>
                        <comment type="line">// include the work to scan M(:,j), since that will</comment>
                        <comment type="line">// be evenly divided between all tasks in this team.</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>pB_start</name> <init>= <expr><call><name>GBP</name> <argument_list>(<argument><expr><name>Bp</name></expr></argument>, <argument><expr><name>kk</name></expr></argument>, <argument><expr><name>bvlen</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>int</name></type> <name>nth</name> <init>= <expr><call><name>GB_nthreads</name> <argument_list>(<argument><expr><name>bjnz</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>s</name></decl> ;</decl_stmt>
                        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nth</omp:expr></omp:argument>)</omp:argument_list></omp:clause> \
                            <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>static</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
                        <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>bjnz</name></expr> ;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content> 
                            <comment type="line">// get B(k,j)</comment>
                            <expr_stmt><expr><name><name>Fine_fl</name> <index>[<expr><name>s</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                            <decl_stmt><decl><type><name>int64_t</name></type> <name>pB</name> <init>= <expr><name>pB_start</name> <operator>+</operator> <name>s</name></expr></init></decl> ;</decl_stmt>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GBB</name> <argument_list>(<argument><expr><name>Bb</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>
                            <decl_stmt><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><call><name>GBI</name> <argument_list>(<argument><expr><name>Bi</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>bvlen</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                            <comment type="line">// fl = flop count for just A(:,k)*B(k,j)</comment>

                            <comment type="line">// find A(:,k)</comment>
                            <decl_stmt><decl><type><name>int64_t</name></type> <name>pA</name></decl>, <decl><type ref="prev"/><name>pA_end</name></decl> ;</decl_stmt>
                            <if_stmt><if>if <condition>(<expr><name>A_is_hyper</name></expr>)</condition>
                            <block>{<block_content> 
                                <comment type="line">// A is hypersparse: find A(:,k) in hyper_hash</comment>
                                <expr_stmt><expr><call><name>GB_hyper_hash_lookup</name> <argument_list>(<argument><expr><name>Ap</name></expr></argument>, <argument><expr><name>A_Yp</name></expr></argument>, <argument><expr><name>A_Yi</name></expr></argument>, <argument><expr><name>A_Yx</name></expr></argument>,
                                    <argument><expr><name>A_hash_bits</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pA</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pA_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content> 
                                <comment type="line">// A is sparse, bitmap, or full</comment>
                                <expr_stmt><expr><name>pA</name>     <operator>=</operator> <call><name>GBP</name> <argument_list>(<argument><expr><name>Ap</name></expr></argument>, <argument><expr><name>k</name></expr></argument>  , <argument><expr><name>avlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><name>pA_end</name> <operator>=</operator> <call><name>GBP</name> <argument_list>(<argument><expr><name>Ap</name></expr></argument>, <argument><expr><name>k</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>avlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block></else></if_stmt>

                            <decl_stmt><decl><type><name>int64_t</name></type> <name>fl</name> <init>= <expr><name>pA_end</name> <operator>-</operator> <name>pA</name></expr></init></decl> ;</decl_stmt>
                            <expr_stmt><expr><name><name>Fine_fl</name> <index>[<expr><name>s</name></expr>]</index></name> <operator>=</operator> <name>fl</name></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>fl</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block></for>

                        <comment type="line">// cumulative sum of flops to compute A*B(:,j)</comment>
                        <expr_stmt><expr><call><name>GB_cumsum</name> <argument_list>(<argument><expr><name>Fine_fl</name></expr></argument>, <argument><expr><name>bjnz</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nth</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

                        <comment type="line">// slice B(:,j) into fine tasks</comment>
                        <decl_stmt><decl><type><name>int</name></type> <name>team_size</name> <init>= <expr><call><name>ceil</name> <argument_list>(<argument><expr><name>jflops</name> <operator>/</operator> <name>target_fine_size</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Fine_slice</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_pslice</name> <argument_list>(<argument><expr><name>Fine_slice</name></expr></argument>, <argument><expr><name>Fine_fl</name></expr></argument>, <argument><expr><name>bjnz</name></expr></argument>, <argument><expr><name>team_size</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// shared hash table for all fine tasks for A*B(:,j)</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>hsize</name> <init>= 
                            <expr><call><name>GB_hash_table_size</name> <argument_list>(<argument><expr><name>jflops</name></expr></argument>, <argument><expr><name>cvlen</name></expr></argument>, <argument><expr><name>AxB_method</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

                        <comment type="line">// construct the fine tasks for C(:,j)=A*B(:,j)</comment>
                        <decl_stmt><decl><type><name>int</name></type> <name>leader</name> <init>= <expr><name>nf</name></expr></init></decl> ;</decl_stmt>
                        <for>for <control>(<init><decl><type><name>int</name></type> <name>fid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>fid</name> <operator>&lt;</operator> <name>team_size</name></expr> ;</condition> <incr><expr><name>fid</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content> 
                            <decl_stmt><decl><type><name>int64_t</name></type> <name>pstart</name> <init>= <expr><name><name>Fine_slice</name> <index>[<expr><name>fid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                            <decl_stmt><decl><type><name>int64_t</name></type> <name>pend</name>   <init>= <expr><name><name>Fine_slice</name> <index>[<expr><name>fid</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                            <decl_stmt><decl><type><name>int64_t</name></type> <name>fl</name> <init>= <expr><name><name>Fine_fl</name> <index>[<expr><name>pend</name></expr>]</index></name> <operator>-</operator> <name><name>Fine_fl</name> <index>[<expr><name>pstart</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                            <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><name>nf</name></expr>]</index></name><operator>.</operator><name>start</name>  <operator>=</operator> <name>pB_start</name> <operator>+</operator> <name>pstart</name></expr> ;</expr_stmt>
                            <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><name>nf</name></expr>]</index></name><operator>.</operator><name>end</name>    <operator>=</operator> <name>pB_start</name> <operator>+</operator> <name>pend</name> <operator>-</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                            <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><name>nf</name></expr>]</index></name><operator>.</operator><name>vector</name> <operator>=</operator> <name>kk</name></expr> ;</expr_stmt>
                            <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><name>nf</name></expr>]</index></name><operator>.</operator><name>hsize</name>  <operator>=</operator> <name>hsize</name></expr> ;</expr_stmt>
                            <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><name>nf</name></expr>]</index></name><operator>.</operator><name>Hi</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>   <comment type="line">// assigned later</comment>
                            <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><name>nf</name></expr>]</index></name><operator>.</operator><name>Hf</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>   <comment type="line">// assigned later</comment>
                            <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><name>nf</name></expr>]</index></name><operator>.</operator><name>Hx</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>   <comment type="line">// assigned later</comment>
                            <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><name>nf</name></expr>]</index></name><operator>.</operator><name>my_cjnz</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
                            <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><name>nf</name></expr>]</index></name><operator>.</operator><name>leader</name> <operator>=</operator> <name>leader</name></expr> ;</expr_stmt>
                            <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><name>nf</name></expr>]</index></name><operator>.</operator><name>team_size</name> <operator>=</operator> <name>team_size</name></expr> ;</expr_stmt>
                            <expr_stmt><expr><name>nf</name><operator>++</operator></expr> ;</expr_stmt>
                        </block_content>}</block></for>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>

                <comment type="line">// flush the last coarse task, if any</comment>
                <if_stmt><if>if <condition>(<expr><name>kcoarse_start</name> <operator>&lt;</operator> <name>klast</name></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// kcoarse_start:klast-1 form a single coarse task</comment>
                    <expr_stmt><expr><call><name>GB_create_coarse_task</name> <argument_list>(<argument><expr><name>kcoarse_start</name></expr></argument>, <argument><expr><name>klast</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SaxpyTasks</name></expr></argument>,
                        <argument><expr><name>nc</name><operator>++</operator></expr></argument>, <argument><expr><name>Bflops</name></expr></argument>, <argument><expr><name>cvlen</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>nthreads_max</name></expr></argument>,
                        <argument><expr><name>Coarse_Work</name></expr></argument>, <argument><expr><name>AxB_method</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>

            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <comment type="line">// This coarse task is OK as-is.</comment>
                <expr_stmt><expr><call><name>GB_create_coarse_task</name> <argument_list>(<argument><expr><name>kfirst</name></expr></argument>, <argument><expr><name>klast</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SaxpyTasks</name></expr></argument>,
                    <argument><expr><name>nc</name><operator>++</operator></expr></argument>, <argument><expr><name>Bflops</name></expr></argument>, <argument><expr><name>cvlen</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>nthreads_max</name></expr></argument>,
                    <argument><expr><name>Coarse_Work</name></expr></argument>, <argument><expr><name>AxB_method</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// entire computation in a single fine or coarse task</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// create a single coarse task: hash or Gustavson</comment>
        <expr_stmt><expr><call><name>GB_create_coarse_task</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bnvec</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SaxpyTasks</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Bflops</name></expr></argument>, <argument><expr><name>cvlen</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
            <argument><expr><name>Coarse_Work</name></expr></argument>, <argument><expr><name>AxB_method</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <decl_stmt><decl><type><name>int64_t</name></type> <name>hash_size</name> <init>= <expr><name><name>SaxpyTasks</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hsize</name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>use_Gustavson</name> <init>= <expr><operator>(</operator><name>hash_size</name> <operator>==</operator> <name>cvlen</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>bnvec</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>use_Gustavson</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// convert the single coarse hash task into a single fine hash task</comment>
            <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>start</name>  <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>           <comment type="line">// first entry in B(:,0)</comment>
            <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>end</name> <operator>=</operator> <name>bnz</name> <operator>-</operator> <literal type="number">1</literal></expr> ;</expr_stmt>        <comment type="line">// last entry in B(:,0)</comment>
            <expr_stmt><expr><name><name>SaxpyTasks</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>vector</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>nfine</name><operator>)</operator> <operator>=</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free workspace and return result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><name>GB_FREE_WORKSPACE</name></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>nthreads</name><operator>)</operator> <operator>=</operator> <call><name>GB_IMIN</name> <argument_list>(<argument><expr><operator>*</operator><name>nthreads</name></expr></argument>, <argument><expr><operator>*</operator><name>ntasks</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>SaxpyTasks_handle</name><operator>)</operator> <operator>=</operator> <name>SaxpyTasks</name></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>SaxpyTasks_size_handle</name><operator>)</operator> <operator>=</operator> <name>SaxpyTasks_size</name></expr> ;</expr_stmt>
    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
