<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/Generated2/GB_AxB__max_second_uint64.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_AxB__max_second_uint64.c: matrix multiply for a single semiring</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// If this file is in the Generated1/ or Generated2/ folder, do not edit it</comment>
<comment type="line">// (it is auto-generated from Generator/*).</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_dev.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GBCUDA_DEV</name></cpp:ifndef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_control.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_atomics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB__include2.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB__include1.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_unused.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_bitmap_assign_methods.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_ek_slice_search.c"</cpp:file></cpp:include>

<comment type="line">// This C=A*B semiring is defined by the following types and operators:</comment>

<comment type="line">// A'*B (dot2):        GB (_Adot2B__max_second_uint64)</comment>
<comment type="line">// A'*B (dot3):        GB (_Adot3B__max_second_uint64)</comment>
<comment type="line">// C+=A'*B (dot4):     GB (_Adot4B__max_second_uint64)</comment>
<comment type="line">// A*B (saxpy bitmap): GB (_AsaxbitB__max_second_uint64)</comment>
<comment type="line">// A*B (saxpy3):       GB (_Asaxpy3B__max_second_uint64)</comment>
<comment type="line">//     no mask:        GB (_Asaxpy3B_noM__max_second_uint64)</comment>
<comment type="line">//     mask M:         GB (_Asaxpy3B_M__max_second_uint64)</comment>
<comment type="line">//     mask !M:        GB (_Asaxpy3B_notM__max_second_uint64)</comment>
<comment type="line">// A*B (saxpy4):       GB (_Asaxpy4B__max_second_uint64)</comment>
<comment type="line">// A*B (saxpy5):       GB (_Asaxpy5B__max_second_uint64)</comment>

<comment type="line">// C type:     uint64_t</comment>
<comment type="line">// A type:     uint64_t</comment>
<comment type="line">// A pattern?  1</comment>
<comment type="line">// B type:     uint64_t</comment>
<comment type="line">// B pattern?  0</comment>

<comment type="line">// Multiply: z = y</comment>
<comment type="line">// Add:      if (cij &lt; t) { cij = t ; }</comment>
<comment type="line">//    'any' monoid?  0</comment>
<comment type="line">//    atomic?        1</comment>
<comment type="line">//    OpenMP atomic? 0</comment>
<comment type="line">//    identity:      0</comment>
<comment type="line">//    terminal?      1</comment>
<comment type="line">//    terminal condition: if (cij == UINT64_MAX) { break ; }</comment>
<comment type="line">// MultAdd:  { uint64_t x_op_y = y ; z = GB_IMAX (z, x_op_y) ; }</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_ATYPE</name></cpp:macro> \
    <cpp:value>uint64_t</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BTYPE</name></cpp:macro> \
    <cpp:value>uint64_t</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CTYPE</name></cpp:macro> \
    <cpp:value>uint64_t</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_ASIZE</name></cpp:macro> \
    <cpp:value>sizeof (uint64_t)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BSIZE</name></cpp:macro> \
    <cpp:value>sizeof (uint64_t)</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CSIZE</name></cpp:macro> \
    <cpp:value>sizeof (uint64_t)</cpp:value></cpp:define>

<comment type="line">// # of bits in the type of C, for AVX2 and AVX512F</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CNBITS</name></cpp:macro> \
    <cpp:value>64</cpp:value></cpp:define>

<comment type="line">// true for int64, uint64, float, double, float complex, and double complex </comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CTYPE_IGNORE_OVERFLOW</name></cpp:macro> \
    <cpp:value>1</cpp:value></cpp:define>

<comment type="line">// aik = Ax [pA]</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_GETA</name><parameter_list>(<parameter><type><name>aik</name></type></parameter>,<parameter><type><name>Ax</name></type></parameter>,<parameter><type><name>pA</name></type></parameter>,<parameter><type><name>A_iso</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>;</cpp:value></cpp:define>

<comment type="line">// true if values of A are not used</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_A_IS_PATTERN</name></cpp:macro> \
    <cpp:value>1</cpp:value></cpp:define> \

<comment type="line">// bkj = Bx [pB]</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_GETB</name><parameter_list>(<parameter><type><name>bkj</name></type></parameter>,<parameter><type><name>Bx</name></type></parameter>,<parameter><type><name>pB</name></type></parameter>,<parameter><type><name>B_iso</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>uint64_t bkj = GBX (Bx, pB, B_iso)</cpp:value></cpp:define>

<comment type="line">// true if values of B are not used</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_B_IS_PATTERN</name></cpp:macro> \
    <cpp:value>0</cpp:value></cpp:define> \

<comment type="line">// Gx [pG] = Ax [pA]</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_LOADA</name><parameter_list>(<parameter><type><name>Gx</name></type></parameter>,<parameter><type><name>pG</name></type></parameter>,<parameter><type><name>Ax</name></type></parameter>,<parameter><type><name>pA</name></type></parameter>,<parameter><type><name>A_iso</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>Gx [pG] = GBX (Ax, pA, A_iso)</cpp:value></cpp:define>

<comment type="line">// Gx [pG] = Bx [pB]</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_LOADB</name><parameter_list>(<parameter><type><name>Gx</name></type></parameter>,<parameter><type><name>pG</name></type></parameter>,<parameter><type><name>Bx</name></type></parameter>,<parameter><type><name>pB</name></type></parameter>,<parameter><type><name>B_iso</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>Gx [pG] = GBX (Bx, pB, B_iso)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CX</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>Cx [p]</cpp:value></cpp:define>

<comment type="line">// multiply operator</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT</name><parameter_list>(<parameter><type><name>z</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>z = y</cpp:value></cpp:define>

<comment type="line">// cast from a real scalar (or 2, if C is complex) to the type of C</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CTYPE_CAST</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>((uint64_t) x)</cpp:value></cpp:define>

<comment type="line">// cast from a real scalar (or 2, if A is complex) to the type of A</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_ATYPE_CAST</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>((uint64_t) x)</cpp:value></cpp:define>

<comment type="line">// multiply-add</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULTADD</name><parameter_list>(<parameter><type><name>z</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>{ uint64_t x_op_y = y ; z = GB_IMAX (z, x_op_y) ; }</cpp:value></cpp:define>

<comment type="line">// monoid identity value</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IDENTITY</name></cpp:macro> \
    <cpp:value>0</cpp:value></cpp:define>

<comment type="line">// 1 if the identity value can be assigned via memset, with all bytes the same</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_HAS_IDENTITY_BYTE</name></cpp:macro> \
    <cpp:value>1</cpp:value></cpp:define>

<comment type="line">// identity byte, for memset</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IDENTITY_BYTE</name></cpp:macro> \
    <cpp:value>0</cpp:value></cpp:define>

<comment type="line">// true if the monoid has a terminal value</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MONOID_IS_TERMINAL</name></cpp:macro> \
    <cpp:value>1</cpp:value></cpp:define>

<comment type="line">// break if cij reaches the terminal value (dot product only)</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_DOT_TERMINAL</name><parameter_list>(<parameter><type><name>cij</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>if (cij == UINT64_MAX) { break ; }</cpp:value></cpp:define>

<comment type="line">// simd pragma for dot-product loop vectorization</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_PRAGMA_SIMD_DOT</name><parameter_list>(<parameter><type><name>cij</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>;</cpp:value></cpp:define>

<comment type="line">// simd pragma for other loop vectorization</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_PRAGMA_SIMD_VECTORIZE</name></cpp:macro> <cpp:value>GB_PRAGMA_SIMD</cpp:value></cpp:define>

<comment type="line">// 1 for the PLUS_PAIR_(real) semirings, not for the complex case</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_PLUS_PAIR_REAL_SEMIRING</name></cpp:macro> \
    <cpp:value>0</cpp:value></cpp:define>

<comment type="line">// 1 if the semiring is accelerated with AVX2 or AVX512f</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_SEMIRING_HAS_AVX_IMPLEMENTATION</name></cpp:macro> \
    <cpp:value>0</cpp:value></cpp:define>

<comment type="line">// declare the cij scalar (initialize cij to zero for PLUS_PAIR)</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CIJ_DECLARE</name><parameter_list>(<parameter><type><name>cij</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>uint64_t cij</cpp:value></cpp:define>

<comment type="line">// Cx [pC] = cij</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_PUTC</name><parameter_list>(<parameter><type><name>cij</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>Cx [p] = cij</cpp:value></cpp:define>

<comment type="line">// Cx [p] = t</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CIJ_WRITE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>Cx [p] = t</cpp:value></cpp:define>

<comment type="line">// C(i,j) += t</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CIJ_UPDATE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>if (Cx [p] &lt; t) { Cx [p] = t ; }</cpp:value></cpp:define>

<comment type="line">// x + y</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_ADD_FUNCTION</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>GB_IMAX (x, y)</cpp:value></cpp:define>

<comment type="line">// bit pattern for bool, 8-bit, 16-bit, and 32-bit integers</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CTYPE_BITS</name></cpp:macro> \
    <cpp:value>0</cpp:value></cpp:define>

<comment type="line">// 1 if monoid update can skipped entirely (the ANY monoid)</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_ANY_MONOID</name></cpp:macro> \
    <cpp:value>0</cpp:value></cpp:define>

<comment type="line">// 1 if monoid update is EQ</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_EQ_MONOID</name></cpp:macro> \
    <cpp:value>0</cpp:value></cpp:define>

<comment type="line">// 1 if monoid update can be done atomically, 0 otherwise</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_HAS_ATOMIC</name></cpp:macro> \
    <cpp:value>1</cpp:value></cpp:define>

<comment type="line">// 1 if monoid update can be done with an OpenMP atomic update, 0 otherwise</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_COMPILER_MSC</name></expr></cpp:if>
    <comment type="block">/* MS Visual Studio only has OpenMP 2.0, with fewer atomics */</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_HAS_OMP_ATOMIC</name></cpp:macro> \
        <cpp:value>0</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_HAS_OMP_ATOMIC</name></cpp:macro> \
        <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// 1 for the ANY_PAIR_ISO semiring</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_ANY_PAIR_SEMIRING</name></cpp:macro> \
    <cpp:value>0</cpp:value></cpp:define>

<comment type="line">// 1 if PAIR is the multiply operator </comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_PAIR_MULTIPLIER</name></cpp:macro> \
    <cpp:value>0</cpp:value></cpp:define>

<comment type="line">// 1 if monoid is PLUS_FC32</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_PLUS_FC32_MONOID</name></cpp:macro> \
    <cpp:value>0</cpp:value></cpp:define>

<comment type="line">// 1 if monoid is PLUS_FC64</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_PLUS_FC64_MONOID</name></cpp:macro> \
    <cpp:value>0</cpp:value></cpp:define>

<comment type="line">// 1 if monoid is ANY_FC32</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_ANY_FC32_MONOID</name></cpp:macro> \
    <cpp:value>0</cpp:value></cpp:define>

<comment type="line">// 1 if monoid is ANY_FC64</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_ANY_FC64_MONOID</name></cpp:macro> \
    <cpp:value>0</cpp:value></cpp:define>

<comment type="line">// 1 if monoid is MIN for signed or unsigned integers</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_IMIN_MONOID</name></cpp:macro> \
    <cpp:value>0</cpp:value></cpp:define>

<comment type="line">// 1 if monoid is MAX for signed or unsigned integers</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_IMAX_MONOID</name></cpp:macro> \
    <cpp:value>1</cpp:value></cpp:define>

<comment type="line">// 1 if monoid is MIN for float or double</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_FMIN_MONOID</name></cpp:macro> \
    <cpp:value>0</cpp:value></cpp:define>

<comment type="line">// 1 if monoid is MAX for float or double</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_FMAX_MONOID</name></cpp:macro> \
    <cpp:value>0</cpp:value></cpp:define>

<comment type="line">// 1 for the FIRSTI or FIRSTI1 multiply operator</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_FIRSTI_MULTIPLIER</name></cpp:macro> \
    <cpp:value>0</cpp:value></cpp:define>

<comment type="line">// 1 for the FIRSTJ or FIRSTJ1 multiply operator</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_FIRSTJ_MULTIPLIER</name></cpp:macro> \
    <cpp:value>0</cpp:value></cpp:define>

<comment type="line">// 1 for the SECONDJ or SECONDJ1 multiply operator</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_SECONDJ_MULTIPLIER</name></cpp:macro> \
    <cpp:value>0</cpp:value></cpp:define>

<comment type="line">// 1 for the FIRSTI1, FIRSTJ1, SECONDI1, or SECONDJ1 multiply operators</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_OFFSET</name></cpp:macro> \
    <cpp:value>0</cpp:value></cpp:define>

<comment type="line">// atomic compare-exchange</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_ATOMIC_COMPARE_EXCHANGE</name><parameter_list>(<parameter><type><name>target</name></type></parameter>, <parameter><type><name>expected</name></type></parameter>, <parameter><type><name>desired</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>GB_ATOMIC_COMPARE_EXCHANGE_64 (target, expected, desired)</cpp:value></cpp:define>

<comment type="line">// Hx [i] = t</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_HX_WRITE</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>Hx [i] = t</cpp:value></cpp:define>

<comment type="line">// Cx [p] = Hx [i]</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CIJ_GATHER</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>Cx [p] = Hx [i]</cpp:value></cpp:define>

<comment type="line">// Cx [p] += Hx [i]</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CIJ_GATHER_UPDATE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>if (Cx [p] &lt; Hx [i]) { Cx [p] = Hx [i] ; }</cpp:value></cpp:define>

<comment type="line">// Hx [i] += t</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_HX_UPDATE</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>if (Hx [i] &lt; t) { Hx [i] = t ; }</cpp:value></cpp:define>

<comment type="line">// memcpy (&amp;(Cx [p]), &amp;(Hx [i]), len)</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CIJ_MEMCPY</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>memcpy (Cx +(p), Hx +(i), (len) * sizeof(uint64_t));</cpp:value></cpp:define>

<comment type="line">// disable this semiring and use the generic case if these conditions hold</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_DISABLE</name></cpp:macro> \
    <cpp:value>(GxB_NO_MAX || GxB_NO_SECOND || GxB_NO_UINT64 || GxB_NO_MAX_UINT64 || GxB_NO_SECOND_UINT64 || GxB_NO_MAX_SECOND_UINT64)</cpp:value></cpp:define>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_Adot2B: C=A'*B, C&lt;M&gt;=A'*B, or C&lt;!M&gt;=A'*B: dot product method, C is bitmap</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// if A_not_transposed is true, then C=A*B is computed where A is bitmap or full</comment>

<function><type><name>GrB_Info</name> <name>GB</name></type> (<name>_Adot2B__max_second_uint64</name>)
<parameter_list>(
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>M</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_comp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_struct</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>A_not_transposed</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>A_slice</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>B</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>B_slice</name></decl></parameter>,
    <parameter><decl><type><name>int</name></type> <name>nthreads</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>naslice</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbslice</name></decl></parameter>
)</parameter_list>
<block>{<block_content> 
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_DISABLE</name></expr></cpp:if>
    <return>return <expr><operator>(</operator><name>GrB_NO_VALUE</name><operator>)</operator></expr> ;</return>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot2_meta.c"</cpp:file></cpp:include>
    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_Adot3B: C&lt;M&gt;=A'*B: masked dot product, C is sparse or hyper</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GrB_Info</name> <name>GB</name></type> (<name>_Adot3B__max_second_uint64</name>)
<parameter_list>(
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>M</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_struct</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>B</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>GB_task_struct</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>TaskList</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>ntasks</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>nthreads</name></decl></parameter>
)</parameter_list>
<block>{<block_content> 
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_DISABLE</name></expr></cpp:if>
    <return>return <expr><operator>(</operator><name>GrB_NO_VALUE</name><operator>)</operator></expr> ;</return>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot3_meta.c"</cpp:file></cpp:include>
    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_Adot4B:  C+=A'*B: dense dot product (not used for ANY_PAIR_ISO)</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>

    <function><type><name>GrB_Info</name> <name>GB</name></type> (<name>_Adot4B__max_second_uint64</name>)
    <parameter_list>(
        <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>A_slice</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>naslice</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>B</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>B_slice</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbslice</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>nthreads</name></decl></parameter>,
        <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
    )</parameter_list>
    <block>{<block_content> 
        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_DISABLE</name></expr></cpp:if>
        <return>return <expr><operator>(</operator><name>GrB_NO_VALUE</name><operator>)</operator></expr> ;</return>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot4_meta.c"</cpp:file></cpp:include>
        <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_AsaxbitB: C=A*B, C&lt;M&gt;=A*B, C&lt;!M&gt;=A*B: saxpy method, C is bitmap/full</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy3_template.h"</cpp:file></cpp:include>

<function><type><name>GrB_Info</name> <name>GB</name></type> (<name>_AsaxbitB__max_second_uint64</name>)
<parameter_list>(
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,   <comment type="line">// bitmap or full</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>M</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_comp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_struct</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>B</name></decl></parameter>,
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content> 
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_DISABLE</name></expr></cpp:if>
    <return>return <expr><operator>(</operator><name>GrB_NO_VALUE</name><operator>)</operator></expr> ;</return>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_bitmap_AxB_saxpy_template.c"</cpp:file></cpp:include>
    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_Asaxpy4B: C += A*B when C is full</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>

    <function><type><name>GrB_Info</name> <name>GB</name></type> (<name>_Asaxpy4B__max_second_uint64</name>)
    <parameter_list>(
        <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>B</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>ntasks</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>nthreads</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>nfine_tasks_per_vector</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>use_coarse_tasks</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>use_atomics</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier></type><name>A_slice</name></decl></parameter>,
        <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
    )</parameter_list>
    <block>{<block_content> 
        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_DISABLE</name></expr></cpp:if>
        <return>return <expr><operator>(</operator><name>GrB_NO_VALUE</name><operator>)</operator></expr> ;</return>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy4_template.c"</cpp:file></cpp:include>
        <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_Asaxpy5B: C += A*B when C is full, A is bitmap/full, B is sparse/hyper</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_DISABLE</name></expr></cpp:if>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator> <operator>!</operator><name>GB_A_IS_PATTERN</name> <operator>)</operator></expr></cpp:elif>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// saxpy5 method with vectors of length 8 for double, 16 for single</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// AVX512F: vector registers are 512 bits, or 64 bytes, which can hold</comment>
        <comment type="line">// 16 floats or 8 doubles.</comment>

        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_V16_512</name></cpp:macro> <cpp:value>(16 * GB_CNBITS &lt;= 512)</cpp:value></cpp:define>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_V8_512</name></cpp:macro>  <cpp:value>( 8 * GB_CNBITS &lt;= 512)</cpp:value></cpp:define>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_V4_512</name></cpp:macro>  <cpp:value>( 4 * GB_CNBITS &lt;= 512)</cpp:value></cpp:define>

        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_V16</name></cpp:macro> <cpp:value>GB_V16_512</cpp:value></cpp:define>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_V8</name></cpp:macro>  <cpp:value>GB_V8_512</cpp:value></cpp:define>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_V4</name></cpp:macro>  <cpp:value>GB_V4_512</cpp:value></cpp:define>

        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_SEMIRING_HAS_AVX_IMPLEMENTATION</name> <operator>&amp;&amp;</operator> <name>GB_COMPILER_SUPPORTS_AVX512F</name> \
            <operator>&amp;&amp;</operator> <name>GB_V4_512</name></expr></cpp:if>

            <function><type><name>GB_TARGET_AVX512F</name> <specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>GB_AxB_saxpy5_unrolled_avx512f</name>
            <parameter_list>(
                <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>B</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>ntasks</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>nthreads</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier></type><name>B_slice</name></decl></parameter>,
                <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
            )</parameter_list>
            <block>{<block_content>
                <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy5_unrolled.c"</cpp:file></cpp:include>
            </block_content>}</block></function>

        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// saxpy5 method with vectors of length 4 for double, 8 for single</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// AVX2: vector registers are 256 bits, or 32 bytes, which can hold</comment>
        <comment type="line">// 8 floats or 4 doubles.</comment>

        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_V16_256</name></cpp:macro> <cpp:value>(16 * GB_CNBITS &lt;= 256)</cpp:value></cpp:define>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_V8_256</name></cpp:macro>  <cpp:value>( 8 * GB_CNBITS &lt;= 256)</cpp:value></cpp:define>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_V4_256</name></cpp:macro>  <cpp:value>( 4 * GB_CNBITS &lt;= 256)</cpp:value></cpp:define>

        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_V16</name></cpp:undef>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_V8</name></cpp:undef>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_V4</name></cpp:undef>

        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_V16</name></cpp:macro> <cpp:value>GB_V16_256</cpp:value></cpp:define>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_V8</name></cpp:macro>  <cpp:value>GB_V8_256</cpp:value></cpp:define>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_V4</name></cpp:macro>  <cpp:value>GB_V4_256</cpp:value></cpp:define>

        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_SEMIRING_HAS_AVX_IMPLEMENTATION</name> <operator>&amp;&amp;</operator> <name>GB_COMPILER_SUPPORTS_AVX2</name> \
            <operator>&amp;&amp;</operator> <name>GB_V4_256</name></expr></cpp:if>

            <function><type><name>GB_TARGET_AVX2</name> <specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>GB_AxB_saxpy5_unrolled_avx2</name>
            <parameter_list>(
                <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>B</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>ntasks</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>nthreads</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier></type><name>B_slice</name></decl></parameter>,
                <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
            )</parameter_list>
            <block>{<block_content>
                <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy5_unrolled.c"</cpp:file></cpp:include>
            </block_content>}</block></function>

        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// saxpy5 method unrolled, with no vectors</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_V16</name></cpp:undef>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_V8</name></cpp:undef>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_V4</name></cpp:undef>

        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_V16</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_V8</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_V4</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>

        <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>GB_AxB_saxpy5_unrolled_vanilla</name>
        <parameter_list>(
            <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,
            <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,
            <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>B</name></decl></parameter>,
            <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>ntasks</name></decl></parameter>,
            <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>nthreads</name></decl></parameter>,
            <parameter><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier></type><name>B_slice</name></decl></parameter>,
            <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
        )</parameter_list>
        <block>{<block_content>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy5_unrolled.c"</cpp:file></cpp:include>
        </block_content>}</block></function>

    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <function><type><name>GrB_Info</name> <name>GB</name></type> (<name>_Asaxpy5B__max_second_uint64</name>)
    <parameter_list>(
        <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>B</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>ntasks</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>nthreads</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier></type><name>B_slice</name></decl></parameter>,
        <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
    )</parameter_list>
    <block>{<block_content> 
        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_DISABLE</name></expr></cpp:if>
        <return>return <expr><operator>(</operator><name>GrB_NO_VALUE</name><operator>)</operator></expr> ;</return>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy5_meta.c"</cpp:file></cpp:include>
        <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_Asaxpy3B: C=A*B, C&lt;M&gt;=A*B, C&lt;!M&gt;=A*B: saxpy method (Gustavson + Hash)</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GrB_Info</name> <name>GB</name></type> (<name>_Asaxpy3B__max_second_uint64</name>)
<parameter_list>(
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,   <comment type="line">// C&lt;any M&gt;=A*B, C sparse or hypersparse</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>M</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_comp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_struct</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>M_in_place</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>B</name></decl></parameter>,
    <parameter><decl><type><name>GB_saxpy3task_struct</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>SaxpyTasks</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>ntasks</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>nfine</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>nthreads</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>do_sort</name></decl></parameter>,
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content> 
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_DISABLE</name></expr></cpp:if>
    <return>return <expr><operator>(</operator><name>GrB_NO_VALUE</name><operator>)</operator></expr> ;</return>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IS_SPARSE</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>M</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// C = A*B, no mask</comment>
        <return>return <expr><operator>(</operator><call><call><name>GB</name> <argument_list>(<argument><expr><name>_Asaxpy3B_noM__max_second_uint64</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>,
            <argument><expr><name>SaxpyTasks</name></expr></argument>, <argument><expr><name>ntasks</name></expr></argument>, <argument><expr><name>nfine</name></expr></argument>, <argument><expr><name>nthreads</name></expr></argument>, <argument><expr><name>do_sort</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><name>Mask_comp</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// C&lt;M&gt; = A*B</comment>
        <return>return <expr><operator>(</operator><call><call><name>GB</name> <argument_list>(<argument><expr><name>_Asaxpy3B_M__max_second_uint64</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>C</name></expr></argument>,
            <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>M_in_place</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>,
            <argument><expr><name>SaxpyTasks</name></expr></argument>, <argument><expr><name>ntasks</name></expr></argument>, <argument><expr><name>nfine</name></expr></argument>, <argument><expr><name>nthreads</name></expr></argument>, <argument><expr><name>do_sort</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// C&lt;!M&gt; = A*B</comment>
        <return>return <expr><operator>(</operator><call><call><name>GB</name> <argument_list>(<argument><expr><name>_Asaxpy3B_notM__max_second_uint64</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>C</name></expr></argument>,
            <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>M_in_place</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>,
            <argument><expr><name>SaxpyTasks</name></expr></argument>, <argument><expr><name>ntasks</name></expr></argument>, <argument><expr><name>nfine</name></expr></argument>, <argument><expr><name>nthreads</name></expr></argument>, <argument><expr><name>do_sort</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>
    </block_content>}</block></else></if_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_Asaxpy3B_M: C&lt;M&gt;=A*B: saxpy method (Gustavson + Hash)</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator> <operator>!</operator><name>GB_DISABLE</name> <operator>)</operator></expr></cpp:if>

    <function><type><name>GrB_Info</name> <name>GB</name></type> (<name>_Asaxpy3B_M__max_second_uint64</name>)
    <parameter_list>(
        <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,   <comment type="line">// C&lt;M&gt;=A*B, C sparse or hypersparse</comment>
        <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>M</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_struct</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>M_in_place</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>B</name></decl></parameter>,
        <parameter><decl><type><name>GB_saxpy3task_struct</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>SaxpyTasks</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>ntasks</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>nfine</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>nthreads</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>do_sort</name></decl></parameter>,
        <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
    )</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>GB_IS_SPARSE</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>GB_IS_SPARSE</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// both A and B are sparse</comment>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_META16</name></cpp:macro></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_NO_MASK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MASK_COMP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_A_IS_SPARSE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_A_IS_HYPER</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_A_IS_BITMAP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_A_IS_FULL</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_B_IS_SPARSE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_B_IS_HYPER</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_B_IS_BITMAP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_B_IS_FULL</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_meta16_definitions.h"</cpp:file></cpp:include>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy3_template.c"</cpp:file></cpp:include>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// general case</comment>
            <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_META16</name></cpp:undef>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_NO_MASK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MASK_COMP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_meta16_definitions.h"</cpp:file></cpp:include>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy3_template.c"</cpp:file></cpp:include>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">//GB_Asaxpy3B_noM: C=A*B: saxpy method (Gustavson + Hash)</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator> <operator>!</operator><name>GB_DISABLE</name> <operator>)</operator></expr></cpp:if>

    <function><type><name>GrB_Info</name> <name>GB</name></type> (<name>_Asaxpy3B_noM__max_second_uint64</name>)
    <parameter_list>(
        <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,   <comment type="line">// C=A*B, C sparse or hypersparse</comment>
        <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>B</name></decl></parameter>,
        <parameter><decl><type><name>GB_saxpy3task_struct</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>SaxpyTasks</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>ntasks</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>nfine</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>nthreads</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>do_sort</name></decl></parameter>,
        <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
    )</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>GB_IS_SPARSE</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>GB_IS_SPARSE</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// both A and B are sparse</comment>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_META16</name></cpp:macro></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_NO_MASK</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MASK_COMP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_A_IS_SPARSE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_A_IS_HYPER</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_A_IS_BITMAP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_A_IS_FULL</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_B_IS_SPARSE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_B_IS_HYPER</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_B_IS_BITMAP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_B_IS_FULL</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_meta16_definitions.h"</cpp:file></cpp:include>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy3_template.c"</cpp:file></cpp:include>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// general case</comment>
            <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_META16</name></cpp:undef>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_NO_MASK</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MASK_COMP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_meta16_definitions.h"</cpp:file></cpp:include>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy3_template.c"</cpp:file></cpp:include>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">//GB_Asaxpy3B_notM: C&lt;!M&gt;=A*B: saxpy method (Gustavson + Hash)</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator> <operator>!</operator><name>GB_DISABLE</name> <operator>)</operator></expr></cpp:if>

    <function><type><name>GrB_Info</name> <name>GB</name></type> (<name>_Asaxpy3B_notM__max_second_uint64</name>)
    <parameter_list>(
        <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,   <comment type="line">// C&lt;!M&gt;=A*B, C sparse or hypersparse</comment>
        <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>M</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_struct</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>M_in_place</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>B</name></decl></parameter>,
        <parameter><decl><type><name>GB_saxpy3task_struct</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>SaxpyTasks</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>ntasks</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>nfine</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>nthreads</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>do_sort</name></decl></parameter>,
        <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
    )</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>GB_IS_SPARSE</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>GB_IS_SPARSE</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// both A and B are sparse</comment>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_META16</name></cpp:macro></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_NO_MASK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MASK_COMP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_A_IS_SPARSE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_A_IS_HYPER</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_A_IS_BITMAP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_A_IS_FULL</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_B_IS_SPARSE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_B_IS_HYPER</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_B_IS_BITMAP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_B_IS_FULL</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_meta16_definitions.h"</cpp:file></cpp:include>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy3_template.c"</cpp:file></cpp:include>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// general case</comment>
            <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_META16</name></cpp:undef>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_NO_MASK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MASK_COMP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_meta16_definitions.h"</cpp:file></cpp:include>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy3_template.c"</cpp:file></cpp:include>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
