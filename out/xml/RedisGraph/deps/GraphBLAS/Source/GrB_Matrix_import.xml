<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GrB_Matrix_import.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GrB_Matrix_import: import a matrix in CSR, CSC, FullC, FullR, or COO format</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// No typecasting is done.  The type of entries in the Ax array must match</comment>
<comment type="line">// the GrB_Type type parameter.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_export.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_build.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_ALL</name></cpp:macro>                 \
<cpp:value>{                                   \
    GB_Matrix_free (A) ;            \
    GB_FREE (&amp;Ap_copy, Ap_size) ;   \
    GB_FREE (&amp;Ai_copy, Ai_size) ;   \
    GB_FREE (&amp;Ax_copy, Ax_size) ;   \
}</cpp:value></cpp:define>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_import_worker: import a matrix of any type</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><specifier>static</specifier> <name>GrB_Info</name></type> <name>GB_import_worker</name>   <comment type="line">// import a matrix of any type</comment>
<parameter_list>(
    <parameter><decl><type><name>GrB_Matrix</name> <modifier>*</modifier></type><name>A</name></decl></parameter>,          <comment type="line">// handle of matrix to create</comment>
    <parameter><decl><type><name>GrB_Type</name></type> <name>type</name></decl></parameter>,          <comment type="line">// type of matrix to create</comment>
    <parameter><decl><type><name>GrB_Index</name></type> <name>nrows</name></decl></parameter>,        <comment type="line">// number of rows of the matrix</comment>
    <parameter><decl><type><name>GrB_Index</name></type> <name>ncols</name></decl></parameter>,        <comment type="line">// number of columns of the matrix</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Index</name> <modifier>*</modifier></type><name>Ap</name></decl></parameter>,    <comment type="line">// pointers for CSR, CSC, row indices for COO</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Index</name> <modifier>*</modifier></type><name>Ai</name></decl></parameter>,    <comment type="line">// row indices for CSR, CSC, col indices for COO</comment>
    <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>Ax</name></decl></parameter>,         <comment type="line">// values (must match the GrB_Type type parameter)</comment>
    <parameter><decl><type><name>GrB_Index</name></type> <name>Ap_len</name></decl></parameter>,       <comment type="line">// number of entries in Ap (not # of bytes)</comment>
    <parameter><decl><type><name>GrB_Index</name></type> <name>Ai_len</name></decl></parameter>,       <comment type="line">// number of entries in Ai (not # of bytes)</comment>
    <parameter><decl><type><name>GrB_Index</name></type> <name>Ax_len</name></decl></parameter>,       <comment type="line">// number of entries in Ax (not # of bytes)</comment>
    <parameter><decl><type><name>GrB_Format</name></type> <name>format</name></decl></parameter>,      <comment type="line">// import format</comment>
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content> 

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_RETURN_IF_NULL</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>A</name><operator>)</operator> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_RETURN_IF_NULL</name> <argument_list>(<argument><expr><name>Ax</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_TYPE_OK</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"type for GrB_Matrix_import"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl> ;</decl_stmt>

    <comment type="line">// GrB_Matrix_import has no descritptor so it only supports a secure import</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>fast_import</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>nrows</name> <operator>&gt;</operator> <name>GB_NMAX</name> <operator>||</operator> <name>ncols</name> <operator>&gt;</operator> <name>GB_NMAX</name> <operator>||</operator> <name>Ap_len</name> <operator>&gt;</operator> <name>GB_NMAX</name>
        <operator>||</operator> <name>Ai_len</name> <operator>&gt;</operator> <name>GB_NMAX</name> <operator>||</operator> <name>Ax_len</name> <operator>&gt;</operator> <name>GB_NMAX</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// problem is too large</comment>
        <return>return <expr><operator>(</operator><name>GrB_INVALID_VALUE</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>GrB_Index</name></type> <name>nvals</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>ok</name> <init>= <expr><name>true</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>plen</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>format</name> <operator>==</operator> <name>GrB_CSR_FORMAT</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>nrows</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>ncols</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr></init></decl> ;</decl_stmt>

    <switch>switch <condition>(<expr><name>format</name></expr>)</condition>
    <block>{<block_content>

        <case>case <expr><name>GrB_CSR_FORMAT</name></expr> :</case>
        <case>case <expr><name>GrB_CSC_FORMAT</name></expr> :</case>

            <expr_stmt><expr><call><name>GB_RETURN_IF_NULL</name> <argument_list>(<argument><expr><name>Ap</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_RETURN_IF_NULL</name> <argument_list>(<argument><expr><name>Ai</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>Ap_len</name> <operator>&lt;</operator> <name>plen</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Ap is too small</comment>
                <return>return <expr><operator>(</operator><name>GrB_INVALID_VALUE</name><operator>)</operator></expr> ;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>nvals</name> <operator>=</operator> <name><name>Ap</name> <index>[<expr><name>plen</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>Ai_len</name> <operator>&lt;</operator> <name>nvals</name> <operator>||</operator> <name><name>Ax_len</name> <argument_list type="generic">&lt; <argument><expr><name>nvals</name> <operator>||</operator> <name>nvals</name></expr></argument> &gt;</argument_list></name> <name>GB_NMAX</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Ai and/or Ax are too small or problem is too large</comment>
                <return>return <expr><operator>(</operator><name>GrB_INVALID_VALUE</name><operator>)</operator></expr> ;</return>
            </block_content>}</block></if></if_stmt>
            <break>break ;</break>

<comment type="line">//      case GrB_DENSE_ROW_FORMAT :</comment>
<comment type="line">//      case GrB_DENSE_COL_FORMAT :</comment>
<comment type="line">//</comment>
<comment type="line">//          ok = GB_int64_multiply (&amp;nvals, (int64_t) nrows, (int64_t) ncols) ;</comment>
<comment type="line">//          if (!ok || Ax_len &lt; nvals)</comment>
<comment type="line">//          {</comment>
<comment type="line">//              // Ap, Ai, and Ax must all have the same size</comment>
<comment type="line">//              return (GrB_INVALID_VALUE) ;</comment>
<comment type="line">//          }</comment>
<comment type="line">//          break ;</comment>

        <case>case <expr><name>GrB_COO_FORMAT</name></expr> :</case>

            <expr_stmt><expr><call><name>GB_RETURN_IF_NULL</name> <argument_list>(<argument><expr><name>Ap</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_RETURN_IF_NULL</name> <argument_list>(<argument><expr><name>Ai</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>nvals</name> <operator>=</operator> <name>Ap_len</name></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>Ai_len</name> <operator>!=</operator> <name>nvals</name> <operator>||</operator> <name>Ax_len</name> <operator>!=</operator> <name>nvals</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// Ap, Ai, and Ax must all have the same size</comment>
                <return>return <expr><operator>(</operator><name>GrB_INVALID_VALUE</name><operator>)</operator></expr> ;</return>
            </block_content>}</block></if></if_stmt>
            <break>break ;</break>

        <default>default :</default>

            <comment type="line">// unknown format</comment>
            <return>return <expr><operator>(</operator><name>GrB_INVALID_VALUE</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></switch>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// allocate copies of Ap, Ai, and Ax to be imported</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Index</name> <modifier>*</modifier></type><name>Ap_copy</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ap_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Index</name> <modifier>*</modifier></type><name>Ai_copy</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ai_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_void</name>   <modifier>*</modifier></type><name>Ax_copy</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ax_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>typesize</name> <init>= <expr><name><name>type</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>

    <comment type="line">// Ap_copy, Ai_copy, Ax_copy are GB_MALLOC'ed so they are already in the</comment>
    <comment type="line">// debug memtable.  Thus, GB_import does not add them again to the</comment>
    <comment type="line">// memtable (with add_to_memtable set to false).</comment>

    <switch>switch <condition>(<expr><name>format</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>GrB_CSR_FORMAT</name></expr> :</case> 
        <case>case <expr><name>GrB_CSC_FORMAT</name></expr> :</case> 
            <expr_stmt><expr><name>Ap_copy</name> <operator>=</operator> <call><name>GB_MALLOC</name> <argument_list>(<argument><expr><name>plen</name></expr></argument>,           <argument><expr><name>GrB_Index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ap_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>Ai_copy</name> <operator>=</operator> <call><name>GB_MALLOC</name> <argument_list>(<argument><expr><name>nvals</name></expr></argument>,          <argument><expr><name>GrB_Index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ai_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>Ax_copy</name> <operator>=</operator> <call><name>GB_MALLOC</name> <argument_list>(<argument><expr><name>nvals</name><operator>*</operator><name>typesize</name></expr></argument>, <argument><expr><name>GB_void</name></expr></argument>,   <argument><expr><operator>&amp;</operator><name>Ax_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <comment type="line">// x:OK</comment>
            <expr_stmt><expr><name>ok</name> <operator>=</operator> <operator>(</operator><name>Ap_copy</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>Ai_copy</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>Ax_copy</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ;</expr_stmt>
            <break>break ;</break>

<comment type="line">//      case GrB_DENSE_ROW_FORMAT :</comment>
<comment type="line">//      case GrB_DENSE_COL_FORMAT :</comment>
<comment type="line">//          Ax_copy = GB_MALLOC (nvals*typesize, GB_void,   &amp;Ax_size) ; // x:OK</comment>
<comment type="line">//          ok = (Ax_copy != NULL) ;</comment>
<comment type="line">//          break ;</comment>

        <default>default :</default> <comment type="line">// GrB_COO_FORMAT, nothing to allocate</comment>
            <break>break ;</break>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// out of memory</comment>
        <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
        <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine the # of threads to use</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_GET_NTHREADS_MAX</name> <argument_list>(<argument><expr><name>nthreads_max</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// copy the user input arrays</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <switch>switch <condition>(<expr><name>format</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>GrB_CSR_FORMAT</name></expr> :</case> 
        <case>case <expr><name>GrB_CSC_FORMAT</name></expr> :</case> 
            <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Ap_copy</name></expr></argument>, <argument><expr><name>Ap</name></expr></argument>, <argument><expr><name>plen</name>  <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>GrB_Index</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Ai_copy</name></expr></argument>, <argument><expr><name>Ai</name></expr></argument>, <argument><expr><name>nvals</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>GrB_Index</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
<comment type="line">//      case GrB_DENSE_ROW_FORMAT :</comment>
<comment type="line">//      case GrB_DENSE_COL_FORMAT :</comment>
            <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Ax_copy</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>nvals</name> <operator>*</operator> <name>typesize</name></expr></argument>          , <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <break>break ;</break>
        <default>default :</default> <comment type="line">// GrB_COO_FORMAT, nothing to copy</comment>
            <break>break ;</break>
    </block_content>}</block></switch>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// import the matrix</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <switch>switch <condition>(<expr><name>format</name></expr>)</condition>
    <block>{<block_content>

        <case>case <expr><name>GrB_CSR_FORMAT</name></expr> :</case> 

            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_import</name> <argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>ncols</name></expr></argument>, <argument><expr><name>nrows</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name>Ap_copy</name></expr></argument>, <argument><expr><name>Ap_size</name></expr></argument>,  <comment type="line">// Ap</comment>
                <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,            <comment type="line">// Ah</comment>
                <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,            <comment type="line">// Ab</comment>
                <argument><expr><operator>&amp;</operator><name>Ai_copy</name></expr></argument>, <argument><expr><name>Ai_size</name></expr></argument>,  <comment type="line">// Ai</comment>
                <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator>
                <operator>&amp;</operator><name>Ax_copy</name></expr></argument>, <argument><expr><name>Ax_size</name></expr></argument>,  <comment type="line">// Ax</comment>
                <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,         <comment type="line">// CSR format may be jumbled</comment>
                <argument><expr><name>GxB_SPARSE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,  <comment type="line">// sparse by row</comment>
                <argument><expr><name>false</name></expr></argument>,              <comment type="line">// not iso</comment>
                <argument><expr><name>fast_import</name></expr></argument>,
                <argument><expr><name>false</name></expr></argument>,              <comment type="line">// do not add to memtable</comment>
                <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <break>break ;</break>

        <case>case <expr><name>GrB_CSC_FORMAT</name></expr> :</case> 

            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_import</name> <argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>nrows</name></expr></argument>, <argument><expr><name>ncols</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name>Ap_copy</name></expr></argument>, <argument><expr><name>Ap_size</name></expr></argument>,  <comment type="line">// Ap</comment>
                <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,            <comment type="line">// Ah</comment>
                <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,            <comment type="line">// Ab</comment>
                <argument><expr><operator>&amp;</operator><name>Ai_copy</name></expr></argument>, <argument><expr><name>Ai_size</name></expr></argument>,  <comment type="line">// Ai</comment>
                <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator>
                <operator>&amp;</operator><name>Ax_copy</name></expr></argument>, <argument><expr><name>Ax_size</name></expr></argument>,  <comment type="line">// Ax</comment>
                <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,         <comment type="line">// CSC format may be jumbled</comment>
                <argument><expr><name>GxB_SPARSE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,   <comment type="line">// sparse by column</comment>
                <argument><expr><name>false</name></expr></argument>,              <comment type="line">// not iso</comment>
                <argument><expr><name>fast_import</name></expr></argument>,
                <argument><expr><name>false</name></expr></argument>,              <comment type="line">// do not add to memtable</comment>
                <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <break>break ;</break>

<comment type="line">//      case GrB_DENSE_ROW_FORMAT :</comment>
<comment type="line">//</comment>
<comment type="line">//          GB_OK (GB_import (false, A, type, ncols, nrows, false,</comment>
<comment type="line">//              NULL, 0,            // Ap</comment>
<comment type="line">//              NULL, 0,            // Ah</comment>
<comment type="line">//              NULL, 0,            // Ab</comment>
<comment type="line">//              NULL, 0,            // Ai</comment>
<comment type="line">//              (void **)</comment>
<comment type="line">//              &amp;Ax_copy, Ax_size,  // Ax</comment>
<comment type="line">//              0, false, 0,        // cannot be jumbled</comment>
<comment type="line">//              GxB_FULL, false,    // full by row</comment>
<comment type="line">//              false,              // not iso</comment>
<comment type="line">//              fast_import,</comment>
<comment type="line">//              false,              // do not add to memtable</comment>
<comment type="line">//              Context)) ;</comment>
<comment type="line">//          break ;</comment>

<comment type="line">//      case GrB_DENSE_COL_FORMAT :</comment>
<comment type="line">//</comment>
<comment type="line">//          GB_OK (GB_import (false, A, type, nrows, ncols, false,</comment>
<comment type="line">//              NULL, 0,            // Ap</comment>
<comment type="line">//              NULL, 0,            // Ah</comment>
<comment type="line">//              NULL, 0,            // Ab</comment>
<comment type="line">//              NULL, 0,            // Ai</comment>
<comment type="line">//              (void **)</comment>
<comment type="line">//              &amp;Ax_copy, Ax_size,  // Ax</comment>
<comment type="line">//              0, false, 0,        // cannot be jumbled</comment>
<comment type="line">//              GxB_FULL, true,     // full by column</comment>
<comment type="line">//              false,              // not iso</comment>
<comment type="line">//              fast_import,</comment>
<comment type="line">//              false,              // do not add to memtable</comment>
<comment type="line">//              Context)) ;</comment>
<comment type="line">//          break ;</comment>

        <default>default :</default> <comment type="line">// GrB_COO_FORMAT</comment>
            <block>{<block_content>
                <comment type="line">// build A as hypersparse by row or by column</comment>
                <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>no_I_work</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>I_work_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>no_J_work</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>J_work_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>GB_void</name> <modifier>*</modifier></type><name>no_X_work</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>X_work_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type> <name>is_csc</name> <init>= <expr><call><name>GB_Global_is_csc_get</name> <argument_list>( )</argument_list></call></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>vlen</name> <init>= <expr><ternary><condition><expr><name>is_csc</name></expr> ?</condition><then> <expr><name>nrows</name></expr> </then><else>: <expr><name>ncols</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>vdim</name> <init>= <expr><ternary><condition><expr><name>is_csc</name></expr> ?</condition><then> <expr><name>ncols</name></expr> </then><else>: <expr><name>nrows</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>

                <comment type="line">// allocate the header for A</comment>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_new</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <comment type="line">// new header</comment>
                    <argument><expr><name>type</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>, <argument><expr><name>vdim</name></expr></argument>, <argument><expr><name>GB_Ap_null</name></expr></argument>, <argument><expr><name>is_csc</name></expr></argument>, <argument><expr><name>GxB_AUTO_SPARSITY</name></expr></argument>,
                    <argument><expr><call><name>GB_Global_hyper_switch_get</name> <argument_list>( )</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

                <comment type="line">// build A from the input triplets</comment>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_builder</name> <argument_list>(
                    <argument><expr><operator>*</operator><name>A</name></expr></argument>,             <comment type="line">// create A using a dynamic header</comment>
                    <argument><expr><name>type</name></expr></argument>,           <comment type="line">// the type of A</comment>
                    <argument><expr><name>vlen</name></expr></argument>,
                    <argument><expr><name>vdim</name></expr></argument>,
                    <argument><expr><name>is_csc</name></expr></argument>,         <comment type="line">// CSR/CSC format</comment>
                    <argument><expr><operator>&amp;</operator><name>no_I_work</name></expr></argument>,     <comment type="line">// I_work_handle, not used here</comment>
                    <argument><expr><operator>&amp;</operator><name>I_work_size</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>no_J_work</name></expr></argument>,     <comment type="line">// J_work_handle, not used here</comment>
                    <argument><expr><operator>&amp;</operator><name>J_work_size</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>no_X_work</name></expr></argument>,     <comment type="line">// X_work_handle, not used here</comment>
                    <argument><expr><operator>&amp;</operator><name>X_work_size</name></expr></argument>,
                    <argument><expr><name>false</name></expr></argument>,          <comment type="line">// known_sorted: not yet known</comment>
                    <argument><expr><name>false</name></expr></argument>,          <comment type="line">// known_no_duplicates: not yet known</comment>
                    <argument><expr><literal type="number">0</literal></expr></argument>,              <comment type="line">// I_work, J_work, and X_work not used here</comment>
                    <argument><expr><name>true</name></expr></argument>,           <comment type="line">// A is a GrB_Matrix</comment>
                    <argument><expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator> <operator>(</operator><ternary><condition><expr><name>is_csc</name></expr> ?</condition><then> <expr><name>Ap</name></expr> </then><else>: <expr><name>Ai</name></expr></else></ternary><operator>)</operator></expr></argument>,     <comment type="line">// row/col indices</comment>
                    <argument><expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator> <operator>(</operator><ternary><condition><expr><name>is_csc</name></expr> ?</condition><then> <expr><name>Ai</name></expr> </then><else>: <expr><name>Ap</name></expr></else></ternary><operator>)</operator></expr></argument>,     <comment type="line">// col/row indices</comment>
                    <argument><expr><operator>(</operator><specifier>const</specifier> <name>GB_void</name> <operator>*</operator><operator>)</operator> <name>Ax</name></expr></argument>,               <comment type="line">// values</comment>
                    <argument><expr><name>false</name></expr></argument>,          <comment type="line">// matrix is not iso</comment>
                    <argument><expr><name>nvals</name></expr></argument>,          <comment type="line">// number of tuples</comment>
                    <argument><expr><name>NULL</name></expr></argument>,           <comment type="line">// implicit SECOND operator for duplicates</comment>
                    <argument><expr><name>type</name></expr></argument>,           <comment type="line">// type of the X array</comment>
                    <argument><expr><name>true</name></expr></argument>,           <comment type="line">// burble is allowed</comment>
                    <argument><expr><name>Context</name></expr></argument>
                )</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block>
            <break>break ;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><operator>*</operator><name>A</name></expr></argument>, <argument><expr><literal type="string">"A imported"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine if A is iso</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><call><name>GB_iso_check</name> <argument_list>(<argument><expr><operator>*</operator><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// All entries in A are the same; convert A to iso</comment>
        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(post iso) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>A</name><operator>)</operator><operator>-&gt;</operator><name>iso</name></name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_convert_any_to_iso</name> <argument_list>(<argument><expr><operator>*</operator><name>A</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// conform the matrix to its desired sparsity and return result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_conform</name> <argument_list>(<argument><expr><operator>*</operator><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><operator>*</operator><name>A</name></expr></argument>, <argument><expr><literal type="string">"final A imported"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GrB_Matrix_import_*: import a matrix of a given type</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IMPORT</name><parameter_list>(<parameter><type><name>prefix</name></type></parameter>,<parameter><type><name>ctype</name></type></parameter>,<parameter><type><name>T</name></type></parameter>,<parameter><type><name>acode</name></type></parameter>)</parameter_list></cpp:macro>                                        \
<cpp:value>GrB_Info GB_EVAL3 (prefix, _Matrix_import_, T) <comment type="block">/* import a matrix */</comment>           \
(                                                                              \
    GrB_Matrix *A,          <comment type="block">/* handle of matrix to create                    */</comment>\
    GrB_Type type,          <comment type="block">/* type of matrix to create                      */</comment>\
    GrB_Index nrows,        <comment type="block">/* number of rows of the matrix                  */</comment>\
    GrB_Index ncols,        <comment type="block">/* number of columns of the matrix               */</comment>\
    const GrB_Index *Ap,    <comment type="block">/* pointers for CSR, CSC, row indices for COO    */</comment>\
    const GrB_Index *Ai,    <comment type="block">/* row indices for CSR, CSC, col indices for COO */</comment>\
    const ctype *Ax,        <comment type="block">/* values (must match GrB_Type type parameter)   */</comment>\
    GrB_Index Ap_len,       <comment type="block">/* number of entries in Ap (not # of bytes)      */</comment>\
    GrB_Index Ai_len,       <comment type="block">/* number of entries in Ai (not # of bytes)      */</comment>\
    GrB_Index Ax_len,       <comment type="block">/* number of entries in Ax (not # of bytes)      */</comment>\
    GrB_Format format       <comment type="block">/* import format                                 */</comment>\
)                                                                              \
{                                                                              \
    GB_WHERE1 (GB_STR(prefix) "_Matrix_import_" GB_STR(T) " (&amp;A, type, nrows," \
        " ncols, Ap, Ai, Ax, Ap_len, Ai_len, Ax_len, format)") ;               \
    GB_BURBLE_START (GB_STR(prefix) "_Matrix_import_" GB_STR(T)) ;             \
    GB_RETURN_IF_NULL_OR_FAULTY (type) ;                                       \
    if (type-&gt;code != acode) return (GrB_DOMAIN_MISMATCH) ;                    \
    GrB_Info info = GB_import_worker (A, type, nrows, ncols, Ap, Ai,           \
        (const void *) Ax, Ap_len, Ai_len, Ax_len, format, Context) ;          \
    GB_BURBLE_END ;                                                            \
    return (info) ;                                                            \
}</cpp:value></cpp:define>

<macro><name>GB_IMPORT</name> <argument_list>(<argument>GrB</argument>, <argument>bool</argument>      , <argument>BOOL</argument>   , <argument>GB_BOOL_code</argument>  )</argument_list></macro>
<macro><name>GB_IMPORT</name> <argument_list>(<argument>GrB</argument>, <argument>int8_t</argument>    , <argument>INT8</argument>   , <argument>GB_INT8_code</argument>  )</argument_list></macro>
<macro><name>GB_IMPORT</name> <argument_list>(<argument>GrB</argument>, <argument>int16_t</argument>   , <argument>INT16</argument>  , <argument>GB_INT16_code</argument> )</argument_list></macro>
<macro><name>GB_IMPORT</name> <argument_list>(<argument>GrB</argument>, <argument>int32_t</argument>   , <argument>INT32</argument>  , <argument>GB_INT32_code</argument> )</argument_list></macro>
<macro><name>GB_IMPORT</name> <argument_list>(<argument>GrB</argument>, <argument>int64_t</argument>   , <argument>INT64</argument>  , <argument>GB_INT64_code</argument> )</argument_list></macro>
<macro><name>GB_IMPORT</name> <argument_list>(<argument>GrB</argument>, <argument>uint8_t</argument>   , <argument>UINT8</argument>  , <argument>GB_UINT8_code</argument> )</argument_list></macro>
<macro><name>GB_IMPORT</name> <argument_list>(<argument>GrB</argument>, <argument>uint16_t</argument>  , <argument>UINT16</argument> , <argument>GB_UINT16_code</argument>)</argument_list></macro>
<macro><name>GB_IMPORT</name> <argument_list>(<argument>GrB</argument>, <argument>uint32_t</argument>  , <argument>UINT32</argument> , <argument>GB_UINT32_code</argument>)</argument_list></macro>
<macro><name>GB_IMPORT</name> <argument_list>(<argument>GrB</argument>, <argument>uint64_t</argument>  , <argument>UINT64</argument> , <argument>GB_UINT64_code</argument>)</argument_list></macro>
<macro><name>GB_IMPORT</name> <argument_list>(<argument>GrB</argument>, <argument>float</argument>     , <argument>FP32</argument>   , <argument>GB_FP32_code</argument>  )</argument_list></macro>
<macro><name>GB_IMPORT</name> <argument_list>(<argument>GrB</argument>, <argument>double</argument>    , <argument>FP64</argument>   , <argument>GB_FP64_code</argument>  )</argument_list></macro>
<macro><name>GB_IMPORT</name> <argument_list>(<argument>GxB</argument>, <argument>GxB_FC32_t</argument>, <argument>FC32</argument>   , <argument>GB_FC32_code</argument>  )</argument_list></macro>
<macro><name>GB_IMPORT</name> <argument_list>(<argument>GxB</argument>, <argument>GxB_FC64_t</argument>, <argument>FC64</argument>   , <argument>GB_FC64_code</argument>  )</argument_list></macro>
<macro><name>GB_IMPORT</name> <argument_list>(<argument>GrB</argument>, <argument>void</argument>      , <argument>UDT</argument>    , <argument>GB_UDT_code</argument>   )</argument_list></macro>

</unit>
