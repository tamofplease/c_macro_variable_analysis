<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_AxB_rowscale.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_AxB_rowscale: C = D*B, row scale with diagonal matrix D</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_mxm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_binop.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_apply.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_stringify.h"</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GBCUDA_DEV</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_binop__include.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_ALL</name></cpp:macro> <cpp:value>GB_phybix_free (C) ;</cpp:value></cpp:define>

<function><type><name>GrB_Info</name></type> <name>GB_AxB_rowscale</name>            <comment type="line">// C = D*B, row scale with diagonal D</comment>
<parameter_list>(
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,                   <comment type="line">// output matrix, static header</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>D</name></decl></parameter>,             <comment type="line">// diagonal input matrix</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>B</name></decl></parameter>,             <comment type="line">// input matrix</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Semiring</name></type> <name>semiring</name></decl></parameter>,    <comment type="line">// semiring that defines C=D*B</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>flipxy</name></decl></parameter>,              <comment type="line">// if true, do z=fmult(b,a) vs fmult(a,b)</comment>
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>static_header</name></name> <operator>||</operator> <name>GBNSTATIC</name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>D</name></expr></argument>, <argument><expr><literal type="string">"D for rowscale D*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><literal type="string">"B for rowscale D*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_JUMBLED</name> <argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_SEMIRING_OK</name> <argument_list>(<argument><expr><name>semiring</name></expr></argument>, <argument><expr><literal type="string">"semiring for numeric D*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>D</name><operator>-&gt;</operator><name>vdim</name></name> <operator>==</operator> <name><name>B</name><operator>-&gt;</operator><name>vlen</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_is_diagonal</name> <argument_list>(<argument><expr><name>D</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>        <comment type="line">// bitmap or full: not needed</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_IS_FULL</name> <argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(%s=%s*%s) "</literal></expr></argument>,
        <argument><expr><call><name>GB_sparsity_char_matrix</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></argument>,    <comment type="line">// C has the sparsity structure of B</comment>
        <argument><expr><call><name>GB_sparsity_char_matrix</name> <argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>GB_sparsity_char_matrix</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get the semiring operators</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_BinaryOp</name></type> <name>mult</name> <init>= <expr><name><name>semiring</name><operator>-&gt;</operator><name>multiply</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Type</name></type> <name>ztype</name> <init>= <expr><name><name>mult</name><operator>-&gt;</operator><name>ztype</name></name></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>ztype</name> <operator>==</operator> <name><name>semiring</name><operator>-&gt;</operator><name>add</name><operator>-&gt;</operator><name>op</name><operator>-&gt;</operator><name>ztype</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>GB_Opcode</name></type> <name>opcode</name> <init>= <expr><name><name>mult</name><operator>-&gt;</operator><name>opcode</name></name></expr></init></decl> ;</decl_stmt>
    <comment type="line">// GB_reduce_to_vector does not use GB_AxB_rowscale:</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>mult</name><operator>-&gt;</operator><name>binop_function</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>opcode</name> <operator>==</operator> <name>GB_FIRST_binop_code</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>GB_SECOND_binop_code</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine if C is iso (ignore the monoid since it isn't used)</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>size_t</name></type> <name>zsize</name> <init>= <expr><name><name>ztype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_void</name></type> <name><name>cscalar</name> <index>[<expr><call><name>GB_VLA</name><argument_list>(<argument><expr><name>zsize</name></expr></argument>)</argument_list></call></expr>]</index></name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>C_iso</name> <init>= <expr><call><name>GB_iso_AxB</name> <argument_list>(<argument><expr><name>cscalar</name></expr></argument>, <argument><expr><name>D</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name><name>D</name><operator>-&gt;</operator><name>vdim</name></name></expr></argument>, <argument><expr><name>semiring</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_DEBUGIFY_DEFN</name></cpp:ifdef>
    <expr_stmt><expr><call><name>GB_debugify_mxm</name> <argument_list>(<argument><expr><name>C_iso</name></expr></argument>, <argument><expr><call><name>GB_sparsity</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ztype</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
        <argument><expr><name>semiring</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>, <argument><expr><name>D</name></expr></argument>, <argument><expr><name>B</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// copy the pattern of B into C</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// allocate C-&gt;x but do not initialize it</comment>
    <comment type="line">// set C-&gt;iso = C_iso   OK</comment>
    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_dup_worker</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>C_iso</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ztype</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>GB_void</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Cx</name> <init>= <expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// C = D*B, row scale, compute numerical values</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><call><name>GB_OPCODE_IS_POSITIONAL</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// apply a positional operator: convert C=D*B to C=op(B)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// determine unary operator to compute C=D*B</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>flipxy</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <decl_stmt><decl><type><name>GrB_UnaryOp</name></type> <name>op</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>ztype</name> <operator>==</operator> <name>GrB_INT64</name></expr>)</condition>
        <block>{<block_content>
            <switch>switch <condition>(<expr><name>opcode</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// first_op(D,B) becomes position_i(B)</comment>
                <case>case <expr><name>GB_FIRSTI_binop_code</name></expr>   :</case> 
                <case>case <expr><name>GB_FIRSTJ_binop_code</name></expr>   :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONI_INT64</name></expr> ;</expr_stmt> <break>break;</break>
                <case>case <expr><name>GB_FIRSTI1_binop_code</name></expr>  :</case> 
                <case>case <expr><name>GB_FIRSTJ1_binop_code</name></expr>  :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONI1_INT64</name></expr>;</expr_stmt> <break>break;</break>
                <comment type="line">// second_op(D,B) becomes position_op(B)</comment>
                <case>case <expr><name>GB_SECONDI_binop_code</name></expr>  :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONI_INT64</name></expr> ;</expr_stmt> <break>break;</break>
                <case>case <expr><name>GB_SECONDJ_binop_code</name></expr>  :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONJ_INT64</name></expr> ;</expr_stmt> <break>break;</break>
                <case>case <expr><name>GB_SECONDI1_binop_code</name></expr> :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONI1_INT64</name></expr>;</expr_stmt> <break>break;</break>
                <case>case <expr><name>GB_SECONDJ1_binop_code</name></expr> :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONJ1_INT64</name></expr>;</expr_stmt> <break>break;</break>
                <default>default:</default>  <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <switch>switch <condition>(<expr><name>opcode</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// first_op(D,B) becomes position_i(B)</comment>
                <case>case <expr><name>GB_FIRSTI_binop_code</name></expr>   :</case> 
                <case>case <expr><name>GB_FIRSTJ_binop_code</name></expr>   :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONI_INT32</name></expr> ;</expr_stmt> <break>break;</break>
                <case>case <expr><name>GB_FIRSTI1_binop_code</name></expr>  :</case> 
                <case>case <expr><name>GB_FIRSTJ1_binop_code</name></expr>  :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONI1_INT32</name></expr>;</expr_stmt> <break>break;</break>
                <comment type="line">// second_op(D,B) becomes position_op(B)</comment>
                <case>case <expr><name>GB_SECONDI_binop_code</name></expr>  :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONI_INT32</name></expr> ;</expr_stmt> <break>break;</break>
                <case>case <expr><name>GB_SECONDJ_binop_code</name></expr>  :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONJ_INT32</name></expr> ;</expr_stmt> <break>break;</break>
                <case>case <expr><name>GB_SECONDI1_binop_code</name></expr> :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONI1_INT32</name></expr>;</expr_stmt> <break>break;</break>
                <case>case <expr><name>GB_SECONDJ1_binop_code</name></expr> :</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>GxB_POSITIONJ1_INT32</name></expr>;</expr_stmt> <break>break;</break>
                <default>default:</default>  <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_apply_op</name> <argument_list>(<argument><expr><name>Cx</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>GB_NON_ISO</name></expr></argument>,
            <argument><expr><operator>(</operator><name>GB_Operator</name><operator>)</operator> <name>op</name></expr></argument>,   <comment type="line">// positional op</comment>
            <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"rowscale positional: C = D*B output"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>C_iso</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C is iso; pattern already computed above</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(iso rowscale) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>Cx</name></expr></argument>, <argument><expr><name>cscalar</name></expr></argument>, <argument><expr><name>zsize</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C is non iso</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// determine if the values are accessed</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><name>bool</name></type> <name>op_is_first</name>  <init>= <expr><operator>(</operator><name>opcode</name> <operator>==</operator> <name>GB_FIRST_binop_code</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>op_is_second</name> <init>= <expr><operator>(</operator><name>opcode</name> <operator>==</operator> <name>GB_SECOND_binop_code</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>op_is_pair</name>   <init>= <expr><operator>(</operator><name>opcode</name> <operator>==</operator> <name>GB_PAIR_binop_code</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>D_is_pattern</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>B_is_pattern</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>op_is_pair</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>flipxy</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// z = fmult (b,a) will be computed</comment>
            <expr_stmt><expr><name>D_is_pattern</name> <operator>=</operator> <name>op_is_first</name>  <operator>||</operator> <name>op_is_pair</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>B_is_pattern</name> <operator>=</operator> <name>op_is_second</name> <operator>||</operator> <name>op_is_pair</name></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><operator>!</operator><name>D_is_pattern</name></expr></argument>,
                <argument><expr><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name><name>D</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>mult</name><operator>-&gt;</operator><name>ytype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><operator>!</operator><name>B_is_pattern</name></expr></argument>,
                <argument><expr><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name><name>B</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>mult</name><operator>-&gt;</operator><name>xtype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// z = fmult (a,b) will be computed</comment>
            <expr_stmt><expr><name>D_is_pattern</name> <operator>=</operator> <name>op_is_second</name> <operator>||</operator> <name>op_is_pair</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>B_is_pattern</name> <operator>=</operator> <name>op_is_first</name>  <operator>||</operator> <name>op_is_pair</name></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><operator>!</operator><name>D_is_pattern</name></expr></argument>,
                <argument><expr><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name><name>D</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>mult</name><operator>-&gt;</operator><name>xtype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><operator>!</operator><name>B_is_pattern</name></expr></argument>,
                <argument><expr><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name><name>B</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>mult</name><operator>-&gt;</operator><name>ytype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// determine the number of threads to use</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><call><name>GB_GET_NTHREADS_MAX</name> <argument_list>(<argument><expr><name>nthreads_max</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nthreads</name> <init>= <expr><call><name>GB_nthreads</name> <argument_list>(<argument><expr><call><name>GB_nnz_held</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>B</name><operator>-&gt;</operator><name>nvec</name></name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>,
            <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

        <decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>

        <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GBCUDA_DEV</name></cpp:ifndef>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// define the worker for the switch factory</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_DxB</name><parameter_list>(<parameter><type><name>mult</name></type></parameter>,<parameter><type><name>xname</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GB (_DxB_ ## mult ## xname)</cpp:value></cpp:define>

            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BINOP_WORKER</name><parameter_list>(<parameter><type><name>mult</name></type></parameter>,<parameter><type><name>xname</name></type></parameter>)</parameter_list></cpp:macro>                     \
            <cpp:value>{                                                       \
                info = GB_DxB(mult,xname) (C, D, B, nthreads) ;     \
                done = (info != GrB_NO_VALUE) ;                     \
            }                                                       \
            break ;</cpp:value></cpp:define>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// launch the switch factory</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>xcode</name></decl>, <decl><type ref="prev"/><name>ycode</name></decl>, <decl><type ref="prev"/><name>zcode</name></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>GB_binop_builtin</name> <argument_list>(<argument><expr><name><name>D</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>D_is_pattern</name></expr></argument>, <argument><expr><name><name>B</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>B_is_pattern</name></expr></argument>,
                <argument><expr><name>mult</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opcode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xcode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ycode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zcode</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// C=D*B, rowscale with built-in operator</comment>
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BINOP_IS_SEMIRING_MULTIPLIER</name></cpp:macro></cpp:define>
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_NO_PAIR</name></cpp:macro></cpp:define>
                <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_binop_factory.c"</cpp:file></cpp:include>
                <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_BINOP_IS_SEMIRING_MULTIPLIER</name></cpp:undef>
            </block_content>}</block></if></if_stmt>

        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition>
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// C = D*B, row scale, with typecasting or user-defined operator</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// get operators, functions, workspace, contents of D, B, and C</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <expr_stmt><expr><call><name>GB_BURBLE_MATRIX</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"(generic C=D*B rowscale) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <decl_stmt><decl><type><name>GxB_binary_function</name></type> <name>fmult</name> <init>= <expr><name><name>mult</name><operator>-&gt;</operator><name>binop_function</name></name></expr></init></decl> ;</decl_stmt>

            <decl_stmt><decl><type><name>size_t</name></type> <name>csize</name> <init>= <expr><name><name>C</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>dsize</name> <init>= <expr><ternary><condition><expr><name>D_is_pattern</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>D</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>size</name></name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>bsize</name> <init>= <expr><ternary><condition><expr><name>B_is_pattern</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>B</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>size</name></name></expr></else></ternary></expr></init></decl> ;</decl_stmt>

            <decl_stmt><decl><type><name>size_t</name></type> <name>xsize</name> <init>= <expr><name><name>mult</name><operator>-&gt;</operator><name>xtype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>ysize</name> <init>= <expr><name><name>mult</name><operator>-&gt;</operator><name>ytype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>

            <comment type="line">// scalar workspace: because of typecasting, the x/y types need not</comment>
            <comment type="line">// be the same as the size of the D and B types.</comment>
            <comment type="line">// flipxy false: dii = (xtype) D(i,i) and bij = (ytype) B(i,j)</comment>
            <comment type="line">// flipxy true:  dii = (ytype) D(i,i) and bij = (xtype) B(i,j)</comment>
            <decl_stmt><decl><type><name>size_t</name></type> <name>dii_size</name> <init>= <expr><ternary><condition><expr><name>flipxy</name></expr> ?</condition><then> <expr><name>ysize</name></expr> </then><else>: <expr><name>xsize</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>bij_size</name> <init>= <expr><ternary><condition><expr><name>flipxy</name></expr> ?</condition><then> <expr><name>xsize</name></expr> </then><else>: <expr><name>ysize</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>

            <decl_stmt><decl><type><name>GB_cast_function</name></type> <name>cast_D</name></decl>, <decl><type ref="prev"/><name>cast_B</name></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>flipxy</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// D is typecasted to y, and B is typecasted to x</comment>
                <expr_stmt><expr><name>cast_D</name> <operator>=</operator> <ternary><condition><expr><name>D_is_pattern</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
                         <expr><call><name>GB_cast_factory</name> <argument_list>(<argument><expr><name><name>mult</name><operator>-&gt;</operator><name>ytype</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>D</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
                <expr_stmt><expr><name>cast_B</name> <operator>=</operator> <ternary><condition><expr><name>B_is_pattern</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
                         <expr><call><name>GB_cast_factory</name> <argument_list>(<argument><expr><name><name>mult</name><operator>-&gt;</operator><name>xtype</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>B</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <comment type="line">// D is typecasted to x, and B is typecasted to y</comment>
                <expr_stmt><expr><name>cast_D</name> <operator>=</operator> <ternary><condition><expr><name>D_is_pattern</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
                         <expr><call><name>GB_cast_factory</name> <argument_list>(<argument><expr><name><name>mult</name><operator>-&gt;</operator><name>xtype</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>D</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
                <expr_stmt><expr><name>cast_B</name> <operator>=</operator> <ternary><condition><expr><name>B_is_pattern</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
                         <expr><call><name>GB_cast_factory</name> <argument_list>(<argument><expr><name><name>mult</name><operator>-&gt;</operator><name>ytype</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>B</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// C = D*B via function pointers, and typecasting</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <comment type="line">// dii = D(i,i), located in Dx [i]</comment>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_A_IS_PATTERN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_GETA</name><parameter_list>(<parameter><type><name>dii</name></type></parameter>,<parameter><type><name>Dx</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>D_iso</name></type></parameter>)</parameter_list></cpp:macro>                             \
                <cpp:value>GB_void dii [GB_VLA(dii_size)] ;                        \
                if (!D_is_pattern)                                      \
                {                                                       \
                    cast_D (dii, Dx +(D_iso ? 0:(i)*dsize), dsize) ;    \
                }</cpp:value></cpp:define>

            <comment type="line">// bij = B(i,j), located in Bx [pB]</comment>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_B_IS_PATTERN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_GETB</name><parameter_list>(<parameter><type><name>bij</name></type></parameter>,<parameter><type><name>Bx</name></type></parameter>,<parameter><type><name>pB</name></type></parameter>,<parameter><type><name>B_iso</name></type></parameter>)</parameter_list></cpp:macro>                            \
                <cpp:value>GB_void bij [GB_VLA(bij_size)] ;                        \
                if (!B_is_pattern)                                      \
                {                                                       \
                    cast_B (bij, Bx +(B_iso ? 0:(pB)*bsize), bsize) ;   \
                }</cpp:value></cpp:define>

            <comment type="line">// address of Cx [p]</comment>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CX</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Cx +((p)*csize)</cpp:value></cpp:define>

            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_ATYPE</name></cpp:macro> <cpp:value>GB_void</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BTYPE</name></cpp:macro> <cpp:value>GB_void</cpp:value></cpp:define>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CTYPE</name></cpp:macro> <cpp:value>GB_void</cpp:value></cpp:define>

            <comment type="line">// no vectorization</comment>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_PRAGMA_SIMD_VECTORIZE</name></cpp:macro> <cpp:value>;</cpp:value></cpp:define>

            <if_stmt><if>if <condition>(<expr><name>flipxy</name></expr>)</condition>
            <block>{<block_content> 
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BINOP</name><parameter_list>(<parameter><type><name>z</name></type></parameter>,<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fmult (z,y,x)</cpp:value></cpp:define>
                <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_rowscale_template.c"</cpp:file></cpp:include>
                <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_BINOP</name></cpp:undef>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BINOP</name><parameter_list>(<parameter><type><name>z</name></type></parameter>,<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fmult (z,x,y)</cpp:value></cpp:define>
                <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_rowscale_template.c"</cpp:file></cpp:include>
                <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_BINOP</name></cpp:undef>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// return result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"rowscale: C = D*B output"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
