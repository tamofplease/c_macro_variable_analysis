<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" xmlns:omp="http://www.srcML.org/srcML/openmp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_wait.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_wait:  finish all pending computations on a single matrix</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// CALLS:     GB_builder</comment>

<comment type="line">// The matrix A has zombies and/or pending tuples placed there by</comment>
<comment type="line">// GrB_setElement, GrB_*assign, or GB_mxm.  Zombies must now be deleted, and</comment>
<comment type="line">// pending tuples must now be assembled together and added into the matrix.</comment>
<comment type="line">// The indices in A might also be jumbled; if so, they are sorted now.</comment>

<comment type="line">// When the function returns, and all pending tuples and zombies have been</comment>
<comment type="line">// deleted.  This is true even the function fails due to lack of memory (in</comment>
<comment type="line">// that case, the matrix is cleared as well).</comment>

<comment type="line">// If A is hypersparse, the time taken is at most O(nnz(A) + t log t), where t</comment>
<comment type="line">// is the number of pending tuples in A, and nnz(A) includes both zombies and</comment>
<comment type="line">// live entries.  There is no O(m) or O(n) time component, if A is m-by-n.</comment>
<comment type="line">// If the number of non-empty vectors of A grows too large, then A can be</comment>
<comment type="line">// converted to non-hypersparse.</comment>

<comment type="line">// If A is non-hypersparse, then O(n) is added in the worst case, to prune</comment>
<comment type="line">// zombies and to update the vector pointers for A.</comment>

<comment type="line">// If A-&gt;nvec_nonempty is unknown (-1) it is computed.</comment>

<comment type="line">// The A-&gt;Y hyper_hash is freed if the A-&gt;h hyperlist has to be constructed.</comment>
<comment type="line">// Instead, it is not computed and left pending (as NULL).  It is not modified</comment>
<comment type="line">// if A-&gt;h doesn't change.</comment>

<comment type="line">// If the method is successful, it does an OpenMP flush just before returning.</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_WORKSPACE</name></cpp:macro>               \
<cpp:value>{                                       \
    GB_Matrix_free (&amp;Y) ;               \
    GB_Matrix_free (&amp;T) ;               \
    GB_Matrix_free (&amp;S) ;               \
    GB_Matrix_free (&amp;A1) ;              \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_ALL</name></cpp:macro>                     \
<cpp:value>{                                       \
    GB_FREE_WORKSPACE ;                 \
    GB_phybix_free (A) ;                \
}</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_select.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_add.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_Pending.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_build.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_jappend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_atomics.h"</cpp:file></cpp:include>

<function><type><name>GB_PUBLIC</name>
<name>GrB_Info</name></type> <name>GB_wait</name>                <comment type="line">// finish all pending computations</comment>
<parameter_list>(
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,               <comment type="line">// matrix with pending computations</comment>
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,           <comment type="line">// name of the matrix</comment>
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name> <init>= <expr><name>GrB_SUCCESS</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>GB_Matrix_opaque</name></name></type> <name>T_header</name></decl>, <decl><type ref="prev"/><name>A1_header</name></decl>, <decl><type ref="prev"/><name>S_header</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>T</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>A1</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>S</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Y</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"A to wait"</literal></expr></argument>, <argument><expr><call><name>GB_FLIP</name> <argument_list>(<argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>GB_IS_FULL</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// full and bitmap matrices never have any pending work</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_JUMBLED</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <comment type="line">// ensure the matrix is written to memory</comment>
        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>flush</omp:name></omp:directive></cpp:pragma>
        <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// only sparse and hypersparse matrices can have pending work</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IS_SPARSE</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_ZOMBIES_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_PENDING_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get the zombie and pending count, and burble if work needs to be done</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>nzombies</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>nzombies</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>npending</name> <init>= <expr><call><name>GB_Pending_n</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>A_iso</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>iso</name></name></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>nzombies</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>npending</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>A</name><operator>-&gt;</operator><name>jumbled</name></name> <operator>||</operator> <name><name>A</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><call><name>GB_BURBLE_MATRIX</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"(%swait:%s "</literal> <name>GBd</name> <literal type="string">" %s, "</literal> <name>GBd</name> <literal type="string">" pending%s%s) "</literal></expr></argument>,
            <argument><expr><ternary><condition><expr><name>A_iso</name></expr> ?</condition><then> <expr><literal type="string">"iso "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nzombies</name></expr></argument>,
            <argument><expr><ternary><condition><expr><operator>(</operator><name>nzombies</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"zombie"</literal></expr> </then><else>: <expr><literal type="string">"zombies"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>npending</name></expr></argument>,
            <argument><expr><ternary><condition><expr><name><name>A</name><operator>-&gt;</operator><name>jumbled</name></name></expr> ?</condition><then> <expr><literal type="string">", jumbled"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
            <argument><expr><ternary><condition><expr><name><name>A</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">", nvec"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine the max # of threads to use</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_GET_NTHREADS_MAX</name> <argument_list>(<argument><expr><name>nthreads_max</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check if only A-&gt;nvec_nonempty is needed</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>npending</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nzombies</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>A</name><operator>-&gt;</operator><name>jumbled</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// A-&gt;Y is not modified.  If not NULL, it remains valid</comment>
        <if_stmt><if>if <condition>(<expr><name><name>A</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>=</operator> <call><name>GB_nvec_nonempty</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check if A only needs to be unjumbled</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>npending</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nzombies</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// A is not conformed, so the sparsity structure of A is not modified.</comment>
        <comment type="line">// That is, if A has no pending tuples and no zombies, but is just</comment>
        <comment type="line">// jumbled, then it stays sparse or hypersparse.  A-&gt;Y is not modified</comment>
        <comment type="line">// nor accessed, and remains NULL if it is NULL on input.  If it is</comment>
        <comment type="line">// present, it remains valid.</comment>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_unjumble</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <return>return <expr><operator>(</operator><name>info</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// assemble the pending tuples into T</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>anz_orig</name> <init>= <expr><call><name>GB_nnz</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>asize</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>tnz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>npending</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// construct a new hypersparse matrix T with just the pending tuples</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// T has the same type as A-&gt;type, which can differ from the type of</comment>
        <comment type="line">// the pending tuples, A-&gt;Pending-&gt;type.  The Pending-&gt;op can be NULL</comment>
        <comment type="line">// (an implicit SECOND function), or it can be any accum operator.  The</comment>
        <comment type="line">// z=accum(x,y) operator can have any types, and it does not have to be</comment>
        <comment type="line">// associative.  T is constructed as iso if A is iso.</comment>

        <decl_stmt><decl><type><name>GB_void</name> <modifier>*</modifier></type><name>S_input</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>A_iso</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name><name>A</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>GrB_Type</name></type> <name>stype</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>A_iso</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr> </then><else>: <expr><name><name>A</name><operator>-&gt;</operator><name>Pending</name><operator>-&gt;</operator><name>type</name></name></expr></else></ternary></expr></init></decl> ;</decl_stmt>

        <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T_header</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>GB_builder</name> <argument_list>(
            <argument><expr><name>T</name></expr></argument>,                      <comment type="line">// create T using a static header</comment>
            <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,                <comment type="line">// T-&gt;type = A-&gt;type</comment>
            <argument><expr><name><name>A</name><operator>-&gt;</operator><name>vlen</name></name></expr></argument>,                <comment type="line">// T-&gt;vlen = A-&gt;vlen</comment>
            <argument><expr><name><name>A</name><operator>-&gt;</operator><name>vdim</name></name></expr></argument>,                <comment type="line">// T-&gt;vdim = A-&gt;vdim</comment>
            <argument><expr><name><name>A</name><operator>-&gt;</operator><name>is_csc</name></name></expr></argument>,              <comment type="line">// T-&gt;is_csc = A-&gt;is_csc</comment>
            <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>A</name><operator>-&gt;</operator><name>Pending</name><operator>-&gt;</operator><name>i</name></name><operator>)</operator></expr></argument>,       <comment type="line">// iwork_handle, becomes T-&gt;i on output</comment>
            <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>A</name><operator>-&gt;</operator><name>Pending</name><operator>-&gt;</operator><name>i_size</name></name><operator>)</operator></expr></argument>,
            <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>A</name><operator>-&gt;</operator><name>Pending</name><operator>-&gt;</operator><name>j</name></name><operator>)</operator></expr></argument>,       <comment type="line">// jwork_handle, free on output</comment>
            <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>A</name><operator>-&gt;</operator><name>Pending</name><operator>-&gt;</operator><name>j_size</name></name><operator>)</operator></expr></argument>,
            <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>A</name><operator>-&gt;</operator><name>Pending</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator></expr></argument>,       <comment type="line">// Swork_handle, free on output</comment>
            <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>A</name><operator>-&gt;</operator><name>Pending</name><operator>-&gt;</operator><name>x_size</name></name><operator>)</operator></expr></argument>,
            <argument><expr><name><name>A</name><operator>-&gt;</operator><name>Pending</name><operator>-&gt;</operator><name>sorted</name></name></expr></argument>,     <comment type="line">// tuples may or may not be sorted</comment>
            <argument><expr><name>false</name></expr></argument>,                  <comment type="line">// there might be duplicates; look for them</comment>
            <argument><expr><name><name>A</name><operator>-&gt;</operator><name>Pending</name><operator>-&gt;</operator><name>nmax</name></name></expr></argument>,       <comment type="line">// size of Pending-&gt;[ijx] arrays</comment>
            <argument><expr><name>true</name></expr></argument>,                   <comment type="line">// is_matrix: unused</comment>
            <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>S_input</name></expr></argument>,    <comment type="line">// original I,J,S_input tuples</comment>
            <argument><expr><name>A_iso</name></expr></argument>,                  <comment type="line">// pending tuples are iso if A is iso</comment>
            <argument><expr><name>npending</name></expr></argument>,               <comment type="line">// # of tuples</comment>
            <argument><expr><name><name>A</name><operator>-&gt;</operator><name>Pending</name><operator>-&gt;</operator><name>op</name></name></expr></argument>,         <comment type="line">// dup operator for assembling duplicates,</comment>
                                    <comment type="line">// NULL if A is iso</comment>
            <argument><expr><name>stype</name></expr></argument>,                  <comment type="line">// type of Pending-&gt;x</comment>
            <argument><expr><name>true</name></expr></argument>,                   <comment type="line">// burble is allowed</comment>
            <argument><expr><name>Context</name></expr></argument>
        )</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// free pending tuples</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// The tuples have been converted to T, which is more compact, and</comment>
        <comment type="line">// duplicates have been removed.  The following work needs to be done</comment>
        <comment type="line">// even if the builder fails.</comment>

        <comment type="line">// GB_builder frees A-&gt;Pending-&gt;j and A-&gt;Pending-&gt;x.  If successful,</comment>
        <comment type="line">// A-&gt;Pending-&gt;i is now T-&gt;i.  Otherwise A-&gt;Pending-&gt;i is freed.  In</comment>
        <comment type="line">// both cases, A-&gt;Pending-&gt;i is NULL.</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>Pending</name><operator>-&gt;</operator><name>i</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>Pending</name><operator>-&gt;</operator><name>j</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>Pending</name><operator>-&gt;</operator><name>x</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">// free the list of pending tuples</comment>
        <expr_stmt><expr><call><name>GB_Pending_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>A</name><operator>-&gt;</operator><name>Pending</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"A after moving pending tuples to T"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// check the status of the builder</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// Finally check the status of the builder.  The pending tuples, must</comment>
        <comment type="line">// be freed (just above), whether or not the builder is successful.</comment>
        <if_stmt><if>if <condition>(<expr><name>info</name> <operator>!=</operator> <name>GrB_SUCCESS</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// out of memory in GB_builder</comment>
            <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
            <return>return <expr><operator>(</operator><name>info</name><operator>)</operator></expr> ;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><literal type="string">"T = hypersparse matrix of pending tuples"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_JUMBLED</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <expr_stmt><expr><name>tnz</name> <operator>=</operator> <call><name>GB_nnz</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>tnz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// delete zombies</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// A zombie is an entry A(i,j) in the matrix that as been marked for</comment>
    <comment type="line">// deletion, but hasn't been deleted yet.  It is marked by "negating"</comment>
    <comment type="line">// replacing its index i with GB_FLIP(i).</comment>

    <comment type="line">// TODO: pass tnz to GB_selector, to pad the reallocated A matrix</comment>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"A before zombies removed"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>nzombies</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// remove all zombies from A</comment>
        <comment type="line">// GB_selector frees A-&gt;Y if it changes A-&gt;h, or leaves it</comment>
        <comment type="line">// unmodified (and valid) otherwise.</comment>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_selector</name> <argument_list>(
            <argument><expr><name>NULL</name></expr></argument>,                       <comment type="line">// A in-place</comment>
            <argument><expr><name>GB_NONZOMBIE_selop_code</name></expr></argument>,    <comment type="line">// use the opcode only</comment>
            <argument><expr><name>NULL</name></expr></argument>,                       <comment type="line">// no GB_Operator</comment>
            <argument><expr><name>false</name></expr></argument>,                      <comment type="line">// flipij is false</comment>
            <argument><expr><name>A</name></expr></argument>,                          <comment type="line">// input/output matrix</comment>
            <argument><expr><literal type="number">0</literal></expr></argument>,                          <comment type="line">// ithunk is unused</comment>
            <argument><expr><name>NULL</name></expr></argument>,                       <comment type="line">// no GrB_Scalar Thunk</comment>
            <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>nzombies</name></name> <operator>==</operator> <operator>(</operator><name>anz_orig</name> <operator>-</operator> <call><name>GB_nnz</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>nzombies</name></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"A after zombies removed"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// all the zombies are gone, and pending tuples are now in T </comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// unjumble the matrix</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_unjumble</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_JUMBLED</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check for pending tuples</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>npending</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// conform A to its desired sparsity structure and return result</comment>
        <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>GB_conform</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>flush</omp:name></omp:directive></cpp:pragma>
        <return>return <expr><operator>(</operator><name>info</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check for quick transplant</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>anz</name> <init>= <expr><call><name>GB_nnz</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>anz</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// A has no entries so just transplant T into A, then free T and</comment>
        <comment type="line">// conform A to its desired hypersparsity.</comment>
        <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>GB_transplant_conform</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>flush</omp:name></omp:directive></cpp:pragma>
        <return>return <expr><operator>(</operator><name>info</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine the method for A = A+T</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// If anz &gt; 0, T is hypersparse, even if A is a GrB_Vector</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>tnz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>T</name><operator>-&gt;</operator><name>nvec</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>nvec</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// tjfirst = first vector in T</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>tjfirst</name> <init>= <expr><name><name>T</name><operator>-&gt;</operator><name>h</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>anz0</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>kA</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>jlast</name></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ap</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ah</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>h</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ai</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>i</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_void</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ax</name> <init>= <expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name><name>A</name><operator>-&gt;</operator><name>x</name></name></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>anvec</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>nvec</name></name></expr></init></decl> ;</decl_stmt>

    <comment type="line">// anz0 = nnz (A0) = nnz (A (:, 0:tjfirst-1)), the region not modified by T</comment>
    <if_stmt><if>if <condition>(<expr><name><name>A</name><operator>-&gt;</operator><name>h</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// find tjfirst in A-&gt;h </comment>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>pright</name> <init>= <expr><name>anvec</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>GB_SPLIT_BINARY_SEARCH</name> <argument_list>(<argument><expr><name>tjfirst</name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>kA</name></expr></argument>, <argument><expr><name>pright</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <comment type="line">// A-&gt;h [0 ... kA-1] excludes vector tjfirst.  The list</comment>
        <comment type="line">// A-&gt;h [kA ... anvec-1] includes tjfirst.</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>kA</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>kA</name> <operator>&lt;=</operator> <name>anvec</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><name>kA</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>kA</name> <operator>&lt;</operator> <name>anvec</name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>h</name> <index>[<expr><name>kA</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name>tjfirst</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><name>found</name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>h</name> <index>[<expr><name>kA</name></expr>]</index></name> <operator>==</operator> <name>tjfirst</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>jlast</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>kA</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>A</name><operator>-&gt;</operator><name>h</name> <index>[<expr><name>kA</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <expr_stmt><expr><name>kA</name> <operator>=</operator> <name>tjfirst</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>jlast</name> <operator>=</operator> <name>tjfirst</name> <operator>-</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// anz1 = nnz (A1) = nnz (A (:, kA:end)), the region modified by T</comment>
    <expr_stmt><expr><name>anz0</name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>p</name> <index>[<expr><name>kA</name></expr>]</index></name></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>anz1</name> <init>= <expr><name>anz</name> <operator>-</operator> <name>anz0</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>ignore</name></decl> ;</decl_stmt>

    <comment type="line">// A + T will have anz_new entries</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>anz_new</name> <init>= <expr><name>anz</name> <operator>+</operator> <name>tnz</name></expr></init></decl> ;</decl_stmt>       <comment type="line">// must have at least this space</comment>

    <if_stmt><if>if <condition>(<expr><literal type="number">2</literal> <operator>*</operator> <name>anz1</name> <operator>&lt;</operator> <name>anz0</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// append new tuples to A</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// A is growing incrementally.  It splits into two parts: A = [A0 A1].</comment>
        <comment type="line">// where A0 = A (:, 0:kA-1) and A1 = A (:, kA:end).  The</comment>
        <comment type="line">// first part (A0 with anz0 = nnz (A0) entries) is not modified.  The</comment>
        <comment type="line">// second part (A1, with anz1 = nnz (A1) entries) overlaps with T.</comment>
        <comment type="line">// If anz1 is zero, or small compared to anz0, then it is faster to</comment>
        <comment type="line">// leave A0 unmodified, and to update just A1.</comment>

        <comment type="line">// TODO: if A also had zombies, GB_selector could pad A so that</comment>
        <comment type="line">// GB_nnz_max (A) is equal to anz + tnz.</comment>

        <comment type="line">// make sure A has enough space for the new tuples</comment>
        <if_stmt><if>if <condition>(<expr><name>anz_new</name> <operator>&gt;</operator> <call><name>GB_nnz_max</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// double the size if not enough space</comment>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_ix_realloc</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>anz_new</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>Ai</name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>i</name></name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>Ax</name> <operator>=</operator> <operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name><name>A</name><operator>-&gt;</operator><name>x</name></name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// T = A1 + T</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <if_stmt><if>if <condition>(<expr><name>anz1</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// extract A1 = A (:, kA:end) as a shallow copy</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <comment type="line">// A1 = [0, A (:, kA:end)], hypersparse with same dimensions as A</comment>
            <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>A1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>A1_header</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>A1</name></expr></argument>, <comment type="line">// hyper, existing header</comment>
                <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>vlen</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>vdim</name></name></expr></argument>, <argument><expr><name>GB_Ap_malloc</name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>is_csc</name></name></expr></argument>,
                <argument><expr><name>GxB_HYPERSPARSE</name></expr></argument>, <argument><expr><name>GB_ALWAYS_HYPER</name></expr></argument>, <argument><expr><name>anvec</name> <operator>-</operator> <name>kA</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <comment type="line">// the A1-&gt;i and A1-&gt;x content are shallow copies of A(:,kA:end).</comment>
            <comment type="line">// They are not allocated pointers, but point to space inside</comment>
            <comment type="line">// Ai and Ax.</comment>

            <expr_stmt><expr><name><name>A1</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>Ax</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>A_iso</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>asize</name> <operator>*</operator> <name>anz0</name><operator>)</operator></expr></else></ternary><operator>)</operator><operator>)</operator></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A1</name><operator>-&gt;</operator><name>x_size</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>A_iso</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>anz1</name></expr></else></ternary><operator>)</operator> <operator>*</operator> <name>asize</name></expr>  ;</expr_stmt>
            <expr_stmt><expr><name><name>A1</name><operator>-&gt;</operator><name>x_shallow</name></name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A1</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <name>Ai</name> <operator>+</operator> <name>anz0</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A1</name><operator>-&gt;</operator><name>i_size</name></name> <operator>=</operator> <name>anz1</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A1</name><operator>-&gt;</operator><name>i_shallow</name></name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A1</name><operator>-&gt;</operator><name>iso</name></name> <operator>=</operator> <name>A_iso</name></expr> ;</expr_stmt>       <comment type="line">// OK</comment>

            <comment type="line">// fill the column A1-&gt;h and A1-&gt;p with A-&gt;h and A-&gt;p, shifted</comment>
            <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>A1p</name> <init>= <expr><name><name>A1</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>A1h</name> <init>= <expr><name><name>A1</name><operator>-&gt;</operator><name>h</name></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>a1nvec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><name>kA</name></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>anvec</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <comment type="line">// get A (:,k)</comment>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>pA_start</name> <init>= <expr><name><name>Ap</name> <index>[<expr><name>k</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>pA_end</name> <init>= <expr><name><name>Ap</name> <index>[<expr><name>k</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>pA_end</name> <operator>&gt;</operator> <name>pA_start</name></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// add this column to A1 if A (:,k) is not empty</comment>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>j</name> <init>= <expr><call><name>GBH</name> <argument_list>(<argument><expr><name>Ah</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                    <expr_stmt><expr><name><name>A1p</name> <index>[<expr><name>a1nvec</name></expr>]</index></name> <operator>=</operator> <name>pA_start</name> <operator>-</operator> <name>anz0</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>A1h</name> <index>[<expr><name>a1nvec</name></expr>]</index></name> <operator>=</operator> <name>j</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>a1nvec</name><operator>++</operator></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <comment type="line">// finalize A1</comment>
            <expr_stmt><expr><name><name>A1p</name> <index>[<expr><name>a1nvec</name></expr>]</index></name> <operator>=</operator> <name>anz1</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A1</name><operator>-&gt;</operator><name>nvec</name></name> <operator>=</operator> <name>a1nvec</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A1</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>=</operator> <name>a1nvec</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A1</name><operator>-&gt;</operator><name>nvals</name></name> <operator>=</operator> <name>anz1</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A1</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>GB_MAGIC</name></expr> ;</expr_stmt>

            <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A1</name></expr></argument>, <argument><expr><literal type="string">"A1 slice for GB_wait"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// S = A1 + T, with no operator or mask</comment>
            <comment type="line">//------------------------------------------------------------------</comment>
    
            <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>S_header</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_add</name> <argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>is_csc</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ignore</name></expr></argument>, <argument><expr><name>A1</name></expr></argument>, <argument><expr><name>T</name></expr></argument>,
                <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><literal type="string">"S = A1+T"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <comment type="line">// free A1 and T</comment>
            <expr_stmt><expr><call><name>GB_Matrix_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>T</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_Matrix_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>A1</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// replace T with S</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <expr_stmt><expr><name>T</name> <operator>=</operator> <name>S</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>S</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>tnz</name> <operator>=</operator> <call><name>GB_nnz</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// remove A1 from the vectors of A, if A is hypersparse</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <if_stmt><if>if <condition>(<expr><name><name>A</name><operator>-&gt;</operator><name>h</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>nvec</name></name> <operator>=</operator> <name>kA</name></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// append T to the end of A0</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Tp</name> <init>= <expr><name><name>T</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Th</name> <init>= <expr><name><name>T</name><operator>-&gt;</operator><name>h</name></name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ti</name> <init>= <expr><name><name>T</name><operator>-&gt;</operator><name>i</name></name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>tnvec</name> <init>= <expr><name><name>T</name><operator>-&gt;</operator><name>nvec</name></name></expr></init></decl> ;</decl_stmt>

        <expr_stmt><expr><name>anz</name> <operator>=</operator> <name>anz0</name></expr> ;</expr_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>anz_last</name> <init>= <expr><name>anz</name></expr></init></decl> ;</decl_stmt>
    
        <decl_stmt><decl><type><name>int</name></type> <name>nthreads</name> <init>= <expr><call><name>GB_nthreads</name> <argument_list>(<argument><expr><name>tnz</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

        <comment type="line">// append the indices and values of T to the end of A</comment>
        <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Ai</name> <operator>+</operator> <name>anz</name></expr></argument>, <argument><expr><name>Ti</name></expr></argument>, <argument><expr><name>tnz</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nthreads</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>A_iso</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>GB_void</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Tx</name> <init>= <expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name><name>T</name><operator>-&gt;</operator><name>x</name></name></expr></init></decl> ;</decl_stmt>
            <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Ax</name> <operator>+</operator> <name>anz</name> <operator>*</operator> <name>asize</name></expr></argument>, <argument><expr><name>Tx</name></expr></argument>, <argument><expr><name>tnz</name> <operator>*</operator> <name>asize</name></expr></argument>, <argument><expr><name>nthreads</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// append the vectors of T to the end of A</comment>
        <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>tnvec</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content> 
            <decl_stmt><decl><type><name>int64_t</name></type> <name>j</name> <init>= <expr><name><name>Th</name> <index>[<expr><name>k</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>j</name> <operator>&gt;=</operator> <name>tjfirst</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>anz</name> <operator>+=</operator> <operator>(</operator><name><name>Tp</name> <index>[<expr><name>k</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>Tp</name> <index>[<expr><name>k</name></expr>]</index></name><operator>)</operator></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_jappend</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jlast</name></expr></argument>, <argument><expr><name>anz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>anz_last</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>GB_jwrapup</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>jlast</name></expr></argument>, <argument><expr><name>anz</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>anz</name> <operator>==</operator> <name>anz_new</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">// need to recompute the # of non-empty vectors in GB_conform</comment>
        <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr> ;</expr_stmt>     <comment type="line">// recomputed just below</comment>

        <comment type="line">// A-&gt;h has been modified so A-&gt;Y is now invalid</comment>
        <expr_stmt><expr><call><name>GB_hyper_hash_free</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"A after GB_wait:append"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <expr_stmt><expr><call><name>GB_Matrix_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>T</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">// conform A to its desired sparsity structure</comment>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_conform</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// A = A+T</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// The update is not incremental since most of A is changing.  Just do</comment>
        <comment type="line">// a single parallel add: S=A+T, free T, and then transplant S back</comment>
        <comment type="line">// into A.  The nzmax of A is tight, with no room for future</comment>
        <comment type="line">// incremental growth.</comment>

        <comment type="line">// FUTURE:: if GB_add could tolerate zombies in A, then the initial</comment>
        <comment type="line">// prune of zombies can be skipped.</comment>

        <comment type="line">// T-&gt;Y is not present (GB_builder does not create it).  The old A-&gt;Y</comment>
        <comment type="line">// is still valid, if present, for the matrix A prior to added the</comment>
        <comment type="line">// pending tuples in T.  GB_add may need A-&gt;Y to compute S, but it does</comment>
        <comment type="line">// not compute S-&gt;Y.</comment>

        <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>S_header</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_add</name> <argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>is_csc</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ignore</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>T</name></expr></argument>,
            <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_Matrix_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>T</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><literal type="string">"S after GB_wait:add"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>A</name><operator>-&gt;</operator><name>Y</name></name> <operator>!=</operator> <name>NULL</name>
            <operator>&amp;&amp;</operator> <operator>!</operator><name><name>A</name><operator>-&gt;</operator><name>Y_shallow</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GB_is_shallow</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// A and S are both hypersparse, and the old A-&gt;Y exists and is not</comment>
            <comment type="line">// shallow.  Check if S-&gt;h and A-&gt;h are identical.  If so, remove</comment>
            <comment type="line">// A-&gt;Y from A and save it.  Then after the transplant of S into A,</comment>
            <comment type="line">// below, if A is still hyperparse, transplant Y back into A-&gt;Y.</comment>
            <if_stmt><if>if <condition>(<expr><name><name>S</name><operator>-&gt;</operator><name>nvec</name></name> <operator>==</operator> <name>anvec</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// A and S have the same number of vectors.  Compare Ah and Sh</comment>
                <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ah</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>h</name></name></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Sh</name> <init>= <expr><name><name>S</name><operator>-&gt;</operator><name>h</name></name></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type> <name>hsame</name> <init>= <expr><name>true</name></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>nthreads</name> <init>= <expr><call><name>GB_nthreads</name> <argument_list>(<argument><expr><name>anvec</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>nthreads</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// compare Ah and Sh with a single thread</comment>
                    <expr_stmt><expr><name>hsame</name> <operator>=</operator> <operator>(</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>Ah</name></expr></argument>, <argument><expr><name>Sh</name></expr></argument>, <argument><expr><name>anvec</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content> 
                    <comment type="line">// compare Ah and Sh with several threads</comment>
                    <decl_stmt><decl><type><name>int</name></type> <name>ntasks</name> <init>= <expr><literal type="number">64</literal> <operator>*</operator> <name>nthreads</name></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>tid</name></decl> ;</decl_stmt>
                    <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nthreads</omp:expr></omp:argument>)</omp:argument_list></omp:clause> \
                        <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>dynamic</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
                    <for>for <control>(<init><expr><name>tid</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>tid</name> <operator>&lt;</operator> <name>ntasks</name></expr> ;</condition> <incr><expr><name>tid</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>kstart</name></decl>, <decl><type ref="prev"/><name>kend</name></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_PARTITION</name> <argument_list>(<argument><expr><name>kstart</name></expr></argument>, <argument><expr><name>kend</name></expr></argument>, <argument><expr><name>anvec</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>ntasks</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <decl_stmt><decl><type><name>bool</name></type> <name>my_hsame</name></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>GB_ATOMIC_READ</name></type>
                        <name>my_hsame</name> <init>= <expr><name>hsame</name></expr></init></decl> ;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>my_hsame</name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="line">// compare my region of Ah and Sh</comment>
                            <expr_stmt><expr><name>my_hsame</name> <operator>=</operator> <operator>(</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>Ah</name> <operator>+</operator> <name>kstart</name></expr></argument>, <argument><expr><name>Sh</name> <operator>+</operator> <name>kstart</name></expr></argument>,
                                <argument><expr><operator>(</operator><name>kend</name> <operator>-</operator> <name>kstart</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>my_hsame</name></expr>)</condition>
                            <block>{<block_content>
                                <comment type="line">// tell other tasks to exit early</comment>
                                <decl_stmt><decl><type><name>GB_ATOMIC_WRITE</name></type>
                                <name>hsame</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></else></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>hsame</name></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// Ah and Sh are the same, so keep A-&gt;Y</comment>
                    <expr_stmt><expr><name>Y</name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>Y</name></name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>Y</name></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>Y_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// transplant S into A</comment>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_transplant_conform</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>S</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>Y</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>A</name><operator>-&gt;</operator><name>Y</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// The hyperlist of A has not changed.  A is still hypersparse, and</comment>
            <comment type="line">// has no A-&gt;Y after the transplant/conform above.  The original</comment>
            <comment type="line">// A-&gt;Y is valid, so transplant it back into A.</comment>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>Y</name></name> <operator>=</operator> <name>Y</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>Y_shallow</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>Y</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"A after GB_wait:add"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// flush the matrix and return result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><name>GB_FREE_WORKSPACE</name></expr> ;</expr_stmt>
    <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>flush</omp:name></omp:directive></cpp:pragma>
    <return>return <expr><operator>(</operator><name>info</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
