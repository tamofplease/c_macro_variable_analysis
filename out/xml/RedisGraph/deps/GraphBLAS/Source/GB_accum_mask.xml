<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_accum_mask.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_accum_mask: accumulate results via the mask and accum operator</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// C&lt;M&gt; = accum (C,T)</comment>

<comment type="line">// The primary computation of a GraphBLAS operations is done, and the results</comment>
<comment type="line">// are in the T matrix.  The T matrix is then used to modify C, via the accum</comment>
<comment type="line">// operator and the mask matrix M.</comment>

<comment type="line">// The results are first accumulated into Z via the accum operator.</comment>

<comment type="line">// Let Z = accum (C,T) if accum is present, or Z = T otherwise.</comment>
<comment type="line">// In either case, the type of Z is the same as the C-&gt;type defined on input.</comment>
<comment type="line">// If accum is present, T is typecast into the type of the y input to accum.</comment>
<comment type="line">// If accum is not present, T is typecast into the same type as C.</comment>

<comment type="line">// If the function z = accum(x,y) is present, then it defines how the existing</comment>
<comment type="line">// values of C are used to accumulate T into Z.  If both T(i,j) and C(i,j) are</comment>
<comment type="line">// present in the pattern, then Z(i,j) = accum (C(i,j), T(i,j)).  Otherwise,</comment>
<comment type="line">// accum is not used: If C(i,j) is present but not T(i,j), then</comment>
<comment type="line">// Z(i,j)=C(i,j).  If C(i,j) is not present but T(i,j) is present, then</comment>
<comment type="line">// Z(i,j)=T(i,j).  The pattern of Z = accum(C,T) is the union of C and T.</comment>

<comment type="line">// The Z = accum (C,T) phase is mimiced by the GB_spec_accum.m script.</comment>

<comment type="line">// The next step is C&lt;M&gt; = Z.</comment>

<comment type="line">// This denotes how the matrix Z is written into C, under the control of the</comment>
<comment type="line">// mask (or !M if Mask_comp is true), and the C_replace flag (which</comment>
<comment type="line">// indicates that C should be set to zero first.  This is C&lt;M&gt;=Z in</comment>
<comment type="line">// GraphBLAS notation.  See GB_mask.c, or GB_spec_mask.m for a script</comment>
<comment type="line">// that describes this step.</comment>

<comment type="line">// If M is not present, C = Z is returned. Otherwise, M defines what</comment>
<comment type="line">// values of C are modified. If M(i,j) is present and nonzero, then</comment>
<comment type="line">// C(i,j)=Z(i,j) is done.  Otherwise, C(i,j) is left unchanged.</comment>

<comment type="line">// The descriptor affects how C and M are handled.  If the descriptor is</comment>
<comment type="line">// NULL, defaults are used.</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_ALL</name></cpp:macro>                 \
<cpp:value>{                                   \
    GB_Matrix_free (Thandle) ;      \
    GB_Matrix_free (&amp;MT) ;          \
    GB_Matrix_free (&amp;Z) ;           \
}</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_subassign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_add.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_mask.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_transpose.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_accum_mask.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_bitmap_assign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_unused.h"</cpp:file></cpp:include>

<comment type="block">/* -----------------------------------------------------------------------------

    function Z = GB_spec_accum (accum, C, T, identity)
    %GB_SPEC_ACCUM: a mimic of the Z=accum(C,T) operation in GraphBLAS
    %
    % Z = GB_spec_accum (accum, C, T, identity)
    %
    % Apply accum binary operator to the input C and the intermediate result T.
    %

    % get the operator; default is class(C) if class is not present
    [opname opclass] = GB_spec_operator (accum, C.class) ;

    if (nargin &lt; 4)
        identity = 0 ;
    end

    % initialize the matrix Z, same size and class as C
    [nrows ncols] = size (C.matrix) ;
    Z.matrix  = zeros (nrows, ncols, C.class) ;
    Z.matrix (:,:) = identity ;
    Z.pattern = false (nrows, ncols) ;
    Z.class = C.class ;

    if (isempty (opname))

        % Z = T, casting into the class of C
        Z.matrix  = GB_mex_cast (T.matrix, C.class) ;
        Z.pattern = T.pattern ;

    else

        % Z = accum (C,T)

        % apply the operator to entries in the intersection of C and T
        p = T.pattern &amp; C.pattern ;
        % first cast the entries into the class of the operator
        % note that in the spec, all three domains z=op(x,y) can be different
        % here they are assumed to all be the same
        c = GB_mex_cast (C.matrix (p), opclass) ;
        t = GB_mex_cast (T.matrix (p), opclass) ;
        z = GB_spec_op (accum, c, t) ;
        % cast the result z frop opclass into the class of C
        Z.matrix (p) = GB_mex_cast (z, C.class) ;

        % copy entries in C but not in T, into the result Z, no typecasting
        p = C.pattern &amp; ~T.pattern ;
        Z.matrix (p) = C.matrix (p) ;

        % cast entries in T but not in C, into the result Z
        p = T.pattern &amp; ~C.pattern ;
        Z.matrix (p) = GB_mex_cast (T.matrix (p), C.class) ;

        % the pattern of Z is the union of both T and C
        Z.pattern = C.pattern | T.pattern ;

    end

----------------------------------------------------------------------------- */</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_accum_mask</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GrB_Info</name></type> <name>GB_accum_mask</name>          <comment type="line">// C&lt;M&gt; = accum (C,T)</comment>
<parameter_list>(
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,               <comment type="line">// input/output matrix for results</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>M_in</name></decl></parameter>,      <comment type="line">// optional mask for C, unused if NULL</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>MT_in</name></decl></parameter>,     <comment type="line">// MT=M' if computed already in the caller</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_BinaryOp</name></type> <name>accum</name></decl></parameter>,   <comment type="line">// optional accum for Z=accum(C,results)</comment>
    <parameter><decl><type><name>GrB_Matrix</name> <modifier>*</modifier></type><name>Thandle</name></decl></parameter>,        <comment type="line">// results of computation, freed when done</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>C_replace</name></decl></parameter>,       <comment type="line">// if true, clear C first</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_comp</name></decl></parameter>,       <comment type="line">// if true, complement the mask</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_struct</name></decl></parameter>,     <comment type="line">// if true, use the only structure of M</comment>
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// C may be aliased with M_in</comment>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Thandle</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>T</name> <init>= <expr><operator>*</operator><name>Thandle</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>GB_Matrix_opaque</name></name></type> <name>MT_header</name></decl>, <decl><type ref="prev"/><name>Z_header</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>MT</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>Z</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>M</name> <init>= <expr><name>M_in</name></expr></init></decl> ;</decl_stmt>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C input for C&lt;M&gt;=accum(C,T)"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK_OR_NULL</name> <argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><literal type="string">"M for GB_accum_mask"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK_OR_NULL</name> <argument_list>(<argument><expr><name>MT_in</name></expr></argument>, <argument><expr><literal type="string">"MT_in for GB_accum_mask"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_BINARYOP_OK_OR_NULL</name> <argument_list>(<argument><expr><name>accum</name></expr></argument>, <argument><expr><literal type="string">"accum for GB_accum_mask"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_OP_IS_POSITIONAL</name> <argument_list>(<argument><expr><name>accum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// pending work in C may be abandoned, or it might not need to be</comment>
    <comment type="line">// finished if GB_subassign is used, so it is not finished here.</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_PENDING_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_ZOMBIES_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_PENDING_OK</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_ZOMBIES_OK</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// pending work in T will be finished now</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_PENDING_OK</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_ZOMBIES_OK</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><literal type="string">"[T = results of computation]"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// remove zombies and pending tuples from T, but leave it jumbled</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_MATRIX_WAIT_IF_PENDING_OR_ZOMBIES</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// ensure M and T have the same CSR/CSC format as C</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>T_transposed</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>M_transposed</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>C</name><operator>-&gt;</operator><name>is_csc</name></name> <operator>!=</operator> <name><name>T</name><operator>-&gt;</operator><name>is_csc</name></name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// T can be jumbled.</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_transpose_in_place</name> <argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>is_csc</name></name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>T_transposed</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><literal type="string">"[T = transposed]"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>M</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>C</name><operator>-&gt;</operator><name>is_csc</name></name> <operator>!=</operator> <name><name>M</name><operator>-&gt;</operator><name>is_csc</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// M and C have different CSR/CSC formats.  This implies </comment>
        <comment type="line">// that C and M are not aliased.</comment>

        <comment type="line">// MT = M' to conform M to the same CSR/CSC format as C.</comment>
        <if_stmt><if>if <condition>(<expr><name>MT_in</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// remove zombies and pending tuples from M.  M can be jumbled.</comment>
            <expr_stmt><expr><call><name>GB_MATRIX_WAIT_IF_PENDING_OR_ZOMBIES</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>MT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>MT_header</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_transpose_cast</name> <argument_list>(<argument><expr><name>MT</name></expr></argument>, <argument><expr><name>GrB_BOOL</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>is_csc</name></name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>,
                <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>MT</name><operator>-&gt;</operator><name>static_header</name></name> <operator>||</operator> <name>GBNSTATIC</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <comment type="line">// use the transpose mask</comment>
            <expr_stmt><expr><name>M</name> <operator>=</operator> <name>MT</name></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>M_transposed</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// Use the transpose mask passed in by the caller.</comment>
            <comment type="line">// It is the right vlen-by-vdim dimension, but its</comment>
            <comment type="line">// CSR/CSC format is ignored.</comment>
            <expr_stmt><expr><name>M</name> <operator>=</operator> <name>MT_in</name></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// T and M now conform to the dimensions and CSR/CSC format of C</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>vlen</name></name> <operator>==</operator> <name><name>T</name><operator>-&gt;</operator><name>vlen</name></name> <operator>&amp;&amp;</operator> <name><name>C</name><operator>-&gt;</operator><name>vdim</name></name> <operator>==</operator> <name><name>T</name><operator>-&gt;</operator><name>vdim</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>is_csc</name></name> <operator>==</operator> <name><name>T</name><operator>-&gt;</operator><name>is_csc</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>M</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>vlen</name></name> <operator>==</operator> <name><name>M</name><operator>-&gt;</operator><name>vlen</name></name> <operator>&amp;&amp;</operator> <name><name>C</name><operator>-&gt;</operator><name>vdim</name></name> <operator>==</operator> <name><name>M</name><operator>-&gt;</operator><name>vdim</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>M</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>is_csc</name></name> <operator>==</operator> <name><name>M</name><operator>-&gt;</operator><name>is_csc</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// decide on the method</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>cnz</name> <init>= <expr><call><name>GB_nnz</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>              <comment type="line">// includes live entries and zombies</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>cnpending</name> <init>= <expr><call><name>GB_Pending_n</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>  <comment type="line">// # pending tuples in C</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>tnz</name> <init>= <expr><call><name>GB_nnz</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <comment type="line">// Use subassign for the accum/mask step if either M or accum is present</comment>
    <comment type="line">// (or both), and if the update is small compared to the size of C.</comment>
    <comment type="line">// tnz+cnpending is an upper bound on the number of pending tuples in C</comment>
    <comment type="line">// after the accum/mask step with subassign.  If this is small (&lt; nnz(C)),</comment>
    <comment type="line">// then use subassign.  It will be fast when T is very sparse and C has</comment>
    <comment type="line">// many nonzeros.  If the # of pending tuples in C is growing, however,</comment>
    <comment type="line">// then it would be better to finish the work now, and leave C completed.</comment>
    <comment type="line">// In this case, GB_transplant if no accum or GB_add with accum, and</comment>
    <comment type="line">// GB_mask are used for the accum/mask step.</comment>

    <comment type="line">// If there is no mask M, and no accum, then C=T is fast (just</comment>
    <comment type="line">// GB_transplant for Z=T and GB_transplant_conform in GB_mask for C=Z).</comment>
    <comment type="line">// So in this case, GB_subassign takes more work.</comment>

    <if_stmt><if>if <condition>(<expr><call><name>GB_aliased</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>M</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(C aliased with M) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>GB_aliased</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(C aliased with T) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>use_subassign</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>M</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>accum</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GB_IS_FULL</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// always use GB_subassign if C is bitmap or full and M and/or</comment>
            <comment type="line">// accum is present.  No zombies or pending tuples are introduced</comment>
            <comment type="line">// into C, and C is modified in-place, so GB_subassign is very</comment>
            <comment type="line">// efficient in this case.</comment>
            <expr_stmt><expr><name>use_subassign</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// C is sparse or hypersparse (at least for now, before any wait on</comment>
            <comment type="line">// C): use GB_subassign if the update is small (resuling in a small</comment>
            <comment type="line">// number of pending tuples), and if C is not aliased with M or T.</comment>
            <expr_stmt><expr><name>use_subassign</name> <operator>=</operator> <operator>(</operator><name>tnz</name> <operator>+</operator> <name>cnpending</name> <operator>&lt;=</operator> <name>cnz</name><operator>)</operator>
                <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GB_aliased</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>M</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GB_aliased</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>T</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>use_transplant</name> <init>= <expr><operator>(</operator><operator>!</operator><name>use_subassign</name><operator>)</operator>
        <operator>&amp;&amp;</operator> <operator>(</operator><name>accum</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>cnz</name> <operator>+</operator> <name>cnpending</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_subassign</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>use_transplant</name> <operator>||</operator> <operator>(</operator><name>M</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>C_replace</name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// GB_accum_mask will be used instead of GB_subassign, or so it</comment>
        <comment type="line">// appears.  GB_subassign does not require the pending work in C to be</comment>
        <comment type="line">// finished, but GB_accum_mask does in most cases.  Finish the work on</comment>
        <comment type="line">// C now.  This may change C to bitmap/full, so recheck the bitmap/full</comment>
        <comment type="line">// condition on C after doing the GB_MATRIX_WAIT (C).</comment>
        <expr_stmt><expr><call><name>GB_MATRIX_WAIT</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GB_IS_FULL</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// See Test/test182 for a test that triggers this condition.</comment>
            <comment type="line">// GB_MATRIX_WAIT (C) has changed C from sparse/hyper to</comment>
            <comment type="line">// bitmap/full.  GB_mask does not handle the case where M is</comment>
            <comment type="line">// present, C_replace is false, and C is bitmap/full, so switch to</comment>
            <comment type="line">// GB_subassign.</comment>
            <expr_stmt><expr><name>use_subassign</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// use_subassign has been reconsidered and the pending work on C may now</comment>
    <comment type="line">// be finished, which changes cnz and cnpending.  Recompute use_transplant.</comment>
    <expr_stmt><expr><name>cnz</name> <operator>=</operator> <call><name>GB_nnz</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>              <comment type="line">// includes live entries and zombies</comment>
    <expr_stmt><expr><name>cnpending</name> <operator>=</operator> <call><name>GB_Pending_n</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>  <comment type="line">// # pending tuples in C</comment>
    <expr_stmt><expr><name>use_transplant</name> <operator>=</operator> <operator>(</operator><operator>!</operator><name>use_subassign</name><operator>)</operator>
        <operator>&amp;&amp;</operator> <operator>(</operator><name>accum</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>cnz</name> <operator>+</operator> <name>cnpending</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ;</expr_stmt>

    <comment type="line">// burble the decision on which method to use</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_transplant</name></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(C%s%s=Z via %s%s%s) "</literal></expr></argument>,
            <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>M</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>Mask_comp</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"&lt;!M&gt;"</literal></expr> </then><else>: <expr><literal type="string">"&lt;M&gt;"</literal></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr></argument>,
            <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>accum</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"+"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
            <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>use_subassign</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"assign"</literal></expr> </then><else>: <expr><literal type="string">"add"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
            <argument><expr><operator>(</operator><ternary><condition><expr><name>M_transposed</name></expr> ?</condition><then> <expr><literal type="string">"(M transposed)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
            <argument><expr><operator>(</operator><ternary><condition><expr><name>T_transposed</name></expr> ?</condition><then> <expr><literal type="string">"(result transposed)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// apply the accumulator and the mask</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>use_subassign</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C(:,:)&lt;M&gt; = accum (C(:,:),T) via GB_subassign</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>C_replace</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>,
            <argument><expr><name>false</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>GrB_ALL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>GrB_ALL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
            <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>GB_ignore_code</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C&lt;M&gt; = accum (C,T) via GB_transplant or GB_add, and GB_mask</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// see GB_spec_accum.m for a description of this step.  If C is empty,</comment>
        <comment type="line">// then the accumulator can be ignored.</comment>

        <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>Z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Z_header</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>use_transplant</name></expr>)</condition>
        <block>{<block_content> 

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// Z = (ctype) T</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <comment type="line">// GB_new allocates just the header for Z; the rest can be</comment>
            <comment type="line">// allocated by the transplant if needed.  Z has the same</comment>
            <comment type="line">// hypersparsity as T.</comment>

            <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>GB_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Z</name></expr></argument>, <comment type="line">// sparse or hyper, existing header</comment>
                <argument><expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>vlen</name></name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>vdim</name></name></expr></argument>, <argument><expr><name>GB_Ap_null</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>is_csc</name></name></expr></argument>,
                <argument><expr><call><name>GB_sparsity</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>T</name><operator>-&gt;</operator><name>hyper_switch</name></name></expr></argument>, <argument><expr><name><name>T</name><operator>-&gt;</operator><name>plen</name></name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <comment type="line">// Transplant T into Z, typecasting if needed, and free T.  This</comment>
            <comment type="line">// may need to do a deep copy if T is shallow.  T is always freed</comment>
            <comment type="line">// by GB_transplant.</comment>

            <comment type="line">// Z and T have same vlen, vdim, is_csc, hypersparsity</comment>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_transplant</name> <argument_list>(<argument><expr><name>Z</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>Thandle</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// Z = (ctype) accum (C,T)</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <comment type="line">// GB_add_sparsity needs the final sparsity pattern of C and T,</comment>
            <comment type="line">// so wait on C and T first.</comment>
            <expr_stmt><expr><call><name>GB_MATRIX_WAIT</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_MATRIX_WAIT</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <decl_stmt><decl><type><name>bool</name></type> <name>apply_mask</name></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>Z_sparsity</name> <init>= <expr><call><name>GB_add_sparsity</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>apply_mask</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>C</name></expr></argument>, <argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

            <comment type="line">// whether or not GB_add chooses to exploit the mask, it must still</comment>
            <comment type="line">// be used in GB_mask, below.  So ignore the mask_applied return</comment>
            <comment type="line">// flag from GB_add.</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>ignore</name></decl> ;</decl_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_add</name> <argument_list>(<argument><expr><name>Z</name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>is_csc</name></name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>apply_mask</name><operator>)</operator></expr> ?</condition><then> <expr><name>M</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
                <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ignore</name></expr></argument>, <argument><expr><name>C</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_Matrix_free</name> <argument_list>(<argument><expr><name>Thandle</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">// T has been transplanted into Z or freed after Z=C+T</comment>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>*</operator><name>Thandle</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
               <operator>(</operator><operator>*</operator><name>Thandle</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><operator>(</operator><operator>*</operator><name>Thandle</name><operator>)</operator><operator>-&gt;</operator><name>static_header</name></name> <operator>||</operator> <name>GBNSTATIC</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">// C and Z have the same type</comment>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>Z</name></expr></argument>, <argument><expr><literal type="string">"Z in accum_mask"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>Z</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name><name>C</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// apply the mask (C&lt;M&gt;=Z) and free Z</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C&lt;M&gt;=Z input"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_mask</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Z</name></expr></argument>, <argument><expr><name>C_replace</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free workspace and return result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C&lt;M&gt;=accum(C,T)"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <return>return <expr><operator>(</operator><call><name>GB_block</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
