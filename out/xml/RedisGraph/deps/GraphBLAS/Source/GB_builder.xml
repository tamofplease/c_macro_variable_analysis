<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" xmlns:omp="http://www.srcML.org/srcML/openmp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_builder.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_builder: build a matrix from tuples</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// CALLED BY: GB_build, GB_wait, GB_transpose, GB_concat_hyper</comment>

<comment type="line">// This function is called by GB_build to build a matrix T for GrB_Matrix_build</comment>
<comment type="line">// or GrB_Vector_build, by GB_wait to build a matrix T from the list of pending</comment>
<comment type="line">// tuples, and by GB_transpose to transpose a matrix or vector.  Duplicates can</comment>
<comment type="line">// appear if called by GB_build or GB_wait, but not GB_transpose.</comment>

<comment type="line">// The indices are provided either as (I_input,J_input) or (I_work,J_work), not</comment>
<comment type="line">// both.  The values are provided as S_input or S_work, not both.  On return,</comment>
<comment type="line">// the *work arrays are either transplanted into T, or freed, since they are</comment>
<comment type="line">// temporary workspaces.</comment>

<comment type="line">// The work is done in major 5 Steps, some of which can be skipped, depending</comment>
<comment type="line">// on how the tuples are provided (*_work or *_input), and whether or not they</comment>
<comment type="line">// are sorted, or have duplicates.  If vdim &lt;= 1, some work is skipped (for</comment>
<comment type="line">// GrB_Vectors, and single-vector GrB_Matrices).  Let e be the of tuples on</comment>
<comment type="line">// input.  Let p be the # of threads used.</comment>

<comment type="line">// STEP 1: copy user input.  O(e/p) read/write per thread, or skipped.</comment>

<comment type="line">// STEP 2: sort the tuples.  Time: O((e log e)/p), read/write, or skipped if</comment>
<comment type="line">//         the tuples are already sorted.</comment>

<comment type="line">// STEP 3: count vectors and duplicates.  O(e/p) reads, per thread, if no</comment>
<comment type="line">//         duplicates, or skipped if already done.  O(e/p) read/writes</comment>
<comment type="line">//         per thread if duplicates appear.</comment>

<comment type="line">// STEP 4: construct T-&gt;h and T-&gt;p.  O(e/p) reads per thread, or skipped if</comment>
<comment type="line">//         T is a vector.</comment>

<comment type="line">// STEP 5: assemble the tuples.  O(e/p) read/writes per thread, or O(1) if the</comment>
<comment type="line">//         values can be transplanted into T as-is.</comment>

<comment type="line">// For GrB_Matrix_build:  If the input (I_input, J_input, S_input) is already</comment>
<comment type="line">// sorted with no duplicates, and no typecasting needs to be done, then Step 1</comment>
<comment type="line">// still must be done (each thread does O(e/p) reads of (I_input,J_input) and</comment>
<comment type="line">// writes to I_work), but Step 1 also does the work for Step 3.  Step 2 and 3</comment>
<comment type="line">// are skipped.  Step 4 does O(e/p) reads per thread (J_input only).  Then</comment>
<comment type="line">// I_work is transplanted into T-&gt;i.  Step 5 does O(e/p) read/writes per thread</comment>
<comment type="line">// to copy Sx into T-&gt;x.</comment>

<comment type="line">// For GrB_Vector_build: as GrB_Matrix_build, Step 1 does O(e/p) read/writes</comment>
<comment type="line">// per thread.  The input is always a vector, so vdim == 1 always holds.  Step</comment>
<comment type="line">// 2 is skipped if the indices are already sorted, and Step 3 does no work at</comment>
<comment type="line">// all unless duplicates appear.  Step 4 takes no time, for any vector. Step 5</comment>
<comment type="line">// does O(e/p) reads/writes per thread.</comment>

<comment type="line">// For GB_wait:  the pending tuples are provided as I_work, J_work, and S_work,</comment>
<comment type="line">// so Step 1 is skipped (no need to check for invalid indices).  The input</comment>
<comment type="line">// J_work may be null (vdim can be anything, since GB_wait is used for both</comment>
<comment type="line">// vectors and matrices).  The tuples might be in sorted order already, which</comment>
<comment type="line">// is known precisely known from A-&gt;Pending-&gt;sorted.  Step 2 does</comment>
<comment type="line">// O((e log e)/p) work to sort the tuples.  Duplicates may appear, and</comment>
<comment type="line">// out-of-order tuples are likely.  Step 3 does O(e/p) read/writes.  Step 4</comment>
<comment type="line">// does O(e/p) reads per thread of (I_work,J_work), or just I_work.  Step 5</comment>
<comment type="line">// does O(e/p) read/writes per thread, or O(1) time if S_work can be</comment>
<comment type="line">// transplanted into T-&gt;x.</comment>

<comment type="line">// For GB_transpose: uses I_work, J_work, and either S_input (if no op applied</comment>
<comment type="line">// to the values) or S_work (if an op was applied to the A-&gt;x values).  This is</comment>
<comment type="line">// only done for matrices, not vectors, so vdim &gt; 1 will always hold.  The</comment>
<comment type="line">// indices are valid so Step 1 is skipped.  The tuples are not sorted, so Step</comment>
<comment type="line">// 2 takes O((e log e)/p) time to do the sort.  There are no duplicates, so</comment>
<comment type="line">// Step 3 only does O(e/p) reads of J_work to count the vectors in each slice.</comment>
<comment type="line">// Step 4 only does O(e/p) reads of J_work to compute T-&gt;h and T-&gt;p.  Step 5</comment>
<comment type="line">// does O(e/p) read/writes per thread, but it uses the simpler case in</comment>
<comment type="line">// GB_reduce_build_template since no duplicates can appear.  It is unlikely</comment>
<comment type="line">// able to transplant S_work into T-&gt;x since the input will almost always be</comment>
<comment type="line">// unsorted.</comment>

<comment type="line">// For GB_concat_hyper:  uses I_work, J_work, and S_work.  No duplicates</comment>
<comment type="line">// appear.  Tuples are not sorted on input.  I_work is transplanted into C-&gt;i.</comment>
<comment type="line">// J_work and S_work are freed on output.  S_work is not transplanted into</comment>
<comment type="line">// C-&gt;x.</comment>

<comment type="line">// For iso inputs/outputs: T and Sx have the same iso property.  If</comment>
<comment type="line">// they are iso, then dup is always NULL.  Duplicates may or may not appear</comment>
<comment type="line">// if T and Sx are iso.</comment>

<comment type="line">//  (1) GrB_Matrix_build, GrB_Vector_build, and GB_wait do not pass in an iso</comment>
<comment type="line">//      Sx array, where Sx is S_input for GrB*build, and S_work for GB_wait.</comment>
<comment type="line">//      Sx and Tx are not iso.  Duplicates may appear.  dup is always present</comment>
<comment type="line">//      for GrB*build, but may be either NULL or non-NULL for GB_wait.</comment>

<comment type="line">//  (2) GxB_Matrix_build_Scalar and GxB_Vector_build_Scalar: always construct</comment>
<comment type="line">//      iso matrices.  For those methods Sx and Tx are always iso, and no dup</comment>
<comment type="line">//      operator is be passed in (dup is NULL here, which is the implied 2nd</comment>
<comment type="line">//      operator).  Duplicates may appear.</comment>

<comment type="line">//  (3) GB_transpose and GB_concat_hyper can pass in Sx as iso or</comment>
<comment type="line">//      non-iso, and always passes in dup as NULL since there are no</comment>
<comment type="line">//      duplicates.  Sx and Tx are either both iso, or both non-iso.</comment>

<comment type="line">// This method always returns T as hypersparse, and T is iso if and only</comment>
<comment type="line">// if Sx is iso.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_build.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_binop.h"</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GBCUDA_DEV</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_red__include.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_I_WORK</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((t) &lt; 0) ? -1 : I_work [t])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_J_WORK</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((t) &lt; 0) ? -1 : ((J_work == NULL) ? 0 : J_work [t]))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_K_WORK</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((t) &lt; 0) ? -1 : ((K_work == NULL) ? t : K_work [t]))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_WORKSPACE</name></cpp:macro>                           \
<cpp:value>{                                                   \
    GB_WERK_POP (Work, int64_t) ;                   \
    GB_FREE (I_work_handle, *I_work_size_handle) ;  \
    GB_FREE (J_work_handle, *J_work_size_handle) ;  \
    GB_FREE (S_work_handle, *S_work_size_handle) ;  \
    GB_FREE_WORK (&amp;K_work, K_work_size) ;           \
}</cpp:value></cpp:define>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_builder</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GrB_Info</name></type> <name>GB_builder</name>                 <comment type="line">// build a matrix from tuples</comment>
<parameter_list>(
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>T</name></decl></parameter>,                   <comment type="line">// matrix to build, static or dynamic header</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Type</name></type> <name>ttype</name></decl></parameter>,           <comment type="line">// type of output matrix T</comment>
    <parameter><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>vlen</name></decl></parameter>,             <comment type="line">// length of each vector of T</comment>
    <parameter><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>vdim</name></decl></parameter>,             <comment type="line">// number of vectors in T</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_csc</name></decl></parameter>,              <comment type="line">// true if T is CSC, false if CSR</comment>
    <parameter><decl><type><name>int64_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>I_work_handle</name></decl></parameter>,        <comment type="line">// for (i,k) or (j,i,k) tuples</comment>
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>I_work_size_handle</name></decl></parameter>,
    <parameter><decl><type><name>int64_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>J_work_handle</name></decl></parameter>,        <comment type="line">// for (j,i,k) tuples</comment>
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>J_work_size_handle</name></decl></parameter>,
    <parameter><decl><type><name>GB_void</name> <modifier>*</modifier><modifier>*</modifier></type><name>S_work_handle</name></decl></parameter>,        <comment type="line">// array of values of tuples, size ijslen,</comment>
                                    <comment type="line">// or size 1 if S is iso</comment>
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>S_work_size_handle</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>known_sorted</name></decl></parameter>,              <comment type="line">// true if tuples known to be sorted</comment>
    <parameter><decl><type><name>bool</name></type> <name>known_no_duplicates</name></decl></parameter>,       <comment type="line">// true if tuples known to not have dupl</comment>
    <parameter><decl><type><name>int64_t</name></type> <name>ijslen</name></decl></parameter>,                 <comment type="line">// size of I_work and J_work arrays</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_matrix</name></decl></parameter>,           <comment type="line">// true if T a GrB_Matrix, false if vector</comment>
    <parameter><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>I_input</name></decl></parameter>,<comment type="line">// original indices, size nvals</comment>
    <parameter><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>J_input</name></decl></parameter>,<comment type="line">// original indices, size nvals</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GB_void</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>S_input</name></decl></parameter>,<comment type="line">// array of values of tuples, size nvals,</comment>
                                    <comment type="line">// or size 1 if S_input or S_work are iso</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>S_iso</name></decl></parameter>,               <comment type="line">// true if S_input or S_work are iso</comment>
    <parameter><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>nvals</name></decl></parameter>,            <comment type="line">// number of tuples, and size of K_work</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_BinaryOp</name></type> <name>dup</name></decl></parameter>,         <comment type="line">// binary function to assemble duplicates,</comment>
                                    <comment type="line">// if NULL use the SECOND operator to</comment>
                                    <comment type="line">// keep the most recent duplicate.</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Type</name></type> <name>stype</name></decl></parameter>,           <comment type="line">// the type of S_work or S_input</comment>
    <parameter><decl><type><name>bool</name></type> <name>do_burble</name></decl></parameter>,                 <comment type="line">// if true, then burble is allowed</comment>
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>T</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>            <comment type="line">// T is a static or dynamic header on input </comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>nvals</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_TYPE_OK</name> <argument_list>(<argument><expr><name>ttype</name></expr></argument>, <argument><expr><literal type="string">"ttype for builder"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_BINARYOP_OK_OR_NULL</name> <argument_list>(<argument><expr><name>dup</name></expr></argument>, <argument><expr><literal type="string">"dup for builder"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>I_work_handle</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>J_work_handle</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>S_work_handle</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_OP_IS_POSITIONAL</name> <argument_list>(<argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>I_work_size_handle</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>J_work_size_handle</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>S_work_size_handle</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get Sx</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GB_void</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>S_work</name> <init>= <expr><operator>(</operator><operator>*</operator><name>S_work_handle</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>GB_void</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Sx</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>S_work</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>S_input</name></expr> </then><else>: <expr><name>S_work</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><name>nvals</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>Sx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><name>S_iso</name></expr></argument>, <argument><expr><name>ttype</name> <operator>==</operator> <name>stype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><name>S_iso</name></expr></argument>, <argument><expr><name>dup</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//==========================================================================</comment>
    <comment type="line">// symbolic phase of the build =============================================</comment>
    <comment type="line">//==========================================================================</comment>

    <comment type="line">// The symbolic phase sorts the tuples and finds any duplicates.  The</comment>
    <comment type="line">// output matrix T is constructed (not including T-&gt;i and T-&gt;x), and T-&gt;h</comment>
    <comment type="line">// and T-&gt;p are computed.  Then I_work is transplanted into T-&gt;i, or T-&gt;i is</comment>
    <comment type="line">// allocated.  T-&gt;x is then allocated.  It is not computed until the</comment>
    <comment type="line">// numeric phase.</comment>

    <comment type="line">// When this function returns, I_work is either freed or transplanted into</comment>
    <comment type="line">// T-&gt;i.  J_work is freed, and the I_work and J_work pointers (in the</comment>
    <comment type="line">// caller) are set to NULL by setting their handles to NULL.  Note that</comment>
    <comment type="line">// J_work may already be NULL on input, if T has one or zero vectors</comment>
    <comment type="line">// (J_work_handle is always non-NULL however).</comment>

    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>I_work</name> <init>= <expr><operator>(</operator><operator>*</operator><name>I_work_handle</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>J_work</name> <init>= <expr><operator>(</operator><operator>*</operator><name>J_work_handle</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>K_work</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>K_work_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine the number of threads to use</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_GET_NTHREADS_MAX</name> <argument_list>(<argument><expr><name>nthreads_max</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nthreads</name> <init>= <expr><call><name>GB_nthreads</name> <argument_list>(<argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// allocate workspace</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_WERK_DECLARE</name> <argument_list>(<argument><expr><name>Work</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_WERK_PUSH</name> <argument_list>(<argument><expr><name>Work</name></expr></argument>, <argument><expr><literal type="number">5</literal><operator>*</operator><operator>(</operator><name>nthreads</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>Work</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// out of memory</comment>
        <expr_stmt><expr><name>GB_FREE_WORKSPACE</name></expr> ;</expr_stmt>
        <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>Work</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Work_nitems</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>tstart_slice</name> <init>= <expr><name>Work</name></expr></init></decl> ;</decl_stmt>                  <comment type="line">// nthreads+1</comment>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>tnvec_slice</name>  <init>= <expr><name>Work</name> <operator>+</operator>   <operator>(</operator><name>nthreads</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl> ;</decl_stmt> <comment type="line">// nthreads+1</comment>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>tnz_slice</name>    <init>= <expr><name>Work</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>nthreads</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl> ;</decl_stmt> <comment type="line">// nthreads+1</comment>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>kbad</name>         <init>= <expr><name>Work</name> <operator>+</operator> <literal type="number">3</literal><operator>*</operator><operator>(</operator><name>nthreads</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl> ;</decl_stmt> <comment type="line">// nthreads</comment>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>ilast_slice</name>  <init>= <expr><name>Work</name> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><operator>(</operator><name>nthreads</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl> ;</decl_stmt> <comment type="line">// nthreads</comment>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// partition the tuples for the threads</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// Thread tid handles tuples tstart_slice [tid] to tstart_slice [tid+1]-1.</comment>
    <comment type="line">// Each thread handles about the same number of tuples.  This partition</comment>
    <comment type="line">// depends only on nvals.</comment>

    <expr_stmt><expr><call><name>GB_eslice</name> <argument_list>(<argument><expr><name>tstart_slice</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>nthreads</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// tstart_slice [tid]: first tuple in slice tid</comment>
    <comment type="line">// tnvec_slice [tid]: # of vectors that start in a slice.  If a vector</comment>
    <comment type="line">//                    starts in one slice and ends in another, it is</comment>
    <comment type="line">//                    counted as being in the first slice.</comment>
    <comment type="line">// tnz_slice   [tid]: # of entries in a slice after removing duplicates</comment>

    <comment type="line">// sentinel values for the final cumulative sum</comment>
    <expr_stmt><expr><name><name>tnvec_slice</name> <index>[<expr><name>nthreads</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>tnz_slice</name>   <index>[<expr><name>nthreads</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>

    <comment type="line">// this becomes true if the first pass computes tnvec_slice and tnz_slice,</comment>
    <comment type="line">// and if the (I_input,J_input) tuples were found to be already sorted with</comment>
    <comment type="line">// no duplicates present.</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>tnvec_and_tnz_slice_computed</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// STEP 1: copy user input and check if valid</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// If the indices are provided by (I_input,J_input), then import them into</comment>
    <comment type="line">// (I_work,J_work) and check if they are valid, and sorted.   If the input</comment>
    <comment type="line">// happens to be already sorted, then duplicates are detected and the # of</comment>
    <comment type="line">// vectors in each slice is counted.</comment>

    <if_stmt><if>if <condition>(<expr><name>I_work</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// allocate I_work</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// allocate workspace to load and sort the index tuples:</comment>

        <comment type="line">// vdim &lt;= 1: I_work and K_work for (i,k) tuples, where i = I_input [k]</comment>

        <comment type="line">// vdim &gt; 1: also J_work for (j,i,k) tuples where i = I_input [k] and</comment>
        <comment type="line">// j = J_input [k].  If the tuples are found to be already sorted on</comment>
        <comment type="line">// input, then J_work is not allocated, and J_input is used instead.</comment>

        <comment type="line">// The k value in the tuple gives the position in the original set of</comment>
        <comment type="line">// tuples: I_input [k] and Sx [k] when vdim &lt;= 1, and also J_input [k]</comment>
        <comment type="line">// for matrices with vdim &gt; 1.</comment>

        <comment type="line">// The workspace I_work and J_work are allocated here but freed (or</comment>
        <comment type="line">// transplanted) inside GB_builder.  K_work is allocated, used, and</comment>
        <comment type="line">// freed in GB_builder.</comment>

        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>J_work</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>I_work</name> <operator>=</operator> <call><name>GB_MALLOC</name> <argument_list>(<argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>I_work_size_handle</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>I_work_handle</name><operator>)</operator> <operator>=</operator> <name>I_work</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>ijslen</name> <operator>=</operator> <name>nvals</name></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>I_work</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// out of memory</comment>
            <expr_stmt><expr><name>GB_FREE_WORKSPACE</name></expr> ;</expr_stmt>
            <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// create the tuples to sort, and check for any invalid indices</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><name>known_sorted</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>no_duplicates_found</name> <init>= <expr><name>true</name></expr></init></decl> ;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>nvals</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content> 

            <comment type="line">// nothing to do</comment>

        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>is_matrix</name></expr>)</condition>
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// C is a matrix; check both I_input and J_input</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>J_input</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>I_work</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>vdim</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>I_input</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>tid</name></decl> ;</decl_stmt>
            <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nthreads</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>static</omp:expr></omp:argument>)</omp:argument_list></omp:clause> \
                <omp:clause><omp:name>reduction</omp:name><omp:argument_list>(<omp:argument><omp:expr>&amp;&amp;:known_sorted</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>reduction</omp:name><omp:argument_list>(<omp:argument><omp:expr>&amp;&amp;:no_duplicates_found</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
            <for>for <control>(<init><expr><name>tid</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>tid</name> <operator>&lt;</operator> <name>nthreads</name></expr> ;</condition> <incr><expr><name>tid</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>

                <expr_stmt><expr><name><name>kbad</name> <index>[<expr><name>tid</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr> ;</expr_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>my_tnvec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>kstart</name>   <init>= <expr><name><name>tstart_slice</name> <index>[<expr><name>tid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>kend</name>     <init>= <expr><name><name>tstart_slice</name> <index>[<expr><name>tid</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>ilast</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>kstart</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name><name>I_input</name> <index>[<expr><name>kstart</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>jlast</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>kstart</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name><name>J_input</name> <index>[<expr><name>kstart</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></else></ternary></expr></init></decl> ;</decl_stmt>

                <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><name>kstart</name></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>kend</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <comment type="line">// get k-th index from user input: (i,j)</comment>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>I_input</name> <index>[<expr><name>k</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>j</name> <init>= <expr><name><name>J_input</name> <index>[<expr><name>k</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>i</name> <operator>&gt;=</operator> <name>vlen</name> <operator>||</operator> <name>j</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>j</name> <operator>&gt;=</operator> <name>vdim</name></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// halt if out of bounds</comment>
                        <expr_stmt><expr><name><name>kbad</name> <index>[<expr><name>tid</name></expr>]</index></name> <operator>=</operator> <name>k</name></expr> ;</expr_stmt>
                        <break>break ;</break>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// check if the tuples are already sorted</comment>
                    <expr_stmt><expr><name>known_sorted</name> <operator>=</operator> <name>known_sorted</name> <operator>&amp;&amp;</operator>
                        <operator>(</operator><operator>(</operator><name>jlast</name> <operator>&lt;</operator> <name>j</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>jlast</name> <operator>==</operator> <name>j</name> <operator>&amp;&amp;</operator> <name>ilast</name> <operator>&lt;=</operator> <name>i</name><operator>)</operator><operator>)</operator></expr> ;</expr_stmt>

                    <comment type="line">// check if this entry is a duplicate of the one before it</comment>
                    <expr_stmt><expr><name>no_duplicates_found</name> <operator>=</operator> <name>no_duplicates_found</name> <operator>&amp;&amp;</operator>
                        <operator>(</operator><operator>!</operator><operator>(</operator><name>jlast</name> <operator>==</operator> <name>j</name> <operator>&amp;&amp;</operator> <name>ilast</name> <operator>==</operator> <name>i</name><operator>)</operator><operator>)</operator></expr> ;</expr_stmt>

                    <comment type="line">// copy the tuple into I_work.  J_work is done later.</comment>
                    <expr_stmt><expr><name><name>I_work</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>jlast</name></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// vector j starts in this slice (but this is</comment>
                        <comment type="line">// valid only if J_input is sorted on input)</comment>
                        <expr_stmt><expr><name>my_tnvec</name><operator>++</operator></expr> ;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// log the last index seen</comment>
                    <expr_stmt><expr><name>ilast</name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt> <expr_stmt><expr><name>jlast</name> <operator>=</operator> <name>j</name></expr> ;</expr_stmt>
                </block_content>}</block></for>

                <comment type="line">// these are valid only if I_input and J_input are sorted on</comment>
                <comment type="line">// input, with no duplicates present.</comment>
                <expr_stmt><expr><name><name>tnvec_slice</name> <index>[<expr><name>tid</name></expr>]</index></name> <operator>=</operator> <name>my_tnvec</name></expr> ;</expr_stmt>
                <expr_stmt><expr><name><name>tnz_slice</name>   <index>[<expr><name>tid</name></expr>]</index></name> <operator>=</operator> <name>kend</name> <operator>-</operator> <name>kstart</name></expr> ;</expr_stmt>

            </block_content>}</block></for>

            <comment type="line">// collect the report from each thread</comment>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>tid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>tid</name> <operator>&lt;</operator> <name>nthreads</name></expr> ;</condition> <incr><expr><name>tid</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>kbad</name> <index>[<expr><name>tid</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// invalid index</comment>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>I_input</name> <index>[<expr><name><name>kbad</name> <index>[<expr><name>tid</name></expr>]</index></name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>j</name> <init>= <expr><name><name>J_input</name> <index>[<expr><name><name>kbad</name> <index>[<expr><name>tid</name></expr>]</index></name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>row</name> <init>= <expr><ternary><condition><expr><name>is_csc</name></expr> ?</condition><then> <expr><name>i</name></expr> </then><else>: <expr><name>j</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>col</name> <init>= <expr><ternary><condition><expr><name>is_csc</name></expr> ?</condition><then> <expr><name>j</name></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>nrows</name> <init>= <expr><ternary><condition><expr><name>is_csc</name></expr> ?</condition><then> <expr><name>vlen</name></expr> </then><else>: <expr><name>vdim</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>ncols</name> <init>= <expr><ternary><condition><expr><name>is_csc</name></expr> ?</condition><then> <expr><name>vdim</name></expr> </then><else>: <expr><name>vlen</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
                    <expr_stmt><expr><name>GB_FREE_WORKSPACE</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_INDEX_OUT_OF_BOUNDS</name></expr></argument>,
                        <argument><expr><literal type="string">"index ("</literal> <name>GBd</name> <literal type="string">","</literal> <name>GBd</name> <literal type="string">") out of bounds,"</literal>
                        <literal type="string">" must be &lt; ("</literal> <name>GBd</name> <literal type="string">", "</literal> <name>GBd</name> <literal type="string">")"</literal></expr></argument>,
                        <argument><expr><name>row</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>nrows</name></expr></argument>, <argument><expr><name>ncols</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <comment type="line">// if the tuples were found to be already in sorted order, and if</comment>
            <comment type="line">// no duplicates were found, then tnvec_slice and tnz_slice are now</comment>
            <comment type="line">// valid, Otherwise, they can only be computed after sorting.</comment>
            <expr_stmt><expr><name>tnvec_and_tnz_slice_computed</name> <operator>=</operator> <name>known_sorted</name> <operator>&amp;&amp;</operator> <name>no_duplicates_found</name></expr> ;</expr_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// allocate J_work, if needed</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <if_stmt><if>if <condition>(<expr><name>vdim</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>known_sorted</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// copy J_input into J_work, so the tuples can be sorted</comment>
                <expr_stmt><expr><name>J_work</name> <operator>=</operator> <call><name>GB_MALLOC</name> <argument_list>(<argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>J_work_size_handle</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><operator>(</operator><operator>*</operator><name>J_work_handle</name><operator>)</operator> <operator>=</operator> <name>J_work</name></expr> ;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>J_work</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// out of memory</comment>
                    <expr_stmt><expr><name>GB_FREE_WORKSPACE</name></expr> ;</expr_stmt>
                    <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>J_work</name></expr></argument>, <argument><expr><name>J_input</name></expr></argument>, <argument><expr><name>nvals</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nthreads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <comment type="line">// J_work is a shallow copy of J_input.  The pointer is not</comment>
                <comment type="line">// copied into (*J_work_handle), so it will not be freed.</comment>
                <comment type="line">// J_input is not modified, even though it is typecast to the</comment>
                <comment type="line">// int64_t *J_work, since J_work is not modified in this case.</comment>
                <expr_stmt><expr><name>J_work</name> <operator>=</operator> <operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator> <name>J_input</name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>

        </block_content>}</block></if>
        <else>else
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// C is a typecasted GrB_Vector; check only I_input</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>I_input</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>J_input</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>vdim</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>tid</name></decl> ;</decl_stmt>
            <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nthreads</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>static</omp:expr></omp:argument>)</omp:argument_list></omp:clause> \
                <omp:clause><omp:name>reduction</omp:name><omp:argument_list>(<omp:argument><omp:expr>&amp;&amp;:known_sorted</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>reduction</omp:name><omp:argument_list>(<omp:argument><omp:expr>&amp;&amp;:no_duplicates_found</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
            <for>for <control>(<init><expr><name>tid</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>tid</name> <operator>&lt;</operator> <name>nthreads</name></expr> ;</condition> <incr><expr><name>tid</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>

                <expr_stmt><expr><name><name>kbad</name> <index>[<expr><name>tid</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr> ;</expr_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>kstart</name>   <init>= <expr><name><name>tstart_slice</name> <index>[<expr><name>tid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>kend</name>     <init>= <expr><name><name>tstart_slice</name> <index>[<expr><name>tid</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>ilast</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>kstart</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name><name>I_input</name> <index>[<expr><name>kstart</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></else></ternary></expr></init></decl> ;</decl_stmt>

                <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><name>kstart</name></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>kend</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <comment type="line">// get k-th index from user input: (i)</comment>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>I_input</name> <index>[<expr><name>k</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>i</name> <operator>&gt;=</operator> <name>vlen</name></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// halt if out of bounds</comment>
                        <expr_stmt><expr><name><name>kbad</name> <index>[<expr><name>tid</name></expr>]</index></name> <operator>=</operator> <name>k</name></expr> ;</expr_stmt>
                        <break>break ;</break>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// check if the tuples are already sorted</comment>
                    <expr_stmt><expr><name>known_sorted</name> <operator>=</operator> <name>known_sorted</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ilast</name> <operator>&lt;=</operator> <name>i</name><operator>)</operator></expr> ;</expr_stmt>

                    <comment type="line">// check if this entry is a duplicate of the one before it</comment>
                    <expr_stmt><expr><name>no_duplicates_found</name> <operator>=</operator> <name>no_duplicates_found</name> <operator>&amp;&amp;</operator>
                        <operator>(</operator><operator>!</operator><operator>(</operator><name>ilast</name> <operator>==</operator> <name>i</name><operator>)</operator><operator>)</operator></expr> ;</expr_stmt>

                    <comment type="line">// copy the tuple into the work arrays to be sorted</comment>
                    <expr_stmt><expr><name><name>I_work</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>

                    <comment type="line">// log the last index seen</comment>
                    <expr_stmt><expr><name>ilast</name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></for>

            <comment type="line">// collect the report from each thread</comment>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>tid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>tid</name> <operator>&lt;</operator> <name>nthreads</name></expr> ;</condition> <incr><expr><name>tid</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>kbad</name> <index>[<expr><name>tid</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// invalid index</comment>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>I_input</name> <index>[<expr><name><name>kbad</name> <index>[<expr><name>tid</name></expr>]</index></name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                    <expr_stmt><expr><name>GB_FREE_WORKSPACE</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_INDEX_OUT_OF_BOUNDS</name></expr></argument>,
                        <argument><expr><literal type="string">"index ("</literal> <name>GBd</name> <literal type="string">") out of bounds, must be &lt; ("</literal> <name>GBd</name> <literal type="string">")"</literal></expr></argument>,
                        <argument><expr><name>i</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// determine if duplicates are possible</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// The input is now known to be sorted, or not.  If it is sorted, and</comment>
        <comment type="line">// if no duplicates were found, then it is known to have no duplicates.</comment>
        <comment type="line">// Otherwise, duplicates might appear, but a sort is required first to</comment>
        <comment type="line">// check for duplicates.</comment>

        <expr_stmt><expr><name>known_no_duplicates</name> <operator>=</operator> <name>known_sorted</name> <operator>&amp;&amp;</operator> <name>no_duplicates_found</name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// STEP 2: sort the tuples in ascending order</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// If the tuples are known to already be sorted, Step 2 is skipped.  In</comment>
    <comment type="line">// that case, K_work is NULL (not allocated), which implicitly means that</comment>
    <comment type="line">// K_work [k] = k for all k = 0:nvals-1.  K_work is always NULL if Sx and</comment>
    <comment type="line">// Tx are iso.</comment>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>known_sorted</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// allocate K_work workspace (not needed if T and Sx are iso)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>S_iso</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// create the k part of each tuple</comment>
            <expr_stmt><expr><name>K_work</name> <operator>=</operator> <call><name>GB_MALLOC_WORK</name> <argument_list>(<argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>K_work_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>K_work</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// out of memory</comment>
                <expr_stmt><expr><name>GB_FREE_WORKSPACE</name></expr> ;</expr_stmt>
                <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// The k part of each tuple (i,k) or (j,i,k) records the original</comment>
            <comment type="line">// position of the tuple in the input list.  This allows an</comment>
            <comment type="line">// unstable sorting algorithm to be used.  Since k is unique, it</comment>
            <comment type="line">// forces the result of the sort to be stable regardless of whether</comment>
            <comment type="line">// or not the sorting algorithm is stable.  It also keeps track of</comment>
            <comment type="line">// where the numerical value of the tuple can be found; it is in</comment>
            <comment type="line">// Sx[k] for the tuple (i,k) or (j,i,k), regardless of where the</comment>
            <comment type="line">// tuple appears in the list after it is sorted.</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>k</name></decl> ;</decl_stmt>
            <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nthreads</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>static</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
            <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>nvals</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content> 
                <expr_stmt><expr><name><name>K_work</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>k</name></expr> ;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// sort all the tuples</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <if_stmt><if>if <condition>(<expr><name>vdim</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// sort a set of (j,i,k) tuples</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <if_stmt><if>if <condition>(<expr><name>S_iso</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// K_work is NULL; only sort (j,i)</comment>
                <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>GB_msort_2</name> <argument_list>(<argument><expr><name>J_work</name></expr></argument>, <argument><expr><name>I_work</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>nthreads</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>GB_msort_3</name> <argument_list>(<argument><expr><name>J_work</name></expr></argument>, <argument><expr><name>I_work</name></expr></argument>, <argument><expr><name>K_work</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>nthreads</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_DEBUG</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>ilast</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>jlast</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>nvals</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>I_work</name> <index>[<expr><name>k</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>j</name> <init>= <expr><name><name>J_work</name> <index>[<expr><name>k</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>(</operator><name>jlast</name> <operator>&lt;</operator> <name>j</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>jlast</name> <operator>==</operator> <name>j</name> <operator>&amp;&amp;</operator> <name>ilast</name> <operator>&lt;=</operator> <name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>ilast</name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>jlast</name> <operator>=</operator> <name>j</name></expr> ;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        </block_content>}</block></if>
        <else>else
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// sort a set of (i,k) tuples</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <if_stmt><if>if <condition>(<expr><name>S_iso</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// K_work is NULL; only sort (i)</comment>
                <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>GB_msort_1</name> <argument_list>(<argument><expr><name>I_work</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>nthreads</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>GB_msort_2</name> <argument_list>(<argument><expr><name>I_work</name></expr></argument>, <argument><expr><name>K_work</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr><name>nthreads</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_DEBUG</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>ilast</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>nvals</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>I_work</name> <index>[<expr><name>k</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>ilast</name> <operator>&lt;=</operator> <name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>ilast</name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>info</name> <operator>!=</operator> <name>GrB_SUCCESS</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// out of memory in GB_msort_*</comment>
            <expr_stmt><expr><name>GB_FREE_WORKSPACE</name></expr> ;</expr_stmt>
            <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// STEP 3: count vectors and duplicates in each slice</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// Duplicates are located, counted and their indices negated.  The # of</comment>
    <comment type="line">// vectors in each slice is counted.  If the indices are known to not have</comment>
    <comment type="line">// duplicates, then only the vectors are counted.  Counting the # of</comment>
    <comment type="line">// vectors is skipped if already done by Step 1.</comment>

    <if_stmt><if>if <condition>(<expr><name>known_no_duplicates</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// no duplicates: just count # vectors in each slice</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// This is much faster, particularly if the # of vectors in each slice</comment>
        <comment type="line">// has already been computed.</comment>

        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_DEBUG</name></cpp:ifdef>
        <block>{<block_content>
            <comment type="line">// assert that there are no duplicates</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>ilast</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>jlast</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>t</name> <operator>&lt;</operator> <name>nvals</name></expr> ;</condition> <incr><expr><name>t</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><call><name>GB_I_WORK</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>j</name> <init>= <expr><call><name>GB_J_WORK</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type> <name>is_duplicate</name> <init>= <expr><operator>(</operator><name>i</name> <operator>==</operator> <name>ilast</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>==</operator> <name>jlast</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>is_duplicate</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><name>ilast</name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt> <expr_stmt><expr><name>jlast</name> <operator>=</operator> <name>j</name></expr> ;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if_stmt><if>if <condition>(<expr><name>vdim</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>

            <comment type="line">// all tuples appear in at most one vector, and there are no</comment>
            <comment type="line">// duplicates, so there is no need to scan I_work or J_work.</comment>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>tid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>tid</name> <operator>&lt;</operator> <name>nthreads</name></expr> ;</condition> <incr><expr><name>tid</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content> 
                <decl_stmt><decl><type><name>int64_t</name></type> <name>tstart</name> <init>= <expr><name><name>tstart_slice</name> <index>[<expr><name>tid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>tend</name>   <init>= <expr><name><name>tstart_slice</name> <index>[<expr><name>tid</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <expr_stmt><expr><name><name>tnvec_slice</name> <index>[<expr><name>tid</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
                <expr_stmt><expr><name><name>tnz_slice</name>   <index>[<expr><name>tid</name></expr>]</index></name> <operator>=</operator> <name>tend</name> <operator>-</operator> <name>tstart</name></expr> ;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><name><name>tnvec_slice</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>nvals</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr> ;</expr_stmt>

        </block_content>}</block></if>
        <else>else
        <block>{<block_content>

            <comment type="line">// count the # of unique vector indices in J_work.  No need to scan</comment>
            <comment type="line">// I_work since there are no duplicates to be found.  Also no need</comment>
            <comment type="line">// to compute them if already found in Step 1. </comment>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tnvec_and_tnz_slice_computed</name></expr>)</condition>
            <block>{<block_content>

                <decl_stmt><decl><type><name>int</name></type> <name>tid</name></decl> ;</decl_stmt>
                <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nthreads</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>static</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
                <for>for <control>(<init><expr><name>tid</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>tid</name> <operator>&lt;</operator> <name>nthreads</name></expr> ;</condition> <incr><expr><name>tid</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>my_tnvec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>tstart</name> <init>= <expr><name><name>tstart_slice</name> <index>[<expr><name>tid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>tend</name>   <init>= <expr><name><name>tstart_slice</name> <index>[<expr><name>tid</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>jlast</name>  <init>= <expr><call><name>GB_J_WORK</name> <argument_list>(<argument><expr><name>tstart</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>t</name> <init>= <expr><name>tstart</name></expr></init></decl> ;</init> <condition><expr><name>t</name> <operator>&lt;</operator> <name>tend</name></expr> ;</condition> <incr><expr><name>t</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <comment type="line">// get the t-th tuple</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>j</name> <init>= <expr><name><name>J_work</name> <index>[<expr><name>t</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>jlast</name></expr>)</condition>
                        <block>{<block_content> 
                            <comment type="line">// vector j starts in this slice</comment>
                            <expr_stmt><expr><name>my_tnvec</name><operator>++</operator></expr> ;</expr_stmt>
                            <expr_stmt><expr><name>jlast</name> <operator>=</operator> <name>j</name></expr> ;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>

                    <expr_stmt><expr><name><name>tnvec_slice</name> <index>[<expr><name>tid</name></expr>]</index></name> <operator>=</operator> <name>my_tnvec</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>tnz_slice</name>   <index>[<expr><name>tid</name></expr>]</index></name> <operator>=</operator> <name>tend</name> <operator>-</operator> <name>tstart</name></expr> ;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// look for duplicates and count # vectors in each slice</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>tid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>tid</name> <operator>&lt;</operator> <name>nthreads</name></expr> ;</condition> <incr><expr><name>tid</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content> 
            <decl_stmt><decl><type><name>int64_t</name></type> <name>tstart</name> <init>= <expr><name><name>tstart_slice</name> <index>[<expr><name>tid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <expr_stmt><expr><name><name>ilast_slice</name> <index>[<expr><name>tid</name></expr>]</index></name> <operator>=</operator> <call><name>GB_I_WORK</name> <argument_list>(<argument><expr><name>tstart</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></for>

        <decl_stmt><decl><type><name>int</name></type> <name>tid</name></decl> ;</decl_stmt>
        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nthreads</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>static</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
        <for>for <control>(<init><expr><name>tid</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>tid</name> <operator>&lt;</operator> <name>nthreads</name></expr> ;</condition> <incr><expr><name>tid</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>my_tnvec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>my_ndupl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>tstart</name>   <init>= <expr><name><name>tstart_slice</name> <index>[<expr><name>tid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>tend</name>     <init>= <expr><name><name>tstart_slice</name> <index>[<expr><name>tid</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>ilast</name>    <init>= <expr><name><name>ilast_slice</name> <index>[<expr><name>tid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>jlast</name>    <init>= <expr><call><name>GB_J_WORK</name> <argument_list>(<argument><expr><name>tstart</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>t</name> <init>= <expr><name>tstart</name></expr></init></decl> ;</init> <condition><expr><name>t</name> <operator>&lt;</operator> <name>tend</name></expr> ;</condition> <incr><expr><name>t</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <comment type="line">// get the t-th tuple</comment>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>I_work</name> <index>[<expr><name>t</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>j</name> <init>= <expr><call><name>GB_J_WORK</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

                <comment type="line">// tuples are now sorted but there may be duplicates</comment>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>(</operator><name>jlast</name> <operator>&lt;</operator> <name>j</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>jlast</name> <operator>==</operator> <name>j</name> <operator>&amp;&amp;</operator> <name>ilast</name> <operator>&lt;=</operator> <name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

                <comment type="line">// check if (j,i,k) is a duplicate</comment>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>ilast</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>==</operator> <name>jlast</name></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// flag the tuple as a duplicate</comment>
                    <expr_stmt><expr><name><name>I_work</name> <index>[<expr><name>t</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>my_ndupl</name><operator>++</operator></expr> ;</expr_stmt>
                    <comment type="line">// the sort places earlier duplicate tuples (with smaller</comment>
                    <comment type="line">// k) after later ones (with larger k).</comment>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_K_WORK</name> <argument_list>(<argument><expr><name>t</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>GB_K_WORK</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="line">// this is a new tuple</comment>
                    <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>jlast</name></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// vector j starts in this slice</comment>
                        <expr_stmt><expr><name>my_tnvec</name><operator>++</operator></expr> ;</expr_stmt>
                        <expr_stmt><expr><name>jlast</name> <operator>=</operator> <name>j</name></expr> ;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>ilast</name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><name><name>tnvec_slice</name> <index>[<expr><name>tid</name></expr>]</index></name> <operator>=</operator> <name>my_tnvec</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>tnz_slice</name>   <index>[<expr><name>tid</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>tend</name> <operator>-</operator> <name>tstart</name><operator>)</operator> <operator>-</operator> <name>my_ndupl</name></expr> ;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// find total # of vectors and duplicates in all tuples</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// Replace tnvec_slice with its cumulative sum, after which each slice tid</comment>
    <comment type="line">// will be responsible for the # vectors in T that range from tnvec_slice</comment>
    <comment type="line">// [tid] to tnvec_slice [tid+1]-1.</comment>
    <expr_stmt><expr><call><name>GB_cumsum</name> <argument_list>(<argument><expr><name>tnvec_slice</name></expr></argument>, <argument><expr><name>nthreads</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>tnvec</name> <init>= <expr><name><name>tnvec_slice</name> <index>[<expr><name>nthreads</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>

    <comment type="line">// Replace tnz_slice with its cumulative sum</comment>
    <expr_stmt><expr><call><name>GB_cumsum</name> <argument_list>(<argument><expr><name>tnz_slice</name></expr></argument>, <argument><expr><name>nthreads</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// find the total # of final entries, after assembling duplicates</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>tnz</name> <init>= <expr><name><name>tnz_slice</name> <index>[<expr><name>nthreads</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>ndupl</name> <init>= <expr><name>nvals</name> <operator>-</operator> <name>tnz</name></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// allocate T; always hypersparse</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// allocate T; allocate T-&gt;p and T-&gt;h but do not initialize them.</comment>
    <comment type="line">// T is always hypersparse.  The header T always exists on input, as</comment>
    <comment type="line">// either a static or dynamic header.</comment>
    <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>GB_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <comment type="line">// always hyper, existing header</comment>
        <argument><expr><name>ttype</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>, <argument><expr><name>vdim</name></expr></argument>, <argument><expr><name>GB_Ap_malloc</name></expr></argument>, <argument><expr><name>is_csc</name></expr></argument>,
        <argument><expr><name>GxB_HYPERSPARSE</name></expr></argument>, <argument><expr><name>GB_ALWAYS_HYPER</name></expr></argument>, <argument><expr><name>tnvec</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>info</name> <operator>!=</operator> <name>GrB_SUCCESS</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// out of memory</comment>
        <expr_stmt><expr><name>GB_FREE_WORKSPACE</name></expr> ;</expr_stmt>
        <return>return <expr><operator>(</operator><name>info</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>T</name><operator>-&gt;</operator><name>p</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>T</name><operator>-&gt;</operator><name>h</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>T</name><operator>-&gt;</operator><name>b</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>T</name><operator>-&gt;</operator><name>i</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>T</name><operator>-&gt;</operator><name>x</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><name><name>T</name><operator>-&gt;</operator><name>iso</name></name> <operator>=</operator> <name>S_iso</name></expr> ;</expr_stmt>                <comment type="line">// OK: T is iso if and only if Sx is iso</comment>
    <expr_stmt><expr><name>do_burble</name> <operator>=</operator> <name>do_burble</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>vlen</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>vdim</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>nvals</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr> ;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>do_burble</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>S_iso</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(iso build) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(build) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// STEP 4: construct the vector pointers and hyperlist for T</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// Step 4 scans the J_work indices and constructs T-&gt;h and T-&gt;p.</comment>

    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Th</name> <init>= <expr><name><name>T</name><operator>-&gt;</operator><name>h</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Tp</name> <init>= <expr><name><name>T</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>vdim</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// special case for vectors</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>tnvec</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>tnvec</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>tnvec</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name><name>Th</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>Tp</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>ndupl</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// no duplicates appear</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><name>int</name></type> <name>tid</name></decl> ;</decl_stmt>
        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nthreads</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>static</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
        <for>for <control>(<init><expr><name>tid</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>tid</name> <operator>&lt;</operator> <name>nthreads</name></expr> ;</condition> <incr><expr><name>tid</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>my_tnvec</name> <init>= <expr><name><name>tnvec_slice</name> <index>[<expr><name>tid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>tstart</name>   <init>= <expr><name><name>tstart_slice</name> <index>[<expr><name>tid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>tend</name>     <init>= <expr><name><name>tstart_slice</name> <index>[<expr><name>tid</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>jlast</name>    <init>= <expr><call><name>GB_J_WORK</name> <argument_list>(<argument><expr><name>tstart</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>t</name> <init>= <expr><name>tstart</name></expr></init></decl> ;</init> <condition><expr><name>t</name> <operator>&lt;</operator> <name>tend</name></expr> ;</condition> <incr><expr><name>t</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <comment type="line">// get the t-th tuple</comment>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>j</name> <init>= <expr><call><name>GB_J_WORK</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>jlast</name></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// vector j starts in this slice</comment>
                    <expr_stmt><expr><name><name>Th</name> <index>[<expr><name>my_tnvec</name></expr>]</index></name> <operator>=</operator> <name>j</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>Tp</name> <index>[<expr><name>my_tnvec</name></expr>]</index></name> <operator>=</operator> <name>t</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>my_tnvec</name><operator>++</operator></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>jlast</name> <operator>=</operator> <name>j</name></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// it is known that at least one duplicate appears</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><name>int</name></type> <name>tid</name></decl> ;</decl_stmt>
        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nthreads</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>static</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
        <for>for <control>(<init><expr><name>tid</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>tid</name> <operator>&lt;</operator> <name>nthreads</name></expr> ;</condition> <incr><expr><name>tid</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>my_tnz</name>   <init>= <expr><name><name>tnz_slice</name> <index>[<expr><name>tid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>my_tnvec</name> <init>= <expr><name><name>tnvec_slice</name> <index>[<expr><name>tid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>tstart</name>   <init>= <expr><name><name>tstart_slice</name> <index>[<expr><name>tid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>tend</name>     <init>= <expr><name><name>tstart_slice</name> <index>[<expr><name>tid</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>jlast</name>    <init>= <expr><call><name>GB_J_WORK</name> <argument_list>(<argument><expr><name>tstart</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>t</name> <init>= <expr><name>tstart</name></expr></init></decl> ;</init> <condition><expr><name>t</name> <operator>&lt;</operator> <name>tend</name></expr> ;</condition> <incr><expr><name>t</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <comment type="line">// get the t-th tuple</comment>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>I_work</name> <index>[<expr><name>t</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>j</name> <init>= <expr><call><name>GB_J_WORK</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// this is a new tuple</comment>
                    <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>jlast</name></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// vector j starts in this slice </comment>
                        <expr_stmt><expr><name><name>Th</name> <index>[<expr><name>my_tnvec</name></expr>]</index></name> <operator>=</operator> <name>j</name></expr> ;</expr_stmt>
                        <expr_stmt><expr><name><name>Tp</name> <index>[<expr><name>my_tnvec</name></expr>]</index></name> <operator>=</operator> <name>my_tnz</name></expr> ;</expr_stmt>
                        <expr_stmt><expr><name>my_tnvec</name><operator>++</operator></expr> ;</expr_stmt>
                        <expr_stmt><expr><name>jlast</name> <operator>=</operator> <name>j</name></expr> ;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>my_tnz</name><operator>++</operator></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// log the end of the last vector</comment>
    <expr_stmt><expr><name><name>T</name><operator>-&gt;</operator><name>nvec_nonempty</name></name> <operator>=</operator> <name>tnvec</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>T</name><operator>-&gt;</operator><name>nvec</name></name> <operator>=</operator> <name>tnvec</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>Tp</name> <index>[<expr><name>tnvec</name></expr>]</index></name> <operator>=</operator> <name>tnz</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>T</name><operator>-&gt;</operator><name>nvals</name></name> <operator>=</operator> <name>tnz</name></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>T</name><operator>-&gt;</operator><name>nvec</name></name> <operator>==</operator> <name><name>T</name><operator>-&gt;</operator><name>plen</name></name> <operator>||</operator> <operator>(</operator><name><name>T</name><operator>-&gt;</operator><name>plen</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>T</name><operator>-&gt;</operator><name>nvec</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>T</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>GB_MAGIC</name></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free J_work if it exists</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>J_work_handle</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_FREE</name> <argument_list>(<argument><expr><name>J_work_handle</name></expr></argument>, <argument><expr><operator>*</operator><name>J_work_size_handle</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><name>J_work</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// allocate T-&gt;i</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>ndupl</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// shrink I_work from size ijslen to size tnz</comment>
        <if_stmt><if>if <condition>(<expr><name>tnz</name> <operator>&lt;</operator> <name>ijslen</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// this cannot fail since the size is shrinking.</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>ok</name></decl> ;</decl_stmt>
            <expr_stmt><expr><call><name>GB_REALLOC</name> <argument_list>(<argument><expr><name>I_work</name></expr></argument>, <argument><expr><name>tnz</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>I_work_size_handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ok</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>ok</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="line">// transplant I_work into T-&gt;i</comment>
        <expr_stmt><expr><name><name>T</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <name>I_work</name></expr> ;</expr_stmt> <expr_stmt><expr><name><name>T</name><operator>-&gt;</operator><name>i_size</name></name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>I_work_size_handle</name><operator>)</operator></expr> ;</expr_stmt>
        <expr_stmt><expr><name>I_work</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>I_work_handle</name><operator>)</operator> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>I_work_size_handle</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// duplicates exist, so allocate a new T-&gt;i.  I_work must be freed later</comment>
        <expr_stmt><expr><name><name>T</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <call><name>GB_MALLOC</name> <argument_list>(<argument><expr><name>tnz</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>T</name><operator>-&gt;</operator><name>i_size</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>T</name><operator>-&gt;</operator><name>i</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// out of memory</comment>
            <expr_stmt><expr><call><name>GB_phybix_free</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>GB_FREE_WORKSPACE</name></expr> ;</expr_stmt>
            <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ti</name> <init>= <expr><name><name>T</name><operator>-&gt;</operator><name>i</name></name></expr></init></decl> ;</decl_stmt>

    <comment type="line">//==========================================================================</comment>
    <comment type="line">// numerical phase of the build: assemble any duplicates</comment>
    <comment type="line">//==========================================================================</comment>

    <comment type="line">// The tuples have been sorted.  Assemble any duplicates with a switch</comment>
    <comment type="line">// factory of built-in workers, or four generic workers.  The vector</comment>
    <comment type="line">// pointers T-&gt;p and hyperlist T-&gt;h (if hypersparse) have already been</comment>
    <comment type="line">// computed.</comment>

    <comment type="line">// If there are no duplicates, T-&gt;i holds the row indices of the tuple.</comment>
    <comment type="line">// Otherwise, the row indices are still in I_work.  K_work holds the</comment>
    <comment type="line">// positions of each tuple in the array Sx.  The tuples are sorted so that</comment>
    <comment type="line">// duplicates are adjacent to each other and they appear in the order they</comment>
    <comment type="line">// appeared in the original tuples.  This method assembles the duplicates</comment>
    <comment type="line">// and computes T-&gt;i and T-&gt;x from I_work, K_work, and Sx.  into T, becoming</comment>
    <comment type="line">// T-&gt;i.  If no duplicates appear, T-&gt;i is already computed, and Sx just</comment>
    <comment type="line">// needs to be copied and permuted into T-&gt;x.</comment>

    <comment type="line">// The (i,k,Sx[k]) tuples are held in two integer arrays: (1) I_work or</comment>
    <comment type="line">// T-&gt;i, and (2) K_work, and an array Sx of numerical values.  Sx has not</comment>
    <comment type="line">// been sorted, nor even accessed yet.  It is identical to the original</comment>
    <comment type="line">// unsorted tuples.  The (i,k,Sx[k]) tuple holds the row index i, the</comment>
    <comment type="line">// position k, and the value Sx [k].  This entry becomes T(i,j) = Sx [k] in</comment>
    <comment type="line">// the matrix T, and duplicates (if any) are assembled via the dup</comment>
    <comment type="line">// operator.</comment>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get opcodes and check types</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// With GB_build, there can be 1 to 2 different types.</comment>
    <comment type="line">//      T-&gt;type is identical to the types of x,y,z for z=dup(x,y).</comment>
    <comment type="line">//      dup is never NULL and all its three types are the same</comment>
    <comment type="line">//      The type of Sx (stype) can different but must be compatible</comment>
    <comment type="line">//          with T-&gt;type</comment>

    <comment type="line">// With GB_wait, there can be 1 to 5 different types:</comment>
    <comment type="line">//      The pending tuples are in Sx, of type stype which must be</comment>
    <comment type="line">//          compatible with dup-&gt;ytype and T-&gt;type</comment>
    <comment type="line">//      z = dup (x,y): can be NULL or have 1 to 3 different types</comment>
    <comment type="line">//      T-&gt;type: must be compatible with all above types.</comment>
    <comment type="line">//      dup may be NULL, in which case it is assumed be the implicit SECOND</comment>
    <comment type="line">//          operator, with all three types equal to T-&gt;type</comment>

    <decl_stmt><decl><type><name>GrB_Type</name></type> <name>xtype</name></decl>, <decl><type ref="prev"/><name>ytype</name></decl>, <decl><type ref="prev"/><name>ztype</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GxB_binary_function</name></type> <name>fdup</name></decl> ;</decl_stmt>
    <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GBCUDA_DEV</name></cpp:ifndef>
    <decl_stmt><decl><type><name>GB_Opcode</name></type> <name>opcode</name></decl> ;</decl_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>tcode</name> <init>= <expr><name><name>ttype</name><operator>-&gt;</operator><name>code</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>tsize</name> <init>= <expr><name><name>ttype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>op_2nd</name></decl> ;</decl_stmt>

    <expr_stmt><expr><call><name>ASSERT_TYPE_OK</name> <argument_list>(<argument><expr><name>ttype</name></expr></argument>, <argument><expr><literal type="string">"ttype for build_factory"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>dup</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// dup is the implicit SECOND operator</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// z = SECOND (x,y) where all three types are the same as ttype</comment>
        <comment type="line">// T(i,j) = (ttype) Sx(k) will be done for all tuples.</comment>

        <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GBCUDA_DEV</name></cpp:ifndef>
        <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_SECOND_binop_code</name></expr> ;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>xtype</name> <operator>=</operator> <name>ttype</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>ytype</name> <operator>=</operator> <name>ttype</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>ztype</name> <operator>=</operator> <name>ttype</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>fdup</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>op_2nd</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_op_is_second</name> <argument_list>(<argument><expr><name>dup</name></expr></argument>, <argument><expr><name>ttype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// dup is an explicit operator</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// T(i,j) = (ttype) Sx[k] will be done for the first tuple.</comment>
        <comment type="line">// for subsequent tuples: T(i,j) += Sx[k], via the dup operator and</comment>
        <comment type="line">// typecasting:</comment>
        <comment type="line">//</comment>
        <comment type="line">//      y = (dup-&gt;ytype) Sx[k]</comment>
        <comment type="line">//      x = (dup-&gt;xtype) T(i,j)</comment>
        <comment type="line">//      z = (dup-&gt;ztype) dup (x,y)</comment>
        <comment type="line">//      T(i,j) = (ttype) z</comment>

        <expr_stmt><expr><call><name>ASSERT_BINARYOP_OK</name> <argument_list>(<argument><expr><name>dup</name></expr></argument>, <argument><expr><literal type="string">"dup for build_factory"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>S_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GBCUDA_DEV</name></cpp:ifndef>
        <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name><name>dup</name><operator>-&gt;</operator><name>opcode</name></name></expr> ;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>xtype</name> <operator>=</operator> <name><name>dup</name><operator>-&gt;</operator><name>xtype</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>ytype</name> <operator>=</operator> <name><name>dup</name><operator>-&gt;</operator><name>ytype</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>ztype</name> <operator>=</operator> <name><name>dup</name><operator>-&gt;</operator><name>ztype</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>fdup</name> <operator>=</operator> <name><name>dup</name><operator>-&gt;</operator><name>binop_function</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>op_2nd</name> <operator>=</operator> <call><name>GB_op_is_second</name> <argument_list>(<argument><expr><name>dup</name></expr></argument>, <argument><expr><name>ttype</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get the sizes and codes of each type</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>zcode</name> <init>= <expr><name><name>ztype</name><operator>-&gt;</operator><name>code</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>xcode</name> <init>= <expr><name><name>xtype</name><operator>-&gt;</operator><name>code</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>ycode</name> <init>= <expr><name><name>ytype</name><operator>-&gt;</operator><name>code</name></name></expr></init></decl> ;</decl_stmt>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name>ttype</name></expr></argument>, <argument><expr><name>stype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>    <comment type="line">// T(i,j) = (ttype) Sx</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name>ytype</name></expr></argument>, <argument><expr><name>stype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>    <comment type="line">// y = (ytype) Sx</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name>xtype</name></expr></argument>, <argument><expr><name>ttype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>    <comment type="line">// x = (xtype) T(i,j)</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name>ttype</name></expr></argument>, <argument><expr><name>ztype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>    <comment type="line">// T(i,j) = (ttype) z</comment>

    <decl_stmt><decl><type><name>size_t</name></type> <name>zsize</name> <init>= <expr><name><name>ztype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>xsize</name> <init>= <expr><name><name>xtype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>ysize</name> <init>= <expr><name><name>ytype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>

    <comment type="line">// no typecasting if all 5 types are the same</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>nocasting</name> <init>= <expr><operator>(</operator><name>ttype</name> <operator>==</operator> <name>stype</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>ttype</name> <operator>==</operator> <name>xtype</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>ttype</name> <operator>==</operator> <name>ytype</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>ttype</name> <operator>==</operator> <name>ztype</name><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <expr_stmt><expr><call><name>ASSERT_TYPE_OK</name> <argument_list>(<argument><expr><name>ttype</name></expr></argument>, <argument><expr><literal type="string">"ttype for build_factory"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_TYPE_OK</name> <argument_list>(<argument><expr><name>stype</name></expr></argument>, <argument><expr><literal type="string">"stype for build_factory"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_TYPE_OK</name> <argument_list>(<argument><expr><name>xtype</name></expr></argument>, <argument><expr><literal type="string">"xtype for build_factory"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_TYPE_OK</name> <argument_list>(<argument><expr><name>ytype</name></expr></argument>, <argument><expr><literal type="string">"ytype for build_factory"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_TYPE_OK</name> <argument_list>(<argument><expr><name>ztype</name></expr></argument>, <argument><expr><literal type="string">"ztype for build_factory"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// STEP 5: assemble the tuples</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>copy_S_into_T</name> <init>= <expr><operator>(</operator><name>nocasting</name> <operator>&amp;&amp;</operator> <name>known_sorted</name> <operator>&amp;&amp;</operator> <name>ndupl</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>copy_S_into_T</name> <operator>&amp;&amp;</operator> <name>S_work</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// transplant S_work into T-&gt;x</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// No typecasting is needed, the tuples were originally in sorted</comment>
        <comment type="line">// order, and no duplicates appear.  All that is required is to copy Sx</comment>
        <comment type="line">// into Tx.  Sx can be directly transplanted into T-&gt;x since Sx is</comment>
        <comment type="line">// provided as S_work.  GB_builder must either transplant or free</comment>
        <comment type="line">// S_work.  The transplant can be used by GB_wait, whenever the tuples</comment>
        <comment type="line">// are already sorted, with no duplicates, and no typecasting is</comment>
        <comment type="line">// needed, since S_work is always A-&gt;Pending-&gt;x.  T and Sx may be iso</comment>
        <comment type="line">// or non-iso.</comment>

        <expr_stmt><expr><name><name>T</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name>S_work</name></expr> ;</expr_stmt> <expr_stmt><expr><name><name>T</name><operator>-&gt;</operator><name>x_size</name></name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>S_work_size_handle</name><operator>)</operator></expr> ;</expr_stmt>
        <expr_stmt><expr><name>S_work</name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>S_work_handle</name><operator>)</operator> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>S_work_size_handle</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>

        <decl_stmt><decl><type><name>int64_t</name></type> <name>tx_size_required</name> <init>= <expr><name>tnz</name> <operator>*</operator> <name>tsize</name></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><literal type="number">2</literal> <operator>*</operator> <name>tx_size_required</name> <operator>&lt;</operator> <name><name>T</name><operator>-&gt;</operator><name>x_size</name></name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// shrink the size of T-&gt;x</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>ok</name> <init>= <expr><name>true</name></expr></init></decl> ;</decl_stmt>
            <expr_stmt><expr><call><name>GB_REALLOC</name> <argument_list>(<argument><expr><name><name>T</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>tx_size_required</name></expr></argument>, <argument><expr><name>GB_void</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>T</name><operator>-&gt;</operator><name>x_size</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>ok</name></expr></argument>,
                <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// allocate T-&gt;x</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><name><name>T</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <call><name>GB_XALLOC</name> <argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>S_iso</name></expr></argument>, <argument><expr><name>tnz</name></expr></argument>, <argument><expr><name>tsize</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>T</name><operator>-&gt;</operator><name>x_size</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <comment type="line">// x:OK</comment>
        <if_stmt><if>if <condition>(<expr><name><name>T</name><operator>-&gt;</operator><name>x</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// out of memory</comment>
            <expr_stmt><expr><call><name>GB_phybix_free</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>GB_FREE_WORKSPACE</name></expr> ;</expr_stmt>
            <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>GB_void</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Tx</name> <init>= <expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name><name>T</name><operator>-&gt;</operator><name>x</name></name></expr></init></decl> ;</decl_stmt>

        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><name>nvals</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>Sx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>nvals</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content> 

            <comment type="line">// nothing to do</comment>

        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>copy_S_into_T</name></expr>)</condition>
        <block>{<block_content> 

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// copy Sx into T-&gt;x</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <comment type="line">// No typecasting is needed, the tuples were originally in sorted</comment>
            <comment type="line">// order, and no duplicates appear.  All that is required is to</comment>
            <comment type="line">// copy Sx into Tx.  Sx cannot be transplanted into T-&gt;x since</comment>
            <comment type="line">// S_work is NULL and S_input cannot be modified by GB_builder.</comment>

            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>S_work</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Sx</name> <operator>==</operator> <name>S_input</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_memcpy</name> <argument_list>(<argument><expr><name>Tx</name></expr></argument>, <argument><expr><name>Sx</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>S_iso</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>nvals</name></expr></else></ternary><operator>)</operator> <operator>*</operator> <name>tsize</name></expr></argument>, <argument><expr><name>nthreads</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>nocasting</name></expr>)</condition>
        <block>{<block_content> 

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// assemble the values, Sx, into T, no typecasting needed</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <comment type="line">// Sx (either S_work or S_input) must be permuted and copied into</comment>
            <comment type="line">// T-&gt;x, since the tuples had to be sorted, or duplicates appear.</comment>
            <comment type="line">// Any duplicates are now assembled.</comment>

            <comment type="line">// There are 44 common cases of this function for built-in types</comment>
            <comment type="line">// and 8 associative operators: MIN, MAX, PLUS, TIMES for 10 types</comment>
            <comment type="line">// (all but boolean; and OR, AND, XOR, and EQ for boolean.</comment>

            <comment type="line">// In addition, the FIRST and SECOND operators are hard-coded, for</comment>
            <comment type="line">// another 22 workers, since SECOND is used by GB_wait and since</comment>
            <comment type="line">// FIRST is useful for keeping the first tuple seen.  It is</comment>
            <comment type="line">// controlled by the GB_INCLUDE_SECOND_OPERATOR definition, so they</comment>
            <comment type="line">// do not appear in GB_reduce_to_* where the FIRST and SECOND</comment>
            <comment type="line">// operators are not needed.</comment>

            <comment type="line">// Early exit cannot be exploited, so the terminal is ignored.</comment>

            <decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>S_iso</name></expr>)</condition>
            <block>{<block_content> 

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// T and Sx are iso; set iso value and delete duplicates</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>Tx</name></expr></argument>, <argument><expr><name>Sx</name></expr></argument>, <argument><expr><name>tsize</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_ISO_BUILD</name></cpp:macro></cpp:define>
                <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_reduce_build_template.c"</cpp:file></cpp:include>
                <expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>

            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// T and Sx are not iso; call in the workers</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GBCUDA_DEV</name></cpp:ifndef>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// define the worker for the switch factory</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_INCLUDE_SECOND_OPERATOR</name></cpp:macro></cpp:define>

                    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_red</name><parameter_list>(<parameter><type><name>opname</name></type></parameter>,<parameter><type><name>aname</name></type></parameter>)</parameter_list></cpp:macro> \
                        <cpp:value>GB (_red_build_ ## opname ## aname)</cpp:value></cpp:define>

                    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_RED_WORKER</name><parameter_list>(<parameter><type><name>opname</name></type></parameter>,<parameter><type><name>aname</name></type></parameter>,<parameter><type><name>atype</name></type></parameter>)</parameter_list></cpp:macro>               \
                    <cpp:value>{                                                       \
                        info = GB_red (opname, aname) ((atype *) Tx, Ti,    \
                            (atype *) Sx, nvals, ndupl, I_work, K_work,     \
                            tstart_slice, tnz_slice, nthreads) ;            \
                        done = (info != GrB_NO_VALUE) ;                     \
                    }                                                       \
                    break ;</cpp:value></cpp:define>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// launch the switch factory</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <comment type="line">// controlled by opcode and typecode</comment>
                    <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>typecode</name> <init>= <expr><name>tcode</name></expr></init></decl> ;</decl_stmt>
                    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_red_factory.c"</cpp:file></cpp:include>

                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></else></if_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// generic worker</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>do_burble</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(generic build) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// no typecasting, but use the fdup function pointer and memcpy</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <comment type="line">// Either the fdup operator or type of Sx and T are</comment>
                <comment type="line">// user-defined, or fdup is not an associative operator handled</comment>
                <comment type="line">// by the GB_red_factory, or some combination of these</comment>
                <comment type="line">// conditions.  User-defined types cannot be typecasted, so</comment>
                <comment type="line">// this handles all user-defined types.</comment>

                <comment type="line">// Tx [p] = (ttype) Sx [k], but with no typecasting</comment>
                <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_CAST_ARRAY_TO_ARRAY</name></cpp:undef>
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CAST_ARRAY_TO_ARRAY</name><parameter_list>(<parameter><type><name>Tx</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>Sx</name></type></parameter>,<parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro>               \
                    <cpp:value>memcpy (Tx +((p)*tsize), Sx +((k)*tsize), tsize) ;</cpp:value></cpp:define>

                <if_stmt><if>if <condition>(<expr><name>op_2nd</name></expr>)</condition>
                <block>{<block_content> 

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// dup is the SECOND operator, with no typecasting</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <comment type="line">// Tx [p] += (ttype) Sx [k], but 2nd op and no typecasting</comment>
                    <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_ADD_CAST_ARRAY_TO_ARRAY</name></cpp:undef>
                    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_ADD_CAST_ARRAY_TO_ARRAY</name><parameter_list>(<parameter><type><name>Tx</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>Sx</name></type></parameter>,<parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro>       \
                        <cpp:value>GB_CAST_ARRAY_TO_ARRAY(Tx,p,Sx,k)</cpp:value></cpp:define>
                    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_reduce_build_template.c"</cpp:file></cpp:include>

                </block_content>}</block></if>
                <else>else
                <block>{<block_content> 

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// dup is another operator, with no typecasting needed</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <comment type="line">// Tx [p] += (ttype) Sx [k], but with no typecasting</comment>
                    <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_ADD_CAST_ARRAY_TO_ARRAY</name></cpp:undef>
                    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_ADD_CAST_ARRAY_TO_ARRAY</name><parameter_list>(<parameter><type><name>Tx</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>Sx</name></type></parameter>,<parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro>       \
                        <cpp:value>fdup (Tx +((p)*tsize), Tx +((p)*tsize), Sx+((k)*tsize));</cpp:value></cpp:define>
                    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_reduce_build_template.c"</cpp:file></cpp:include>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

        </block_content>}</block></if>
        <else>else
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// assemble the values Sx into T, typecasting as needed</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <if_stmt><if>if <condition>(<expr><name>do_burble</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(generic build with typecast) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// If T and Sx are iso, no typecasting is ever done, so this method</comment>
            <comment type="line">// is not used in that case.</comment>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>S_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <comment type="line">// Sx (either S_work or S_input) must be permuted and copied into</comment>
            <comment type="line">// T-&gt;x, since the tuples had to be sorted, or duplicates appear.</comment>
            <comment type="line">// Any duplicates are now assembled.  Not all of the 5 types are</comment>
            <comment type="line">// the same, but all of them are built-in since user-defined types</comment>
            <comment type="line">// cannot be typecasted.</comment>

            <decl_stmt><decl><type><specifier>const</specifier> <name>GB_Type_code</name></type> <name>scode</name> <init>= <expr><name><name>stype</name><operator>-&gt;</operator><name>code</name></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>ssize</name> <init>= <expr><name><name>stype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>GB_cast_function</name></type> <name>cast_S_to_T</name> <init>= <expr><call><name>GB_cast_factory</name> <argument_list>(<argument><expr><name>tcode</name></expr></argument>, <argument><expr><name>scode</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>GB_cast_function</name></type> <name>cast_S_to_Y</name> <init>= <expr><call><name>GB_cast_factory</name> <argument_list>(<argument><expr><name>ycode</name></expr></argument>, <argument><expr><name>scode</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>GB_cast_function</name></type> <name>cast_T_to_X</name> <init>= <expr><call><name>GB_cast_factory</name> <argument_list>(<argument><expr><name>xcode</name></expr></argument>, <argument><expr><name>tcode</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>GB_cast_function</name></type> <name>cast_Z_to_T</name> <init>= <expr><call><name>GB_cast_factory</name> <argument_list>(<argument><expr><name>tcode</name></expr></argument>, <argument><expr><name>zcode</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>scode</name> <operator>&lt;=</operator> <name>GB_FC64_code</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>tcode</name> <operator>&lt;=</operator> <name>GB_FC64_code</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>xcode</name> <operator>&lt;=</operator> <name>GB_FC64_code</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>ycode</name> <operator>&lt;=</operator> <name>GB_FC64_code</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>zcode</name> <operator>&lt;=</operator> <name>GB_FC64_code</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

            <comment type="line">// Tx [p] = (ttype) Sx [k], with typecasting</comment>
            <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_CAST_ARRAY_TO_ARRAY</name></cpp:undef>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CAST_ARRAY_TO_ARRAY</name><parameter_list>(<parameter><type><name>Tx</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>Sx</name></type></parameter>,<parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro>                   \
                <cpp:value>cast_S_to_T (Tx +((p)*tsize), Sx +((k)*ssize), ssize) ;</cpp:value></cpp:define>

            <if_stmt><if>if <condition>(<expr><name>op_2nd</name></expr>)</condition>
            <block>{<block_content> 

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// dup operator is the SECOND operator, with typecasting</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <comment type="line">// Tx [p] += (ttype) Sx [k], but 2nd op, with typecasting</comment>
                <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_ADD_CAST_ARRAY_TO_ARRAY</name></cpp:undef>
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_ADD_CAST_ARRAY_TO_ARRAY</name><parameter_list>(<parameter><type><name>Tx</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>Sx</name></type></parameter>,<parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro>           \
                    <cpp:value>GB_CAST_ARRAY_TO_ARRAY(Tx,p,Sx,k)</cpp:value></cpp:define>
                <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_reduce_build_template.c"</cpp:file></cpp:include>

            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// dup is another operator, with typecasting required</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <comment type="line">// Tx [p] += Sx [k], with typecasting</comment>
                <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_ADD_CAST_ARRAY_TO_ARRAY</name></cpp:undef>
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_ADD_CAST_ARRAY_TO_ARRAY</name><parameter_list>(<parameter><type><name>Tx</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>Sx</name></type></parameter>,<parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro>               \
                <cpp:value>{                                                           \
                    <comment type="block">/* ywork = (ytype) Sx [k] */</comment>                            \
                    GB_void ywork [GB_VLA(ysize)] ;                         \
                    cast_S_to_Y (ywork, Sx +((k)*ssize), ssize) ;           \
                    <comment type="block">/* xwork = (xtype) Tx [p] */</comment>                            \
                    GB_void xwork [GB_VLA(xsize)] ;                         \
                    cast_T_to_X (xwork, Tx +((p)*tsize), tsize) ;           \
                    <comment type="block">/* zwork = f (xwork, ywork) */</comment>                          \
                    GB_void zwork [GB_VLA(zsize)] ;                         \
                    fdup (zwork, xwork, ywork) ;                            \
                    <comment type="block">/* Tx [tnz-1] = (ttype) zwork */</comment>                        \
                    cast_Z_to_T (Tx +((p)*tsize), zwork, zsize) ;           \
                }</cpp:value></cpp:define>

                <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_reduce_build_template.c"</cpp:file></cpp:include>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free workspace and return result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><name>GB_FREE_WORKSPACE</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>T</name><operator>-&gt;</operator><name>jumbled</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><literal type="string">"T built"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
