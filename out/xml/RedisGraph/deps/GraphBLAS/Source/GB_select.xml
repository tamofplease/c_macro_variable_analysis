<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_select.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_select: apply a select operator</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// C&lt;M&gt; = accum (C, select(A,Thunk)) or select(A,Thunk)')</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_ALL</name></cpp:macro>         \
<cpp:value>{                           \
    GB_Matrix_free (&amp;T) ;   \
}</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_select.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_accum_mask.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_transpose.h"</cpp:file></cpp:include>

<function><type><name>GrB_Info</name></type> <name>GB_select</name>          <comment type="line">// C&lt;M&gt; = accum (C, select(A,k)) or select(A',k)</comment>
<parameter_list>(
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,                   <comment type="line">// input/output matrix for results</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>C_replace</name></decl></parameter>,           <comment type="line">// C descriptor</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>M</name></decl></parameter>,             <comment type="line">// optional mask for C, unused if NULL</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_comp</name></decl></parameter>,           <comment type="line">// descriptor for M</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_struct</name></decl></parameter>,         <comment type="line">// if true, use the only structure of M</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_BinaryOp</name></type> <name>accum</name></decl></parameter>,       <comment type="line">// optional accum for Z=accum(C,T)</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GB_Operator</name></type> <name>op</name></decl></parameter>,           <comment type="line">// GxB_SelectOp or GrB_IndexUnaryOp</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,             <comment type="line">// input matrix</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Scalar</name></type> <name>Thunk</name></decl></parameter>,         <comment type="line">// optional input for select operator</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>A_transpose</name></decl></parameter>,         <comment type="line">// A matrix descriptor</comment>
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// C may be aliased with M and/or A</comment>

    <expr_stmt><expr><call><name>GB_RETURN_IF_FAULTY_OR_POSITIONAL</name> <argument_list>(<argument><expr><name>accum</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_RETURN_IF_FAULTY</name> <argument_list>(<argument><expr><name>Thunk</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_RETURN_IF_NULL_OR_FAULTY</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C input for GB_select"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK_OR_NULL</name> <argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><literal type="string">"M for GB_select"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_BINARYOP_OK_OR_NULL</name> <argument_list>(<argument><expr><name>accum</name></expr></argument>, <argument><expr><literal type="string">"accum for GB_select"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_OP_OK</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"selectop/indexunaryop for GB_select"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"A input for GB_select"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_SCALAR_OK_OR_NULL</name> <argument_list>(<argument><expr><name>Thunk</name></expr></argument>, <argument><expr><literal type="string">"Thunk for GB_select"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>GB_Matrix_opaque</name></name></type> <name>T_header</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>T</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>

    <comment type="line">// check domains and dimensions for C&lt;M&gt; = accum (C,T)</comment>
    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_compatible</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>C</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>acode</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>xcode</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>xtype</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>GB_ignore_code</name></expr> </then><else>: <expr><name><name>op</name><operator>-&gt;</operator><name>xtype</name><operator>-&gt;</operator><name>code</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>tcode</name> <init>= <expr><name>GB_ignore_code</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_Opcode</name></type> <name>opcode</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>opcode</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>op_is_selectop</name> <init>= <expr><call><name>GB_IS_SELECTOP_CODE</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>op_is_idxunop</name>  <init>= <expr><call><name>GB_IS_INDEXUNARYOP_CODE</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>op_is_selectop</name> <operator>||</operator> <name>op_is_idxunop</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>opcode</name> <operator>!=</operator> <name>GB_FLIPDIAGINDEX_idxunop_code</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>op_is_idxunop</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// Thunk is optional for GxB_Selectop, required for GrB_IndexUnaryOp</comment>
        <expr_stmt><expr><call><name>GB_RETURN_IF_NULL</name> <argument_list>(<argument><expr><name>Thunk</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// this opcodes are not available to the user</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>opcode</name> <operator>!=</operator> <name>GB_NONZOMBIE_selop_code</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// check if the op is a GT, GE, LT, or LE comparator</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>op_is_ordered_comparator</name> <init>=
        <expr><name>opcode</name> <operator>==</operator> <name>GB_GT_ZERO_selop_code</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>GB_GT_THUNK_selop_code</name> <operator>||</operator>
        <name>opcode</name> <operator>==</operator> <name>GB_GE_ZERO_selop_code</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>GB_GE_THUNK_selop_code</name> <operator>||</operator>
        <name>opcode</name> <operator>==</operator> <name>GB_LT_ZERO_selop_code</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>GB_LT_THUNK_selop_code</name> <operator>||</operator>
        <name>opcode</name> <operator>==</operator> <name>GB_LE_ZERO_selop_code</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>GB_LE_THUNK_selop_code</name> <operator>||</operator>
        <name>opcode</name> <operator>==</operator> <name>GB_VALUEGT_idxunop_code</name> <operator>||</operator>
        <name>opcode</name> <operator>==</operator> <name>GB_VALUEGE_idxunop_code</name> <operator>||</operator>
        <name>opcode</name> <operator>==</operator> <name>GB_VALUELT_idxunop_code</name> <operator>||</operator>
        <name>opcode</name> <operator>==</operator> <name>GB_VALUELE_idxunop_code</name></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>op_is_ordered_comparator</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// built-in GT, GE, LT, and LE operators cannot be used with</comment>
        <comment type="line">// user-defined or complex types.</comment>
        <if_stmt><if>if <condition>(<expr><name>acode</name> <operator>==</operator> <name>GB_UDT_code</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DOMAIN_MISMATCH</name></expr></argument>,
                <argument><expr><literal type="string">"Operator %s not defined for user-defined types"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>acode</name> <operator>==</operator> <name>GB_FC32_code</name> <operator>||</operator> <name>acode</name> <operator>==</operator> <name>GB_FC64_code</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DOMAIN_MISMATCH</name></expr></argument>,
                <argument><expr><literal type="string">"Operator %s not defined for complex types"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// C = op (A) must be compatible, already checked in GB_compatible</comment>

    <comment type="line">// A must also be compatible with op-&gt;xtype</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>xtype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DOMAIN_MISMATCH</name></expr></argument>,
            <argument><expr><literal type="string">"Incompatible type for C=%s(A,Thunk):\n"</literal>
            <literal type="string">"input A type [%s]\n"</literal>
            <literal type="string">"cannot be typecast to operator input of type [%s]"</literal></expr></argument>,
            <argument><expr><name><name>op</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>xtype</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// check the dimensions</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>tnrows</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>A_transpose</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>tncols</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>A_transpose</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>tnrows</name> <operator>||</operator> <call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>tncols</name></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DIMENSION_MISMATCH</name></expr></argument>,
            <argument><expr><literal type="string">"Dimensions not compatible:\n"</literal>
            <literal type="string">"output is "</literal> <name>GBd</name> <literal type="string">"-by-"</literal> <name>GBd</name> <literal type="string">"\n"</literal>
            <literal type="string">"input is "</literal> <name>GBd</name> <literal type="string">"-by-"</literal> <name>GBd</name> <literal type="string">"%s"</literal></expr></argument>,
            <argument><expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>tnrows</name></expr></argument>, <argument><expr><name>tncols</name></expr></argument>, <argument><expr><ternary><condition><expr><name>A_transpose</name></expr> ?</condition><then> <expr><literal type="string">" (transposed)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// check if op is (NE, EQ, GT, GE, LT, LE)_THUNK or VALUE*</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>op_is_thunk_comparator</name> <init>=
        <expr><operator>(</operator><name>opcode</name> <operator>&gt;=</operator> <name>GB_VALUENE_idxunop_code</name> <operator>&amp;&amp;</operator> <name>opcode</name> <operator>&lt;=</operator> <name>GB_VALUELE_idxunop_code</name><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name>opcode</name> <operator>&gt;=</operator> <name>GB_NE_THUNK_selop_code</name> <operator>&amp;&amp;</operator> <name>opcode</name> <operator>&lt;=</operator> <name>GB_LE_THUNK_selop_code</name><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <comment type="line">// check if op is TRIL, TRIU, DIAG, OFFDIAG, ROW/COL/DIAGINDEX</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>op_is_positional</name> <init>= <expr><call><name>GB_OPCODE_IS_POSITIONAL</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <comment type="line">// check if op is user-defined</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>op_is_user_defined</name> <init>=
        <expr><operator>(</operator><name>opcode</name> <operator>==</operator> <name>GB_USER_selop_code</name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>opcode</name> <operator>==</operator> <name>GB_USER_idxunop_code</name><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>nz_thunk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Type</name></type> <name>ttype</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>Thunk</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// finish any pending work on the Thunk</comment>
        <expr_stmt><expr><name>ttype</name> <operator>=</operator> <name><name>Thunk</name><operator>-&gt;</operator><name>type</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_MATRIX_WAIT</name> <argument_list>(<argument><expr><name>Thunk</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>nz_thunk</name> <operator>=</operator> <call><name>GB_nnz</name> <argument_list>(<argument><expr><operator>(</operator><name>GrB_Matrix</name><operator>)</operator> <name>Thunk</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>nz_thunk</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>nz_thunk</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>tcode</name> <operator>=</operator> <name><name>ttype</name><operator>-&gt;</operator><name>code</name></name></expr> ;</expr_stmt>

        <comment type="line">// if op is positional, Thunk must be compatible with GrB_INT64 (both</comment>
        <comment type="line">// GxB_SelectOp and GrB_IndexUnaryOp)</comment>
        <if_stmt><if>if <condition>(<expr><name>op_is_positional</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name>GrB_INT64</name></expr></argument>, <argument><expr><name>ttype</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// Thunk not a built-in type, for a built-in select operator</comment>
            <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DOMAIN_MISMATCH</name></expr></argument>,
                <argument><expr><literal type="string">"Incompatible type for C=%s(A,Thunk):\n"</literal>
                <literal type="string">"input Thunk type [%s]\n"</literal>
                <literal type="string">"not compatible with GrB_INT64 input to built-in operator %s"</literal></expr></argument>,
                <argument><expr><name><name>op</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>ttype</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// if op is (NE, EQ, GT, GE, LT, LE)_THUNK, then Thunk must be</comment>
        <comment type="line">// compatible with the matrix type</comment>
        <if_stmt><if>if <condition>(<expr><name>op_is_thunk_comparator</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>op_is_selectop</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>ttype</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DOMAIN_MISMATCH</name></expr></argument>,
                    <argument><expr><literal type="string">"Incompatible type for C=%s(A,Thunk):\n"</literal>
                    <literal type="string">"input A type [%s] and Thunk type [%s] not compatible"</literal></expr></argument>,
                    <argument><expr><name><name>op</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>ttype</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>op_is_idxunop</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// check the GrB_IndexUnaryOp</comment>
        <if_stmt><if>if <condition>(<expr><name>nz_thunk</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// Thunk cannot be empty for GrB_select</comment>
            <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_EMPTY_OBJECT</name></expr></argument>, <argument><expr><literal type="string">"Thunk for C=%s(A,Thunk)"</literal>
                <literal type="string">" cannot be an empty scalar\n"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name>GrB_BOOL</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>ztype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// GrB_IndexUnaryOp ztype must be compatible with GrB_BOOL</comment>
            <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DOMAIN_MISMATCH</name></expr></argument>,
                <argument><expr><literal type="string">"Output of user-defined IndexUnaryOp %s is %s\n"</literal>
                <literal type="string">"which cannot be typecasted to bool\n"</literal></expr></argument>,
                <argument><expr><name><name>op</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>ztype</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name>ttype</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>ytype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// Thunk must be typecasted to the op-&gt;ytype</comment>
            <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DOMAIN_MISMATCH</name></expr></argument>,
                <argument><expr><literal type="string">"Incompatible type for C=%s(A,Thunk):\n"</literal>
                <literal type="string">"input Thunk type [%s] and op thunk type [%s]"</literal>
                <literal type="string">" not compatible"</literal></expr></argument>,
                <argument><expr><name><name>op</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>ttype</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>ytype</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>op_is_user_defined</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// for a user-defined selectop, Thunk must match the op-&gt;ytype exactly</comment>
        <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>ytype</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>Thunk</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// select operator does not take a Thunk, but one is present</comment>
            <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DOMAIN_MISMATCH</name></expr></argument>,
                <argument><expr><literal type="string">"User-defined operator %s(A,Thunk) does not take a Thunk\n"</literal>
                <literal type="string">"input, but Thunk parameter is non-NULL"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>ytype</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>Thunk</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// select operator takes a Thunk, but Thunk parameter is missing</comment>
            <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_NULL_POINTER</name></expr></argument>,
                <argument><expr><literal type="string">"Required argument is null: [%s]"</literal></expr></argument>, <argument><expr><literal type="string">"Thunk"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>ytype</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>Thunk</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// select operator takes a Thunk, and it is present on input.</comment>
            <comment type="line">// The types must match exactly.</comment>
            <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>ytype</name></name> <operator>!=</operator> <name>ttype</name></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DOMAIN_MISMATCH</name></expr></argument>,
                    <argument><expr><literal type="string">"User-defined operator %s(A,Thunk) has a Thunk input\n"</literal>
                    <literal type="string">"type of [%s], which must exactly match the type of the\n"</literal>
                    <literal type="string">"Thunk parameter; parameter has type [%s]"</literal></expr></argument>,
                    <argument><expr><name><name>op</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>ytype</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>ttype</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>nz_thunk</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_EMPTY_OBJECT</name></expr></argument>,
                    <argument><expr><literal type="string">"User-defined operator %s(A,Thunk) has a Thunk input,\n"</literal>
                    <literal type="string">"which must not be empty"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// quick return if an empty mask is complemented</comment>
    <expr_stmt><expr><call><name>GB_RETURN_IF_QUICK_MASK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>C_replace</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// delete any lingering zombies and assemble any pending tuples</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_MATRIX_WAIT</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>        <comment type="line">// TODO: delay until accum/mask phase</comment>
    <expr_stmt><expr><call><name>GB_MATRIX_WAIT</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>        <comment type="line">// TODO: could tolerate jumbled in some cases</comment>

    <expr_stmt><expr><call><name>GB_BURBLE_DENSE</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"(C %s) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BURBLE_DENSE</name> <argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><literal type="string">"(M %s) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_BURBLE_DENSE</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"(A %s) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// handle the CSR/CSC format and the transposed case</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// A and C can be in CSR or CSC format (in any combination), and A can be</comment>
    <comment type="line">// transposed first via A_transpose.  However, A is not explicitly</comment>
    <comment type="line">// transposed first.  Instead, the selection operation is modified by</comment>
    <comment type="line">// changing the operator, and the resulting matrix T is transposed, if</comment>
    <comment type="line">// needed.</comment>

    <comment type="line">// Instead of explicitly transposing the input matrix A and output T:</comment>
    <comment type="line">// If A in CSC format and not transposed: treat as if A and T were CSC</comment>
    <comment type="line">// If A in CSC format and transposed:     treat as if A and T were CSR</comment>
    <comment type="line">// If A in CSR format and not transposed: treat as if A and T were CSR</comment>
    <comment type="line">// If A in CSR format and transposed:     treat as if A and T were CSC</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>A_csc</name> <init>= <expr><operator>(</operator><name><name>A</name><operator>-&gt;</operator><name>is_csc</name></name> <operator>==</operator> <operator>!</operator><name>A_transpose</name><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <comment type="line">// The final transpose, if needed, is accomplished in GB_accum_mask, by</comment>
    <comment type="line">// tagging T as the same CSR/CSC format as A_csc.  If the format of T and C</comment>
    <comment type="line">// do not match, GB_accum_mask transposes T, computing C&lt;M&gt;=accum(C,T').</comment>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// change the opcode if needed</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>flipij</name> <init>= <expr><operator>!</operator><name>A_csc</name></expr></init></decl> ;</decl_stmt>

    <expr_stmt><expr><call><name>ASSERT_SCALAR_OK_OR_NULL</name> <argument_list>(<argument><expr><name>Thunk</name></expr></argument>, <argument><expr><literal type="string">"Thunk now GB_select"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// if A is boolean, get the value of Thunk typecasted to boolean</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>bthunk</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>

    <comment type="line">// if Thunk is not present, or has no entries, then k defaults to zero</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>ithunk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>        <comment type="line">// ithunk = (int64_t) Thunk (0)</comment>

    <if_stmt><if>if <condition>(<expr><name>nz_thunk</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name>GrB_INT64</name></expr></argument>, <argument><expr><name>ttype</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// ithunk = (int64_t) Thunk</comment>
        <expr_stmt><expr><call><name>GB_cast_scalar</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>ithunk</name></expr></argument>, <argument><expr><name>GB_INT64_code</name></expr></argument>, <argument><expr><name><name>Thunk</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>tcode</name></expr></argument>,
            <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <comment type="line">// bthunk = (bool) Thunk</comment>
        <expr_stmt><expr><name>bthunk</name> <operator>=</operator> <operator>(</operator><name>ithunk</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>thunk_is_zero</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>nz_thunk</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><name>thunk_is_zero</name> <operator>=</operator> <operator>!</operator><call><name>GB_is_nonzero</name> <argument_list>(<argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name><name>Thunk</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>ttype</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>make_copy</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_empty</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>op_is_positional</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// replace idxunop with their corresponding selectop positional ops</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <switch>switch <condition>(<expr><name>opcode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_TRIL_idxunop_code</name></expr> :</case> 
                <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_TRIL_selop_code</name></expr> ;</expr_stmt>
                <break>break ;</break>
            <case>case <expr><name>GB_TRIU_idxunop_code</name></expr> :</case> 
                <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_TRIU_selop_code</name></expr> ;</expr_stmt>
                <break>break ;</break>
            <case>case <expr><name>GB_DIAG_idxunop_code</name></expr> :</case> 
                <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_DIAG_selop_code</name></expr> ;</expr_stmt>
                <break>break ;</break>
            <case>case <expr><name>GB_DIAGINDEX_idxunop_code</name></expr> :</case> 
            <case>case <expr><name>GB_OFFDIAG_idxunop_code</name></expr> :</case> 
                <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_OFFDIAG_selop_code</name></expr> ;</expr_stmt>
                <break>break ;</break>
            <default>default:</default><empty_stmt>;</empty_stmt>
        </block_content>}</block></switch>

        <comment type="line">// The only remaining positional GrB_IndexUnaryOps are:</comment>
        <comment type="line">// ROWINDEX, COLINDEX, COLLE, COLGT, ROWLE, and ROWGT.</comment>

        <comment type="line">// These GrB_IndexUnaryOps are distinct from any GxB_SelectOps, but act</comment>
        <comment type="line">// just like all positional GxB_SelectOps (TRIL, TRIU, etc), so the</comment>
        <comment type="line">// same code base can handle both kinds of positional ops.  No</comment>
        <comment type="line">// typecasting needs to be performed.</comment>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// tril, triu, diag, offdiag, ...: get k and handle the flip</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// The built-in operators are modified so they can always work as if A</comment>
        <comment type="line">// were in CSC format.  If A is not in CSC, then the operation is</comment>
        <comment type="line">// flipped.</comment>

        <if_stmt><if>if <condition>(<expr><name>flipij</name></expr>)</condition>
        <block>{<block_content> 
            <switch>switch <condition>(<expr><name>opcode</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// TRIL becomes TRIU with thunk negated</comment>
                <case>case <expr><name>GB_TRIL_selop_code</name></expr> :</case> 
                    <expr_stmt><expr><name>ithunk</name> <operator>=</operator> <operator>-</operator><name>ithunk</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_TRIU_selop_code</name></expr> ;</expr_stmt>
                    <break>break ;</break>

                <comment type="line">// TRIU becomes TRIL with thunk negated</comment>
                <case>case <expr><name>GB_TRIU_selop_code</name></expr> :</case> 
                    <expr_stmt><expr><name>ithunk</name> <operator>=</operator> <operator>-</operator><name>ithunk</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_TRIL_selop_code</name></expr> ;</expr_stmt>
                    <break>break ;</break>

                <comment type="line">// DIAG and OFFDIAG: same opcode, but negate the thunk</comment>
                <case>case <expr><name>GB_DIAG_selop_code</name></expr> :</case> 
                <case>case <expr><name>GB_OFFDIAG_selop_code</name></expr> :</case> 
                    <expr_stmt><expr><name>ithunk</name> <operator>=</operator> <operator>-</operator><name>ithunk</name></expr> ;</expr_stmt>
                    <break>break ;</break>

                <comment type="line">// ROWINDEX becomes COLINDEX</comment>
                <case>case <expr><name>GB_ROWINDEX_idxunop_code</name></expr>  :</case> 
                    <comment type="line">// i+thunk becomes j+thunk: no change to thunk</comment>
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_COLINDEX_idxunop_code</name></expr> ;</expr_stmt>
                    <break>break ;</break>

                <comment type="line">// COLINDEX becomes ROWINDEX</comment>
                <case>case <expr><name>GB_COLINDEX_idxunop_code</name></expr>  :</case> 
                    <comment type="line">// j+thunk becomes i+thunk: no change to thunk</comment>
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_ROWINDEX_idxunop_code</name></expr> ;</expr_stmt>
                    <break>break ;</break>

                <comment type="line">// COLLE becomes ROWLE</comment>
                <case>case <expr><name>GB_COLLE_idxunop_code</name></expr> :</case> 
                    <comment type="line">// j &lt;= thunk becomes i &lt;= thunk: no change to thunk</comment>
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_ROWLE_idxunop_code</name></expr> ;</expr_stmt>
                    <break>break ;</break>

                <comment type="line">// COLGT becomes ROWGT</comment>
                <case>case <expr><name>GB_COLGT_idxunop_code</name></expr> :</case> 
                    <comment type="line">// j &gt; thunk becomes i &gt; thunk: no change to thunk</comment>
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_ROWGT_idxunop_code</name></expr> ;</expr_stmt>
                    <break>break ;</break>

                <comment type="line">// ROWLE becomes COLLE</comment>
                <case>case <expr><name>GB_ROWLE_idxunop_code</name></expr> :</case> 
                    <comment type="line">// i &lt;= thunk becomes j &lt;= thunk: no change to thunk</comment>
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_COLLE_idxunop_code</name></expr> ;</expr_stmt>
                    <break>break ;</break>

                <comment type="line">// ROWGT becomes COLGT</comment>
                <case>case <expr><name>GB_ROWGT_idxunop_code</name></expr> :</case> 
                    <comment type="line">// i &gt; thunk becomes j &gt; thunk: no change to thunk</comment>
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_COLGT_idxunop_code</name></expr> ;</expr_stmt>
                    <break>break ;</break>

                <default>default:</default><empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>

            <expr_stmt><expr><name>flipij</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// flipij is now false for any positional operator</comment>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// replace GrB_IndexUnaryOp with GxB_SelectOp if no typecasting</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <if_stmt><if>if <condition>(<expr><name>op_is_idxunop</name> <operator>&amp;&amp;</operator> <name><name>A</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name><name>op</name><operator>-&gt;</operator><name>xtype</name></name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// If there is no typecasting of the A matrix, the VALUE* operators</comment>
            <comment type="line">// are identical to their selectop counterparts.  The GxB_SelectOps</comment>
            <comment type="line">// never typecast the input matrix A, but do their tests on the</comment>
            <comment type="line">// original type of A, after typecasting the thunk scalar to the</comment>
            <comment type="line">// type of A if needed.  If A-&gt;type and op-&gt;xtype are the same for</comment>
            <comment type="line">// a GrB_IndexUnaryOp, then no typecasting occurs at all, neither</comment>
            <comment type="line">// for A nor the thunk scalar.  After this conversion, the VALUE*</comment>
            <comment type="line">// operators are only applied in the generic select method.</comment>
            <switch>switch <condition>(<expr><name>opcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_VALUENE_idxunop_code</name></expr> :</case> 
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_NE_THUNK_selop_code</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                <case>case <expr><name>GB_VALUEEQ_idxunop_code</name></expr> :</case> 
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_EQ_THUNK_selop_code</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                <case>case <expr><name>GB_VALUEGT_idxunop_code</name></expr> :</case> 
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_GT_THUNK_selop_code</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                <case>case <expr><name>GB_VALUEGE_idxunop_code</name></expr> :</case> 
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_GE_THUNK_selop_code</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                <case>case <expr><name>GB_VALUELT_idxunop_code</name></expr> :</case> 
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_LT_THUNK_selop_code</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                <case>case <expr><name>GB_VALUELE_idxunop_code</name></expr> :</case> 
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_LE_THUNK_selop_code</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                <default>default:</default><empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// rename THUNK comparators if thunk is zero</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <if_stmt><if>if <condition>(<expr><name>thunk_is_zero</name></expr>)</condition>
        <block>{<block_content> 
            <switch>switch <condition>(<expr><name>opcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_NE_THUNK_selop_code</name></expr> :</case> 
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_NONZERO_selop_code</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                <case>case <expr><name>GB_EQ_THUNK_selop_code</name></expr> :</case> 
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_EQ_ZERO_selop_code</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                <case>case <expr><name>GB_GT_THUNK_selop_code</name></expr> :</case> 
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_GT_ZERO_selop_code</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                <case>case <expr><name>GB_GE_THUNK_selop_code</name></expr> :</case> 
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_GE_ZERO_selop_code</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                <case>case <expr><name>GB_LT_THUNK_selop_code</name></expr> :</case> 
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_LT_ZERO_selop_code</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                <case>case <expr><name>GB_LE_THUNK_selop_code</name></expr> :</case> 
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_LE_ZERO_selop_code</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                <default>default:</default><empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// (NE, EQ, GT, GE, LT, LE) x (0, thunk): handle bool and uint cases</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <switch>switch <condition>(<expr><name>opcode</name></expr>)</condition>
        <block>{<block_content>

            <case>case <expr><name>GB_GT_ZERO_selop_code</name></expr>   :</case>  <comment type="line">// A(i,j) &gt; 0</comment>

                <comment type="line">// bool and uint: rename GxB_GT_ZERO to GxB_NONZERO</comment>
                <switch>switch <condition>(<expr><name>acode</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_BOOL_code</name></expr>   :</case>   <comment type="line">// C is iso, if boolean</comment>
                    <case>case <expr><name>GB_UINT8_code</name></expr>  :</case>   <comment type="line">// C is not iso if uint*</comment>
                    <case>case <expr><name>GB_UINT16_code</name></expr> :</case> 
                    <case>case <expr><name>GB_UINT32_code</name></expr> :</case> 
                    <case>case <expr><name>GB_UINT64_code</name></expr> :</case> 
                        <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_NONZERO_selop_code</name></expr> ;</expr_stmt> <break>break ;</break>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_GE_ZERO_selop_code</name></expr>   :</case>  <comment type="line">// A(i,j) &gt;= 0</comment>

                <comment type="line">// bool and uint: always true; use GB_dup_worker</comment>
                <switch>switch <condition>(<expr><name>acode</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> 
                    <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> 
                    <case>case <expr><name>GB_UINT16_code</name></expr> :</case> 
                    <case>case <expr><name>GB_UINT32_code</name></expr> :</case> 
                    <case>case <expr><name>GB_UINT64_code</name></expr> :</case> 
                        <expr_stmt><expr><name>make_copy</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt> <break>break ;</break>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_LT_ZERO_selop_code</name></expr>   :</case>  <comment type="line">// A(i,j) &lt; 0</comment>

                <comment type="line">// bool and uint: always false; return an empty matrix</comment>
                <switch>switch <condition>(<expr><name>acode</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> 
                    <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> 
                    <case>case <expr><name>GB_UINT16_code</name></expr> :</case> 
                    <case>case <expr><name>GB_UINT32_code</name></expr> :</case> 
                    <case>case <expr><name>GB_UINT64_code</name></expr> :</case> 
                        <expr_stmt><expr><name>is_empty</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt> <break>break ;</break>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_LE_ZERO_selop_code</name></expr>   :</case>  <comment type="line">// A(i,j) &lt;= 0</comment>

                <comment type="line">// bool and uint: rename GxB_LE_ZERO to GxB_EQ_ZERO</comment>
                <switch>switch <condition>(<expr><name>acode</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> 
                    <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> 
                    <case>case <expr><name>GB_UINT16_code</name></expr> :</case> 
                    <case>case <expr><name>GB_UINT32_code</name></expr> :</case> 
                    <case>case <expr><name>GB_UINT64_code</name></expr> :</case> 
                        <comment type="line">// C is iso for boolean and uint* cases</comment>
                        <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_EQ_ZERO_selop_code</name></expr> ;</expr_stmt> <break>break ;</break>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_NE_THUNK_selop_code</name></expr>   :</case> <comment type="line">// A(i,j) != thunk</comment>

                <comment type="line">// bool: if thunk is true,  rename GxB_NE_THUNK to GxB_EQ_ZERO </comment>
                <comment type="line">//       if thunk is false, rename GxB_NE_THUNK to GxB_NONZERO </comment>
                <if_stmt><if>if <condition>(<expr><name>acode</name> <operator>==</operator> <name>GB_BOOL_code</name></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// C is iso boolean, in both cases</comment>
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>bthunk</name><operator>)</operator></expr> ?</condition><then>
                        <expr><name>GB_EQ_ZERO_selop_code</name></expr> </then><else>: <expr><name>GB_NONZERO_selop_code</name></expr></else></ternary></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break ;</break>

            <case>case <expr><name>GB_EQ_THUNK_selop_code</name></expr>   :</case> <comment type="line">// A(i,j) == thunk</comment>

                <comment type="line">// bool: if thunk is true,  rename GxB_NE_THUNK to GxB_NONZERO </comment>
                <comment type="line">//       if thunk is false, rename GxB_NE_THUNK to GxB_EQ_ZERO </comment>
                <if_stmt><if>if <condition>(<expr><name>acode</name> <operator>==</operator> <name>GB_BOOL_code</name></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// C is iso boolean, in both cases</comment>
                    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>bthunk</name><operator>)</operator></expr> ?</condition><then>
                        <expr><name>GB_NONZERO_selop_code</name></expr> </then><else>: <expr><name>GB_EQ_ZERO_selop_code</name></expr></else></ternary></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break ;</break>

            <case>case <expr><name>GB_GT_THUNK_selop_code</name></expr>   :</case> <comment type="line">// A(i,j) &gt; thunk</comment>

                <comment type="line">// bool: if thunk is true,  return an empty matrix</comment>
                <comment type="line">//       if thunk is false, rename GxB_GT_THUNK to GxB_NONZERO</comment>
                <comment type="line">// user type: return error above</comment>
                <if_stmt><if>if <condition>(<expr><name>acode</name> <operator>==</operator> <name>GB_BOOL_code</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>bthunk</name></expr>)</condition>
                    <block>{<block_content> 
                        <expr_stmt><expr><name>is_empty</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content> 
                        <comment type="line">// C is iso boolean</comment>
                        <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_NONZERO_selop_code</name></expr> ;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break ;</break>

            <case>case <expr><name>GB_GE_THUNK_selop_code</name></expr>   :</case> <comment type="line">// A(i,j) &gt;= thunk</comment>

                <comment type="line">// bool: if thunk is true,  rename GxB_GE_THUNK to GxB_NONZERO</comment>
                <comment type="line">//       if thunk is false, use GB_dup_worker</comment>
                <comment type="line">// user type: return error above</comment>
                <if_stmt><if>if <condition>(<expr><name>acode</name> <operator>==</operator> <name>GB_BOOL_code</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>bthunk</name></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// C is iso boolean</comment>
                        <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_NONZERO_selop_code</name></expr> ;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content> 
                        <comment type="line">// use dup for GE_THUNK if thunk is false</comment>
                        <expr_stmt><expr><name>make_copy</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break ;</break>

            <case>case <expr><name>GB_LT_THUNK_selop_code</name></expr>   :</case> <comment type="line">// A(i,j) &lt; thunk</comment>

                <comment type="line">// bool: if thunk is true,  rename GxB_LT_THUNK to GxB_EQ_ZERO</comment>
                <comment type="line">//       if thunk is false, return an empty matrix</comment>
                <comment type="line">// user type: return error above</comment>
                <if_stmt><if>if <condition>(<expr><name>acode</name> <operator>==</operator> <name>GB_BOOL_code</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>bthunk</name></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// C is iso boolean</comment>
                        <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_EQ_ZERO_selop_code</name></expr> ;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content> 
                        <comment type="line">// matrix empty for LT_THUNK_BOOL, if thunk false</comment>
                        <expr_stmt><expr><name>is_empty</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break ;</break>

            <case>case <expr><name>GB_LE_THUNK_selop_code</name></expr>   :</case> <comment type="line">// A(i,j) &lt;= thunk</comment>

                <comment type="line">// bool: if thunk is true,  use GB_dup_worker</comment>
                <comment type="line">//       if thunk is false, rename GxB_LE_ZERO to GxB_EQ_ZERO</comment>
                <comment type="line">// user type: return error</comment>
                <if_stmt><if>if <condition>(<expr><name>acode</name> <operator>==</operator> <name>GB_BOOL_code</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>bthunk</name></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// use dup for LE_THUNK if thunk is true</comment>
                        <expr_stmt><expr><name>make_copy</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content> 
                        <comment type="line">// C is iso boolean</comment>
                        <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>GB_EQ_ZERO_selop_code</name></expr> ;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break ;</break>

            <default>default :</default> <empty_stmt>;</empty_stmt>     <comment type="line">// use the opcode as-is</comment>
        </block_content>}</block></switch>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>op_is_user_defined</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// flipij can still be true but is only needed for if the op</comment>
        <comment type="line">// (GrB_IndexUnaryOp or GxB_SelectOp) is user-defined.  So set here it</comment>
        <comment type="line">// to false for all but user-defined op.</comment>
        <expr_stmt><expr><name>flipij</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// create T</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T_header</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>make_copy</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// selectop is always true, so T = A</comment>
        <comment type="line">// set T-&gt;iso = A-&gt;iso  OK</comment>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_shallow_copy</name> <argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>A_csc</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>is_empty</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// selectop is always false, so T is an empty non-iso matrix</comment>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_new</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <comment type="line">// auto (sparse or hyper), existing header</comment>
            <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>vlen</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>vdim</name></name></expr></argument>, <argument><expr><name>GB_Ap_calloc</name></expr></argument>, <argument><expr><name>A_csc</name></expr></argument>,
            <argument><expr><name>GxB_SPARSE</name> <operator>+</operator> <name>GxB_HYPERSPARSE</name></expr></argument>, <argument><expr><call><name>GB_Global_hyper_switch_get</name> <argument_list>( )</argument_list></call></expr></argument>,
            <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <comment type="line">// T = select (A, Thunk)</comment>
        <decl_stmt><decl><type><name>GrB_Scalar</name></type> <name>Thunk2</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>nz_thunk</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>op_is_thunk_comparator</name> <operator>||</operator> <name>op_is_user_defined</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// the GrB_Scalar Thunk is passed to GB_selector only if the</comment>
            <comment type="line">// operator is a thunk comparator (EQ, NE, GT, GE, LT, LE),</comment>
            <comment type="line">// or if the operator is user-defined.</comment>
            <expr_stmt><expr><name>Thunk2</name> <operator>=</operator> <name>Thunk</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_selector</name> <argument_list>(
            <argument><expr><name>T</name></expr></argument>,          <comment type="line">// output matrix</comment>
            <argument><expr><name>opcode</name></expr></argument>,     <comment type="line">// opcode of the operator</comment>
            <argument><expr><name>op</name></expr></argument>,         <comment type="line">// the GB_Operator itself</comment>
            <argument><expr><name>flipij</name></expr></argument>,     <comment type="line">// if true, flip i and j for user-defined operator</comment>
            <argument><expr><name>A</name></expr></argument>,          <comment type="line">// input matrix</comment>
            <argument><expr><name>ithunk</name></expr></argument>,     <comment type="line">// thunk typecasted to int64_t</comment>
            <argument><expr><name>Thunk2</name></expr></argument>,     <comment type="line">// NULL, or the GrB_Scalar Thunk</comment>
            <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>T</name><operator>-&gt;</operator><name>is_csc</name></name> <operator>=</operator> <name>A_csc</name></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><literal type="string">"T=select(A,Thunk) output"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C for accum; T=select(A,Thunk) output"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// C&lt;M&gt; = accum (C,T): accumulate the results into C via the mask</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <return>return <expr><operator>(</operator><call><name>GB_accum_mask</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><name>C_replace</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>,
        <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
