<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" xmlns:omp="http://www.srcML.org/srcML/openmp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_Global.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_Global: global values in GraphBLAS</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// All Global storage is declared, initialized, and accessed here.  The</comment>
<comment type="line">// contents of the GB_Global struct are only accessible to functions in this</comment>
<comment type="line">// file.  Global storage is used to keep track of the GraphBLAS mode (blocking</comment>
<comment type="line">// or non-blocking), for pointers to malloc/realloc/free functions,</comment>
<comment type="line">// global matrix options, and other settings.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_atomics.h"</cpp:file></cpp:include>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// Global storage: for all threads in a user application that uses GraphBLAS</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<typedef>typedef <type><struct>struct
<block>{

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// blocking/non-blocking mode, set by GrB_init</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Mode</name></type> <name>mode</name></decl> ;</decl_stmt>             <comment type="line">// GrB_NONBLOCKING, GrB_BLOCKING</comment>
                                <comment type="line">// GxB_NONBLOCKING_GPU, or GxB_BLOCKING_GPU</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>GrB_init_called</name></decl> ;</decl_stmt>      <comment type="line">// true if GrB_init already called</comment>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// threading control</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>nthreads_max</name></decl> ;</decl_stmt>          <comment type="line">// max number of threads to use</comment>
    <decl_stmt><decl><type><name>double</name></type> <name>chunk</name></decl> ;</decl_stmt>              <comment type="line">// chunk size for determining # threads to use</comment>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// hypersparsity and CSR/CSC format control</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>float</name></type> <name><name>bitmap_switch</name> <index>[<expr><name>GxB_NBITMAP_SWITCH</name></expr>]</index></name></decl> ;</decl_stmt> <comment type="line">// default bitmap_switch</comment>
    <decl_stmt><decl><type><name>float</name></type> <name>hyper_switch</name></decl> ;</decl_stmt>        <comment type="line">// default hyper_switch for new matrices</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_csc</name></decl> ;</decl_stmt>               <comment type="line">// default CSR/CSC format for new matrices</comment>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// abort function: only used for debugging</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <function_decl><type><name>void</name></type> (<modifier>*</modifier> <name>abort_function</name> ) <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> ;</function_decl>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// malloc/realloc/free: memory management functions</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// All threads must use the same malloc/realloc/free functions.</comment>
    <comment type="line">// They default to the ANSI C11 functions, but can be defined by GxB_init.</comment>

    <function_decl><type><name>void</name> <modifier>*</modifier></type> (<modifier>*</modifier> <name>malloc_function</name>  ) <parameter_list>(<parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>         ;</function_decl>     <comment type="line">// required</comment>
    <function_decl><type><name>void</name> <modifier>*</modifier></type> (<modifier>*</modifier> <name>realloc_function</name> ) <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list> ;</function_decl>     <comment type="line">// may be NULL</comment>
    <function_decl><type><name>void</name></type>   (<modifier>*</modifier> <name>free_function</name>    ) <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>         ;</function_decl>     <comment type="line">// required</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>malloc_is_thread_safe</name></decl> ;</decl_stmt>   <comment type="line">// default is true</comment>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// memory usage tracking: for testing and debugging only</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// malloc_tracking:  default is false.  There is no user-accessible API for</comment>
    <comment type="line">// setting this to true.  If true, the following statistics are computed.</comment>
    <comment type="line">// If false, all of the following are unused.</comment>

    <comment type="line">// nmalloc:  To aid in searching for memory leaks, GraphBLAS keeps track of</comment>
    <comment type="line">// the number of blocks of allocated that have not yet been freed.  The</comment>
    <comment type="line">// count starts at zero.  GB_malloc_memory and GB_calloc_memory increment</comment>
    <comment type="line">// this count, and free (of a non-NULL pointer) decrements it.  realloc</comment>
    <comment type="line">// increments the count it if is allocating a new block, but it does this</comment>
    <comment type="line">// by calling GB_malloc_memory.</comment>

    <comment type="line">// malloc_debug: this is used for testing only (GraphBLAS/Tcov).  If true,</comment>
    <comment type="line">// then use malloc_debug_count for testing memory allocation and</comment>
    <comment type="line">// out-of-memory conditions.  If malloc_debug_count &gt; 0, the value is</comment>
    <comment type="line">// decremented after each allocation of memory.  If malloc_debug_count &lt;=</comment>
    <comment type="line">// 0, the GB_*_memory routines pretend to fail; returning NULL and not</comment>
    <comment type="line">// allocating anything.</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>malloc_tracking</name></decl> ;</decl_stmt>          <comment type="line">// true if allocations are being tracked</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nmalloc</name></decl> ;</decl_stmt>               <comment type="line">// number of blocks allocated but not freed</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>malloc_debug</name></decl> ;</decl_stmt>             <comment type="line">// if true, test memory handling</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>malloc_debug_count</name></decl> ;</decl_stmt>    <comment type="line">// for testing memory handling</comment>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// for testing and development</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name><name>hack</name> <index>[<expr><literal type="number">2</literal></expr>]</index></name></decl> ;</decl_stmt>              <comment type="line">// settings for testing/development only</comment>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// diagnostic output</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>burble</name></decl> ;</decl_stmt>                   <comment type="line">// controls GBURBLE output</comment>
    <decl_stmt><decl><type><name>GB_printf_function_t</name></type> <name>printf_func</name></decl> ;</decl_stmt>  <comment type="line">// pointer to printf</comment>
    <decl_stmt><decl><type><name>GB_flush_function_t</name></type> <name>flush_func</name></decl> ;</decl_stmt>   <comment type="line">// pointer to flush</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>print_one_based</name></decl> ;</decl_stmt>          <comment type="line">// if true, print 1-based indices</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>print_mem_shallow</name></decl> ;</decl_stmt>        <comment type="line">// if true, print # shallow bytes</comment>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// timing: for code development only</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>double</name></type> <name><name>timing</name> <index>[<expr><literal type="number">40</literal></expr>]</index></name></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// for malloc debugging only</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_DEBUG</name></cpp:ifdef>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MEMTABLE_SIZE</name></cpp:macro> <cpp:value>10000</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>GB_void</name> <modifier>*</modifier></type><name><name>memtable_p</name> <index>[<expr><name>GB_MEMTABLE_SIZE</name></expr>]</index></name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>   <name><name>memtable_s</name> <index>[<expr><name>GB_MEMTABLE_SIZE</name></expr>]</index></name></decl> ;</decl_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int</name></type> <name>nmemtable</name></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// internal memory pool</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// free_pool [k] is a pointer to a link list of freed blocks, all of size</comment>
    <comment type="line">// exactly equal to 2^k.  The total number of blocks in the kth pool is</comment>
    <comment type="line">// given by free_pool_nblocks [k], and the upper bound on this is given by</comment>
    <comment type="line">// free_pool_limit [k].  If any additional blocks of size 2^k above that</comment>
    <comment type="line">// limit are freed by GB_dealloc_memory, they are not placed in the pool,</comment>
    <comment type="line">// but actually freed instead.</comment>

    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name><name>free_pool</name> <index>[<expr><literal type="number">64</literal></expr>]</index></name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name><name>free_pool_nblocks</name> <index>[<expr><literal type="number">64</literal></expr>]</index></name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name><name>free_pool_limit</name> <index>[<expr><literal type="number">64</literal></expr>]</index></name></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// CPU features</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>cpu_features_avx2</name></decl> ;</decl_stmt>        <comment type="line">// x86_64 with AVX2</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>cpu_features_avx512f</name></decl> ;</decl_stmt>     <comment type="line">// x86_64 with AVX512f</comment>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// CUDA (DRAFT: in progress)</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>gpu_count</name></decl> ;</decl_stmt>                 <comment type="line">// # of GPUs in the system</comment>
    <decl_stmt><decl><type><name>GrB_Desc_Value</name></type> <name>gpu_control</name></decl> ;</decl_stmt>    <comment type="line">// always, never, or default</comment>
    <decl_stmt><decl><type><name>double</name></type> <name>gpu_chunk</name></decl> ;</decl_stmt>              <comment type="line">// min problem size for using a GPU</comment>
    <comment type="line">// properties of each GPU:</comment>
    <decl_stmt><decl><type><name>GB_cuda_device</name></type> <name><name>gpu_properties</name> <index>[<expr><name>GB_CUDA_MAX_GPUS</name></expr>]</index></name></decl> ;</decl_stmt>

}</block></struct></type>
<name>GB_Global_struct</name> ;</typedef>

<decl_stmt><decl><type><name>GB_PUBLIC</name> <name>GB_Global_struct</name></type> <name>GB_Global</name></decl> ;</decl_stmt>

<decl_stmt><decl><type><name>GB_Global_struct</name></type> <name>GB_Global</name> <init>=
<expr><block>{

    <comment type="line">// GraphBLAS mode</comment>
    <expr><operator>.</operator><name>mode</name> <operator>=</operator> <name>GrB_NONBLOCKING</name></expr>,    <comment type="line">// default is nonblocking, no GPU</comment>

    <comment type="line">// initialization flag</comment>
    <expr><operator>.</operator><name>GrB_init_called</name> <operator>=</operator> <name>false</name></expr>,   <comment type="line">// GrB_init has not yet been called</comment>

    <comment type="line">// max number of threads and chunk size</comment>
    <expr><operator>.</operator><name>nthreads_max</name> <operator>=</operator> <literal type="number">1</literal></expr>,
    <expr><operator>.</operator><name>chunk</name> <operator>=</operator> <name>GB_CHUNK_DEFAULT</name></expr>,

    <comment type="line">// min dimension                density</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BITSWITCH_1</name></cpp:macro>          <cpp:value>((float) 0.04)</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BITSWITCH_2</name></cpp:macro>          <cpp:value>((float) 0.05)</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BITSWITCH_3_to_4</name></cpp:macro>     <cpp:value>((float) 0.06)</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BITSWITCH_5_to_8</name></cpp:macro>     <cpp:value>((float) 0.08)</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BITSWITCH_9_to_16</name></cpp:macro>    <cpp:value>((float) 0.10)</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BITSWITCH_17_to_32</name></cpp:macro>   <cpp:value>((float) 0.20)</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BITSWITCH_33_to_64</name></cpp:macro>   <cpp:value>((float) 0.30)</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BITSWITCH_gt_than_64</name></cpp:macro> <cpp:value>((float) 0.40)</cpp:value></cpp:define>

    <comment type="line">// default format</comment>
    <expr><operator>.</operator><name>bitmap_switch</name> <operator>=</operator> <block>{
        <expr><name>GB_BITSWITCH_1</name></expr>,
        <expr><name>GB_BITSWITCH_2</name></expr>,
        <expr><name>GB_BITSWITCH_3_to_4</name></expr>,
        <expr><name>GB_BITSWITCH_5_to_8</name></expr>,
        <expr><name>GB_BITSWITCH_9_to_16</name></expr>,
        <expr><name>GB_BITSWITCH_17_to_32</name></expr>,
        <expr><name>GB_BITSWITCH_33_to_64</name></expr>,
        <expr><name>GB_BITSWITCH_gt_than_64</name></expr> }</block></expr>,
    <expr><operator>.</operator><name>hyper_switch</name> <operator>=</operator> <name>GB_HYPER_SWITCH_DEFAULT</name></expr>,

    <expr><operator>.</operator><name>is_csc</name> <operator>=</operator> <name>false</name></expr>,    <comment type="line">// default is GxB_BY_ROW</comment>

    <comment type="line">// abort function for debugging only</comment>
    <expr><operator>.</operator><name>abort_function</name>   <operator>=</operator> <name>abort</name></expr>,

    <comment type="line">// malloc/realloc/free functions: default to ANSI C11 functions</comment>
    <expr><operator>.</operator><name>malloc_function</name>  <operator>=</operator> <name>malloc</name></expr>,
    <expr><operator>.</operator><name>realloc_function</name> <operator>=</operator> <name>realloc</name></expr>,
    <expr><operator>.</operator><name>free_function</name>    <operator>=</operator> <name>free</name></expr>,
    <expr><operator>.</operator><name>malloc_is_thread_safe</name> <operator>=</operator> <name>true</name></expr>,

    <comment type="line">// malloc tracking, for testing, statistics, and debugging only</comment>
    <expr><operator>.</operator><name>malloc_tracking</name> <operator>=</operator> <name>false</name></expr>,
    <expr><operator>.</operator><name>nmalloc</name> <operator>=</operator> <literal type="number">0</literal></expr>,                <comment type="line">// memory block counter</comment>
    <expr><operator>.</operator><name>malloc_debug</name> <operator>=</operator> <name>false</name></expr>,       <comment type="line">// do not test memory handling</comment>
    <expr><operator>.</operator><name>malloc_debug_count</name> <operator>=</operator> <literal type="number">0</literal></expr>,     <comment type="line">// counter for testing memory handling</comment>

    <comment type="line">// for testing and development only</comment>
    <expr><operator>.</operator><name>hack</name> <operator>=</operator> <block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,

    <comment type="line">// diagnostics</comment>
    <expr><operator>.</operator><name>burble</name> <operator>=</operator> <name>false</name></expr>,
    <expr><operator>.</operator><name>printf_func</name> <operator>=</operator> <name>NULL</name></expr>,
    <expr><operator>.</operator><name>flush_func</name> <operator>=</operator> <name>NULL</name></expr>,
    <expr><operator>.</operator><name>print_one_based</name> <operator>=</operator> <name>false</name></expr>,   <comment type="line">// if true, print 1-based indices</comment>
    <expr><operator>.</operator><name>print_mem_shallow</name> <operator>=</operator> <name>false</name></expr>, <comment type="line">// for @GrB interface only</comment>

    <expr><operator>.</operator><name>timing</name> <operator>=</operator> <block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, 
                <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,

    <comment type="line">// for malloc debugging only</comment>
    <expr><operator>.</operator><name>nmemtable</name> <operator>=</operator> <literal type="number">0</literal></expr>,     <comment type="line">// memtable is empty</comment>

    <comment type="line">// all free_pool lists start out empty</comment>
    <expr><operator>.</operator><name>free_pool</name> <operator>=</operator> <block>{
        <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
        <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
        <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
        <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
        <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
        <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
        <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
        <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,

    <expr><operator>.</operator><name>free_pool_nblocks</name> <operator>=</operator> <block>{
        <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
        <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
        <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
        <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,

    <comment type="line">// default limits on the number of free blocks in each list:</comment>
    <expr><operator>.</operator><name>free_pool_limit</name> <operator>=</operator>

    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_OPENMP</name></cpp:ifdef>
    <block>{   <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^0 = 1 byte   none</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^1 = 2        none</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^2 = 4        none</comment>

        <expr><literal type="number">16483</literal></expr>,  <comment type="line">// size 2^3 = 8        (2^14 blocks * 2^3  = 128 KB total)</comment>
        <expr><literal type="number">16483</literal></expr>,  <comment type="line">// size 2^4 = 16 bytes (2^14 blocks * 2^4  = 256 KB total)</comment>
        <expr><literal type="number">16483</literal></expr>,  <comment type="line">// size 2^5 = 32       (2^14 blocks * 2^5  = 512 KB total)</comment>
        <expr><literal type="number">16483</literal></expr>,  <comment type="line">// size 2^6 = 64       (2^14 blocks * 2^6  = 1 MB total)</comment>
        <expr><literal type="number">16483</literal></expr>,  <comment type="line">// size 2^7 = 128      (2^14 blocks * 2^7  = 2 MB total)</comment>

        <expr><literal type="number">16483</literal></expr>,  <comment type="line">// size 2^8 = 256      (2^14 blocks * 2^8  = 4 MB total)</comment>
        <expr><literal type="number">8192</literal></expr>,   <comment type="line">// size 2^9 = 512      (2^13 blocks * 2^9  = 4 MB total)</comment>
        <expr><literal type="number">4096</literal></expr>,   <comment type="line">// size 2^10 = 1 KB    (2^12 blocks * 2^10 = 4 MB total)</comment>
        <expr><literal type="number">2048</literal></expr>,   <comment type="line">// size 2^11 = 2 KB    (2^11 blocks * 2^11 = 4 MB total)</comment>

        <expr><literal type="number">1024</literal></expr>,   <comment type="line">// size 2^12 = 4 KB    (2^10 blocks * 2^12 = 4 MB total)</comment>
        <expr><literal type="number">512</literal></expr>,    <comment type="line">// size 2^13 = 8 KB    (2^9  blocks * 2^13 = 4 MB total)</comment>
        <expr><literal type="number">256</literal></expr>,    <comment type="line">// size 2^14 = 16 KB   (2^8  blocks * 2^14 = 4 MB total)</comment>
        <expr><literal type="number">128</literal></expr>,    <comment type="line">// size 2^15 = 32 KB   (2^7  blocks * 2^15 = 4 MB total)</comment>

        <comment type="line">// maximum total size = about 36 MB</comment>
        <comment type="line">// by default, no blocks larger than 32 KB are kept in the free_pool</comment>

        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^16 = 64 KB</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^17 = 128 KB</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^18 = 256 KB</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^19 = 512 KB</comment>

        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^20 = 1 MB</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^21</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^22</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^23</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^24</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^25</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^26</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^27</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^28</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^29</comment>

        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^30 (1 GB)</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^31</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^32</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^33</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^34</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^35</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^36</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^37</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^38</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^39</comment>

        <comment type="line">// These larger sizes are of course unlikely to appear, but adding all</comment>
        <comment type="line">// 64 possibilities means that the free_pool does not need to check an</comment>
        <comment type="line">// upper bound.</comment>

        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^40 (1 TB)</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^41</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^42</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^43</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^44</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^45</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^46</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^47</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^48</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^49</comment>

        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^50 (1 PB)</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^51</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^52</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^53</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^54</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^55</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^56</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^57</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^58</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^59</comment>

        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^60 (1 exabyte)</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^61</comment>
        <expr><literal type="number">0</literal></expr>,      <comment type="line">// size 2^62</comment>
        <expr><literal type="number">0</literal></expr> }</block></expr>,    <comment type="line">// size 2^63 (4 exabytes!)</comment>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="line">// the free pool requires an OpenMP critical section,</comment>
    <comment type="line">// so disable it if OpenMP is not available.</comment>
      <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
        <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
        <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
        <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// CPU features</comment>
    <expr><operator>.</operator><name>cpu_features_avx2</name> <operator>=</operator> <name>false</name></expr>,         <comment type="line">// x86_64 with AVX2</comment>
    <expr><operator>.</operator><name>cpu_features_avx512f</name> <operator>=</operator> <name>false</name></expr>,      <comment type="line">// x86_64 with AVX512f</comment>

    <comment type="line">// CUDA environment (DRAFT: in progress)</comment>
    <expr><operator>.</operator><name>gpu_count</name> <operator>=</operator> <literal type="number">0</literal></expr>,                     <comment type="line">// # of GPUs in the system</comment>
    <expr><operator>.</operator><name>gpu_control</name> <operator>=</operator> <name>GxB_DEFAULT</name></expr>,         <comment type="line">// always, never, or default</comment>
    <expr><operator>.</operator><name>gpu_chunk</name> <operator>=</operator> <name>GB_GPU_CHUNK_DEFAULT</name></expr>,  <comment type="line">// min problem size for using a GPU</comment>

}</block></expr></init></decl> ;</decl_stmt>

<comment type="line">//==============================================================================</comment>
<comment type="line">// GB_Global access functions</comment>
<comment type="line">//==============================================================================</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// mode</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>void</name></type> <name>GB_Global_mode_set</name> <parameter_list>(<parameter><decl><type><name>GrB_Mode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>mode</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>GrB_Mode</name></type> <name>GB_Global_mode_get</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>mode</name></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GrB_init_called</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_GrB_init_called_set</name> <parameter_list>(<parameter><decl><type><name>bool</name></type> <name>GrB_init_called</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>GrB_init_called</name></name> <operator>=</operator> <name>GrB_init_called</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>bool</name></type> <name>GB_Global_GrB_init_called_get</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>GrB_init_called</name></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// cpu features</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// GB_Global_cpu_features_query is used just once, by GrB_init or GxB_init,</comment>
<comment type="line">// to determine at run-time whether or not AVX2 and/or AVX512F is available.</comment>
<comment type="line">// Once these two flags are set, they are saved in the GB_Global struct, and</comment>
<comment type="line">// can then be queried later by GB_Global_cpu_features_avx*.</comment>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_cpu_features_query</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GBX86</name></expr></cpp:if>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// x86_64 architecture: see if AVX2 and/or AVX512F are supported</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name> <argument_list>( <argument><expr><name>GBNCPUFEAT</name></expr></argument> )</argument_list></call></expr></cpp:if>
        <block>{<block_content>
            <comment type="line">// Google's cpu_features package is available: use run-time tests</comment>
            <decl_stmt><decl><type><name>X86Features</name></type> <name>features</name> <init>= <expr><call><name>GetX86Info</name> <argument_list>( )</argument_list></call><operator>.</operator><name>features</name></expr></init></decl> ;</decl_stmt>
            <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>cpu_features_avx2</name></name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator> <operator>(</operator><name><name>features</name><operator>.</operator><name>avx2</name></name><operator>)</operator></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>cpu_features_avx512f</name></name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator> <operator>(</operator><name><name>features</name><operator>.</operator><name>avx512f</name></name><operator>)</operator></expr> ;</expr_stmt>
        </block_content>}</block>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <block>{<block_content>
            <comment type="line">// cpu_features package not available; use compile-time tests</comment>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GBAVX2</name></expr></argument> )</argument_list></call></expr></cpp:if>
            <block>{<block_content>
                <comment type="line">// the build system asserts whether or not AVX2 is available</comment>
                <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>cpu_features_avx2</name></name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator> <operator>(</operator><name>GBAVX2</name><operator>)</operator></expr> ;</expr_stmt>
            </block_content>}</block>
            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <block>{<block_content>
                <comment type="line">// AVX2 not available</comment>
                <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>cpu_features_avx2</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
            </block_content>}</block>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GBAVX512F</name></expr></argument> )</argument_list></call></expr></cpp:if>
            <block>{<block_content>
                <comment type="line">// the build system asserts whether or not AVX512F is available</comment>
                <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>cpu_features_avx512f</name></name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator> <operator>(</operator><name>GBAVX512F</name><operator>)</operator></expr> ;</expr_stmt>
            </block_content>}</block>
            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <block>{<block_content>
                <comment type="line">// AVX512F not available</comment>
                <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>cpu_features_avx512f</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
            </block_content>}</block>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </block_content>}</block>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// not on the x86_64 architecture, so no AVX2 or AVX512F acceleration</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>cpu_features_avx2</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>cpu_features_avx512f</name></name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>

    </block_content>}</block>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>bool</name></type> <name>GB_Global_cpu_features_avx2</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>cpu_features_avx2</name></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>bool</name></type> <name>GB_Global_cpu_features_avx512f</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>cpu_features_avx512f</name></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// nthreads_max</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_nthreads_max_set</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>nthreads_max</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>nthreads_max</name></name> <operator>=</operator> <call><name>GB_IMAX</name> <argument_list>(<argument><expr><name>nthreads_max</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>int</name></type> <name>GB_Global_nthreads_max_get</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>nthreads_max</name></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// OpenMP max_threads</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GB_PUBLIC</name>
<name>int</name></type> <name>GB_Global_omp_get_max_threads</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <return>return <expr><operator>(</operator><name>GB_OPENMP_MAX_THREADS</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// chunk</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_chunk_set</name> <parameter_list>(<parameter><decl><type><name>double</name></type> <name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <if_stmt><if>if <condition>(<expr><name>chunk</name> <operator>&lt;=</operator> <name>GxB_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>chunk</name> <operator>=</operator> <name>GB_CHUNK_DEFAULT</name></expr> ;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>chunk</name></name> <operator>=</operator> <call><name>fmax</name> <argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>double</name></type> <name>GB_Global_chunk_get</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>chunk</name></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// hyper_switch</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_hyper_switch_set</name> <parameter_list>(<parameter><decl><type><name>float</name></type> <name>hyper_switch</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>hyper_switch</name></name> <operator>=</operator> <name>hyper_switch</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>float</name></type> <name>GB_Global_hyper_switch_get</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>hyper_switch</name></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// bitmap_switch</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_bitmap_switch_set</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>GB_IMAX</name> <argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>GB_IMIN</name> <argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>bitmap_switch</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>b</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>float</name></type> <name>GB_Global_bitmap_switch_get</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>GB_IMAX</name> <argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>GB_IMIN</name> <argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>bitmap_switch</name> <index>[<expr><name>k</name></expr>]</index></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>float</name></type> <name>GB_Global_bitmap_switch_matrix_get</name> <parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>vlen</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>vdim</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <decl_stmt><decl><type><name>int64_t</name></type> <name>d</name> <init>= <expr><call><name>GB_IMIN</name> <argument_list>(<argument><expr><name>vlen</name></expr></argument>, <argument><expr><name>vdim</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>d</name> <operator>&lt;=</operator>  <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>bitmap_switch</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr> ;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>d</name> <operator>&lt;=</operator>  <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>bitmap_switch</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr> ;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>d</name> <operator>&lt;=</operator>  <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>bitmap_switch</name> <index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr> ;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>d</name> <operator>&lt;=</operator>  <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>bitmap_switch</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator></expr> ;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>d</name> <operator>&lt;=</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>bitmap_switch</name> <index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>)</operator></expr> ;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>d</name> <operator>&lt;=</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>bitmap_switch</name> <index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>)</operator></expr> ;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>d</name> <operator>&lt;=</operator> <literal type="number">64</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>bitmap_switch</name> <index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>)</operator></expr> ;</return></block_content></block></if></if_stmt>
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>bitmap_switch</name> <index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_bitmap_switch_default</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>bitmap_switch</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>GB_BITSWITCH_1</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>bitmap_switch</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>GB_BITSWITCH_2</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>bitmap_switch</name> <index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>GB_BITSWITCH_3_to_4</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>bitmap_switch</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>GB_BITSWITCH_5_to_8</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>bitmap_switch</name> <index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>GB_BITSWITCH_9_to_16</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>bitmap_switch</name> <index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>GB_BITSWITCH_17_to_32</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>bitmap_switch</name> <index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>GB_BITSWITCH_33_to_64</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>bitmap_switch</name> <index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>GB_BITSWITCH_gt_than_64</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// is_csc</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>void</name></type> <name>GB_Global_is_csc_set</name> <parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_csc</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>is_csc</name></name> <operator>=</operator> <name>is_csc</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>GB_Global_is_csc_get</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>is_csc</name></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// abort_function</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_abort_function_set</name> <parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier> <name>abort_function</name>) <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content> 
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>abort_function</name></name> <operator>=</operator> <name>abort_function</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_abort_function</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name><name>GB_Global</name><operator>.</operator><name>abort_function</name></name> <argument_list>( )</argument_list></call></expr> ;</expr_stmt>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// malloc debuging</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// These functions keep a separate record of the pointers to all allocated</comment>
<comment type="line">// blocks of memory and their sizes, just for sanity checks.</comment>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_memtable_dump</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"\nmemtable dump: %d nmalloc "</literal> <name>GBd</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>GB_Global</name><operator>.</operator><name>nmemtable</name></name></expr></argument>,
        <argument><expr><name><name>GB_Global</name><operator>.</operator><name>nmalloc</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>GB_Global</name><operator>.</operator><name>nmemtable</name></name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"  %4d: %12p : %ld\n"</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>,
            <argument><expr><name><name>GB_Global</name><operator>.</operator><name>memtable_p</name> <index>[<expr><name>k</name></expr>]</index></name></expr></argument>,
            <argument><expr><name><name>GB_Global</name><operator>.</operator><name>memtable_s</name> <index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></for>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>int</name></type> <name>GB_Global_memtable_n</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>nmemtable</name></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_memtable_clear</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>nmemtable</name></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// add a pointer to the table of malloc'd blocks</comment>
<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_memtable_add</name> <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return ;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>GB_Global</name><operator>.</operator><name>malloc_tracking</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>GB_ATOMIC_UPDATE</name>
        <name><name>GB_Global</name><operator>.</operator><name>nmalloc</name></name><operator>++</operator></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type> <name>fail</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_MEMDUMP</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"memtable add %p size %ld\n"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:clause><omp:name>critical</omp:name><omp:argument_list>(<omp:argument><omp:expr>GB_memtable</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>GB_Global</name><operator>.</operator><name>nmemtable</name></name></expr></init></decl> ;</decl_stmt>
        <expr_stmt><expr><name>fail</name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&gt;</operator> <name>GB_MEMTABLE_SIZE</name><operator>)</operator></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fail</name></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name><name>GB_Global</name><operator>.</operator><name>memtable_p</name> <index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"\nadd duplicate %p size %ld\n"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>GB_Global_memtable_dump</name> <argument_list>( )</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"Hey %d %p\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>fail</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fail</name> <operator>&amp;&amp;</operator> <name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>memtable_p</name> <index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>memtable_s</name> <index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>size</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>nmemtable</name></name><operator>++</operator></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>fail</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_MEMDUMP</name></cpp:ifdef>
    <expr_stmt><expr><call><name>GB_Global_memtable_dump</name> <argument_list>( )</argument_list></call></expr> ;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="line">// get the size of a malloc'd block</comment>
<function><type><name>GB_PUBLIC</name>
<name>size_t</name></type> <name>GB_Global_memtable_size</name> <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_DEBUG</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr> ;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
    <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:clause><omp:name>critical</omp:name><omp:argument_list>(<omp:argument><omp:expr>GB_memtable</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>GB_Global</name><operator>.</operator><name>nmemtable</name></name></expr></init></decl> ;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name><name>GB_Global</name><operator>.</operator><name>memtable_p</name> <index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>GB_Global</name><operator>.</operator><name>memtable_s</name> <index>[<expr><name>i</name></expr>]</index></name></expr> ;</expr_stmt>
                <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                <break>break ;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"\nFAIL: %p not found\n"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_Global_memtable_dump</name> <argument_list>( )</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><operator>(</operator><name>size</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">// test if a malloc'd block is in the table</comment>
<function><type><name>GB_PUBLIC</name>
<name>bool</name></type> <name>GB_Global_memtable_find</name> <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_DEBUG</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>false</name><operator>)</operator></expr> ;</return></block_content></block></if></if_stmt>
    <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:clause><omp:name>critical</omp:name><omp:argument_list>(<omp:argument><omp:expr>GB_memtable</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>GB_Global</name><operator>.</operator><name>nmemtable</name></name></expr></init></decl> ;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name><name>GB_Global</name><operator>.</operator><name>memtable_p</name> <index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                <break>break ;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><operator>(</operator><name>found</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">// remove a pointer from the table of malloc'd blocks</comment>
<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_memtable_remove</name> <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return ;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>GB_Global</name><operator>.</operator><name>malloc_tracking</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>GB_ATOMIC_UPDATE</name>
        <name><name>GB_Global</name><operator>.</operator><name>nmalloc</name></name><operator>--</operator></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_MEMDUMP</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"memtable remove %p "</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:clause><omp:name>critical</omp:name><omp:argument_list>(<omp:argument><omp:expr>GB_memtable</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>GB_Global</name><operator>.</operator><name>nmemtable</name></name></expr></init></decl> ;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name><name>GB_Global</name><operator>.</operator><name>memtable_p</name> <index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// found p in the table; remove it</comment>
                <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>memtable_p</name> <index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>GB_Global</name><operator>.</operator><name>memtable_p</name> <index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr> ;</expr_stmt>
                <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>memtable_s</name> <index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>GB_Global</name><operator>.</operator><name>memtable_s</name> <index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr> ;</expr_stmt>
                <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>nmemtable</name></name> <operator>--</operator></expr> ;</expr_stmt>
                <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                <break>break ;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"remove %p NOT FOUND\n"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_Global_memtable_dump</name> <argument_list>( )</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_MEMDUMP</name></cpp:ifdef>
    <expr_stmt><expr><call><name>GB_Global_memtable_dump</name> <argument_list>( )</argument_list></call></expr> ;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// malloc_function</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>void</name></type> <name>GB_Global_malloc_function_set</name> <parameter_list>(<parameter><function_decl><type><name>void</name> <modifier>*</modifier></type> (<modifier>*</modifier> <name>malloc_function</name>) <parameter_list>(<parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content> 
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>malloc_function</name></name> <operator>=</operator> <name>malloc_function</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type> <name>GB_Global_malloc_function</name> <parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>GB_Global</name><operator>.</operator><name>malloc_is_thread_safe</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name><name>GB_Global</name><operator>.</operator><name>malloc_function</name></name> <argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:clause><omp:name>critical</omp:name><omp:argument_list>(<omp:argument><omp:expr>GB_malloc_protection</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
        <block>{<block_content>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name><name>GB_Global</name><operator>.</operator><name>malloc_function</name></name> <argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>GB_Global_memtable_add</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <return>return <expr><operator>(</operator><name>p</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// realloc_function</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>void</name></type> <name>GB_Global_realloc_function_set</name>
<parameter_list>(
    <parameter><function_decl><type><name>void</name> <modifier>*</modifier></type> (<modifier>*</modifier> <name>realloc_function</name>) <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list>
<block>{<block_content> 
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>realloc_function</name></name> <operator>=</operator> <name>realloc_function</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>GB_Global_have_realloc_function</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>realloc_function</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type> <name>GB_Global_realloc_function</name> <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pnew</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>GB_Global</name><operator>.</operator><name>malloc_is_thread_safe</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>pnew</name> <operator>=</operator> <call><name><name>GB_Global</name><operator>.</operator><name>realloc_function</name></name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:clause><omp:name>critical</omp:name><omp:argument_list>(<omp:argument><omp:expr>GB_malloc_protection</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
        <block>{<block_content>
            <expr_stmt><expr><name>pnew</name> <operator>=</operator> <call><name><name>GB_Global</name><operator>.</operator><name>realloc_function</name></name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>pnew</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GB_Global_memtable_remove</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_Global_memtable_add</name> <argument_list>(<argument><expr><name>pnew</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><operator>(</operator><name>pnew</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// free_function</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>void</name></type> <name>GB_Global_free_function_set</name> <parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier> <name>free_function</name>) <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content> 
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>free_function</name></name> <operator>=</operator> <name>free_function</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>GB_Global_free_function</name> <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <if_stmt><if>if <condition>(<expr><name><name>GB_Global</name><operator>.</operator><name>malloc_is_thread_safe</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>GB_Global</name><operator>.</operator><name>free_function</name></name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:clause><omp:name>critical</omp:name><omp:argument_list>(<omp:argument><omp:expr>GB_malloc_protection</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>GB_Global</name><operator>.</operator><name>free_function</name></name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>GB_Global_memtable_remove</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// malloc_is_thread_safe</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_malloc_is_thread_safe_set</name> <parameter_list>(<parameter><decl><type><name>bool</name></type> <name>malloc_is_thread_safe</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>malloc_is_thread_safe</name></name> <operator>=</operator> <name>malloc_is_thread_safe</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>bool</name></type> <name>GB_Global_malloc_is_thread_safe_get</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>malloc_is_thread_safe</name></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// malloc_tracking</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_malloc_tracking_set</name> <parameter_list>(<parameter><decl><type><name>bool</name></type> <name>malloc_tracking</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>malloc_tracking</name></name> <operator>=</operator> <name>malloc_tracking</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>GB_Global_malloc_tracking_get</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>malloc_tracking</name></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// nmalloc</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>void</name></type> <name>GB_Global_nmalloc_clear</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <decl_stmt><decl><type><name>GB_ATOMIC_WRITE</name></type>
    <name><name>GB_Global</name><operator>.</operator><name>nmalloc</name></name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>int64_t</name></type> <name>GB_Global_nmalloc_get</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nmalloc</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_ATOMIC_READ</name></type>
    <name>nmalloc</name> <init>= <expr><name><name>GB_Global</name><operator>.</operator><name>nmalloc</name></name></expr></init></decl> ;</decl_stmt>
    <return>return <expr><operator>(</operator><name>nmalloc</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// malloc_debug</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_malloc_debug_set</name> <parameter_list>(<parameter><decl><type><name>bool</name></type> <name>malloc_debug</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <decl_stmt><decl><type><name>GB_ATOMIC_WRITE</name></type>
    <name><name>GB_Global</name><operator>.</operator><name>malloc_debug</name></name> <init>= <expr><name>malloc_debug</name></expr></init></decl> ;</decl_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>GB_Global_malloc_debug_get</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <decl_stmt><decl><type><name>bool</name></type> <name>malloc_debug</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_ATOMIC_READ</name></type>
    <name>malloc_debug</name> <init>= <expr><name><name>GB_Global</name><operator>.</operator><name>malloc_debug</name></name></expr></init></decl> ;</decl_stmt>
    <return>return <expr><operator>(</operator><name>malloc_debug</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// malloc_debug_count</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_malloc_debug_count_set</name> <parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>malloc_debug_count</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <decl_stmt><decl><type><name>GB_ATOMIC_WRITE</name></type>
    <name><name>GB_Global</name><operator>.</operator><name>malloc_debug_count</name></name> <init>= <expr><name>malloc_debug_count</name></expr></init></decl> ;</decl_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>GB_Global_malloc_debug_count_decrement</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <expr_stmt><expr><name>GB_ATOMIC_UPDATE</name>
    <name><name>GB_Global</name><operator>.</operator><name>malloc_debug_count</name></name><operator>--</operator></expr> ;</expr_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>malloc_debug_count</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_ATOMIC_READ</name></type>
    <name>malloc_debug_count</name> <init>= <expr><name><name>GB_Global</name><operator>.</operator><name>malloc_debug_count</name></name></expr></init></decl> ;</decl_stmt>
    <return>return <expr><operator>(</operator><name>malloc_debug_count</name> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// hack: for setting an internal flag for testing and development only</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_hack_set</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>hack</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>hack</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>hack</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>int64_t</name></type> <name>GB_Global_hack_get</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>hack</name> <index>[<expr><name>k</name></expr>]</index></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// burble: for controlling the burble output</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>void</name></type> <name>GB_Global_burble_set</name> <parameter_list>(<parameter><decl><type><name>bool</name></type> <name>burble</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>burble</name></name> <operator>=</operator> <name>burble</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>bool</name></type> <name>GB_Global_burble_get</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>burble</name></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>GB_printf_function_t</name></type> <name>GB_Global_printf_get</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>printf_func</name></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>GB_flush_function_t</name></type> <name>GB_Global_flush_get</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>flush_func</name></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_printf_set</name> <parameter_list>(<parameter><decl><type><name>GB_printf_function_t</name></type> <name>pr_func</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>printf_func</name></name> <operator>=</operator> <name>pr_func</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_flush_set</name> <parameter_list>(<parameter><decl><type><name>GB_flush_function_t</name></type> <name>fl_func</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>flush_func</name></name> <operator>=</operator> <name>fl_func</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// for printing matrices in 1-based index notation (@GrB and Julia)</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_print_one_based_set</name> <parameter_list>(<parameter><decl><type><name>bool</name></type> <name>onebased</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>print_one_based</name></name> <operator>=</operator> <name>onebased</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>bool</name></type> <name>GB_Global_print_one_based_get</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>print_one_based</name></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// for printing matrix in @GrB interface</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_print_mem_shallow_set</name> <parameter_list>(<parameter><decl><type><name>bool</name></type> <name>mem_shallow</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>print_mem_shallow</name></name> <operator>=</operator> <name>mem_shallow</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>bool</name></type> <name>GB_Global_print_mem_shallow_get</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>print_mem_shallow</name></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// CUDA (DRAFT: in progress)</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>void</name></type> <name>GB_Global_gpu_control_set</name> <parameter_list>(<parameter><decl><type><name>GrB_Desc_Value</name></type> <name>gpu_control</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <comment type="line">// set the GPU control to always, never, or default</comment>
    <if_stmt><if>if <condition>(<expr><name><name>GB_Global</name><operator>.</operator><name>gpu_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// one or more GPUs are available: set gpu_control to</comment>
        <comment type="line">// always, never, or default.</comment>
        <if_stmt><if>if <condition>(<expr><name>gpu_control</name> <operator>==</operator> <name>GxB_GPU_ALWAYS</name> <operator>||</operator> <name>gpu_control</name> <operator>==</operator> <name>GxB_GPU_NEVER</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>gpu_control</name></name> <operator>=</operator> <name>gpu_control</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>gpu_control</name></name> <operator>=</operator> <name>GxB_DEFAULT</name></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// no GPUs available: never use a GPU</comment>
        <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>gpu_control</name></name> <operator>=</operator> <name>GxB_GPU_NEVER</name></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>GrB_Desc_Value</name></type> <name>GB_Global_gpu_control_get</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <comment type="line">// get the GPU control parameter</comment>
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>gpu_control</name></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>GB_Global_gpu_chunk_set</name> <parameter_list>(<parameter><decl><type><name>double</name></type> <name>gpu_chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <comment type="line">// set the GPU chunk factor</comment>
    <if_stmt><if>if <condition>(<expr><name>gpu_chunk</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>gpu_chunk</name> <operator>=</operator> <name>GB_GPU_CHUNK_DEFAULT</name></expr> ;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>gpu_chunk</name></name> <operator>=</operator> <name>gpu_chunk</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>double</name></type> <name>GB_Global_gpu_chunk_get</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <comment type="line">// get the GPU chunk factor</comment>
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>gpu_chunk</name></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>GB_Global_gpu_count_set</name> <parameter_list>(<parameter><decl><type><name>bool</name></type> <name>enable_cuda</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <comment type="line">// set the # of GPUs in the system;</comment>
    <comment type="line">// this function is only called once, by GB_init.</comment>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GBCUDA</name></expr></argument> )</argument_list></call></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>enable_cuda</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><operator>(</operator><call><name>GB_cuda_get_device_count</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>GB_Global</name><operator>.</operator><name>gpu_count</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>
    </block_content>}</block></if>
    <else>else
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
        <comment type="line">// no GPUs available, or available but not requested</comment>
        <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>gpu_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
        <return>return <expr><operator>(</operator><name>true</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>GB_Global_gpu_count_get</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <comment type="line">// get the # of GPUs in the system</comment>
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>gpu_count</name></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_GPU_DEVICE_CHECK</name><parameter_list>(<parameter><type><name>error</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>if (device &lt; 0 || device &gt;= GB_Global.gpu_count) return (error) ;</cpp:value></cpp:define>

<function><type><name>size_t</name></type> <name>GB_Global_gpu_memorysize_get</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>device</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// get the memory size of a specific GPU</comment>
    <expr_stmt><expr><call><name>GB_GPU_DEVICE_CHECK</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>       <comment type="line">// memory size zero if invalid GPU</comment>
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>gpu_properties</name> <index>[<expr><name>device</name></expr>]</index></name><operator>.</operator><name>total_global_memory</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>GB_Global_gpu_sm_get</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>device</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// get the # of SMs in a specific GPU</comment>
    <expr_stmt><expr><call><name>GB_GPU_DEVICE_CHECK</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>       <comment type="line">// zero if invalid GPU</comment>
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>gpu_properties</name> <index>[<expr><name>device</name></expr>]</index></name><operator>.</operator><name>number_of_sms</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>GB_Global_gpu_device_pool_size_set</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>device</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>GB_GPU_DEVICE_CHECK</name> <argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>   <comment type="line">// fail if invalid GPU</comment>
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>gpu_properties</name> <index>[<expr><name>device</name></expr>]</index></name><operator>.</operator><name>pool_size</name> <operator>=</operator> <name>size</name></expr> ;</expr_stmt>
    <return>return <expr><operator>(</operator><name>true</name><operator>)</operator></expr> ;</return> 
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>GB_Global_gpu_device_max_pool_size_set</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>device</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>GB_GPU_DEVICE_CHECK</name> <argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>   <comment type="line">// fail if invalid GPU</comment>
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>gpu_properties</name><index>[<expr><name>device</name></expr>]</index></name><operator>.</operator><name>max_pool_size</name> <operator>=</operator> <name>size</name></expr> ;</expr_stmt>
    <return>return <expr><operator>(</operator><name>true</name><operator>)</operator></expr> ;</return> 
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>GB_Global_gpu_device_memory_resource_set</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>device</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>resource</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>GB_GPU_DEVICE_CHECK</name> <argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>   <comment type="line">// fail if invalid GPU</comment>
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>gpu_properties</name><index>[<expr><name>device</name></expr>]</index></name><operator>.</operator><name>memory_resource</name> <operator>=</operator> <name>resource</name></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>true</name><operator>)</operator></expr> ;</return> 
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>GB_Global_gpu_device_memory_resource_get</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>device</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>GB_GPU_DEVICE_CHECK</name> <argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>   <comment type="line">// fail if invalid GPU</comment>
    <return>return  <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>gpu_properties</name> <index>[<expr><name>device</name></expr>]</index></name><operator>.</operator><name>memory_resource</name><operator>)</operator></expr> ;</return>
    <comment type="line">// NOTE: this returns a void*, needs to be cast to be used</comment>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>GB_Global_gpu_device_properties_get</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>device</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// get all properties of a specific GPU;</comment>
    <comment type="line">// this function is only called once per GPU, by GB_init.</comment>
    <expr_stmt><expr><call><name>GB_GPU_DEVICE_CHECK</name> <argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>   <comment type="line">// fail if invalid GPU</comment>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GBCUDA</name></expr></argument> )</argument_list></call></expr></cpp:if>
    <return>return <expr><operator>(</operator><call><name>GB_cuda_get_device_properties</name> <argument_list>(<argument><expr><name>device</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>gpu_properties</name> <index>[<expr><name>device</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="line">// if no GPUs exist, they cannot be queried</comment>
    <return>return <expr><operator>(</operator><name>false</name><operator>)</operator></expr> ;</return>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// timing: for code development only</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_timing_clear_all</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <literal type="number">40</literal></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>timing</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_timing_clear</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>timing</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_timing_set</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>timing</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>t</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_timing_add</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>timing</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>+=</operator> <name>t</name></expr> ;</expr_stmt>
</block_content>}</block></function>

<function><type><name>GB_PUBLIC</name>
<name>double</name></type> <name>GB_Global_timing_get</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>timing</name> <index>[<expr><name>k</name></expr>]</index></name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// free_pool: fast access to free memory blocks</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// each free block contains a pointer to the next free block.  This requires</comment>
<comment type="line">// the free block to be at least 8 bytes in size.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_NEXT</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void **) p) [0]</cpp:value></cpp:define>

<comment type="line">// free_pool_init: initialize the free_pool</comment>
<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_free_pool_init</name> <parameter_list>(<parameter><decl><type><name>bool</name></type> <name>clear</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_OPENMP</name></cpp:ifdef>
        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:clause><omp:name>critical</omp:name><omp:argument_list>(<omp:argument><omp:expr>GB_free_pool</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>clear</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// clear the free pool</comment>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <literal type="number">64</literal></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>free_pool</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>free_pool_nblocks</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
            <comment type="line">// set the default free_pool_limit</comment>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <literal type="number">64</literal></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>free_pool_limit</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
            </block_content>}</block></for>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>n</name> <init>= <expr><literal type="number">16384</literal></expr></init></decl> ;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">3</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>free_pool_limit</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>n</name></expr> ;</expr_stmt>
            </block_content>}</block></for>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">9</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;=</operator> <literal type="number">19</literal></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name>n</name> <operator>=</operator> <name>n</name><operator>/</operator><literal type="number">2</literal></expr> ;</expr_stmt>
                <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>free_pool_limit</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>n</name></expr> ;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="line">// OpenMP not available: disable the free pool</comment>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <literal type="number">64</literal></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>free_pool</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>free_pool_nblocks</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
        </block_content>}</block></for>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_DEBUG</name></cpp:ifdef>
<comment type="line">// check if a block is valid</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>GB_Global_free_pool_check</name> <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>where</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// check the size of the block</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>k</name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;</operator> <literal type="number">64</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>GB_Global_memtable_size</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>size</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>k</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// free_pool_get: get a block from the free_pool, or return NULL if none</comment>
<function><type><name>GB_PUBLIC</name>
<name>void</name> <modifier>*</modifier></type><name>GB_Global_free_pool_get</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_OPENMP</name></cpp:ifdef>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>k</name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;</operator> <literal type="number">64</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:clause><omp:name>critical</omp:name><omp:argument_list>(<omp:argument><omp:expr>GB_free_pool</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
        <block>{<block_content>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>GB_Global</name><operator>.</operator><name>free_pool</name> <index>[<expr><name>k</name></expr>]</index></name></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// remove the block from the kth free_pool</comment>
                <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>free_pool_nblocks</name> <index>[<expr><name>k</name></expr>]</index></name><operator>--</operator></expr> ;</expr_stmt>
                <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>free_pool</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <call><name>GB_NEXT</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// clear the next pointer inside the block, since the block needs</comment>
            <comment type="line">// to be all zero</comment>
            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_DEBUG</name></cpp:ifdef>
            <expr_stmt><expr><call><name>GB_Global_free_pool_check</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"get"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><operator>(</operator><name>p</name><operator>)</operator></expr> ;</return>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="line">// OpenMP not available: free pool not in use</comment>
        <return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr> ;</return>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="line">// free_pool_put: put a block in the free_pool, unless it is full</comment>
<function><type><name>GB_PUBLIC</name>
<name>bool</name></type> <name>GB_Global_free_pool_put</name> <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_OPENMP</name></cpp:ifdef>
        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><call><name>GB_Global_free_pool_check</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"put"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <decl_stmt><decl><type><name>bool</name></type> <name>returned_to_pool</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:clause><omp:name>critical</omp:name><omp:argument_list>(<omp:argument><omp:expr>GB_free_pool</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
        <block>{<block_content>
            <expr_stmt><expr><name>returned_to_pool</name> <operator>=</operator>
                <operator>(</operator><name><name>GB_Global</name><operator>.</operator><name>free_pool_nblocks</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>&lt;</operator>
                 <name><name>GB_Global</name><operator>.</operator><name>free_pool_limit</name> <index>[<expr><name>k</name></expr>]</index></name><operator>)</operator></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>returned_to_pool</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// add the block to the head of the free_pool list</comment>
                <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>free_pool_nblocks</name> <index>[<expr><name>k</name></expr>]</index></name><operator>++</operator></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_NEXT</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>GB_Global</name><operator>.</operator><name>free_pool</name> <index>[<expr><name>k</name></expr>]</index></name></expr> ;</expr_stmt>
                <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>free_pool</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <return>return <expr><operator>(</operator><name>returned_to_pool</name><operator>)</operator></expr> ;</return>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><operator>(</operator><name>false</name><operator>)</operator></expr> ;</return>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="line">// free_pool_dump: check the validity of the free_pool</comment>
<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_free_pool_dump</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>pr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_OPENMP</name></cpp:ifdef>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type> <name>fail</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
    <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:clause><omp:name>critical</omp:name><omp:argument_list>(<omp:argument><omp:expr>GB_free_pool</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
    <block>{<block_content>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <literal type="number">64</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>fail</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>nblocks</name> <init>= <expr><name><name>GB_Global</name><operator>.</operator><name>free_pool_nblocks</name> <index>[<expr><name>k</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>limit</name>   <init>= <expr><name><name>GB_Global</name><operator>.</operator><name>free_pool_limit</name> <index>[<expr><name>k</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>nblocks</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pr</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"pool %2d: "</literal> <name>GBd</name> <literal type="string">" blocks, "</literal> <name>GBd</name> <literal type="string">" limit\n"</literal></expr></argument>,
                    <argument><expr><name>k</name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>nblocks_actual</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>GB_Global</name><operator>.</operator><name>free_pool</name> <index>[<expr><name>k</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <for>for <control>( <init>;</init> <condition><expr><name>p</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>fail</name></expr> ;</condition> <incr><expr><name>p</name> <operator>=</operator> <call><name>GB_NEXT</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>pr</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"  %16p "</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt></block_content></block></if></if_stmt>
                <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>GB_Global_memtable_size</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>pr</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"size: %ld\n"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>nblocks_actual</name><operator>++</operator></expr> ;</expr_stmt>
                <expr_stmt><expr><name>fail</name> <operator>=</operator> <name>fail</name> <operator>||</operator> <operator>(</operator><name>size</name> <operator>!=</operator> <operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>k</name><operator>)</operator></expr> ;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>fail</name> <operator>&amp;&amp;</operator> <name>pr</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"    fail\n"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>fail</name> <operator>=</operator> <name>fail</name> <operator>||</operator> <operator>(</operator><name>nblocks_actual</name> <operator>&gt;</operator> <name>nblocks</name><operator>)</operator></expr> ;</expr_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><name>nblocks_actual</name> <operator>!=</operator> <name>nblocks</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>pr</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"fail: # blocks "</literal> <name>GBd</name> <literal type="string">" "</literal> <name>GBd</name> <literal type="string">" \n"</literal></expr></argument>,
                    <argument><expr><name>nblocks_actual</name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>fail</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>fail</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="line">// free_pool_limit_get: get the limit on the # of blocks in the kth pool</comment>
<function><type><name>GB_PUBLIC</name>
<name>int64_t</name></type> <name>GB_Global_free_pool_limit_get</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_OPENMP</name></cpp:ifdef>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>nblocks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition>
        <block>{<block_content>
            <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:clause><omp:name>critical</omp:name><omp:argument_list>(<omp:argument><omp:expr>GB_free_pool</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
            <block>{<block_content>
                <expr_stmt><expr><name>nblocks</name> <operator>=</operator> <name><name>GB_Global</name><operator>.</operator><name>free_pool_limit</name> <index>[<expr><name>k</name></expr>]</index></name></expr> ;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><operator>(</operator><name>nblocks</name><operator>)</operator></expr> ;</return>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr> ;</return>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="line">// free_pool_limit_set: set the limit on the # of blocks in the kth pool</comment>
<function><type><name>GB_PUBLIC</name>
<name>void</name></type> <name>GB_Global_free_pool_limit_set</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>nblocks</name></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition>
    <block>{<block_content>
        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_OPENMP</name></cpp:ifdef>
            <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:clause><omp:name>critical</omp:name><omp:argument_list>(<omp:argument><omp:expr>GB_free_pool</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
            <block>{<block_content>
                <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>free_pool_limit</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>nblocks</name></expr> ;</expr_stmt>
            </block_content>}</block>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <block>{<block_content>
                <expr_stmt><expr><name><name>GB_Global</name><operator>.</operator><name>free_pool_limit</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
            </block_content>}</block>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// free_pool_nblocks_total:  total # of blocks in free_pool (for debug only)</comment>
<function><type><name>GB_PUBLIC</name>
<name>int64_t</name></type> <name>GB_Global_free_pool_nblocks_total</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nblocks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_OPENMP</name></cpp:ifdef>
    <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:clause><omp:name>critical</omp:name><omp:argument_list>(<omp:argument><omp:expr>GB_free_pool</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
    <block>{<block_content>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <literal type="number">64</literal></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>nblocks</name> <operator>+=</operator> <name><name>GB_Global</name><operator>.</operator><name>free_pool_nblocks</name> <index>[<expr><name>k</name></expr>]</index></name></expr> ;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><operator>(</operator><name>nblocks</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// get_wtime: return current wallclock time</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<function><type><name>GB_PUBLIC</name>
<name>double</name></type> <name>GB_Global_get_wtime</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content> 
    <return>return <expr><operator>(</operator><name>GB_OPENMP_GET_WTIME</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
