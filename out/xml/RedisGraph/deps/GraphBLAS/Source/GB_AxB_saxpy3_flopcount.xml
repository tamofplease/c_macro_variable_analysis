<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" xmlns:omp="http://www.srcML.org/srcML/openmp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_AxB_saxpy3_flopcount.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_AxB_saxpy3_flopcount:  compute flops for GB_AxB_saxpy3</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// On input, A, B, and M (optional) are matrices for C=A*B, C&lt;M&gt;=A*B, or</comment>
<comment type="line">// C&lt;!M&gt;=A*B.  The flop count for each B(:,j) is computed, and returned as a</comment>
<comment type="line">// cumulative sum.  This function is CSR/CSC agnostic, but for simplicity of</comment>
<comment type="line">// this description, assume A and B are both CSC matrices, so that ncols(A) ==</comment>
<comment type="line">// nrows(B).  For both CSR and CSC, A-&gt;vdim == B-&gt;vlen holds.  A and/or B may</comment>
<comment type="line">// be hypersparse, in any combination.</comment>

<comment type="line">// Bflops has size (B-&gt;nvec)+1, for both standard and hypersparse B.  Let</comment>
<comment type="line">// n=B-&gt;vdim be the column dimension of B (that is, B is m-by-n).</comment>

<comment type="line">// If B is a standard CSC matrix then Bflops has size n+1 == B-&gt;nvec+1, and on</comment>
<comment type="line">// output, Bflops [j] is the # of flops required to compute C (:, 0:j-1).  B-&gt;h</comment>
<comment type="line">// is NULL, and is implicitly the vector 0:(n-1).</comment>

<comment type="line">// If B is hypersparse, then let Bh = B-&gt;h.  Its size is B-&gt;nvec, and j = Bh</comment>
<comment type="line">// [kk] is the (kk)th column in the data structure for B.  C will also be</comment>
<comment type="line">// hypersparse, and only C(:,Bh) will be computed (C may have fewer non-empty</comment>
<comment type="line">// columns than B).  On output, Bflops [kk] is the number of needed flops to</comment>
<comment type="line">// compute C (:, Bh [0:kk-1]).</comment>

<comment type="line">// In both cases, Bflops [0] = 0, and Bflops [B-&gt;nvec] = total number of flops.</comment>
<comment type="line">// The size of Bflops is B-&gt;nvec+1 so that it has the same size as B-&gt;p.  The</comment>
<comment type="line">// first entry of B-&gt;p and Bflops are both zero.  This allows B to be sliced</comment>
<comment type="line">// either by # of entries in B (by slicing B-&gt;p) or by the flop count required</comment>
<comment type="line">// (by slicing Bflops).</comment>

<comment type="line">// This algorithm does not look at the values of M, A, or B, just their</comment>
<comment type="line">// patterns.  The flop count of C=A*B, C&lt;M&gt;=A*B, or C&lt;!M&gt;=A*B is computed for a</comment>
<comment type="line">// saxpy-based method; the work for A'*B for the dot product method is not</comment>
<comment type="line">// computed.</comment>

<comment type="line">// The algorithm scans all nonzeros in B.  It only scans at most the min and</comment>
<comment type="line">// max (first and last) row indices in A and M (if M is present).  If A and M</comment>
<comment type="line">// are not hypersparse, the time taken is O(nnz(B)+n).  If all matrices are</comment>
<comment type="line">// hypersparse, the time is O(nnz(B)*log(h)) where h = max # of vectors present</comment>
<comment type="line">// in A and M.  Assuming B is in standard (not hypersparse) form:</comment>

<comment type="block">/*
    [m n] = size (B) ;
    Bflops = zeros (1,n+1) ;        % (set to zero in the caller)
    Mwork = 0 ;
    for each column j in B:
        if (B (:,j) is empty) continue ;
        mjnz = nnz (M (:,j))
        if (M is present, not complemented, and M (:,j) is empty) continue ;
        Bflops (j) = mjnz if M present and not dense, to scatter M(:,j)
        Mwork += mjnz
        for each k where B (k,j) is nonzero:
            aknz = nnz (A (:,k))
            if (aknz == 0) continue ;
            % numerical phase will compute: C(:,j)&lt;#M(:,j)&gt; += A(:,k)*B(k,j)
            % where #M is no mask, M, or !M.  This typically takes aknz flops,
            % or with a binary search if nnz(M(:,j)) &lt;&lt; nnz(A(:,k)).
            Bflops (j) += aknz
        end
    end
*/</comment> 

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_mxm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_ek_slice.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy3.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_unused.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_ALL</name></cpp:macro>                         \
<cpp:value>{                                           \
    GB_WERK_POP (Work, int64_t) ;           \
    GB_WERK_POP (B_ek_slicing, int64_t) ;   \
}</cpp:value></cpp:define>

<function><type><name>GB_PUBLIC</name>
<name>GrB_Info</name></type> <name>GB_AxB_saxpy3_flopcount</name>
<parameter_list>(
    <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>Mwork</name></decl></parameter>,             <comment type="line">// amount of work to handle the mask M</comment>
    <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>Bflops</name></decl></parameter>,            <comment type="line">// size B-&gt;nvec+1</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>M</name></decl></parameter>,         <comment type="line">// optional mask matrix</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_comp</name></decl></parameter>,       <comment type="line">// if true, mask is complemented</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>B</name></decl></parameter>,
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK_OR_NULL</name> <argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><literal type="string">"M for flop count A*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"A for flop count A*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><literal type="string">"B for flop count A*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>vdim</name></name> <operator>==</operator> <name><name>B</name><operator>-&gt;</operator><name>vlen</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Bflops</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Mwork</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine the number of threads to use</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>bnvec</name> <init>= <expr><name><name>B</name><operator>-&gt;</operator><name>nvec</name></name></expr></init></decl> ;</decl_stmt>

    <expr_stmt><expr><call><name>GB_GET_NTHREADS_MAX</name> <argument_list>(<argument><expr><name>nthreads_max</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// clear Bflops</comment>
    <expr_stmt><expr><call><name>GB_memset</name> <argument_list>(<argument><expr><name>Bflops</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>bnvec</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nthreads_max</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get the mask, if present: any sparsity structure</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>mask_is_M</name> <init>= <expr><operator>(</operator><name>M</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>Mask_comp</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Mp</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Mh</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>M_Yp</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>M_Yi</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>M_Yx</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>mnvec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>mvlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>M_hash_bits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>M_is_hyper</name> <init>= <expr><call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>M_is_dense</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>M</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><name>Mh</name> <operator>=</operator> <name><name>M</name><operator>-&gt;</operator><name>h</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>Mp</name> <operator>=</operator> <name><name>M</name><operator>-&gt;</operator><name>p</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>mnvec</name> <operator>=</operator> <name><name>M</name><operator>-&gt;</operator><name>nvec</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>mvlen</name> <operator>=</operator> <name><name>M</name><operator>-&gt;</operator><name>vlen</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>M_is_dense</name> <operator>=</operator> <call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GB_as_if_full</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>M_is_hyper</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// mask is present, and hypersparse</comment>
            <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name><name>M</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>, <argument><expr><literal type="string">"M-&gt;Y hyper_hash"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>M_Yp</name> <operator>=</operator> <name><name>M</name><operator>-&gt;</operator><name>Y</name><operator>-&gt;</operator><name>p</name></name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>M_Yi</name> <operator>=</operator> <name><name>M</name><operator>-&gt;</operator><name>Y</name><operator>-&gt;</operator><name>i</name></name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>M_Yx</name> <operator>=</operator> <name><name>M</name><operator>-&gt;</operator><name>Y</name><operator>-&gt;</operator><name>x</name></name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>M_hash_bits</name> <operator>=</operator> <name><name>M</name><operator>-&gt;</operator><name>Y</name><operator>-&gt;</operator><name>vdim</name></name> <operator>-</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get A and B: any sparsity structure</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ap</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ah</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>h</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>anvec</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>nvec</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>avlen</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>vlen</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>A_is_hyper</name> <init>= <expr><call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>A_Yp</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>A_Yi</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>A_Yx</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>A_hash_bits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>A_is_hyper</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>Y</name></name></expr></argument>, <argument><expr><literal type="string">"A-&gt;Y hyper_hash"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>A_Yp</name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>Y</name><operator>-&gt;</operator><name>p</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>A_Yi</name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>Y</name><operator>-&gt;</operator><name>i</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>A_Yx</name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>Y</name><operator>-&gt;</operator><name>x</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>A_hash_bits</name> <operator>=</operator> <name><name>A</name><operator>-&gt;</operator><name>Y</name><operator>-&gt;</operator><name>vdim</name></name> <operator>-</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Bp</name> <init>= <expr><name><name>B</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Bh</name> <init>= <expr><name><name>B</name><operator>-&gt;</operator><name>h</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int8_t</name>  <modifier>*</modifier><specifier>restrict</specifier></type> <name>Bb</name> <init>= <expr><name><name>B</name><operator>-&gt;</operator><name>b</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Bi</name> <init>= <expr><name><name>B</name><operator>-&gt;</operator><name>i</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>B_is_hyper</name> <init>= <expr><call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>B_is_bitmap</name> <init>= <expr><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>B_is_sparse_or_hyper</name> <init>= <expr><name>B_is_hyper</name> <operator>||</operator> <call><name>GB_IS_SPARSE</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>bvlen</name> <init>= <expr><name><name>B</name><operator>-&gt;</operator><name>vlen</name></name></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// declare workspace</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_WERK_DECLARE</name> <argument_list>(<argument><expr><name>Work</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_WERK_DECLARE</name> <argument_list>(<argument><expr><name>B_ek_slicing</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Wfirst</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Wlast</name>  <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// construct the parallel tasks</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>B_ntasks</name></decl>, <decl><type ref="prev"/><name>B_nthreads</name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>GB_SLICE_MATRIX</name> <argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// allocate workspace</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_WERK_PUSH</name> <argument_list>(<argument><expr><name>Work</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name>B_ntasks</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>Work</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// out of memory</comment>
        <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
        <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>Wfirst</name> <operator>=</operator> <name>Work</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name>Wlast</name>  <operator>=</operator> <name>Work</name> <operator>+</operator> <name>B_ntasks</name></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// compute flop counts for C=A*B, C&lt;M&gt;=A*B, or C&lt;!M&gt;=A*B</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>total_Mwork</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>taskid</name></decl> ;</decl_stmt>
    <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>B_nthreads</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>dynamic</omp:expr></omp:argument>,<omp:argument><omp:expr>1</omp:expr></omp:argument>)</omp:argument_list></omp:clause> \
        <omp:clause><omp:name>reduction</omp:name><omp:argument_list>(<omp:argument><omp:expr>+:total_Mwork</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
    <for>for <control>(<init><expr><name>taskid</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>taskid</name> <operator>&lt;</operator> <name>B_ntasks</name></expr> ;</condition> <incr><expr><name>taskid</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// get the task descriptor</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><name>int64_t</name></type> <name>kfirst</name> <init>= <expr><name><name>kfirst_Bslice</name> <index>[<expr><name>taskid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>klast</name>  <init>= <expr><name><name>klast_Bslice</name>  <index>[<expr><name>taskid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
        <expr_stmt><expr><name><name>Wfirst</name> <index>[<expr><name>taskid</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
        <expr_stmt><expr><name><name>Wlast</name>  <index>[<expr><name>taskid</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>task_Mwork</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// count flops for vectors kfirst to klast of B</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>kk</name> <init>= <expr><name>kfirst</name></expr></init></decl> ;</init> <condition><expr><name>kk</name> <operator>&lt;=</operator> <name>klast</name></expr> ;</condition> <incr><expr><name>kk</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>

            <comment type="line">// nnz (B (:,j)), for all tasks</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>bjnz</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>Bp</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>bvlen</name></expr> </then><else>: <expr><operator>(</operator><name><name>Bp</name> <index>[<expr><name>kk</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>Bp</name> <index>[<expr><name>kk</name></expr>]</index></name><operator>)</operator></expr></else></ternary></expr></init></decl> ;</decl_stmt>
            <comment type="line">// C(:,j) is empty if the entire vector B(:,j) is empty</comment>
            <if_stmt><if>if <condition>(<expr><name>bjnz</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// find the part of B(:,j) to be computed by this task</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>pB</name></decl>, <decl><type ref="prev"/><name>pB_end</name></decl> ;</decl_stmt>
            <expr_stmt><expr><call><name>GB_get_pA</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>pB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pB_end</name></expr></argument>, <argument><expr><name>taskid</name></expr></argument>, <argument><expr><name>kk</name></expr></argument>,
                <argument><expr><name>kfirst</name></expr></argument>, <argument><expr><name>klast</name></expr></argument>, <argument><expr><name>pstart_Bslice</name></expr></argument>, <argument><expr><name>Bp</name></expr></argument>, <argument><expr><name>bvlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>my_bjnz</name> <init>= <expr><name>pB_end</name> <operator>-</operator> <name>pB</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>j</name> <init>= <expr><call><name>GBH</name> <argument_list>(<argument><expr><name>Bh</name></expr></argument>, <argument><expr><name>kk</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// see if M(:,j) is present and non-empty</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <comment type="line">// if M(:,j) is full, bitmap, or dense, do not add mjnz to bjflops</comment>
            <comment type="line">// or task_MWork.</comment>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>bjflops</name> <init>= <expr><name>my_bjnz</name></expr></init></decl> ;</decl_stmt> <comment type="line">// account for scan of B(:,j) itself</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>mjnz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>M</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>M_is_dense</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// find M(:,j): only do this if M is sparse or hypersparse</comment>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>pM</name></decl>, <decl><type ref="prev"/><name>pM_end</name></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>M_is_hyper</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// M is hypersparse: find M(:,j) in the M-&gt;Y hyper_hash</comment>
                    <expr_stmt><expr><call><name>GB_hyper_hash_lookup</name> <argument_list>(<argument><expr><name>Mp</name></expr></argument>, <argument><expr><name>M_Yp</name></expr></argument>, <argument><expr><name>M_Yi</name></expr></argument>, <argument><expr><name>M_Yx</name></expr></argument>, <argument><expr><name>M_hash_bits</name></expr></argument>,
                        <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pM</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pM_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="line">// M is sparse</comment>
                    <expr_stmt><expr><name>pM</name>     <operator>=</operator> <name><name>Mp</name> <index>[<expr><name>j</name></expr>]</index></name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>pM_end</name> <operator>=</operator> <name><name>Mp</name> <index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr> ;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name>mjnz</name> <operator>=</operator> <name>pM_end</name> <operator>-</operator> <name>pM</name></expr> ;</expr_stmt>
                <comment type="line">// If M not complemented: C(:,j) is empty if M(:,j) is empty.</comment>
                <if_stmt><if>if <condition>(<expr><name>mjnz</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>Mask_comp</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>mjnz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// M(:,j) not empty</comment>
                    <if_stmt><if>if <condition>(<expr><name>pB</name> <operator>==</operator> <call><name>GBP</name> <argument_list>(<argument><expr><name>Bp</name></expr></argument>, <argument><expr><name>kk</name></expr></argument>, <argument><expr><name>bvlen</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// this task owns the top part of B(:,j), so it can</comment>
                        <comment type="line">// account for the work to access M(:,j), without the</comment>
                        <comment type="line">// work being duplicated by other tasks working on</comment>
                        <comment type="line">// B(:,j)</comment>
                        <expr_stmt><expr><name>bjflops</name> <operator>=</operator> <name>mjnz</name></expr> ;</expr_stmt>
                        <comment type="line">// keep track of total work spent examining the mask.</comment>
                        <comment type="line">// If any B(:,j) is empty, M(:,j) can be ignored.  So</comment>
                        <comment type="line">// total_Mwork will be &lt;= nnz (M).</comment>
                        <expr_stmt><expr><name>task_Mwork</name> <operator>+=</operator> <name>mjnz</name></expr> ;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>mjnz_much</name> <init>= <expr><literal type="number">64</literal> <operator>*</operator> <name>mjnz</name></expr></init></decl> ;</decl_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// count the flops to compute C(:,j)&lt;#M(:,j)&gt; = A*B(:,j)</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <comment type="line">// where #M is either not present, M, or !M</comment>

            <for>for <control>( <init>;</init> <condition><expr><name>pB</name> <operator>&lt;</operator> <name>pB_end</name></expr> ;</condition> <incr><expr><name>pB</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <comment type="line">// get B(k,j)</comment>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><call><name>GBI</name> <argument_list>(<argument><expr><name>Bi</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>bvlen</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GBB</name> <argument_list>(<argument><expr><name>Bb</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>

                <comment type="line">// B(k,j) is nonzero</comment>

                <comment type="line">// find A(:,k)</comment>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>pA</name></decl>, <decl><type ref="prev"/><name>pA_end</name></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>A_is_hyper</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// A is hypersparse: find A(:,k) in the A-&gt;Y hyper_hash</comment>
                    <expr_stmt><expr><call><name>GB_hyper_hash_lookup</name> <argument_list>(<argument><expr><name>Ap</name></expr></argument>, <argument><expr><name>A_Yp</name></expr></argument>, <argument><expr><name>A_Yi</name></expr></argument>, <argument><expr><name>A_Yx</name></expr></argument>, <argument><expr><name>A_hash_bits</name></expr></argument>,
                        <argument><expr><name>k</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pA</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pA_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="line">// A is sparse, bitmap, or full</comment>
                    <expr_stmt><expr><name>pA</name>     <operator>=</operator> <call><name>GBP</name> <argument_list>(<argument><expr><name>Ap</name></expr></argument>, <argument><expr><name>k</name></expr></argument>  , <argument><expr><name>avlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>pA_end</name> <operator>=</operator> <call><name>GBP</name> <argument_list>(<argument><expr><name>Ap</name></expr></argument>, <argument><expr><name>k</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>avlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <comment type="line">// skip if A(:,k) empty</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>aknz</name> <init>= <expr><name>pA_end</name> <operator>-</operator> <name>pA</name></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>aknz</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>

                <decl_stmt><decl><type><name>double</name></type> <name>bkjflops</name></decl> ;</decl_stmt>

                <comment type="line">// skip if intersection of A(:,k) and M(:,j) is empty</comment>
                <comment type="line">// and mask is not complemented (C&lt;M&gt;=A*B)</comment>
                <if_stmt><if>if <condition>(<expr><name>mask_is_M</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// A(:,k) is non-empty; get first and last index of A(:,k)</comment>
                    <if_stmt><if>if <condition>(<expr><name>aknz</name> <operator>&gt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <name>mjnz_much</name> <operator>&lt;</operator> <name>aknz</name> <operator>&amp;&amp;</operator> <name>mjnz</name> <operator>&lt;</operator> <name>mvlen</name> <operator>&amp;&amp;</operator>
                        <name>aknz</name> <operator>&lt;</operator> <name>avlen</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>A</name><operator>-&gt;</operator><name>jumbled</name></name><operator>)</operator></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// scan M(:j), and do binary search for A(i,j)</comment>
                        <expr_stmt><expr><name>bkjflops</name> <operator>=</operator> <name>mjnz</name> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <literal type="number">4</literal> <operator>*</operator> <call><name>log2</name> <argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>aknz</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content> 
                        <comment type="line">// scan A(:k), and lookup M(i,j)</comment>
                        <expr_stmt><expr><name>bkjflops</name> <operator>=</operator> <name>aknz</name></expr> ;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content> 
                    <comment type="line">// A(:,k)*B(k,j) requires aknz flops</comment>
                    <expr_stmt><expr><name>bkjflops</name> <operator>=</operator> <name>aknz</name></expr> ;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <comment type="line">// increment by flops for the single entry B(k,j)</comment>
                <comment type="line">// C(:,j)&lt;#M(:,j)&gt; += A(:,k)*B(k,j).</comment>
                <expr_stmt><expr><name>bjflops</name> <operator>+=</operator> <name>bkjflops</name></expr> ;</expr_stmt>
            </block_content>}</block></for>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// log the flops for B(:,j)</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <if_stmt><if>if <condition>(<expr><name>kk</name> <operator>==</operator> <name>kfirst</name></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><name><name>Wfirst</name> <index>[<expr><name>taskid</name></expr>]</index></name> <operator>=</operator> <name>bjflops</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>kk</name> <operator>==</operator> <name>klast</name></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><name><name>Wlast</name> <index>[<expr><name>taskid</name></expr>]</index></name> <operator>=</operator> <name>bjflops</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <expr_stmt><expr><name><name>Bflops</name> <index>[<expr><name>kk</name></expr>]</index></name> <operator>=</operator> <name>bjflops</name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// compute the total work to access the mask, which is &lt;= nnz (M)</comment>
        <expr_stmt><expr><name>total_Mwork</name> <operator>+=</operator> <name>task_Mwork</name></expr> ;</expr_stmt>
    </block_content>}</block></for>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// reduce the first and last vector of each slice</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// See also Template/GB_select_phase1.c</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>kprior</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>

    <for>for <control>(<init><decl><type><name>int</name></type> <name>taskid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>taskid</name> <operator>&lt;</operator> <name>B_ntasks</name></expr> ;</condition> <incr><expr><name>taskid</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// sum up the partial flops that taskid computed for kfirst</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><name>int64_t</name></type> <name>kfirst</name> <init>= <expr><name><name>kfirst_Bslice</name> <index>[<expr><name>taskid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>klast</name>  <init>= <expr><name><name>klast_Bslice</name>  <index>[<expr><name>taskid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>kfirst</name> <operator>&lt;=</operator> <name>klast</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pB</name> <init>= <expr><name><name>pstart_Bslice</name> <index>[<expr><name>taskid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pB_end</name> <init>= <expr><call><name>GBP</name> <argument_list>(<argument><expr><name>Bp</name></expr></argument>, <argument><expr><name>kfirst</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>bvlen</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
            <expr_stmt><expr><name>pB_end</name> <operator>=</operator> <call><name>GB_IMIN</name> <argument_list>(<argument><expr><name>pB_end</name></expr></argument>, <argument><expr><name><name>pstart_Bslice</name> <index>[<expr><name>taskid</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>pB</name> <operator>&lt;</operator> <name>pB_end</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>kprior</name> <operator>&lt;</operator> <name>kfirst</name></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// This task is the first one that did work on</comment>
                    <comment type="line">// B(:,kfirst), so use it to start the reduction.</comment>
                    <expr_stmt><expr><name><name>Bflops</name> <index>[<expr><name>kfirst</name></expr>]</index></name> <operator>=</operator> <name><name>Wfirst</name> <index>[<expr><name>taskid</name></expr>]</index></name></expr> ;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content> 
                    <comment type="line">// subsequent task for B(:,kfirst)</comment>
                    <expr_stmt><expr><name><name>Bflops</name> <index>[<expr><name>kfirst</name></expr>]</index></name> <operator>+=</operator> <name><name>Wfirst</name> <index>[<expr><name>taskid</name></expr>]</index></name></expr> ;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name>kprior</name> <operator>=</operator> <name>kfirst</name></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// sum up the partial flops that taskid computed for klast</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <if_stmt><if>if <condition>(<expr><name>kfirst</name> <operator>&lt;</operator> <name>klast</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pB</name> <init>= <expr><call><name>GBP</name> <argument_list>(<argument><expr><name>Bp</name></expr></argument>, <argument><expr><name>klast</name></expr></argument>, <argument><expr><name>bvlen</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pB_end</name> <init>= <expr><name><name>pstart_Bslice</name> <index>[<expr><name>taskid</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>pB</name> <operator>&lt;</operator> <name>pB_end</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* if */</comment> <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>kprior</name> <operator>&lt;</operator> <name>klast</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <block>{<block_content> 
                    <comment type="line">// This task is the first one that did work on</comment>
                    <comment type="line">// B(:,klast), so use it to start the reduction.</comment>
                    <expr_stmt><expr><name><name>Bflops</name> <index>[<expr><name>klast</name></expr>]</index></name> <operator>=</operator> <name><name>Wlast</name> <index>[<expr><name>taskid</name></expr>]</index></name></expr> ;</expr_stmt>
                </block_content>}</block>
                <comment type="block">/*
                else
                {
                    // If kfirst &lt; klast and B(:,klast) is not empty,
                    // then this task is always the first one to do
                    // work on B(:,klast), so this case is never used.
                    ASSERT (GB_DEAD_CODE) ;
                    // subsequent task to work on B(:,klast)
                    Bflops [klast] += Wlast [taskid] ;
                }
                */</comment>
                <expr_stmt><expr><name>kprior</name> <operator>=</operator> <name>klast</name></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// cumulative sum of Bflops</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// Bflops = cumsum ([0 Bflops]) ;</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>Bflops</name> <index>[<expr><name>bnvec</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_cumsum</name> <argument_list>(<argument><expr><name>Bflops</name></expr></argument>, <argument><expr><name>bnvec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>B_nthreads</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <comment type="line">// Bflops [bnvec] is now the total flop count, including the time to</comment>
    <comment type="line">// compute A*B and to handle the mask.  total_Mwork is part of this total</comment>
    <comment type="line">// flop count, but is also returned separtely.</comment>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free workspace and return result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>Mwork</name><operator>)</operator> <operator>=</operator> <name>total_Mwork</name></expr> ;</expr_stmt>
    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
