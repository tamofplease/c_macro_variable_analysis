<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_AxB_meta.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_AxB_meta: C&lt;M&gt;=A*B meta algorithm</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// C, C&lt;M&gt;, C&lt;!M&gt; = A*B, A'*B, A*B', or A'*B' : both symbolic and numeric, with</comment>
<comment type="line">// the optional mask matrix.  This function is called by GB_mxm only.  If the</comment>
<comment type="line">// mask matrix is present, it can be regular or complemented, and either valued</comment>
<comment type="line">// or structural.</comment>

<comment type="line">// This algorithm may decide that it is more efficient to apply the mask later,</comment>
<comment type="line">// in GB_accum_mask, after this matrix C is computed, in GB_mxm.  The result is</comment>
<comment type="line">// either the T matrix in GB_mxm, or (if done in-place), the final output</comment>
<comment type="line">// matrix C passed in from the user (C_in).</comment>

<comment type="line">// The method is chosen automatically:  a gather/scatter saxpy method</comment>
<comment type="line">// (Gustavson), or a dot product method.</comment>

<comment type="line">// FUTURE:: an outer-product method for C=A*B'</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_WORKSPACE</name></cpp:macro>       \
<cpp:value>{                               \
    GB_Matrix_free (&amp;AT) ;      \
    GB_Matrix_free (&amp;BT) ;      \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_ALL</name></cpp:macro>             \
<cpp:value>{                               \
    GB_FREE_WORKSPACE ;         \
    GB_phybix_free (C) ;        \
    GB_phybix_free (MT) ;       \
}</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_mxm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_transpose.h"</cpp:file></cpp:include>

<function><type><name>GB_PUBLIC</name>
<name>GrB_Info</name></type> <name>GB_AxB_meta</name>                <comment type="line">// C&lt;M&gt;=A*B meta algorithm</comment>
<parameter_list>(
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,                   <comment type="line">// output, static header (if not in-place)</comment>
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C_in</name></decl></parameter>,                <comment type="line">// input/output matrix, if done in-place</comment>
    <parameter><decl><type><name>bool</name></type> <name>C_replace</name></decl></parameter>,                 <comment type="line">// C matrix descriptor</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>C_is_csc</name></decl></parameter>,            <comment type="line">// desired CSR/CSC format of C</comment>
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>MT</name></decl></parameter>,                  <comment type="line">// return MT = M' (static header)</comment>
    <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>M_transposed</name></decl></parameter>,             <comment type="line">// true if MT = M' was computed</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>M_in</name></decl></parameter>,          <comment type="line">// mask for C&lt;M&gt; (not complemented)</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_comp</name></decl></parameter>,           <comment type="line">// if true, use !M</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_struct</name></decl></parameter>,         <comment type="line">// if true, use the only structure of M</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_BinaryOp</name></type> <name>accum</name></decl></parameter>,       <comment type="line">// accum operator for C_in += A*B</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A_in</name></decl></parameter>,          <comment type="line">// input matrix</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>B_in</name></decl></parameter>,          <comment type="line">// input matrix</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Semiring</name></type> <name>semiring_in</name></decl></parameter>, <comment type="line">// semiring that defines C=A*B</comment>
    <parameter><decl><type><name>bool</name></type> <name>A_transpose</name></decl></parameter>,               <comment type="line">// if true, use A', else A</comment>
    <parameter><decl><type><name>bool</name></type> <name>B_transpose</name></decl></parameter>,               <comment type="line">// if true, use B', else B</comment>
    <parameter><decl><type><name>bool</name></type> <name>flipxy</name></decl></parameter>,                    <comment type="line">// if true, do z=fmult(b,a) vs fmult(a,b)</comment>
    <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>mask_applied</name></decl></parameter>,             <comment type="line">// if true, mask was applied</comment>
    <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>done_in_place</name></decl></parameter>,            <comment type="line">// if true, C was computed in-place</comment>
    <parameter><decl><type><name>GrB_Desc_Value</name></type> <name>AxB_method</name></decl></parameter>,      <comment type="line">// for auto vs user selection of methods</comment>
    <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>do_sort</name></decl></parameter>,              <comment type="line">// if nonzero, try to return C unjumbled</comment>
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK_OR_NULL</name> <argument_list>(<argument><expr><name>C_in</name></expr></argument>, <argument><expr><literal type="string">"C_in for meta A*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK_OR_NULL</name> <argument_list>(<argument><expr><name>M_in</name></expr></argument>, <argument><expr><literal type="string">"M for meta A*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_BINARYOP_OK_OR_NULL</name> <argument_list>(<argument><expr><name>accum</name></expr></argument>, <argument><expr><literal type="string">"accum for meta A*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A_in</name></expr></argument>, <argument><expr><literal type="string">"A_in for meta A*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>B_in</name></expr></argument>, <argument><expr><literal type="string">"B_in for meta A*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>M_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>M_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>M_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>A_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>A_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>A_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>B_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>B_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>B_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT_SEMIRING_OK</name> <argument_list>(<argument><expr><name>semiring_in</name></expr></argument>, <argument><expr><literal type="string">"semiring_in for numeric A*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>mask_applied</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C</name>  <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator> <name><name>C</name><operator>-&gt;</operator><name>static_header</name></name> <operator>||</operator> <name>GBNSTATIC</name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>MT</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>MT</name><operator>-&gt;</operator><name>static_header</name></name> <operator>||</operator> <name>GBNSTATIC</name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// declare workspace</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>GB_Matrix_opaque</name></name></type> <name>AT_header</name></decl>, <decl><type ref="prev"/><name>BT_header</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>AT</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>BT</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>

    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>mask_applied</name><operator>)</operator> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>done_in_place</name><operator>)</operator> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get the semiring_in</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GB_Opcode</name></type> <name>opcode</name> <init>= <expr><name><name>semiring_in</name><operator>-&gt;</operator><name>multiply</name><operator>-&gt;</operator><name>opcode</name></name></expr></init></decl>  ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>op_is_positional</name> <init>= <expr><call><name>GB_OPCODE_IS_POSITIONAL</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>op_is_first</name>  <init>= <expr><operator>(</operator><name>opcode</name> <operator>==</operator> <name>GB_FIRST_binop_code</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>op_is_second</name> <init>= <expr><operator>(</operator><name>opcode</name> <operator>==</operator> <name>GB_SECOND_binop_code</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>op_is_pair</name>   <init>= <expr><operator>(</operator><name>opcode</name> <operator>==</operator> <name>GB_PAIR_binop_code</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>allow_scale</name> <init>= <expr><name>true</name></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>semiring_in</name><operator>-&gt;</operator><name>multiply</name><operator>-&gt;</operator><name>binop_function</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>op_is_first</name> <operator>||</operator> <name>op_is_second</name><operator>)</operator></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// GB_AxB_rowscale and GB_AxB_colscale do not handle the implicit FIRST</comment>
        <comment type="line">// operator for GB_reduce_to_vector.  They do handle any other</comment>
        <comment type="line">// positional operator (FIRSTI, FIRSTJ, SECONDI, SECONDJ, etc).</comment>
        <expr_stmt><expr><name>allow_scale</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// estimate the work to transpose A, B, and C</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>double</name></type> <name>A_work</name> <init>= <expr><call><name>GB_nnz_held</name> <argument_list>(<argument><expr><name>A_in</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>    <comment type="line">// work to transpose A</comment>
    <decl_stmt><decl><type><name>double</name></type> <name>B_work</name> <init>= <expr><call><name>GB_nnz_held</name> <argument_list>(<argument><expr><name>B_in</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>    <comment type="line">// work to transpose B</comment>
    <comment type="line">// work to transpose C cannot be determined; assume it is full</comment>
    <decl_stmt><decl><type><name>double</name></type> <name>C_work</name> <init>=
        <expr><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><ternary><condition><expr><name>A_transpose</name></expr> ?</condition><then> <expr><call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>A_in</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>A_in</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator> <operator>*</operator>
        <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><ternary><condition><expr><name>B_transpose</name></expr> ?</condition><then> <expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>B_in</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>B_in</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// see if the work can be done in-place</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// If C is hypersparse, sparse, or full:</comment>
    <comment type="line">//</comment>
    <comment type="line">//      C can be computed in-place if it is already dense, and if it is</comment>
    <comment type="line">//      guaranteed to remain dense after the computation is done.  This</comment>
    <comment type="line">//      case requires the accum operator to be present and it must match</comment>
    <comment type="line">//      the monoid of the semiring.  C_replace must be false, or</comment>
    <comment type="line">//      effectively false.</comment>
    <comment type="line">//</comment>
    <comment type="line">//      todo:  if C is full and accum is not present, it can be quickly</comment>
    <comment type="line">//      converted to bitmap and then done in-place.</comment>
    <comment type="line">//</comment>
    <comment type="line">// If C is bitmap:</comment>
    <comment type="line">//</comment>
    <comment type="line">//      C can be computed in-place if its type is the same as the semiring</comment>
    <comment type="line">//      monoid.  The accum must not be present, or if present it must match</comment>
    <comment type="line">//      the semiring monoid.  C_replace can be true or false.</comment>
    <comment type="line">//</comment>
    <comment type="line">//      todo: modify GB_AxB_dot2 so it can compute C in-place,</comment>
    <comment type="line">//      or add a bitmap dot product method.  Also modify GB_AxB_saxpy</comment>
    <comment type="line">//      so it can compute a C bitmap in-place.</comment>
    <comment type="line">//</comment>
    <comment type="line">// In both cases, C must not be transposed, nor can it be aliased with any</comment>
    <comment type="line">// input matrix.</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>can_do_in_place</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>C_in</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
        <comment type="line">// disabled: this will work for most methods in the future is too</comment>
        <comment type="line">// aggressive for dot4</comment>
        if (GB_IS_BITMAP (C_in))
        {
            <comment type="line">// C is bitmap</comment>
            ASSERT (!GB_PENDING (C_in)) ; <comment type="line">// no pending tuples in bitmap</comment>
            ASSERT (!GB_ZOMBIES (C_in)) ; <comment type="line">// bitmap never has zombies</comment>
            can_do_in_place = (C_in-&gt;type == semiring_in-&gt;add-&gt;op-&gt;ztype)
                &amp;&amp; ((accum == NULL) || (accum == semiring_in-&gt;add-&gt;op)) ;
        }
        else
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if <condition>(<expr><name>accum</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// C is hypersparse, sparse, or full, and accum is present.</comment>
            <comment type="line">// check if C_in is competely dense:  no pending work.</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>C_is_dense</name> <init>= <expr><call><name>GB_as_if_full</name> <argument_list>(<argument><expr><name>C_in</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

            <comment type="line">// accum must be present, and must match the monoid of the</comment>
            <comment type="line">// semiring, and the ztype of the monoid must match the type of C</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>accum_is_monoid</name> <init>= <expr><operator>(</operator><name>accum</name> <operator>==</operator> <name><name>semiring_in</name><operator>-&gt;</operator><name>add</name><operator>-&gt;</operator><name>op</name></name><operator>)</operator>
                <operator>&amp;&amp;</operator> <operator>(</operator><name><name>C_in</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name><name>accum</name><operator>-&gt;</operator><name>ztype</name></name><operator>)</operator></expr></init></decl> ;</decl_stmt>

            <comment type="line">// C += A*B with C_replace ignored (effectively false)</comment>
            <comment type="line">// C&lt;M&gt; += A*B with C_replace false</comment>
            <comment type="line">// C&lt;!M&gt; += A*B with C_replace false</comment>
            <expr_stmt><expr><name>can_do_in_place</name> <operator>=</operator> <name>C_is_dense</name> <operator>&amp;&amp;</operator> <name>accum_is_monoid</name>
                <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>M_in</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>M_in</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>C_replace</name><operator>)</operator><operator>)</operator></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// C must also not be transposed on output; see below.  Nor can it be</comment>
        <comment type="line">// aliased with any input matrix.  This test is done after handling the</comment>
        <comment type="line">// CSR/CSC formats since the input matrices may be transposed (thus</comment>
        <comment type="line">// breaking the alias with C).</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// handle the CSR/CSC formats of C, M, A, and B</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// On input, A and/or B can be transposed, and all four matrices can be in</comment>
    <comment type="line">// either CSR or CSC format, in any combination.  This gives a total of 64</comment>
    <comment type="line">// possible combinations.  However, a CSR matrix that is transposed is just</comment>
    <comment type="line">// the same as a non-transposed CSC matrix.</comment>

    <comment type="line">// Use transpose to handle the CSR/CSC format.  If C is desired in CSR</comment>
    <comment type="line">// format, treat it as if it were in format CSC but transposed.</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>C_transpose</name> <init>= <expr><operator>!</operator><name>C_is_csc</name></expr></init></decl> ;</decl_stmt>

    <comment type="line">// If the mask is not present, then treat it as having the same CSR/CSC</comment>
    <comment type="line">// format as C.</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>M_is_csc</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>M_in</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>C_is_csc</name></expr> </then><else>: <expr><name><name>M_in</name><operator>-&gt;</operator><name>is_csc</name></name></expr></else></ternary></expr></init></decl> ;</decl_stmt>

    <comment type="line">// Treat M just like C.  If M is in CSR format, treat it as if it were CSC</comment>
    <comment type="line">// but transposed, since there are no descriptors that transpose C or M.</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>M_transpose</name> <init>= <expr><operator>!</operator><name>M_is_csc</name></expr></init></decl> ;</decl_stmt>

    <comment type="line">// A can be transposed, and can also be in CSR or CSC format.  If A is in</comment>
    <comment type="line">// CSR, treat it as A' in CSC, and if A' is in CSR, treat it as A in CSC.</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>A_in</name><operator>-&gt;</operator><name>is_csc</name></name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// Flip the sense of A_transpose</comment>
        <expr_stmt><expr><name>A_transpose</name> <operator>=</operator> <operator>!</operator><name>A_transpose</name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// B is treated just like A</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>B_in</name><operator>-&gt;</operator><name>is_csc</name></name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// Flip the sense of B_transpose</comment>
        <expr_stmt><expr><name>B_transpose</name> <operator>=</operator> <operator>!</operator><name>B_transpose</name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

        <comment type="line">// Now all matrices C, M_in, A_in, and B_in, can be treated as if they</comment>
        <comment type="line">// were all in CSC format, except any of them can be transposed.  There</comment>
        <comment type="line">// are now 16 cases to handle, where M, A, and B are M_in, A_in, and</comment>
        <comment type="line">// B_in and all matrices are CSR/CSC agnostic, and where C has not yet</comment>
        <comment type="line">// been created.</comment>

        <comment type="line">//      C &lt;M &gt; = A  * B</comment>
        <comment type="line">//      C &lt;M'&gt; = A  * B</comment>
        <comment type="line">//      C'&lt;M &gt; = A  * B</comment>
        <comment type="line">//      C'&lt;M'&gt; = A  * B</comment>

        <comment type="line">//      C &lt;M &gt; = A  * B'</comment>
        <comment type="line">//      C &lt;M'&gt; = A  * B'</comment>
        <comment type="line">//      C'&lt;M &gt; = A  * B'</comment>
        <comment type="line">//      C'&lt;M'&gt; = A  * B'</comment>

        <comment type="line">//      C &lt;M &gt; = A' * B</comment>
        <comment type="line">//      C &lt;M'&gt; = A' * B</comment>
        <comment type="line">//      C'&lt;M &gt; = A' * B</comment>
        <comment type="line">//      C'&lt;M'&gt; = A' * B</comment>

        <comment type="line">//      C &lt;M &gt; = A' * B'</comment>
        <comment type="line">//      C &lt;M'&gt; = A' * B'</comment>
        <comment type="line">//      C'&lt;M &gt; = A' * B'</comment>
        <comment type="line">//      C'&lt;M'&gt; = A' * B'</comment>

    <comment type="line">//==========================================================================</comment>
    <comment type="line">// swap_rule: decide if C or C' should be computed</comment>
    <comment type="line">//==========================================================================</comment>

    <comment type="line">// This function can compute C or C', by setting C-&gt;is_csc as the negation</comment>
    <comment type="line">// of the desired format C_is_csc.  This ensures that GB_accum_mask will</comment>
    <comment type="line">// transpose C when this function is done.</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>swap_rule</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>A_in_is_diagonal</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>            <comment type="line">// not yet computed</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>B_in_is_diagonal</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>            <comment type="line">// not yet computed</comment>

    <if_stmt><if>if <condition>(<expr><name>C_transpose</name> <operator>&amp;&amp;</operator> <name>A_transpose</name> <operator>&amp;&amp;</operator> <name>B_transpose</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C' = A'*B'       becomes C = B*A, never stays as-is</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><name>swap_rule</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><name>C_transpose</name> <operator>&amp;&amp;</operator> <name>A_transpose</name> <operator>&amp;&amp;</operator> <name>B_transpose</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C  = A'*B'       becomes C = (B*A)', never stays as-is</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><name>swap_rule</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>C_transpose</name> <operator>&amp;&amp;</operator> <name>A_transpose</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>B_transpose</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C' = A'*B        becomes C = B'*A via swap rule, or stays C'=A'*B</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// by default, use the swap rule and compute C=B'*A instead</comment>
        <expr_stmt><expr><name>swap_rule</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>

        <comment type="line">// In v6.1.1 and earlier, this method always chose swap_rule = true.</comment>
        <comment type="line">// The heuristic has been modified in v6.1.2 by adding the following</comment>
        <comment type="line">// refinement, possibly selecting swap_rule as false instead:</comment>

        <comment type="line">// see what the swap_rule == true would do for C=B'*A</comment>
        <expr_stmt><expr><name>A_in_is_diagonal</name> <operator>=</operator> <call><name>GB_is_diagonal</name> <argument_list>(<argument><expr><name>A_in</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>tentative_axb_method</name></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>GB_AxB_meta_adotb_control</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>tentative_axb_method</name></expr></argument>, <argument><expr><name>C_in</name></expr></argument>, <argument><expr><name>M_in</name></expr></argument>,
            <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>B_in</name></expr></argument>, <argument><expr><name>A_in</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>semiring_in</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>, <argument><expr><name>can_do_in_place</name></expr></argument>,
            <argument><expr><name>allow_scale</name></expr></argument>, <argument><expr><name>A_in_is_diagonal</name></expr></argument>, <argument><expr><name>AxB_method</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>tentative_axb_method</name> <operator>==</operator> <name>GB_USE_SAXPY</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// reconsider and do not use swap rule if saxpy C=B'*A is too</comment>
            <comment type="line">// expensive.  C'=A'*B is either computed as-is with swap_rule</comment>
            <comment type="line">// false, requiring a transpose of C and A.  Or, C=B'*A is</comment>
            <comment type="line">// computed, with swap_rule true, requiring a transpose of B.</comment>
            <expr_stmt><expr><name>swap_rule</name> <operator>=</operator> <operator>(</operator><name>B_work</name> <operator>&lt;</operator> <name>A_work</name> <operator>+</operator> <name>C_work</name><operator>)</operator></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>C_transpose</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>A_transpose</name> <operator>&amp;&amp;</operator> <name>B_transpose</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C' = A*B'        becomes C = B*A', or stays as C' = A*B'</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// C'=A*B' is either computed as-is with C'=A*B', or C=B*A' with</comment>
        <comment type="line">// swap_rule true.  Both require explicit transpose(s).</comment>
        <comment type="line">// C'=A*B' requires B to be transposed, then C on output.</comment>
        <comment type="line">// C=B*A' requires A to be transposed.</comment>

        <comment type="line">// In v5.1 and earlier swap_rule = true was used for this case.</comment>
        <comment type="line">// If C is very large, this will still be true.  swap_rule can only be</comment>
        <comment type="line">// false if C is small.</comment>

        <expr_stmt><expr><name>swap_rule</name> <operator>=</operator> <operator>(</operator><name>A_work</name> <operator>&lt;</operator> <name>B_work</name> <operator>+</operator> <name>C_work</name><operator>)</operator></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><name>C_transpose</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>A_transpose</name> <operator>&amp;&amp;</operator> <name>B_transpose</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C  = A*B'        becomes C'=B*A' or stays C=A*B'</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// C=A*B' is either computed as-is with C=A*B', or C'=B*A' with</comment>
        <comment type="line">// swap_rule true.  Both require explicit transpose(s).</comment>
        <comment type="line">// C'=B*A' requires A to be transposed, then C on output.</comment>
        <comment type="line">// C=A*B' requires B to be transposed.</comment>

        <comment type="line">// In v5.1 and earlier swap_rule = false was used for this case.</comment>
        <comment type="line">// If C is very large, this will still be false.  swap_rule can only be</comment>
        <comment type="line">// true if C is small.</comment>

        <expr_stmt><expr><name>swap_rule</name> <operator>=</operator> <operator>(</operator><name>B_work</name> <operator>&gt;</operator> <name>A_work</name> <operator>+</operator> <name>C_work</name><operator>)</operator></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><name>C_transpose</name> <operator>&amp;&amp;</operator> <name>A_transpose</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>B_transpose</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C  = A'*B        becomes C'=B'*A or stays C=A'*B</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// by default, do not use the swap rule and compute C=A'*B as-is</comment>
        <expr_stmt><expr><name>swap_rule</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>

        <comment type="line">// In v6.1.1 and earlier, this method always chose swap_rule = false.</comment>
        <comment type="line">// The heuristic has been modified in v6.1.2 by adding the following</comment>
        <comment type="line">// refinement, possibly selecting swap_rule as true instead:</comment>

        <comment type="line">// see what method C=A'*B would use if swap_rule is false</comment>
        <expr_stmt><expr><name>B_in_is_diagonal</name> <operator>=</operator> <call><name>GB_is_diagonal</name> <argument_list>(<argument><expr><name>B_in</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>tentative_axb_method</name></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>GB_AxB_meta_adotb_control</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>tentative_axb_method</name></expr></argument>, <argument><expr><name>C_in</name></expr></argument>, <argument><expr><name>M_in</name></expr></argument>,
            <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>A_in</name></expr></argument>, <argument><expr><name>B_in</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>semiring_in</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>, <argument><expr><name>can_do_in_place</name></expr></argument>,
            <argument><expr><name>allow_scale</name></expr></argument>, <argument><expr><name>B_in_is_diagonal</name></expr></argument>, <argument><expr><name>AxB_method</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>tentative_axb_method</name> <operator>==</operator> <name>GB_USE_SAXPY</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// reconsider and use swap rule if saxpy C=(A')*B is too expensive.</comment>
            <comment type="line">// C=(A')*B is either computed as-is, requiring a transpose of A,</comment>
            <comment type="line">// or it is computed as C'=(B')*A using the swap rule, requiring a</comment>
            <comment type="line">// transpose of C and B.</comment>
            <expr_stmt><expr><name>swap_rule</name> <operator>=</operator> <operator>(</operator><name>A_work</name> <operator>&gt;</operator> <name>B_work</name> <operator>+</operator> <name>C_work</name><operator>)</operator></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>C_transpose</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>A_transpose</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>B_transpose</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C' = A*B         stays as-is</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><name>swap_rule</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C  = A*B         stays as-is</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><name>swap_rule</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// apply the swap_rule</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>A</name></decl>, <decl><type ref="prev"/><name>B</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>atrans</name></decl>, <decl><type ref="prev"/><name>btrans</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>A_is_diagonal</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>            <comment type="line">// not yet computed</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>B_is_diagonal</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>            <comment type="line">// not yet computed</comment>

    <if_stmt><if>if <condition>(<expr><name>swap_rule</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// Replace C'=(A'*B') with C=B*A, and so on.  Swap A and B and transose</comment>
        <comment type="line">// them, transpose M, negate flipxy, and transpose M and C.</comment>
        <expr_stmt><expr><name>A</name> <operator>=</operator> <name>B_in</name></expr> ;</expr_stmt> <expr_stmt><expr><name>atrans</name> <operator>=</operator> <operator>!</operator><name>B_transpose</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>B</name> <operator>=</operator> <name>A_in</name></expr> ;</expr_stmt> <expr_stmt><expr><name>btrans</name> <operator>=</operator> <operator>!</operator><name>A_transpose</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>flipxy</name> <operator>=</operator> <operator>!</operator><name>flipxy</name></expr> ;</expr_stmt>              <comment type="line">// flipxy is modified here</comment>
        <expr_stmt><expr><name>M_transpose</name> <operator>=</operator> <operator>!</operator><name>M_transpose</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>C_transpose</name> <operator>=</operator> <operator>!</operator><name>C_transpose</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>A_is_diagonal</name> <operator>=</operator> <name>B_in_is_diagonal</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>B_is_diagonal</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <comment type="line">// use the input matrices as-is</comment>
        <expr_stmt><expr><name>A</name> <operator>=</operator> <name>A_in</name></expr> ;</expr_stmt> <expr_stmt><expr><name>atrans</name> <operator>=</operator> <name>A_transpose</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>B</name> <operator>=</operator> <name>B_in</name></expr> ;</expr_stmt> <expr_stmt><expr><name>btrans</name> <operator>=</operator> <name>B_transpose</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>A_is_diagonal</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr> ;</expr_stmt>
        <expr_stmt><expr><name>B_is_diagonal</name> <operator>=</operator> <name>B_in_is_diagonal</name></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"final A for A*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><literal type="string">"final B for A*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// finalize the semiring after flipping the binary multiplicative operator</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name><name>struct</name> <name>GB_Semiring_opaque</name></name></type> <name>semiring_struct</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Semiring</name></type> <name>semiring</name> <init>= <expr><operator>&amp;</operator><name>semiring_struct</name></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><name><name>semiring</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>GB_MAGIC</name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>semiring</name><operator>-&gt;</operator><name>header_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>semiring</name><operator>-&gt;</operator><name>add</name></name> <operator>=</operator> <name><name>semiring_in</name><operator>-&gt;</operator><name>add</name></name></expr> ;</expr_stmt>
    <expr_stmt><expr><name><name>semiring</name><operator>-&gt;</operator><name>multiply</name></name> <operator>=</operator> <call><name>GB_flip_binop</name> <argument_list>(<argument><expr><name><name>semiring_in</name><operator>-&gt;</operator><name>multiply</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flipxy</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name><name>semiring</name><operator>-&gt;</operator><name>multiply</name><operator>-&gt;</operator><name>opcode</name></name></expr>  ;</expr_stmt>
    <expr_stmt><expr><name>op_is_first</name>  <operator>=</operator> <operator>(</operator><name>opcode</name> <operator>==</operator> <name>GB_FIRST_binop_code</name><operator>)</operator></expr> ;</expr_stmt>
    <expr_stmt><expr><name>op_is_second</name> <operator>=</operator> <operator>(</operator><name>opcode</name> <operator>==</operator> <name>GB_SECOND_binop_code</name><operator>)</operator></expr> ;</expr_stmt>

    <comment type="line">// flipxy is now false for all built-in semirings, and for all user-defined</comment>
    <comment type="line">// semirings that use built-in multiplicative operators that are handled by</comment>
    <comment type="line">// GB_flip_binop.</comment>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// explicitly transpose the mask</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>M</name></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>M_transpose</name> <operator>&amp;&amp;</operator> <name>M_in</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// MT = M_in' also typecasting to boolean.  It is not freed here</comment>
        <comment type="line">// unless an error occurs, but is returned to the caller.</comment>
        <comment type="line">// If Mask_struct is true, MT = one(M') is iso.</comment>
        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(M transpose) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_transpose_cast</name> <argument_list>(<argument><expr><name>MT</name></expr></argument>, <argument><expr><name>GrB_BOOL</name></expr></argument>, <argument><expr><name>C_is_csc</name></expr></argument>, <argument><expr><name>M_in</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>,
            <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>M</name> <operator>=</operator> <name>MT</name></expr> ;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>M_transposed</name><operator>)</operator> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <comment type="line">// M_in can be used as-is; it may be NULL</comment>
        <expr_stmt><expr><name>M</name> <operator>=</operator> <name>M_in</name></expr> ;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>M_transposed</name><operator>)</operator> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK_OR_NULL</name> <argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><literal type="string">"final M for A*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check additional conditions for in-place computation of C</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>can_do_in_place</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// C cannot be done in-place if it is aliased with any input matrix.</comment>
        <comment type="line">// Also cannot compute C in-place if it is to be transposed.</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>C_aliased</name> <init>= <expr><call><name>GB_aliased</name> <argument_list>(<argument><expr><name>C_in</name></expr></argument>, <argument><expr><name>M</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GB_aliased</name> <argument_list>(<argument><expr><name>C_in</name></expr></argument>, <argument><expr><name>A</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>GB_aliased</name> <argument_list>(<argument><expr><name>C_in</name></expr></argument>, <argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>C_transpose</name> <operator>||</operator> <name>C_aliased</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>can_do_in_place</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="line">// todo: A and B can be transposed below, so this check should be</comment>
        <comment type="line">// done after any such transposings.</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// burble</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>M_str</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>M</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><name>Mask_comp</name></expr> ?</condition><then>  <expr><literal type="string">"&lt;!M&gt;"</literal></expr> </then><else>: <expr><literal type="string">"&lt;M&gt;"</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></init></decl> ;</decl_stmt>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_PROP_LEN</name></cpp:macro> <cpp:value>(GxB_MAX_NAME_LEN+128)</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>char</name></type> <name><name>A_str</name> <index>[<expr><name>GB_PROP_LEN</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>B_str</name> <index>[<expr><name>GB_PROP_LEN</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>GB_Global_burble_get</name> <argument_list>( )</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>anz</name> <init>= <expr><call><name>GB_nnz</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>bnz</name> <init>= <expr><call><name>GB_nnz</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
        <expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>A_str</name></expr></argument>, <argument><expr><name>GB_PROP_LEN</name></expr></argument>, <argument><expr><literal type="string">"A: "</literal> <name>GBd</name> <literal type="string">"-by-"</literal> <name>GBd</name> <literal type="string">", %s, "</literal> <name>GBd</name>
            <literal type="string">" entries"</literal></expr></argument>, <argument><expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>anz</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>B_str</name></expr></argument>, <argument><expr><name>GB_PROP_LEN</name></expr></argument>, <argument><expr><literal type="string">"B: "</literal> <name>GBd</name> <literal type="string">"-by-"</literal> <name>GBd</name> <literal type="string">", %s, "</literal> <name>GBd</name>
            <literal type="string">" entries"</literal></expr></argument>, <argument><expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>B</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>bnz</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// typecast A and B when transposing them, if needed</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>A_is_pattern</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>B_is_pattern</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Type</name></type> <name>atype_cast</name></decl>, <decl><type ref="prev"/><name>btype_cast</name></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>flipxy</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// A is passed as y, and B as x, in z = mult(x,y)</comment>
        <comment type="line">// The built-in first, second, pair, and positional ops have all been</comment>
        <comment type="line">// renamed, so A and B are not pattern-only if flipxy is still true.</comment>
        <expr_stmt><expr><name>A_is_pattern</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>B_is_pattern</name> <operator>=</operator> <name>false</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>atype_cast</name> <operator>=</operator> <name><name>semiring</name><operator>-&gt;</operator><name>multiply</name><operator>-&gt;</operator><name>ytype</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>btype_cast</name> <operator>=</operator> <name><name>semiring</name><operator>-&gt;</operator><name>multiply</name><operator>-&gt;</operator><name>xtype</name></name></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <comment type="line">// A is passed as x, and B as y, in z = mult(x,y)</comment>
        <expr_stmt><expr><name>A_is_pattern</name> <operator>=</operator> <name>op_is_second</name> <operator>||</operator> <name>op_is_pair</name> <operator>||</operator> <name>op_is_positional</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>B_is_pattern</name> <operator>=</operator> <name>op_is_first</name>  <operator>||</operator> <name>op_is_pair</name> <operator>||</operator> <name>op_is_positional</name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>atype_cast</name> <operator>=</operator> <name><name>semiring</name><operator>-&gt;</operator><name>multiply</name><operator>-&gt;</operator><name>xtype</name></name></expr> ;</expr_stmt>
        <expr_stmt><expr><name>btype_cast</name> <operator>=</operator> <name><name>semiring</name><operator>-&gt;</operator><name>multiply</name><operator>-&gt;</operator><name>ytype</name></name></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//==========================================================================</comment>
    <comment type="line">// select the final algorithm and perform the matrix multiply</comment>
    <comment type="line">//==========================================================================</comment>

    <comment type="line">// use GB_AxB_saxpy3 by default</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>axb_method</name> <init>= <expr><name>GB_USE_SAXPY</name></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>atrans</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C&lt;M&gt; = A'*B' or A'*B</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <if_stmt><if>if <condition>(<expr><name>B_is_diagonal</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>B_is_diagonal</name> <operator>=</operator> <call><name>GB_is_diagonal</name> <argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// explicitly transpose B</comment>
        <if_stmt><if>if <condition>(<expr><name>btrans</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>B_is_diagonal</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// B = B', or B = one(B') if only the pattern of B is needed.</comment>
            <comment type="line">// This is currently unused, since C=A'*B' and C'=A'*B' are always</comment>
            <comment type="line">// converted to C=(B*A)' and C=B*A, respectively.  It is left here</comment>
            <comment type="line">// in case the swap_rule changes.</comment>
            <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>BT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>BT_header</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_transpose_cast</name> <argument_list>(<argument><expr><name>BT</name></expr></argument>, <argument><expr><name>btype_cast</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>B_is_pattern</name></expr></argument>,
                <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><name>B</name> <operator>=</operator> <name>BT</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// select the method for C&lt;M&gt;=A'*B</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><call><name>GB_AxB_meta_adotb_control</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>axb_method</name></expr></argument>, <argument><expr><name>C_in</name></expr></argument>, <argument><expr><name>M</name></expr></argument>,
            <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>semiring</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>, <argument><expr><name>can_do_in_place</name></expr></argument>,
            <argument><expr><name>allow_scale</name></expr></argument>, <argument><expr><name>B_is_diagonal</name></expr></argument>, <argument><expr><name>AxB_method</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// AT = A'</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <if_stmt><if>if <condition>(<expr><name>axb_method</name> <operator>==</operator> <name>GB_USE_COLSCALE</name> <operator>||</operator> <name>axb_method</name> <operator>==</operator> <name>GB_USE_SAXPY</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// AT = A', or AT=one(A') if only the pattern is needed.</comment>
            <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>AT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>AT_header</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_transpose_cast</name> <argument_list>(<argument><expr><name>AT</name></expr></argument>, <argument><expr><name>atype_cast</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>A_is_pattern</name></expr></argument>,
                <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <comment type="line">// do not use colscale if AT is now bitmap</comment>
            <if_stmt><if>if <condition>(<expr><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>AT</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><name>axb_method</name> <operator>=</operator> <name>GB_USE_SAXPY</name></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C&lt;M&gt;=A'*B</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <switch>switch <condition>(<expr><name>axb_method</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_USE_ROWSCALE</name></expr> :</case> 
                <comment type="line">// C = D*B using rowscale</comment>
                <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"C%s=A'*B, rowscale "</literal></expr></argument>, <argument><expr><name>M_str</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_AxB_rowscale</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>semiring</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>,
                    <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <break>break ;</break>

            <case>case <expr><name>GB_USE_COLSCALE</name></expr> :</case> 
                <comment type="line">// C = A'*D using colscale</comment>
                <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"C%s=A'*B, colscale (transposed %s) "</literal></expr></argument>, <argument><expr><name>M_str</name></expr></argument>, <argument><expr><name>A_str</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_AxB_colscale</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>AT</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>semiring</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>,
                    <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <break>break ;</break>

            <case>case <expr><name>GB_USE_DOT</name></expr> :</case> 
                <comment type="line">// C&lt;M&gt;=A'*B via dot, or C_in&lt;M&gt;+=A'*B if in-place</comment>
                <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"C%s=A'*B, %sdot_product "</literal></expr></argument>, <argument><expr><name>M_str</name></expr></argument>,
                    <argument><expr><ternary><condition><expr><operator>(</operator><name>M</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>Mask_comp</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"masked_"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_AxB_dot</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>can_do_in_place</name><operator>)</operator></expr> ?</condition><then> <expr><name>C_in</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
                    <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>semiring</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>,
                    <argument><expr><name>mask_applied</name></expr></argument>, <argument><expr><name>done_in_place</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <break>break ;</break>

            <default>default :</default> 
                <comment type="line">// C = A'*B via saxpy: Gustavson + Hash method</comment>
                <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"C%s=A'*B, saxpy (transposed %s) "</literal></expr></argument>, <argument><expr><name>M_str</name></expr></argument>, <argument><expr><name>A_str</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_AxB_saxpy</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><ternary><condition><expr><name>can_do_in_place</name></expr> ?</condition><then> <expr><name>C_in</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>, <argument><expr><name>M</name></expr></argument>,
                    <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>AT</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>semiring</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>,
                    <argument><expr><name>mask_applied</name></expr></argument>, <argument><expr><name>done_in_place</name></expr></argument>, <argument><expr><name>AxB_method</name></expr></argument>, <argument><expr><name>do_sort</name></expr></argument>,
                    <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <break>break ;</break>
        </block_content>}</block></switch>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>btrans</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// select the method for C&lt;M&gt; = A*B'</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <if_stmt><if>if <condition>(<expr><name>allow_scale</name> <operator>&amp;&amp;</operator> <name>M</name> <operator>==</operator> <name>NULL</name>
            <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call>     <comment type="line">// todo: A*D colscale with A bitmap</comment>
            <operator>&amp;&amp;</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>B_is_diagonal</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then>
                <expr><call><name>GB_is_diagonal</name> <argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>B_is_diagonal</name></expr></else></ternary><operator>)</operator></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// C = A*D, column scale</comment>
            <expr_stmt><expr><name>axb_method</name> <operator>=</operator> <name>GB_USE_COLSCALE</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>allow_scale</name> <operator>&amp;&amp;</operator> <name>M</name> <operator>==</operator> <name>NULL</name>
            <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call>     <comment type="line">// todo: D*B' rowscale with B bitmap</comment>
            <operator>&amp;&amp;</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>A_is_diagonal</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then>
                <expr><call><name>GB_is_diagonal</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>A_is_diagonal</name></expr></else></ternary><operator>)</operator></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// C = D*B', row scale</comment>
            <expr_stmt><expr><name>axb_method</name> <operator>=</operator> <name>GB_USE_ROWSCALE</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>AxB_method</name> <operator>==</operator> <name>GxB_AxB_DOT</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// only use the dot product method if explicitly requested</comment>
            <expr_stmt><expr><name>axb_method</name> <operator>=</operator> <name>GB_USE_DOT</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// BT = B'</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <if_stmt><if>if <condition>(<expr><name>axb_method</name> <operator>!=</operator> <name>GB_USE_COLSCALE</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// BT = B', or BT=one(B') if only the pattern of B is needed</comment>
            <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>BT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>BT_header</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_transpose_cast</name> <argument_list>(<argument><expr><name>BT</name></expr></argument>, <argument><expr><name>btype_cast</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>B_is_pattern</name></expr></argument>,
                <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <comment type="line">// do not use rowscale if BT is now bitmap</comment>
            <if_stmt><if>if <condition>(<expr><name>axb_method</name> <operator>==</operator> <name>GB_USE_ROWSCALE</name> <operator>&amp;&amp;</operator> <call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>BT</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><name>axb_method</name> <operator>=</operator> <name>GB_USE_SAXPY</name></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C&lt;M&gt; = A*B'</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <switch>switch <condition>(<expr><name>axb_method</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_USE_COLSCALE</name></expr> :</case> 
                <comment type="line">// C = A*D</comment>
                <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"C%s=A*B', colscale "</literal></expr></argument>, <argument><expr><name>M_str</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_AxB_colscale</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>semiring</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>,
                    <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <break>break ;</break>

            <case>case <expr><name>GB_USE_ROWSCALE</name></expr> :</case> 
                <comment type="line">// C = D*B'</comment>
                <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"C%s=A*B', rowscale (transposed %s) "</literal></expr></argument>, <argument><expr><name>M_str</name></expr></argument>, <argument><expr><name>B_str</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_AxB_rowscale</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>BT</name></expr></argument>, <argument><expr><name>semiring</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>,
                    <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <break>break ;</break>

            <case>case <expr><name>GB_USE_DOT</name></expr> :</case> 
                <comment type="line">// C&lt;M&gt;=A*B' via dot product, or C_in&lt;M&gt;+=A*B' if in-place</comment>
                <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"C%s=A*B', dot_product (transposed %s) "</literal>
                    <literal type="string">"(transposed %s) "</literal></expr></argument>, <argument><expr><name>M_str</name></expr></argument>, <argument><expr><name>A_str</name></expr></argument>, <argument><expr><name>B_str</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>AT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>AT_header</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_transpose_cast</name> <argument_list>(<argument><expr><name>AT</name></expr></argument>, <argument><expr><name>atype_cast</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>A_is_pattern</name></expr></argument>,
                    <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_AxB_dot</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>can_do_in_place</name><operator>)</operator></expr> ?</condition><then> <expr><name>C_in</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
                    <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>AT</name></expr></argument>, <argument><expr><name>BT</name></expr></argument>, <argument><expr><name>semiring</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>,
                    <argument><expr><name>mask_applied</name></expr></argument>, <argument><expr><name>done_in_place</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <break>break ;</break>

            <default>default :</default> 
                <comment type="line">// C = A*B' via saxpy: Gustavson + Hash method</comment>
                <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"C%s=A*B', saxpy (transposed %s) "</literal></expr></argument>, <argument><expr><name>M_str</name></expr></argument>, <argument><expr><name>B_str</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_AxB_saxpy</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><ternary><condition><expr><name>can_do_in_place</name></expr> ?</condition><then> <expr><name>C_in</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>, <argument><expr><name>M</name></expr></argument>,
                    <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>BT</name></expr></argument>, <argument><expr><name>semiring</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>,
                    <argument><expr><name>mask_applied</name></expr></argument>, <argument><expr><name>done_in_place</name></expr></argument>, <argument><expr><name>AxB_method</name></expr></argument>, <argument><expr><name>do_sort</name></expr></argument>,
                    <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <break>break ;</break>
        </block_content>}</block></switch>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// select the method for C&lt;M&gt; = A*B</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <if_stmt><if>if <condition>(<expr><name>allow_scale</name> <operator>&amp;&amp;</operator> <name>M</name> <operator>==</operator> <name>NULL</name>
            <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call>     <comment type="line">// todo: A*D colscale with A bitmap</comment>
            <operator>&amp;&amp;</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>B_is_diagonal</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then>
                <expr><call><name>GB_is_diagonal</name> <argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>B_is_diagonal</name></expr></else></ternary><operator>)</operator></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// C = A*D, column scale</comment>
            <expr_stmt><expr><name>axb_method</name> <operator>=</operator> <name>GB_USE_COLSCALE</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>allow_scale</name> <operator>&amp;&amp;</operator> <name>M</name> <operator>==</operator> <name>NULL</name>
            <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call>     <comment type="line">// todo: D*B rowscale with B bitmap</comment>
            <operator>&amp;&amp;</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>A_is_diagonal</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then>
                <expr><call><name>GB_is_diagonal</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>A_is_diagonal</name></expr></else></ternary><operator>)</operator></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// C = D*B, row scale</comment>
            <expr_stmt><expr><name>axb_method</name> <operator>=</operator> <name>GB_USE_ROWSCALE</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>AxB_method</name> <operator>==</operator> <name>GxB_AxB_DOT</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// C&lt;M&gt;=A*B via dot product, or C_in&lt;M&gt;+=A*B if in-place.</comment>
            <expr_stmt><expr><name>axb_method</name> <operator>=</operator> <name>GB_USE_DOT</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>AxB_method</name> <operator>==</operator> <name>GxB_AxB_SAXPY</name>
              <operator>||</operator> <name>AxB_method</name> <operator>==</operator> <name>GxB_AxB_HASH</name>
              <operator>||</operator> <name>AxB_method</name> <operator>==</operator> <name>GxB_AxB_GUSTAVSON</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// C&lt;M&gt;=A*B via saxpy</comment>
            <expr_stmt><expr><name>axb_method</name> <operator>=</operator> <name>GB_USE_SAXPY</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// C = A*B: auto selection: select saxpy or dot</comment>
            <if_stmt><if>if <condition>(<expr><call><name>GB_IS_HYPERSPARSE</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GB_IS_FULL</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// If A is hyper and B is bitmap/full, then saxpy will compute</comment>
                <comment type="line">// C as sparse or bitmap.  If bitmap, use saxpy; if sparse, use</comment>
                <comment type="line">// dot product instead.</comment>
                <decl_stmt><decl><type><name>int</name></type> <name>ignore</name></decl>, <decl><type ref="prev"/><name>saxpy_method</name></decl> ;</decl_stmt>
                <expr_stmt><expr><call><name>GB_AxB_saxpy_sparsity</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>ignore</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saxpy_method</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>,
                    <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>saxpy_method</name> <operator>==</operator> <name>GB_SAXPY_METHOD_BITMAP</name></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// bitmap = hyper * (bitmap or full) is very efficient</comment>
                    <comment type="line">// to do via GB_bitmap_AxB_saxpy.</comment>
                    <expr_stmt><expr><name>axb_method</name> <operator>=</operator> <name>GB_USE_SAXPY</name></expr> ;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content> 
                    <comment type="line">// sparse = hyper * (bitmap or full) would use</comment>
                    <comment type="line">// GB_AxB_saxpy3, which can be slow, so use dot instead.</comment>
                    <expr_stmt><expr><name>axb_method</name> <operator>=</operator> <name>GB_USE_DOT</name></expr> ;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <comment type="line">// otherwise, always use GB_AxB_saxpy</comment>
                <expr_stmt><expr><name>axb_method</name> <operator>=</operator> <name>GB_USE_SAXPY</name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C&lt;M&gt; = A*B</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <switch>switch <condition>(<expr><name>axb_method</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_USE_COLSCALE</name></expr> :</case> 
                <comment type="line">// C = A*D, column scale</comment>
                <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"C%s=A*B, colscale "</literal></expr></argument>, <argument><expr><name>M_str</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_AxB_colscale</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>semiring</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <break>break ;</break>

            <case>case <expr><name>GB_USE_ROWSCALE</name></expr> :</case> 
                <comment type="line">// C = D*B, row scale</comment>
                <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"C%s=A*B, rowscale "</literal></expr></argument>, <argument><expr><name>M_str</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_AxB_rowscale</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>semiring</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <break>break ;</break>

            <case>case <expr><name>GB_USE_DOT</name></expr> :</case> 
                <comment type="line">// C&lt;M&gt;=A*B via dot product, or C_in&lt;M&gt;+=A*B if in-place.</comment>
                <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"C%s=A*B', dot_product (transposed %s) "</literal></expr></argument>,
                    <argument><expr><name>M_str</name></expr></argument>, <argument><expr><name>A_str</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>AT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>AT_header</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_transpose_cast</name> <argument_list>(<argument><expr><name>AT</name></expr></argument>, <argument><expr><name>atype_cast</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>A_is_pattern</name></expr></argument>,
                    <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_AxB_dot</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>can_do_in_place</name><operator>)</operator></expr> ?</condition><then> <expr><name>C_in</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
                    <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>AT</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>semiring</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>,
                    <argument><expr><name>mask_applied</name></expr></argument>, <argument><expr><name>done_in_place</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <break>break ;</break>

            <default>default :</default> 
                <comment type="line">// C = A*B via saxpy: Gustavson + Hash method</comment>
                <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"C%s=A*B, saxpy "</literal></expr></argument>, <argument><expr><name>M_str</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_AxB_saxpy</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><ternary><condition><expr><name>can_do_in_place</name></expr> ?</condition><then> <expr><name>C_in</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>, <argument><expr><name>M</name></expr></argument>,
                    <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>semiring</name></expr></argument>, <argument><expr><name>flipxy</name></expr></argument>,
                    <argument><expr><name>mask_applied</name></expr></argument>, <argument><expr><name>done_in_place</name></expr></argument>, <argument><expr><name>AxB_method</name></expr></argument>, <argument><expr><name>do_sort</name></expr></argument>,
                    <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <break>break ;</break>
        </block_content>}</block></switch>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>M_transposed</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(M transposed) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>M</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><operator>*</operator><name>mask_applied</name><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(mask later) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt> </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// handle C_transpose and assign the CSR/CSC format</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// If C_transpose is true, then C' has been computed.  In this case, negate</comment>
    <comment type="line">// the desired C_is_csc so that GB_accum_mask transposes the result before</comment>
    <comment type="line">// applying the accum operator and/or writing the result back to the user's</comment>
    <comment type="line">// C.</comment>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>done_in_place</name></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(C in place) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <comment type="line">// C can be done in-place only if C is not transposed on output</comment>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C_in</name></expr></argument>, <argument><expr><literal type="string">"C_in output for all C=A*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>C_in</name><operator>-&gt;</operator><name>is_csc</name></name> <operator>==</operator> <name>C_is_csc</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>is_csc</name></name> <operator>=</operator> <ternary><condition><expr><name>C_transpose</name></expr> ?</condition><then> <expr><operator>!</operator><name>C_is_csc</name></expr> </then><else>: <expr><name>C_is_csc</name></expr></else></ternary></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C output for all C=A*B"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free workspace and return result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><name>GB_FREE_WORKSPACE</name></expr> ;</expr_stmt>
    <comment type="line">// do not free MT; return it to the caller</comment>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_DEBUG</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>M_transposed</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>MT</name></expr></argument>, <argument><expr><literal type="string">"MT computed"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt></block_content></block></if></if_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
