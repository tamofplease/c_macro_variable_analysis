<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/Template/GB_AxB_saxpy_generic_method.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_AxB_saxpy_generic_method: C=A*B, C&lt;M&gt;=A*B, or C&lt;!M&gt;=A*B</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// GB_AxB_saxpy_generic_method computes C=A*B, C&lt;M&gt;=A*B, or C&lt;!M&gt;=A*B.</comment>
<comment type="line">// with arbitrary types and operators.  C can have any sparsity pattern:</comment>
<comment type="line">// hyper, sparse, bitmap, or full.  For all cases, the four matrices C, M</comment>
<comment type="line">// (if present), A, and B have the same format (by-row or by-column), or they</comment>
<comment type="line">// represent implicitly transposed matrices with the same effect.  This method</comment>
<comment type="line">// does not handle the dot-product methods, which compute C=A'*B if A and B</comment>
<comment type="line">// are held by column, or equivalently A*B' if both are held by row.</comment>

<comment type="line">// This method uses GB_AxB_saxpy_generic_template.c to implement two</comment>
<comment type="line">// meta-methods, each of which can contain further specialized methods (such as</comment>
<comment type="line">// the fine/coarse x Gustavson/Hash, mask/no-mask methods in saxpy3):</comment>

<comment type="line">// saxpy3: general purpose method, where C is sparse or hypersparse,</comment>
<comment type="line">//          via GB_AxB_saxpy3_template.c.  SaxpyTasks holds the (fine/coarse x</comment>
<comment type="line">//          Gustavson/Hash) tasks constructed by GB_AxB_saxpy3_slice*.</comment>

<comment type="line">// bitmap_saxpy: general purpose method, where C is bitmap or full, via</comment>
<comment type="line">//          GB_bitmap_AxB_saxpy_template.c.  The method constructs its own</comment>
<comment type="line">//          tasks in workspace defined and freed in that template.</comment>

<comment type="line">// C is not iso.</comment>

<comment type="line">// This template is used to construct the following methods, all of which</comment>
<comment type="line">// are called by GB_AxB_saxpy_generic:</comment>

<comment type="line">//      GB_AxB_saxpy3_generic_firsti64</comment>
<comment type="line">//      GB_AxB_saxpy3_generic_firstj64</comment>
<comment type="line">//      GB_AxB_saxpy3_generic_secondj64</comment>
<comment type="line">//      GB_AxB_saxpy3_generic_firsti32</comment>
<comment type="line">//      GB_AxB_saxpy3_generic_firstj32</comment>
<comment type="line">//      GB_AxB_saxpy3_generic_secondj32</comment>
<comment type="line">//      GB_AxB_saxpy3_generic_first</comment>
<comment type="line">//      GB_AxB_saxpy3_generic_second</comment>
<comment type="line">//      GB_AxB_saxpy3_generic_flipped</comment>
<comment type="line">//      GB_AxB_saxpy3_generic_unflipped</comment>

<comment type="line">//      GB_bitmap_AxB_saxpy_generic_firsti64</comment>
<comment type="line">//      GB_bitmap_AxB_saxpy_generic_firstj64</comment>
<comment type="line">//      GB_bitmap_AxB_saxpy_generic_secondj64</comment>
<comment type="line">//      GB_bitmap_AxB_saxpy_generic_firsti32</comment>
<comment type="line">//      GB_bitmap_AxB_saxpy_generic_firstj32</comment>
<comment type="line">//      GB_bitmap_AxB_saxpy_generic_secondj32</comment>
<comment type="line">//      GB_bitmap_AxB_saxpy_generic_first</comment>
<comment type="line">//      GB_bitmap_AxB_saxpy_generic_second</comment>
<comment type="line">//      GB_bitmap_AxB_saxpy_generic_flipped</comment>
<comment type="line">//      GB_bitmap_AxB_saxpy_generic_unflipped</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_mxm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_ek_slice.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_binop.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_sort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_atomics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_ek_slice_search.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_bitmap_assign_methods.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy_generic.h"</cpp:file></cpp:include>

<function><type><name>GrB_Info</name></type> <name>GB_AXB_SAXPY_GENERIC_METHOD</name>
<parameter_list>(
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,                   <comment type="line">// any sparsity</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>M</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>Mask_comp</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_struct</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>M_in_place</name></decl></parameter>,          <comment type="line">// ignored if C is bitmap</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>A_is_pattern</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>B</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>B_is_pattern</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Semiring</name></type> <name>semiring</name></decl></parameter>,    <comment type="line">// semiring that defines C=A*B</comment>
    <comment type="line">// for saxpy3 only:</comment>
    <parameter><decl><type><name>GB_saxpy3task_struct</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>SaxpyTasks</name></decl></parameter>, <comment type="line">// NULL if C is bitmap</comment>
    <parameter><decl><type><name>int</name></type> <name>ntasks</name></decl></parameter>,
    <parameter><decl><type><name>int</name></type> <name>nfine</name></decl></parameter>,
    <parameter><decl><type><name>int</name></type> <name>nthreads</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>do_sort</name></decl></parameter>,              <comment type="line">// if true, sort in saxpy3</comment>
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get operators, functions, workspace, contents of A, B, and C</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_BinaryOp</name></type> <name>mult</name> <init>= <expr><name><name>semiring</name><operator>-&gt;</operator><name>multiply</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Monoid</name></type> <name>add</name> <init>= <expr><name><name>semiring</name><operator>-&gt;</operator><name>add</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_void</name> <modifier>*</modifier></type><name>identity</name> <init>= <expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name><name>add</name><operator>-&gt;</operator><name>identity</name></name></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>mult</name><operator>-&gt;</operator><name>ztype</name></name> <operator>==</operator> <name><name>add</name><operator>-&gt;</operator><name>op</name><operator>-&gt;</operator><name>ztype</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>mult</name><operator>-&gt;</operator><name>ztype</name></name> <operator>==</operator> <name><name>C</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <decl_stmt><decl><type><name>GxB_binary_function</name></type> <name>fmult</name> <init>= <expr><name><name>mult</name><operator>-&gt;</operator><name>binop_function</name></name></expr></init></decl> ;</decl_stmt>    <comment type="line">// NULL if positional</comment>
    <decl_stmt><decl><type><name>GxB_binary_function</name></type> <name>fadd</name>  <init>= <expr><name><name>add</name><operator>-&gt;</operator><name>op</name><operator>-&gt;</operator><name>binop_function</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_Opcode</name></type> <name>opcode</name> <init>= <expr><name><name>mult</name><operator>-&gt;</operator><name>opcode</name></name></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>csize</name> <init>= <expr><name><name>C</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>asize</name> <init>= <expr><ternary><condition><expr><name>A_is_pattern</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>A</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>size</name></name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>bsize</name> <init>= <expr><ternary><condition><expr><name>B_is_pattern</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>B</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>size</name></name></expr></else></ternary></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>xsize</name> <init>= <expr><name><name>mult</name><operator>-&gt;</operator><name>xtype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>ysize</name> <init>= <expr><name><name>mult</name><operator>-&gt;</operator><name>ytype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>

    <comment type="line">// scalar workspace: because of typecasting, the x/y types need not</comment>
    <comment type="line">// be the same as the size of the A and B types.</comment>
    <comment type="line">// FLIPXY false: aik = (xtype) A(i,k) and bkj = (ytype) B(k,j)</comment>
    <comment type="line">// FLIPXY true:  aik = (ytype) A(i,k) and bkj = (xtype) B(k,j)</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>aik_size</name> <init>= <expr><ternary><condition><expr><name>FLIPXY</name></expr> ?</condition><then> <expr><name>ysize</name></expr> </then><else>: <expr><name>xsize</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>bkj_size</name> <init>= <expr><ternary><condition><expr><name>FLIPXY</name></expr> ?</condition><then> <expr><name>xsize</name></expr> </then><else>: <expr><name>ysize</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>GB_cast_function</name></type> <name>cast_A</name></decl>, <decl><type ref="prev"/><name>cast_B</name></decl> ;</decl_stmt>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FLIPXY</name></expr></cpp:if>
    <block>{<block_content> 
        <comment type="line">// A is typecasted to y, and B is typecasted to x</comment>
        <expr_stmt><expr><name>cast_A</name> <operator>=</operator> <ternary><condition><expr><name>A_is_pattern</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: 
                 <expr><call><name>GB_cast_factory</name> <argument_list>(<argument><expr><name><name>mult</name><operator>-&gt;</operator><name>ytype</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
        <expr_stmt><expr><name>cast_B</name> <operator>=</operator> <ternary><condition><expr><name>B_is_pattern</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: 
                 <expr><call><name>GB_cast_factory</name> <argument_list>(<argument><expr><name><name>mult</name><operator>-&gt;</operator><name>xtype</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>B</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
    </block_content>}</block>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <block>{<block_content> 
        <comment type="line">// A is typecasted to x, and B is typecasted to y</comment>
        <expr_stmt><expr><name>cast_A</name> <operator>=</operator> <ternary><condition><expr><name>A_is_pattern</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
                 <expr><call><name>GB_cast_factory</name> <argument_list>(<argument><expr><name><name>mult</name><operator>-&gt;</operator><name>xtype</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
        <expr_stmt><expr><name>cast_B</name> <operator>=</operator> <ternary><condition><expr><name>B_is_pattern</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
                 <expr><call><name>GB_cast_factory</name> <argument_list>(<argument><expr><name><name>mult</name><operator>-&gt;</operator><name>ytype</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>B</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
    </block_content>}</block>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// C = A*B via saxpy3 or bitmap method, function pointers, and typecasting</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// memcpy (&amp;(Cx [pC]), &amp;(Hx [i]), len*csize)</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CIJ_MEMCPY</name><parameter_list>(<parameter><type><name>pC</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy (GB_CX (pC), GB_HX (i), (len)*csize)</cpp:value></cpp:define>

    <comment type="line">// atomic update not available for function pointers</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_HAS_ATOMIC</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

    <comment type="line">// user-defined monoid update cannot be done with an OpenMP atomic</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_HAS_OMP_ATOMIC</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

    <comment type="line">// no special cases (C is not iso)</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_ANY_MONOID</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_ANY_FC32_MONOID</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_ANY_FC64_MONOID</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_PLUS_FC32_MONOID</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_PLUS_FC64_MONOID</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_ANY_PAIR_SEMIRING</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_PAIR_MULTIPLIER</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_ATYPE</name></cpp:macro> <cpp:value>GB_void</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BTYPE</name></cpp:macro> <cpp:value>GB_void</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_ASIZE</name></cpp:macro> <cpp:value>asize</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BSIZE</name></cpp:macro> <cpp:value>bsize</cpp:value></cpp:define>

    <comment type="line">// no vectorization</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_PRAGMA_SIMD_VECTORIZE</name></cpp:macro> <cpp:value>;</cpp:value></cpp:define>

    <comment type="line">// The monoid identity byte value is not used in saxpy3</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_GENERIC</name></cpp:macro></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_HAS_IDENTITY_BYTE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IDENTITY_BYTE</name></cpp:macro> <cpp:value>(none)</cpp:value></cpp:define>

    <comment type="line">// definitions for GB_AxB_saxpy_generic_template.c</comment>
    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy3_template.h"</cpp:file></cpp:include>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OP_IS_POSITIONAL</name></expr></cpp:if>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// generic semirings with positional mulitiply operators</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><call><name>GB_BURBLE_MATRIX</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"(generic positional C=A*B) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">// C always has type int64_t or int32_t.  The monoid must be used via</comment>
        <comment type="line">// its function pointer.  The positional multiply operator must be</comment>
        <comment type="line">// hard-coded since it has no function pointer.  The numerical values</comment>
        <comment type="line">// and types of A and B are not accessed.</comment>

        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>A_is_pattern</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>B_is_pattern</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">// aik = A(i,k), located in Ax [A_iso ? 0:pA], value not used</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_A_IS_PATTERN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_GETA</name><parameter_list>(<parameter><type><name>aik</name></type></parameter>,<parameter><type><name>Ax</name></type></parameter>,<parameter><type><name>pA</name></type></parameter>,<parameter><type><name>A_iso</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>;</cpp:value></cpp:define>

        <comment type="line">// bkj = B(k,j), located in Bx [B_iso ? 0:pB], value not used</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_B_IS_PATTERN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_GETB</name><parameter_list>(<parameter><type><name>bkj</name></type></parameter>,<parameter><type><name>Bx</name></type></parameter>,<parameter><type><name>pB</name></type></parameter>,<parameter><type><name>B_iso</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>;</cpp:value></cpp:define>

        <comment type="line">// Gx [pG] = A(i,k), located in Ax [A_iso ? 0:pA], value not used</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_LOADA</name><parameter_list>(<parameter><type><name>Gx</name></type></parameter>,<parameter><type><name>pG</name></type></parameter>,<parameter><type><name>Ax</name></type></parameter>,<parameter><type><name>pA</name></type></parameter>,<parameter><type><name>A_iso</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>;</cpp:value></cpp:define>

        <comment type="line">// Gx [pG] = B(k,j), located in Bx [B_iso ? 0:pB], value not used</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_LOADB</name><parameter_list>(<parameter><type><name>Gx</name></type></parameter>,<parameter><type><name>pG</name></type></parameter>,<parameter><type><name>Bx</name></type></parameter>,<parameter><type><name>pB</name></type></parameter>,<parameter><type><name>B_iso</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>;</cpp:value></cpp:define>

        <comment type="line">// define t for each task</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CIJ_DECLARE</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GB_CTYPE t</cpp:value></cpp:define>

        <comment type="line">// address of Cx [p]</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CX</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;Cx [p])</cpp:value></cpp:define>

        <comment type="line">// Cx [p] = t</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CIJ_WRITE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Cx [p] = t</cpp:value></cpp:define>

        <comment type="line">// address of Hx [i]</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_HX</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;Hx [i])</cpp:value></cpp:define>

        <comment type="line">// Hx [i] = t</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_HX_WRITE</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Hx [i] = t</cpp:value></cpp:define>

        <comment type="line">// Cx [p] = Hx [i]</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CIJ_GATHER</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Cx [p] = Hx [i]</cpp:value></cpp:define>

        <comment type="line">// Cx [p] += Hx [i]</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CIJ_GATHER_UPDATE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fadd (GB_CX (p), GB_CX (p), GB_HX (i))</cpp:value></cpp:define>

        <comment type="line">// Cx [p] += t</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CIJ_UPDATE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fadd (GB_CX (p), GB_CX (p), &amp;t)</cpp:value></cpp:define>

        <comment type="line">// Hx [i] += t</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_HX_UPDATE</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fadd (GB_HX (i), GB_HX (i), &amp;t)</cpp:value></cpp:define>

        <comment type="line">// the original multiplier op may have been flipped, but the offset</comment>
        <comment type="line">// is unchanged</comment>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>offset</name> <init>= <expr><call><name>GB_positional_offset</name> <argument_list>(<argument><expr><name><name>mult</name><operator>-&gt;</operator><name>opcode</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OP_IS_INT64</name></expr></cpp:if>
        <block>{<block_content>
            <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_CTYPE</name></cpp:undef>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CTYPE</name></cpp:macro> <cpp:value>int64_t</cpp:value></cpp:define>
            <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_CSIZE</name></cpp:undef>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CSIZE</name></cpp:macro> <cpp:value>(sizeof (int64_t))</cpp:value></cpp:define>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>GrB_INT64</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>csize</name> <operator>==</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OP_IS_FIRSTI</name></expr></cpp:if>
            <block>{<block_content> 
                <comment type="line">// GB_FIRSTI_binop_code   :   // z = first_i(A(i,k),y) == i</comment>
                <comment type="line">// GB_FIRSTI1_binop_code  :   // z = first_i1(A(i,k),y) == i+1</comment>
                <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_MULT</name></cpp:undef>
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>aik</name></type></parameter>, <parameter><type><name>bkj</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>t = i + offset</cpp:value></cpp:define>
                <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy_generic_template.c"</cpp:file></cpp:include>
            </block_content>}</block>
            <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>OP_IS_FIRSTJ</name></expr></cpp:elif>
            <block>{<block_content> 
                <comment type="line">// GB_FIRSTJ_binop_code   :   // z = first_j(A(i,k),y) == k</comment>
                <comment type="line">// GB_FIRSTJ1_binop_code  :   // z = first_j1(A(i,k),y) == k+1</comment>
                <comment type="line">// GB_SECONDI_binop_code  :   // z = second_i(x,B(k,j)) == k</comment>
                <comment type="line">// GB_SECONDI1_binop_code :   // z = second_i1(x,B(k,j))== k+1</comment>
                <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_MULT</name></cpp:undef>
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>aik</name></type></parameter>, <parameter><type><name>bkj</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>t = k + offset</cpp:value></cpp:define>
                <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy_generic_template.c"</cpp:file></cpp:include>
            </block_content>}</block>
            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <block>{<block_content> 
                <comment type="line">// GB_SECONDJ_binop_code  :   // z = second_j(x,B(k,j)) == j</comment>
                <comment type="line">// GB_SECONDJ1_binop_code :   // z = second_j1(x,B(k,j))== j+1</comment>
                <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_MULT</name></cpp:undef>
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>aik</name></type></parameter>, <parameter><type><name>bkj</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>t = j + offset</cpp:value></cpp:define>
                <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy_generic_template.c"</cpp:file></cpp:include>
            </block_content>}</block>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <block>{<block_content>
            <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_CTYPE</name></cpp:undef>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CTYPE</name></cpp:macro> <cpp:value>int32_t</cpp:value></cpp:define>
            <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_CSIZE</name></cpp:undef>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CSIZE</name></cpp:macro> <cpp:value>(sizeof (int32_t))</cpp:value></cpp:define>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>GrB_INT32</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>csize</name> <operator>==</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OP_IS_FIRSTI</name></expr></cpp:if>
            <block>{<block_content> 
                <comment type="line">// GB_FIRSTI_binop_code   :   // z = first_i(A(i,k),y) == i</comment>
                <comment type="line">// GB_FIRSTI1_binop_code  :   // z = first_i1(A(i,k),y) == i+1</comment>
                <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_MULT</name></cpp:undef>
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>aik</name></type></parameter>,<parameter><type><name>bkj</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>k</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>t = (int32_t) (i + offset)</cpp:value></cpp:define>
                <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy_generic_template.c"</cpp:file></cpp:include>
            </block_content>}</block>
            <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>OP_IS_FIRSTJ</name></expr></cpp:elif>
            <block>{<block_content> 
                <comment type="line">// GB_FIRSTJ_binop_code   :   // z = first_j(A(i,k),y) == k</comment>
                <comment type="line">// GB_FIRSTJ1_binop_code  :   // z = first_j1(A(i,k),y) == k+1</comment>
                <comment type="line">// GB_SECONDI_binop_code  :   // z = second_i(x,B(k,j)) == k</comment>
                <comment type="line">// GB_SECONDI1_binop_code :   // z = second_i1(x,B(k,j))== k+1</comment>
                <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_MULT</name></cpp:undef>
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>aik</name></type></parameter>,<parameter><type><name>bkj</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>k</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>t = (int32_t) (k + offset)</cpp:value></cpp:define>
                <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy_generic_template.c"</cpp:file></cpp:include>
            </block_content>}</block>
            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <block>{<block_content> 
                <comment type="line">// GB_SECONDJ_binop_code  :   // z = second_j(x,B(k,j)) == j</comment>
                <comment type="line">// GB_SECONDJ1_binop_code :   // z = second_j1(x,B(k,j))== j+1</comment>
                <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_MULT</name></cpp:undef>
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>aik</name></type></parameter>,<parameter><type><name>bkj</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>k</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>t = (int32_t) (j + offset)</cpp:value></cpp:define>
                <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy_generic_template.c"</cpp:file></cpp:include>
            </block_content>}</block>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </block_content>}</block>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// generic semirings with standard multiply operators</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><call><name>GB_BURBLE_MATRIX</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"(generic C=A*B) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">// aik = A(i,k), located in Ax [A_iso ? 0:pA]</comment>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_A_IS_PATTERN</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_A_IS_PATTERN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_GETA</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_GETA</name><parameter_list>(<parameter><type><name>aik</name></type></parameter>,<parameter><type><name>Ax</name></type></parameter>,<parameter><type><name>pA</name></type></parameter>,<parameter><type><name>A_iso</name></type></parameter>)</parameter_list></cpp:macro>                                    \
            <cpp:value>GB_void aik [GB_VLA(aik_size)] ;                                \
            if (!A_is_pattern)                                              \
            {                                                               \
                cast_A (aik, Ax +((A_iso) ? 0:((pA)*asize)), asize) ;       \
            }</cpp:value></cpp:define>

        <comment type="line">// bkj = B(k,j), located in Bx [B_iso ? 0:pB]</comment>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_B_IS_PATTERN</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_B_IS_PATTERN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_GETB</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_GETB</name><parameter_list>(<parameter><type><name>bkj</name></type></parameter>,<parameter><type><name>Bx</name></type></parameter>,<parameter><type><name>pB</name></type></parameter>,<parameter><type><name>B_iso</name></type></parameter>)</parameter_list></cpp:macro>                                    \
            <cpp:value>GB_void bkj [GB_VLA(bkj_size)] ;                                \
            if (!B_is_pattern)                                              \
            {                                                               \
                cast_B (bkj, Bx +((B_iso) ? 0:((pB)*bsize)), bsize) ;       \
            }</cpp:value></cpp:define>

        <comment type="line">// Gx [pG] = A(i,k), located in Ax [A_iso ? 0:pA], no typecasting</comment>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_LOADA</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_LOADA</name><parameter_list>(<parameter><type><name>Gx</name></type></parameter>,<parameter><type><name>pG</name></type></parameter>,<parameter><type><name>Ax</name></type></parameter>,<parameter><type><name>pA</name></type></parameter>,<parameter><type><name>A_iso</name></type></parameter>)</parameter_list></cpp:macro>                                 \
            <cpp:value>memcpy (Gx + ((pG)*asize), Ax +((A_iso) ? 0:((pA)*asize)), asize)</cpp:value></cpp:define>

        <comment type="line">// Gx [pG] = B(k,j), located in Bx [B_iso ? 0:pB], no typecasting</comment>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_LOADB</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_LOADB</name><parameter_list>(<parameter><type><name>Gx</name></type></parameter>,<parameter><type><name>pG</name></type></parameter>,<parameter><type><name>Bx</name></type></parameter>,<parameter><type><name>pB</name></type></parameter>,<parameter><type><name>B_iso</name></type></parameter>)</parameter_list></cpp:macro>                                 \
            <cpp:value>memcpy (Gx + ((pG)*bsize), Bx +((B_iso) ? 0:((pB)*bsize)), bsize)</cpp:value></cpp:define>

        <comment type="line">// define t for each task</comment>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_CIJ_DECLARE</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CIJ_DECLARE</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GB_void t [GB_VLA(csize)]</cpp:value></cpp:define>

        <comment type="line">// address of Cx [p]</comment>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_CX</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CX</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(Cx +((p)*csize))</cpp:value></cpp:define>

        <comment type="line">// Cx [p] = t</comment>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_CIJ_WRITE</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CIJ_WRITE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy (GB_CX (p), t, csize)</cpp:value></cpp:define>

        <comment type="line">// address of Hx [i]</comment>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_HX</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_HX</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(Hx +((i)*csize))</cpp:value></cpp:define>

        <comment type="line">// Hx [i] = t</comment>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_HX_WRITE</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_HX_WRITE</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy (GB_HX (i), t, csize)</cpp:value></cpp:define>

        <comment type="line">// Cx [p] = Hx [i]</comment>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_CIJ_GATHER</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CIJ_GATHER</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy (GB_CX (p), GB_HX(i), csize)</cpp:value></cpp:define>

        <comment type="line">// Cx [p] += Hx [i]</comment>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_CIJ_GATHER_UPDATE</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CIJ_GATHER_UPDATE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fadd (GB_CX (p), GB_CX (p), GB_HX (i))</cpp:value></cpp:define>

        <comment type="line">// Cx [p] += t</comment>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_CIJ_UPDATE</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CIJ_UPDATE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fadd (GB_CX (p), GB_CX (p), t)</cpp:value></cpp:define>

        <comment type="line">// Hx [i] += t</comment>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_HX_UPDATE</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_HX_UPDATE</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fadd (GB_HX (i), GB_HX (i), t)</cpp:value></cpp:define>

        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_CTYPE</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CTYPE</name></cpp:macro> <cpp:value>GB_void</cpp:value></cpp:define>

        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_CSIZE</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CSIZE</name></cpp:macro> <cpp:value>csize</cpp:value></cpp:define>

        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OP_IS_FIRST</name></expr></cpp:if>
        <block>{<block_content> 
            <comment type="line">// t = A(i,k)</comment>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>B_is_pattern</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_MULT</name></cpp:undef>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>aik</name></type></parameter>, <parameter><type><name>bkj</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy (t, aik, csize)</cpp:value></cpp:define>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy_generic_template.c"</cpp:file></cpp:include>
        </block_content>}</block>
        <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>OP_IS_SECOND</name></expr></cpp:elif>
        <block>{<block_content> 
            <comment type="line">// t = B(i,k)</comment>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>A_is_pattern</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_MULT</name></cpp:undef>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>aik</name></type></parameter>, <parameter><type><name>bkj</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy (t, bkj, csize)</cpp:value></cpp:define>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy_generic_template.c"</cpp:file></cpp:include>
        </block_content>}</block>
        <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>FLIPXY</name></expr></cpp:elif>
        <block>{<block_content> 
            <comment type="line">// t = B(k,j) * A(i,k)</comment>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>fmult</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_MULT</name></cpp:undef>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>aik</name></type></parameter>, <parameter><type><name>bkj</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fmult (t, bkj, aik)</cpp:value></cpp:define>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy_generic_template.c"</cpp:file></cpp:include>
        </block_content>}</block>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <block>{<block_content> 
            <comment type="line">// t = A(i,k) * B(k,j)</comment>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>fmult</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_MULT</name></cpp:undef>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>aik</name></type></parameter>, <parameter><type><name>bkj</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fmult (t, aik, bkj)</cpp:value></cpp:define>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_saxpy_generic_template.c"</cpp:file></cpp:include>
        </block_content>}</block>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
