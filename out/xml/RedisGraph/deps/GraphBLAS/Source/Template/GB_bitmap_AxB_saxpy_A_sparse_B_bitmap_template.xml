<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" xmlns:omp="http://www.srcML.org/srcML/openmp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/Template/GB_bitmap_AxB_saxpy_A_sparse_B_bitmap_template.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_bitmap_AxB_saxpy_A_sparse_B_bitmap: C&lt;#M&gt;+=A*B, C bitmap, M any format</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// C is bitmap or full. A is hyper/sparse, B is bitmap/full.</comment>

<comment type="line">// if C is bitmap: no accumulator is used</comment>

<comment type="line">// if C is full: C += A*B is computed with the accumulator identical to</comment>
<comment type="line">// the monoid</comment>

<block>{<block_content>

    <if_stmt><if>if <condition>(<expr><name>use_coarse_tasks</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C&lt;#M&gt; += A*B using coarse tasks</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// number of columns in the workspace for each task</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_PANEL_SIZE</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

        <if_stmt><if>if <condition>(<expr><name>B_iso</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// No special cases needed.  GB_GETB handles the B iso case.</comment>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// allocate workspace for each task</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><call><name>GB_WERK_PUSH</name> <argument_list>(<argument><expr><name>H_slice</name></expr></argument>, <argument><expr><name>ntasks</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>H_slice</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// out of memory</comment>
            <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
            <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>int64_t</name></type> <name>hwork</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>tid</name></decl> ;</decl_stmt>
        <for>for <control>(<init><expr><name>tid</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>tid</name> <operator>&lt;</operator> <name>ntasks</name></expr> ;</condition> <incr><expr><name>tid</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>jstart</name></decl>, <decl><type ref="prev"/><name>jend</name></decl> ;</decl_stmt>
            <expr_stmt><expr><call><name>GB_PARTITION</name> <argument_list>(<argument><expr><name>jstart</name></expr></argument>, <argument><expr><name>jend</name></expr></argument>, <argument><expr><name>bvdim</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>ntasks</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>jtask</name> <init>= <expr><name>jend</name> <operator>-</operator> <name>jstart</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>jpanel</name> <init>= <expr><call><name>GB_IMIN</name> <argument_list>(<argument><expr><name>jtask</name></expr></argument>, <argument><expr><name>GB_PANEL_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
            <expr_stmt><expr><name><name>H_slice</name> <index>[<expr><name>tid</name></expr>]</index></name> <operator>=</operator> <name>hwork</name></expr> ;</expr_stmt>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator> <operator>!</operator><name>GB_C_IS_BITMAP</name> <operator>)</operator></expr></cpp:if>
            <comment type="line">// bitmap case always needs Hx workspace; full case only needs it</comment>
            <comment type="line">// if jpanel &gt; 1</comment>
            <if_stmt><if>if <condition>(<expr><name>jpanel</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <block>{<block_content> 
                <expr_stmt><expr><name>hwork</name> <operator>+=</operator> <name>jpanel</name></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><name>int64_t</name></type> <name>cvlenx</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>GB_IS_ANY_PAIR_SEMIRING</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>cvlen</name></expr></else></ternary><operator>)</operator> <operator>*</operator> <name>GB_CSIZE</name></expr></init></decl> ;</decl_stmt>
        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
        <expr_stmt><expr><name>Wf</name>  <operator>=</operator> <call><name>GB_MALLOC_WORK</name> <argument_list>(<argument><expr><name>hwork</name> <operator>*</operator> <name>cvlen</name></expr></argument>, <argument><expr><name>int8_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Wf_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>Wcx</name> <operator>=</operator> <call><name>GB_MALLOC_WORK</name> <argument_list>(<argument><expr><name>hwork</name> <operator>*</operator> <name>cvlenx</name></expr></argument>, <argument><expr><name>GB_void</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Wcx_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>GB_C_IS_BITMAP</name> <operator>&amp;&amp;</operator> <name>Wf</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <name>Wcx</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// out of memory</comment>
            <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
            <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C&lt;#M&gt; += A*B</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nthreads</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>dynamic</omp:expr></omp:argument>,<omp:argument><omp:expr>1</omp:expr></omp:argument>)</omp:argument_list></omp:clause> \
            <omp:clause><omp:name>reduction</omp:name><omp:argument_list>(<omp:argument><omp:expr>+:cnvals</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nthreads</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>dynamic</omp:expr></omp:argument>,<omp:argument><omp:expr>1</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <for>for <control>(<init><expr><name>tid</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>tid</name> <operator>&lt;</operator> <name>ntasks</name></expr> ;</condition> <incr><expr><name>tid</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// determine the vectors of B and C for this coarse task</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>jstart</name></decl>, <decl><type ref="prev"/><name>jend</name></decl> ;</decl_stmt>
            <expr_stmt><expr><call><name>GB_PARTITION</name> <argument_list>(<argument><expr><name>jstart</name></expr></argument>, <argument><expr><name>jend</name></expr></argument>, <argument><expr><name>bvdim</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>ntasks</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>jtask</name> <init>= <expr><name>jend</name> <operator>-</operator> <name>jstart</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>jpanel</name> <init>= <expr><call><name>GB_IMIN</name> <argument_list>(<argument><expr><name>jtask</name></expr></argument>, <argument><expr><name>GB_PANEL_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>task_cnvals</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// get the workspace for this task</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <comment type="line">// Hf and Hx workspace to compute the panel of C</comment>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
            <decl_stmt><decl><type><name>int8_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hf</name> <init>= <expr><name>Wf</name> <operator>+</operator> <operator>(</operator><name><name>H_slice</name> <index>[<expr><name>tid</name></expr>]</index></name> <operator>*</operator> <name>cvlen</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator> <operator>!</operator><name>GB_IS_ANY_PAIR_SEMIRING</name> <operator>)</operator></expr></cpp:if>
            <decl_stmt><decl><type><name>GB_CTYPE</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hx</name> <init>= <expr><operator>(</operator><name>GB_CTYPE</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>Wcx</name> <operator>+</operator> <name><name>H_slice</name> <index>[<expr><name>tid</name></expr>]</index></name> <operator>*</operator> <name>cvlenx</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// clear the panel</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
            <expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>Hf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>jpanel</name> <operator>*</operator> <name>cvlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// C&lt;#M&gt;(:,jstart:jend-1) += A * B(:,jstart:jend-1) by panel</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>j1</name> <init>= <expr><name>jstart</name></expr></init></decl> ;</init> <condition><expr><name>j1</name> <operator>&lt;</operator> <name>jend</name></expr> ;</condition> <incr><expr><name>j1</name> <operator>+=</operator> <name>jpanel</name></expr></incr>)</control>
            <block>{<block_content>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// get the panel of np vectors j1:j2-1</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <decl_stmt><decl><type><name>int64_t</name></type> <name>j2</name> <init>= <expr><call><name>GB_IMIN</name> <argument_list>(<argument><expr><name>jend</name></expr></argument>, <argument><expr><name>j1</name> <operator>+</operator> <name>jpanel</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>np</name> <init>= <expr><name>j2</name> <operator>-</operator> <name>j1</name></expr></init></decl> ;</decl_stmt>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// G = B(:,j1:j2-1), of size bvlen-by-np, in column major order</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <decl_stmt><decl><type><name>int8_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Gb</name> <init>= <expr><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>Bb</name> <operator>+</operator> <operator>(</operator><name>j1</name> <operator>*</operator> <name>bvlen</name><operator>)</operator><operator>)</operator></expr></init></decl> ;</decl_stmt>
                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator> <operator>!</operator><name>GB_IS_ANY_PAIR_SEMIRING</name> <operator>)</operator></expr></cpp:if>
                <decl_stmt><decl><type><name>GB_BTYPE</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Gx</name> <init>= <expr><operator>(</operator><name>GB_BTYPE</name> <operator>*</operator><operator>)</operator>
                     <operator>(</operator><operator>(</operator><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>B</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator><operator>)</operator> <operator>+</operator>
                       <operator>(</operator><ternary><condition><expr><name>B_iso</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>j1</name> <operator>*</operator> <name>bvlen</name><operator>)</operator> <operator>*</operator> <name>GB_BSIZE</name><operator>)</operator></expr></else></ternary><operator>)</operator><operator>)</operator></expr></init></decl> ;</decl_stmt>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// clear the panel H to compute C(:,j1:j2-1)</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator> <operator>!</operator><name>GB_C_IS_BITMAP</name> <operator>)</operator></expr></cpp:if>
                <if_stmt><if>if <condition>(<expr><name>np</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// Make H an alias to C(:,j1)</comment>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>j</name> <init>= <expr><name>j1</name></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>pC_start</name> <init>= <expr><name>j</name> <operator>*</operator> <name>cvlen</name></expr></init></decl> ;</decl_stmt>    <comment type="line">// get pointer to C(:,j)</comment>
                    <expr_stmt><expr><name>Hx</name> <operator>=</operator> <name>Cx</name> <operator>+</operator> <name>pC_start</name></expr> ;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content> 
                    <comment type="line">// Hx = identity</comment>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>nc</name> <init>= <expr><name>np</name> <operator>*</operator> <name>cvlen</name></expr></init></decl> ;</decl_stmt>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_HAS_IDENTITY_BYTE</name></expr></cpp:if>
                        <expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>Hx</name></expr></argument>, <argument><expr><name>GB_IDENTITY_BYTE</name></expr></argument>, <argument><expr><name>nc</name> <operator>*</operator> <name>GB_CSIZE</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nc</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content> 
                            <expr_stmt><expr><name><name>Hx</name> <index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>GB_IDENTITY</name></expr> ;</expr_stmt>
                        </block_content>}</block></for>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></else></if_stmt>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_IS_PLUS_FC32_MONOID</name></expr></cpp:if>
                <decl_stmt><decl><type><name>float</name>  <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hx_real</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator> <name>Hx</name></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>float</name>  <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hx_imag</name> <init>= <expr><name>Hx_real</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>GB_IS_PLUS_FC64_MONOID</name></expr></cpp:elif>
                <decl_stmt><decl><type><name>double</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hx_real</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator> <name>Hx</name></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>double</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hx_imag</name> <init>= <expr><name>Hx_real</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// H += A*G for one panel</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_B_kj_PRESENT</name></cpp:undef>
                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_B_IS_BITMAP</name></expr></cpp:if>
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_B_kj_PRESENT</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>b</cpp:value></cpp:define>
                <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_B_kj_PRESENT</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_MULT_A_ik_G_kj</name></cpp:undef>
                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_IS_PAIR_MULTIPLIER</name></expr></cpp:if>
                    <comment type="line">// t = A(i,k) * B (k,j) is already #defined as 1</comment>
                    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT_A_ik_G_kj</name><parameter_list>(<parameter><type><name>gkj</name></type></parameter>,<parameter><type><name>jj</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
                <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <comment type="line">// t = A(i,k) * B (k,j)</comment>
                    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT_A_ik_G_kj</name><parameter_list>(<parameter><type><name>gkj</name></type></parameter>,<parameter><type><name>jj</name></type></parameter>)</parameter_list></cpp:macro>                       \
                        <cpp:value>GB_CIJ_DECLARE (t) ;                                \
                        GB_MULT (t, aik, gkj, i, k, j1 + jj)</cpp:value></cpp:define>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_HX_COMPUTE</name></cpp:undef>
                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
                    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_HX_COMPUTE</name><parameter_list>(<parameter><type><name>gkj</name></type></parameter>,<parameter><type><name>gb</name></type></parameter>,<parameter><type><name>jj</name></type></parameter>)</parameter_list></cpp:macro>                        \
                    <cpp:value>{                                                       \
                        <comment type="block">/* H (i,jj) += A(i,k) * B(k,j) */</comment>                   \
                        if (GB_B_kj_PRESENT (gb))                           \
                        {                                                   \
                            <comment type="block">/* t = A(i,k) * B (k,j) */</comment>                      \
                            GB_MULT_A_ik_G_kj (gkj, jj) ;                   \
                            if (Hf [pH+jj] == 0)                            \
                            {                                               \
                                <comment type="block">/* H(i,jj) is a new entry */</comment>                \
                                GB_HX_WRITE (pH+jj, t) ; <comment type="block">/* Hx(i,jj)=t */</comment>   \
                                Hf [pH+jj] = 1 ;                            \
                            }                                               \
                            else                                            \
                            {                                               \
                                <comment type="block">/* H(i,jj) is already present */</comment>            \
                                <comment type="block">/* Hx(i,jj)+=t */</comment>                           \
                                GB_HX_UPDATE (pH+jj, t) ;                   \
                            }                                               \
                        }                                                   \
                    }</cpp:value></cpp:define>
                <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_HX_COMPUTE</name><parameter_list>(<parameter><type><name>gkj</name></type></parameter>,<parameter><type><name>gb</name></type></parameter>,<parameter><type><name>jj</name></type></parameter>)</parameter_list></cpp:macro>                        \
                    <cpp:value>{                                                       \
                        <comment type="block">/* H (i,jj) += A(i,k) * B(k,j) */</comment>                   \
                        if (GB_B_kj_PRESENT (gb))                           \
                        {                                                   \
                            <comment type="block">/* t = A(i,k) * B (k,j) */</comment>                      \
                            GB_MULT_A_ik_G_kj (gkj, jj) ;                   \
                            <comment type="block">/* Hx(i,jj)+=t */</comment>                               \
                            GB_HX_UPDATE (pH+jj, t) ;                       \
                        }                                                   \
                    }</cpp:value></cpp:define>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <switch>switch <condition>(<expr><name>np</name></expr>)</condition>
                <block>{<block_content>

                    <case>case <expr><literal type="number">4</literal></expr> :</case> 

                        <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>kA</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>kA</name> <operator>&lt;</operator> <name>anvec</name></expr> ;</condition> <incr><expr><name>kA</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <comment type="line">// get A(:,k)</comment>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>k</name> <init>= <expr><call><name>GBH</name> <argument_list>(<argument><expr><name>Ah</name></expr></argument>, <argument><expr><name>kA</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                            <comment type="line">// get B(k,j1:j2-1)</comment>
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_B_IS_BITMAP</name></expr></cpp:if>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>int8_t</name></type> <name>gb0</name> <init>= <expr><name><name>Gb</name> <index>[<expr><name>k</name></expr>          ]</index></name></expr></init></decl> ;</decl_stmt>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>int8_t</name></type> <name>gb1</name> <init>= <expr><name><name>Gb</name> <index>[<expr><name>k</name> <operator>+</operator>   <name>bvlen</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>int8_t</name></type> <name>gb2</name> <init>= <expr><name><name>Gb</name> <index>[<expr><name>k</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>bvlen</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>int8_t</name></type> <name>gb3</name> <init>= <expr><name><name>Gb</name> <index>[<expr><name>k</name> <operator>+</operator> <literal type="number">3</literal><operator>*</operator><name>bvlen</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>gb0</name> <operator>||</operator> <name>gb1</name> <operator>||</operator> <name>gb2</name> <operator>||</operator> <name>gb3</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>gk0</name></expr></argument>, <argument><expr><name>Gx</name></expr></argument>, <argument><expr><name>k</name></expr></argument>          , <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>gk1</name></expr></argument>, <argument><expr><name>Gx</name></expr></argument>, <argument><expr><name>k</name> <operator>+</operator>   <name>bvlen</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>gk2</name></expr></argument>, <argument><expr><name>Gx</name></expr></argument>, <argument><expr><name>k</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>bvlen</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>gk3</name></expr></argument>, <argument><expr><name>Gx</name></expr></argument>, <argument><expr><name>k</name> <operator>+</operator> <literal type="number">3</literal><operator>*</operator><name>bvlen</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <comment type="line">// H += A(:,k)*B(k,j1:j2-1)</comment>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>pA_end</name> <init>= <expr><name><name>Ap</name> <index>[<expr><name>kA</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>pA</name> <init>= <expr><name><name>Ap</name> <index>[<expr><name>kA</name></expr>]</index></name></expr></init></decl> ;</init> <condition><expr><name>pA</name> <operator>&lt;</operator> <name>pA_end</name></expr> ;</condition> <incr><expr><name>pA</name><operator>++</operator></expr></incr>)</control>
                            <block>{<block_content> 
                                <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                                <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>pH</name> <init>= <expr><name>i</name> <operator>*</operator> <literal type="number">4</literal></expr></init></decl> ;</decl_stmt>
                                <expr_stmt><expr><call><name>GB_GETA</name> <argument_list>(<argument><expr><name>aik</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_HX_COMPUTE</name> <argument_list>(<argument><expr><name>gk0</name></expr></argument>, <argument><expr><name>gb0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_HX_COMPUTE</name> <argument_list>(<argument><expr><name>gk1</name></expr></argument>, <argument><expr><name>gb1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_HX_COMPUTE</name> <argument_list>(<argument><expr><name>gk2</name></expr></argument>, <argument><expr><name>gb2</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_HX_COMPUTE</name> <argument_list>(<argument><expr><name>gk3</name></expr></argument>, <argument><expr><name>gb3</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block></for>
                        </block_content>}</block></for>
                        <break>break ;</break>

                    <case>case <expr><literal type="number">3</literal></expr> :</case> 

                        <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>kA</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>kA</name> <operator>&lt;</operator> <name>anvec</name></expr> ;</condition> <incr><expr><name>kA</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <comment type="line">// get A(:,k)</comment>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>k</name> <init>= <expr><call><name>GBH</name> <argument_list>(<argument><expr><name>Ah</name></expr></argument>, <argument><expr><name>kA</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                            <comment type="line">// get B(k,j1:j2-1)</comment>
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_B_IS_BITMAP</name></expr></cpp:if>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>int8_t</name></type> <name>gb0</name> <init>= <expr><name><name>Gb</name> <index>[<expr><name>k</name></expr>          ]</index></name></expr></init></decl> ;</decl_stmt>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>int8_t</name></type> <name>gb1</name> <init>= <expr><name><name>Gb</name> <index>[<expr><name>k</name> <operator>+</operator>   <name>bvlen</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>int8_t</name></type> <name>gb2</name> <init>= <expr><name><name>Gb</name> <index>[<expr><name>k</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>bvlen</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>gb0</name> <operator>||</operator> <name>gb1</name> <operator>||</operator> <name>gb2</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>gk0</name></expr></argument>, <argument><expr><name>Gx</name></expr></argument>, <argument><expr><name>k</name></expr></argument>          , <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>gk1</name></expr></argument>, <argument><expr><name>Gx</name></expr></argument>, <argument><expr><name>k</name> <operator>+</operator>   <name>bvlen</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>gk2</name></expr></argument>, <argument><expr><name>Gx</name></expr></argument>, <argument><expr><name>k</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>bvlen</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <comment type="line">// H += A(:,k)*B(k,j1:j2-1)</comment>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>pA_end</name> <init>= <expr><name><name>Ap</name> <index>[<expr><name>kA</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>pA</name> <init>= <expr><name><name>Ap</name> <index>[<expr><name>kA</name></expr>]</index></name></expr></init></decl> ;</init> <condition><expr><name>pA</name> <operator>&lt;</operator> <name>pA_end</name></expr> ;</condition> <incr><expr><name>pA</name><operator>++</operator></expr></incr>)</control>
                            <block>{<block_content> 
                                <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                                <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>pH</name> <init>= <expr><name>i</name> <operator>*</operator> <literal type="number">3</literal></expr></init></decl> ;</decl_stmt>
                                <expr_stmt><expr><call><name>GB_GETA</name> <argument_list>(<argument><expr><name>aik</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_HX_COMPUTE</name> <argument_list>(<argument><expr><name>gk0</name></expr></argument>, <argument><expr><name>gb0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_HX_COMPUTE</name> <argument_list>(<argument><expr><name>gk1</name></expr></argument>, <argument><expr><name>gb1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_HX_COMPUTE</name> <argument_list>(<argument><expr><name>gk2</name></expr></argument>, <argument><expr><name>gb2</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block></for>
                        </block_content>}</block></for>
                        <break>break ;</break>

                    <case>case <expr><literal type="number">2</literal></expr> :</case> 

                        <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>kA</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>kA</name> <operator>&lt;</operator> <name>anvec</name></expr> ;</condition> <incr><expr><name>kA</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <comment type="line">// get A(:,k)</comment>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>k</name> <init>= <expr><call><name>GBH</name> <argument_list>(<argument><expr><name>Ah</name></expr></argument>, <argument><expr><name>kA</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                            <comment type="line">// get B(k,j1:j2-1)</comment>
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_B_IS_BITMAP</name></expr></cpp:if>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>int8_t</name></type> <name>gb0</name> <init>= <expr><name><name>Gb</name> <index>[<expr><name>k</name></expr>          ]</index></name></expr></init></decl> ;</decl_stmt>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>int8_t</name></type> <name>gb1</name> <init>= <expr><name><name>Gb</name> <index>[<expr><name>k</name> <operator>+</operator>   <name>bvlen</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>gb0</name> <operator>||</operator> <name>gb1</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <comment type="line">// H += A(:,k)*B(k,j1:j2-1)</comment>
                            <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>gk0</name></expr></argument>, <argument><expr><name>Gx</name></expr></argument>, <argument><expr><name>k</name></expr></argument>          , <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>gk1</name></expr></argument>, <argument><expr><name>Gx</name></expr></argument>, <argument><expr><name>k</name> <operator>+</operator>   <name>bvlen</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>pA_end</name> <init>= <expr><name><name>Ap</name> <index>[<expr><name>kA</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>pA</name> <init>= <expr><name><name>Ap</name> <index>[<expr><name>kA</name></expr>]</index></name></expr></init></decl> ;</init> <condition><expr><name>pA</name> <operator>&lt;</operator> <name>pA_end</name></expr> ;</condition> <incr><expr><name>pA</name><operator>++</operator></expr></incr>)</control>
                            <block>{<block_content> 
                                <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                                <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>pH</name> <init>= <expr><name>i</name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl> ;</decl_stmt>
                                <expr_stmt><expr><call><name>GB_GETA</name> <argument_list>(<argument><expr><name>aik</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_HX_COMPUTE</name> <argument_list>(<argument><expr><name>gk0</name></expr></argument>, <argument><expr><name>gb0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_HX_COMPUTE</name> <argument_list>(<argument><expr><name>gk1</name></expr></argument>, <argument><expr><name>gb1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block></for>
                        </block_content>}</block></for>
                        <break>break ;</break>

                    <case>case <expr><literal type="number">1</literal></expr> :</case> 

                        <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>kA</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>kA</name> <operator>&lt;</operator> <name>anvec</name></expr> ;</condition> <incr><expr><name>kA</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <comment type="line">// get A(:,k)</comment>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>k</name> <init>= <expr><call><name>GBH</name> <argument_list>(<argument><expr><name>Ah</name></expr></argument>, <argument><expr><name>kA</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                            <comment type="line">// get B(k,j1:j2-1) where j1 == j2-1</comment>
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_B_IS_BITMAP</name></expr></cpp:if>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>int8_t</name></type> <name>gb0</name> <init>= <expr><name><name>Gb</name> <index>[<expr><name>k</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>gb0</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <comment type="line">// H += A(:,k)*B(k,j1:j2-1)</comment>
                            <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>gk0</name></expr></argument>, <argument><expr><name>Gx</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>pA_end</name> <init>= <expr><name><name>Ap</name> <index>[<expr><name>kA</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>pA</name> <init>= <expr><name><name>Ap</name> <index>[<expr><name>kA</name></expr>]</index></name></expr></init></decl> ;</init> <condition><expr><name>pA</name> <operator>&lt;</operator> <name>pA_end</name></expr> ;</condition> <incr><expr><name>pA</name><operator>++</operator></expr></incr>)</control>
                            <block>{<block_content> 
                                <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                                <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>pH</name> <init>= <expr><name>i</name></expr></init></decl> ;</decl_stmt>
                                <expr_stmt><expr><call><name>GB_GETA</name> <argument_list>(<argument><expr><name>aik</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_HX_COMPUTE</name> <argument_list>(<argument><expr><name>gk0</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block></for>
                        </block_content>}</block></for>
                        <break>break ;</break>

                    <default>default:</default><empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>

                <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_HX_COMPUTE</name></cpp:undef>
                <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_B_kj_PRESENT</name></cpp:undef>
                <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_MULT_A_ik_G_kj</name></cpp:undef>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// C&lt;#M&gt;(:,j1:j2-1) = H</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator> <operator>!</operator><name>GB_C_IS_BITMAP</name> <operator>)</operator></expr></cpp:if>
                <if_stmt><if>if <condition>(<expr><name>np</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// Hx is already aliased to Cx; no more work to do</comment>
                    <continue>continue ;</continue>
                </block_content>}</block></if></if_stmt>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>jj</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>jj</name> <operator>&lt;</operator> <name>np</name></expr> ;</condition> <incr><expr><name>jj</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// C&lt;#M&gt;(:,j) = H (:,jj)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <decl_stmt><decl><type><name>int64_t</name></type> <name>j</name> <init>= <expr><name>j1</name> <operator>+</operator> <name>jj</name></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>pC_start</name> <init>= <expr><name>j</name> <operator>*</operator> <name>cvlen</name></expr></init></decl> ;</decl_stmt>  <comment type="line">// get pointer to C(:,j)</comment>

                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cvlen</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>pC</name> <init>= <expr><name>pC_start</name> <operator>+</operator> <name>i</name></expr></init></decl> ;</decl_stmt>     <comment type="line">// pointer to C(i,j)</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>pH</name> <init>= <expr><name>i</name> <operator>*</operator> <name>np</name> <operator>+</operator> <name>jj</name></expr></init></decl> ;</decl_stmt>      <comment type="line">// pointer to H(i,jj)</comment>
                        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>Hf</name> <index>[<expr><name>pH</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>
                        <expr_stmt><expr><name><name>Hf</name> <index>[<expr><name>pH</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>                   <comment type="line">// clear the panel</comment>
                        <decl_stmt><decl><type><name>int8_t</name></type> <name>cb</name> <init>= <expr><name><name>Cb</name> <index>[<expr><name>pC</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                        <comment type="line">//------------------------------------------------------</comment>
                        <comment type="line">// check M(i,j)</comment>
                        <comment type="line">//------------------------------------------------------</comment>

                        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_MASK_IS_SPARSE_OR_HYPER</name></expr></cpp:if>

                            <comment type="line">// M is sparse or hypersparse</comment>
                            <decl_stmt><decl><type><name>bool</name></type> <name>mij</name> <init>= <expr><operator>(</operator><operator>(</operator><name>cb</name> <operator>&amp;</operator> <literal type="number">2</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>^</operator> <name>Mask_comp</name></expr></init></decl> ;</decl_stmt>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>mij</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>
                            <expr_stmt><expr><name>cb</name> <operator>=</operator> <operator>(</operator><name>cb</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr> ;</expr_stmt>

                        <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>GB_MASK_IS_BITMAP_OR_FULL</name></expr></cpp:elif>

                            <comment type="line">// M is bitmap or full</comment>
                            <expr_stmt><expr><call><name>GB_GET_M_ij</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><name>mij</name> <operator>=</operator> <name>mij</name> <operator>^</operator> <name>Mask_comp</name></expr> ;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>mij</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>

                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                        <comment type="line">//------------------------------------------------------</comment>
                        <comment type="line">// C(i,j) += H(i,jj)</comment>
                        <comment type="line">//------------------------------------------------------</comment>

                        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
                        <if_stmt><if>if <condition>(<expr><name>cb</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content> 
                            <comment type="line">// C(i,j) = H(i,jj)</comment>
                            <expr_stmt><expr><call><name>GB_CIJ_GATHER</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pH</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><name><name>Cb</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>keep</name></expr> ;</expr_stmt>
                            <expr_stmt><expr><name>task_cnvals</name><operator>++</operator></expr> ;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <comment type="line">// Currently, the matrix C is a newly allocated</comment>
                            <comment type="line">// matrix, not the C_in input matrix to GrB_mxm.</comment>
                            <comment type="line">// As a result, this condition is not used.  It</comment>
                            <comment type="line">// will be in the future when this method is</comment>
                            <comment type="line">// modified to modify C in-place.</comment>
                            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>GB_DEAD_CODE</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <comment type="line">// C(i,j) += H(i,jj)</comment>
                            <expr_stmt><expr><call><name>GB_CIJ_GATHER_UPDATE</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pH</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <block>{<block_content> 
                            <comment type="line">// C(i,j) = H(i,jj)</comment>
                            <expr_stmt><expr><call><name>GB_CIJ_GATHER_UPDATE</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pH</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></for>
                </block_content>}</block></for>
            </block_content>}</block></for>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
            <expr_stmt><expr><name>cnvals</name> <operator>+=</operator> <name>task_cnvals</name></expr> ;</expr_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></for>

        <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_PANEL_SIZE</name></cpp:undef>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>use_atomics</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C&lt;#M&gt; += A*B using fine tasks and atomics</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <if_stmt><if>if <condition>(<expr><name>B_iso</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// No special cases needed.  GB_GET_B_kj (bkj = B(k,j))</comment>
            <comment type="line">// handles the B iso case.</comment>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>tid</name></decl> ;</decl_stmt>
        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nthreads</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>dynamic</omp:expr></omp:argument>,<omp:argument><omp:expr>1</omp:expr></omp:argument>)</omp:argument_list></omp:clause> \
            <omp:clause><omp:name>reduction</omp:name><omp:argument_list>(<omp:argument><omp:expr>+:cnvals</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nthreads</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>dynamic</omp:expr></omp:argument>,<omp:argument><omp:expr>1</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <for>for <control>(<init><expr><name>tid</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>tid</name> <operator>&lt;</operator> <name>ntasks</name></expr> ;</condition> <incr><expr><name>tid</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// determine the vector of B and C for this fine task</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <comment type="line">// The fine task operates on C(:,j) and B(:,j).  Its fine task</comment>
            <comment type="line">// id ranges from 0 to nfine_tasks_per_vector-1, and determines</comment>
            <comment type="line">// which slice of A to operate on.</comment>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>j</name>    <init>= <expr><name>tid</name> <operator>/</operator> <name>nfine_tasks_per_vector</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>fine_tid</name> <init>= <expr><name>tid</name> <operator>%</operator> <name>nfine_tasks_per_vector</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>kfirst</name> <init>= <expr><name><name>A_slice</name> <index>[<expr><name>fine_tid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>klast</name> <init>= <expr><name><name>A_slice</name> <index>[<expr><name>fine_tid</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pB_start</name> <init>= <expr><name>j</name> <operator>*</operator> <name>bvlen</name></expr></init></decl> ;</decl_stmt>      <comment type="line">// pointer to B(:,j)</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pC_start</name> <init>= <expr><name>j</name> <operator>*</operator> <name>cvlen</name></expr></init></decl> ;</decl_stmt>      <comment type="line">// pointer to C(:,j)</comment>
            <expr_stmt><expr><name>GB_GET_T_FOR_SECONDJ</name></expr> ;</expr_stmt>              <comment type="line">// t = j or j+1 for SECONDJ*</comment>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>task_cnvals</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="line">// for Hx Gustavason workspace: use C(:,j) in-place:</comment>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator> <operator>!</operator><name>GB_IS_ANY_PAIR_SEMIRING</name> <operator>)</operator></expr></cpp:if>
            <decl_stmt><decl><type><name>GB_CTYPE</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hx</name> <init>= <expr><operator>(</operator><name>GB_CTYPE</name> <operator>*</operator><operator>)</operator>
                <operator>(</operator><operator>(</operator><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name>Cx</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>pC_start</name> <operator>*</operator> <name>GB_CSIZE</name><operator>)</operator><operator>)</operator></expr></init></decl> ;</decl_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_IS_PLUS_FC32_MONOID</name> <operator>||</operator> <name>GB_IS_ANY_FC32_MONOID</name></expr></cpp:if>
            <decl_stmt><decl><type><name>float</name>  <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hx_real</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator> <name>Hx</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>float</name>  <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hx_imag</name> <init>= <expr><name>Hx_real</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>GB_IS_PLUS_FC64_MONOID</name> <operator>||</operator> <name>GB_IS_ANY_FC64_MONOID</name></expr></cpp:elif>
            <decl_stmt><decl><type><name>double</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hx_real</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator> <name>Hx</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>double</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hx_imag</name> <init>= <expr><name>Hx_real</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// C&lt;#M&gt;(:,j) += A(:,k1:k2) * B(k1:k2,j)</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>kk</name> <init>= <expr><name>kfirst</name></expr></init></decl> ;</init> <condition><expr><name>kk</name> <operator>&lt;</operator> <name>klast</name></expr> ;</condition> <incr><expr><name>kk</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// C&lt;#M&gt;(:,j) += A(:,k) * B(k,j)</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <decl_stmt><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><call><name>GBH</name> <argument_list>(<argument><expr><name>Ah</name></expr></argument>, <argument><expr><name>kk</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>      <comment type="line">// k in range k1:k2</comment>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>pB</name> <init>= <expr><name>pB_start</name> <operator>+</operator> <name>k</name></expr></init></decl> ;</decl_stmt>     <comment type="line">// get pointer to B(k,j)</comment>
                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_B_IS_BITMAP</name></expr></cpp:if>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GBB</name> <argument_list>(<argument><expr><name>Bb</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>   
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>pA</name> <init>= <expr><name><name>Ap</name> <index>[<expr><name>kk</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>pA_end</name> <init>= <expr><name><name>Ap</name> <index>[<expr><name>kk</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <expr_stmt><expr><name>GB_GET_B_kj</name></expr> ;</expr_stmt>                   <comment type="line">// bkj = B(k,j)</comment>

                <for>for <control>( <init>;</init> <condition><expr><name>pA</name> <operator>&lt;</operator> <name>pA_end</name></expr> ;</condition> <incr><expr><name>pA</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// get A(i,k) and C(i,j)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>       <comment type="line">// get A(i,k) index</comment>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>pC</name> <init>= <expr><name>pC_start</name> <operator>+</operator> <name>i</name></expr></init></decl> ;</decl_stmt> <comment type="line">// get C(i,j) pointer</comment>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// C&lt;#M&gt;(i,j) += A(i,k) * B(k,j)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator> <operator>!</operator><name>GB_C_IS_BITMAP</name> <operator>)</operator></expr></cpp:if>
                    <block>{<block_content> 

                        <comment type="line">//------------------------------------------------------</comment>
                        <comment type="line">// C is full: the monoid is always atomic</comment>
                        <comment type="line">//------------------------------------------------------</comment>

                        <expr_stmt><expr><name>GB_MULT_A_ik_B_kj</name></expr> ;</expr_stmt>     <comment type="line">// t = A(i,k) * B(k,j)</comment>
                        <expr_stmt><expr><call><name>GB_ATOMIC_UPDATE_HX</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>    <comment type="line">// C(i,j) += t</comment>

                    </block_content>}</block>
                    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>GB_MASK_IS_SPARSE_OR_HYPER</name></expr></cpp:elif>
                    <block>{<block_content> 

                        <comment type="line">//------------------------------------------------------</comment>
                        <comment type="line">// M is sparse, and scattered into the C bitmap</comment>
                        <comment type="line">//------------------------------------------------------</comment>

                        <comment type="line">// finite-state machine in Cb [pC]:</comment>
                        <comment type="line">// 0:   cij not present, mij zero</comment>
                        <comment type="line">// 1:   cij present, mij zero (keep==1 for !M)</comment>
                        <comment type="line">// 2:   cij not present, mij one</comment>
                        <comment type="line">// 3:   cij present, mij one (keep==3 for M)</comment>
                        <comment type="line">// 7:   cij is locked</comment>

                        <decl_stmt><decl><type><name>int8_t</name></type> <name>cb</name></decl> ;</decl_stmt>
                        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_HAS_ATOMIC</name></expr></cpp:if>
                        <block>{<block_content> 
                            <comment type="line">// if C(i,j) is already present and can be modified</comment>
                            <comment type="line">// (cb==keep), and the monoid can be done</comment>
                            <comment type="line">// atomically, then do the atomic update.  No need</comment>
                            <comment type="line">// to modify Cb [pC].</comment>
                            <decl_stmt><decl><type><name>GB_ATOMIC_READ</name></type>
                            <name>cb</name> <init>= <expr><name><name>Cb</name> <index>[<expr><name>pC</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>          <comment type="line">// grab the entry</comment>
                            <if_stmt><if>if <condition>(<expr><name>cb</name> <operator>==</operator> <name>keep</name></expr>)</condition>
                            <block>{<block_content> 
                                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>GB_IS_ANY_MONOID</name></expr></cpp:if>
                                <expr_stmt><expr><name>GB_MULT_A_ik_B_kj</name></expr> ;</expr_stmt>     <comment type="line">// t = A(i,k) * B(k,j)</comment>
                                <expr_stmt><expr><call><name>GB_ATOMIC_UPDATE_HX</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>    <comment type="line">// C(i,j) += t</comment>
                                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                <continue>continue ;</continue>          <comment type="line">// C(i,j) has been updated</comment>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                        <do>do  <comment type="line">// lock the entry</comment>
                        <block>{<block_content> 
                            <comment type="line">// do this atomically:</comment>
                            <comment type="line">// { cb = Cb [pC] ;  Cb [pC] = 7 ; }</comment>
                            <expr_stmt><expr><call><name>GB_ATOMIC_CAPTURE_INT8</name> <argument_list>(<argument><expr><name>cb</name></expr></argument>, <argument><expr><name><name>Cb</name> <index>[<expr><name>pC</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block> while <condition>(<expr><name>cb</name> <operator>==</operator> <literal type="number">7</literal></expr>)</condition> ;</do> <comment type="line">// lock owner gets 0, 1, 2, or 3</comment>
                        <if_stmt><if>if <condition>(<expr><name>cb</name> <operator>==</operator> <name>keep</name><operator>-</operator><literal type="number">1</literal></expr>)</condition>
                        <block>{<block_content> 
                            <comment type="line">// C(i,j) is a new entry</comment>
                            <expr_stmt><expr><name>GB_MULT_A_ik_B_kj</name></expr> ;</expr_stmt>             <comment type="line">// t = A(i,k)*B(k,j)</comment>
                            <expr_stmt><expr><call><name>GB_ATOMIC_WRITE_HX</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>     <comment type="line">// C(i,j) = t</comment>
                            <expr_stmt><expr><name>task_cnvals</name><operator>++</operator></expr> ;</expr_stmt>
                            <expr_stmt><expr><name>cb</name> <operator>=</operator> <name>keep</name></expr> ;</expr_stmt>                     <comment type="line">// keep the entry</comment>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><name>cb</name> <operator>==</operator> <name>keep</name></expr>)</condition>
                        <block>{<block_content> 
                            <comment type="line">// C(i,j) is already present</comment>
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>GB_IS_ANY_MONOID</name></expr></cpp:if>
                            <expr_stmt><expr><name>GB_MULT_A_ik_B_kj</name></expr> ;</expr_stmt>             <comment type="line">// t = A(i,k)*B(k,j)</comment>
                            <expr_stmt><expr><call><name>GB_ATOMIC_UPDATE_HX</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>    <comment type="line">// C(i,j) += t</comment>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block></if></if_stmt>
                        <decl_stmt><decl><type><name>GB_ATOMIC_WRITE</name></type>
                        <name><name>Cb</name> <index>[<expr><name>pC</name></expr>]</index></name> <init>= <expr><name>cb</name></expr></init></decl> ;</decl_stmt>                  <comment type="line">// unlock the entry</comment>

                    </block_content>}</block>
                    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <block>{<block_content> 

                        <comment type="line">//------------------------------------------------------</comment>
                        <comment type="line">// M is not present, or bitmap/full</comment>
                        <comment type="line">//------------------------------------------------------</comment>

                        <comment type="line">// finite-state machine in Cb [pC]:</comment>
                        <comment type="line">// 0:   cij not present; can be written</comment>
                        <comment type="line">// 1:   cij present; can be updated</comment>
                        <comment type="line">// 7:   cij is locked</comment>

                        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_MASK_IS_BITMAP_OR_FULL</name></expr></cpp:if>
                        <block>{<block_content> 
                            <comment type="line">// M is bitmap or full, and not in C bitmap.</comment>
                            <comment type="line">// Do not modify C(i,j) if not permitted by the mask</comment>
                            <expr_stmt><expr><call><name>GB_GET_M_ij</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><name>mij</name> <operator>=</operator> <name>mij</name> <operator>^</operator> <name>Mask_comp</name></expr> ;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>mij</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>
                        </block_content>}</block>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                        <comment type="line">//------------------------------------------------------</comment>
                        <comment type="line">// C(i,j) += A(i,j) * B(k,j)</comment>
                        <comment type="line">//------------------------------------------------------</comment>

                        <decl_stmt><decl><type><name>int8_t</name></type> <name>cb</name></decl> ;</decl_stmt>
                        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_HAS_ATOMIC</name></expr></cpp:if>
                        <block>{<block_content> 
                            <comment type="line">// if C(i,j) is already present (cb==1), and the</comment>
                            <comment type="line">// monoid can be done atomically, then do the</comment>
                            <comment type="line">// atomic update.  No need to modify Cb [pC].</comment>
                            <decl_stmt><decl><type><name>GB_ATOMIC_READ</name></type>
                            <name>cb</name> <init>= <expr><name><name>Cb</name> <index>[<expr><name>pC</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>          <comment type="line">// grab the entry</comment>
                            <if_stmt><if>if <condition>(<expr><name>cb</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
                            <block>{<block_content> 
                                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>GB_IS_ANY_MONOID</name></expr></cpp:if>
                                <expr_stmt><expr><name>GB_MULT_A_ik_B_kj</name></expr> ;</expr_stmt>     <comment type="line">// t = A(i,k) * B(k,j)</comment>
                                <expr_stmt><expr><call><name>GB_ATOMIC_UPDATE_HX</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>    <comment type="line">// C(i,j) += t</comment>
                                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                <continue>continue ;</continue>          <comment type="line">// C(i,j) has been updated</comment>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                        <do>do  <comment type="line">// lock the entry</comment>
                        <block>{<block_content> 
                            <comment type="line">// do this atomically:</comment>
                            <comment type="line">// { cb = Cb [pC] ;  Cb [pC] = 7 ; }</comment>
                            <expr_stmt><expr><call><name>GB_ATOMIC_CAPTURE_INT8</name> <argument_list>(<argument><expr><name>cb</name></expr></argument>, <argument><expr><name><name>Cb</name> <index>[<expr><name>pC</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block> while <condition>(<expr><name>cb</name> <operator>==</operator> <literal type="number">7</literal></expr>)</condition> ;</do> <comment type="line">// lock owner gets 0 or 1</comment>
                        <if_stmt><if>if <condition>(<expr><name>cb</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content> 
                            <comment type="line">// C(i,j) is a new entry</comment>
                            <expr_stmt><expr><name>GB_MULT_A_ik_B_kj</name></expr> ;</expr_stmt>             <comment type="line">// t = A(i,k)*B(k,j)</comment>
                            <expr_stmt><expr><call><name>GB_ATOMIC_WRITE_HX</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>     <comment type="line">// C(i,j) = t</comment>
                            <expr_stmt><expr><name>task_cnvals</name><operator>++</operator></expr> ;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else <comment type="line">// cb == 1</comment>
                        <block>{<block_content> 
                            <comment type="line">// C(i,j) is already present</comment>
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>GB_IS_ANY_MONOID</name></expr></cpp:if>
                            <expr_stmt><expr><name>GB_MULT_A_ik_B_kj</name></expr> ;</expr_stmt>             <comment type="line">// t = A(i,k)*B(k,j)</comment>
                            <expr_stmt><expr><call><name>GB_ATOMIC_UPDATE_HX</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>    <comment type="line">// C(i,j) += t</comment>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block></else></if_stmt>
                        <decl_stmt><decl><type><name>GB_ATOMIC_WRITE</name></type>
                        <name><name>Cb</name> <index>[<expr><name>pC</name></expr>]</index></name> <init>= <expr><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>               <comment type="line">// unlock the entry</comment>

                    </block_content>}</block>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                </block_content>}</block></for>
            </block_content>}</block></for>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
            <expr_stmt><expr><name>cnvals</name> <operator>+=</operator> <name>task_cnvals</name></expr> ;</expr_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></for>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C&lt;#M&gt; += A*B using fine tasks and workspace, with no atomics</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// Each fine task is given size-cvlen workspace to compute its result</comment>
        <comment type="line">// in the first phase, W(:,tid) = A(:,k1:k2) * B(k1:k2,j), where k1:k2</comment>
        <comment type="line">// is defined by the fine_tid of the task.  The workspaces are then</comment>
        <comment type="line">// summed into C in the second phase.</comment>

        <if_stmt><if>if <condition>(<expr><name>B_iso</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// No special cases needed.  GB_GET_B_kj (bkj = B(k,j))</comment>
            <comment type="line">// handles the B iso case.</comment>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// allocate workspace</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><name>size_t</name></type> <name>workspace</name> <init>= <expr><name>cvlen</name> <operator>*</operator> <name>ntasks</name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>cxsize</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>GB_IS_ANY_PAIR_SEMIRING</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>GB_CSIZE</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
        <expr_stmt><expr><name>Wf</name>  <operator>=</operator> <call><name>GB_MALLOC_WORK</name> <argument_list>(<argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>int8_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Wf_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>Wcx</name> <operator>=</operator> <call><name>GB_MALLOC_WORK</name> <argument_list>(<argument><expr><name>workspace</name> <operator>*</operator> <name>cxsize</name></expr></argument>, <argument><expr><name>GB_void</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Wcx_size</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>GB_C_IS_BITMAP</name> <operator>&amp;&amp;</operator> <name>Wf</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <name>Wcx</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// out of memory</comment>
            <expr_stmt><expr><name>GB_FREE_ALL</name></expr> ;</expr_stmt>
            <return>return <expr><operator>(</operator><name>GrB_OUT_OF_MEMORY</name><operator>)</operator></expr> ;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// first phase: W (:,tid) = A (:,k1:k2) * B (k2:k2,j) for each fine task</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><name>int</name></type> <name>tid</name></decl> ;</decl_stmt>
        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nthreads</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>dynamic</omp:expr></omp:argument>,<omp:argument><omp:expr>1</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
        <for>for <control>(<init><expr><name>tid</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>tid</name> <operator>&lt;</operator> <name>ntasks</name></expr> ;</condition> <incr><expr><name>tid</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// determine the vector of B and C for this fine task</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <comment type="line">// The fine task operates on C(:,j) and B(:,j).  Its fine task</comment>
            <comment type="line">// id ranges from 0 to nfine_tasks_per_vector-1, and determines</comment>
            <comment type="line">// which slice of A to operate on.</comment>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>j</name>    <init>= <expr><name>tid</name> <operator>/</operator> <name>nfine_tasks_per_vector</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>fine_tid</name> <init>= <expr><name>tid</name> <operator>%</operator> <name>nfine_tasks_per_vector</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>kfirst</name> <init>= <expr><name><name>A_slice</name> <index>[<expr><name>fine_tid</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>klast</name> <init>= <expr><name><name>A_slice</name> <index>[<expr><name>fine_tid</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pB_start</name> <init>= <expr><name>j</name> <operator>*</operator> <name>bvlen</name></expr></init></decl> ;</decl_stmt>      <comment type="line">// pointer to B(:,j)</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pC_start</name> <init>= <expr><name>j</name> <operator>*</operator> <name>cvlen</name></expr></init></decl> ;</decl_stmt>      <comment type="line">// pointer to C(:,j), for bitmap</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pW_start</name> <init>= <expr><name>tid</name> <operator>*</operator> <name>cvlen</name></expr></init></decl> ;</decl_stmt>    <comment type="line">// pointer to W(:,tid)</comment>
            <expr_stmt><expr><name>GB_GET_T_FOR_SECONDJ</name></expr> ;</expr_stmt>              <comment type="line">// t = j or j+1 for SECONDJ*</comment>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>task_cnvals</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="line">// for Hf and Hx Gustavason workspace: use W(:,tid):</comment>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
            <decl_stmt><decl><type><name>int8_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hf</name> <init>= <expr><name>Wf</name> <operator>+</operator> <name>pW_start</name></expr></init></decl> ;</decl_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator> <operator>!</operator><name>GB_IS_ANY_PAIR_SEMIRING</name> <operator>)</operator></expr></cpp:if>
            <decl_stmt><decl><type><name>GB_CTYPE</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hx</name> <init>= <expr><operator>(</operator><name>GB_CTYPE</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>Wcx</name> <operator>+</operator> <operator>(</operator><name>pW_start</name> <operator>*</operator> <name>cxsize</name><operator>)</operator><operator>)</operator></expr></init></decl> ;</decl_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_IS_PLUS_FC32_MONOID</name></expr></cpp:if>
            <decl_stmt><decl><type><name>float</name>  <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hx_real</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator> <name>Hx</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>float</name>  <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hx_imag</name> <init>= <expr><name>Hx_real</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>GB_IS_PLUS_FC64_MONOID</name></expr></cpp:elif>
            <decl_stmt><decl><type><name>double</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hx_real</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator> <name>Hx</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>double</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hx_imag</name> <init>= <expr><name>Hx_real</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// clear the panel</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
            <block>{<block_content> 
                <expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>Hf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cvlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block>
            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <block>{<block_content> 
                <comment type="line">// set Hx to identity</comment>
                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_HAS_IDENTITY_BYTE</name></expr></cpp:if>
                    <expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>Hx</name></expr></argument>, <argument><expr><name>GB_IDENTITY_BYTE</name></expr></argument>, <argument><expr><name>cvlen</name> <operator>*</operator> <name>GB_CSIZE</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cvlen</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content> 
                        <expr_stmt><expr><name><name>Hx</name> <index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>GB_IDENTITY</name></expr> ;</expr_stmt>
                    </block_content>}</block></for>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// W&lt;#M&gt; = A(:,k1:k2) * B(k1:k2,j)</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>kk</name> <init>= <expr><name>kfirst</name></expr></init></decl> ;</init> <condition><expr><name>kk</name> <operator>&lt;</operator> <name>klast</name></expr> ;</condition> <incr><expr><name>kk</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// W&lt;#M&gt;(:,tid) += A(:,k) * B(k,j)</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <decl_stmt><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><call><name>GBH</name> <argument_list>(<argument><expr><name>Ah</name></expr></argument>, <argument><expr><name>kk</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>      <comment type="line">// k in range k1:k2</comment>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>pB</name> <init>= <expr><name>pB_start</name> <operator>+</operator> <name>k</name></expr></init></decl> ;</decl_stmt>     <comment type="line">// get pointer to B(k,j)</comment>
                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_B_IS_BITMAP</name></expr></cpp:if>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GBB</name> <argument_list>(<argument><expr><name>Bb</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>   
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>pA</name> <init>= <expr><name><name>Ap</name> <index>[<expr><name>kk</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>pA_end</name> <init>= <expr><name><name>Ap</name> <index>[<expr><name>kk</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <expr_stmt><expr><name>GB_GET_B_kj</name></expr> ;</expr_stmt>                   <comment type="line">// bkj = B(k,j)</comment>

                <for>for <control>( <init>;</init> <condition><expr><name>pA</name> <operator>&lt;</operator> <name>pA_end</name></expr> ;</condition> <incr><expr><name>pA</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// get A(i,k)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>       <comment type="line">// get A(i,k) index</comment>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// check M(i,j)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_MASK_IS_SPARSE_OR_HYPER</name></expr></cpp:if>
                    <block>{<block_content> 
                        <comment type="line">// M is sparse or hypersparse</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>pC</name> <init>= <expr><name>pC_start</name> <operator>+</operator> <name>i</name></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>int8_t</name></type> <name>cb</name> <init>= <expr><name><name>Cb</name> <index>[<expr><name>pC</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>bool</name></type> <name>mij</name> <init>= <expr><operator>(</operator><operator>(</operator><name>cb</name> <operator>&amp;</operator> <literal type="number">2</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>^</operator> <name>Mask_comp</name></expr></init></decl> ;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>mij</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>
                    </block_content>}</block>
                    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>GB_MASK_IS_BITMAP_OR_FULL</name></expr></cpp:elif>
                    <block>{<block_content> 
                        <comment type="line">// M is bitmap or full</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>pC</name> <init>= <expr><name>pC_start</name> <operator>+</operator> <name>i</name></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_GET_M_ij</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><name>mij</name> <operator>=</operator> <name>mij</name> <operator>^</operator> <name>Mask_comp</name></expr> ;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>mij</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>
                    </block_content>}</block>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// W&lt;#M&gt;(i) += A(i,k) * B(k,j)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_IS_ANY_PAIR_SEMIRING</name></expr></cpp:if>
                    <block>{<block_content> 
                        <expr_stmt><expr><name><name>Hf</name> <index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    </block_content>}</block>
                    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <block>{<block_content>
                        <expr_stmt><expr><name>GB_MULT_A_ik_B_kj</name></expr> ;</expr_stmt>         <comment type="line">// t = A(i,k)*B(k,j)</comment>
                        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
                        <if_stmt><if>if <condition>(<expr><name><name>Hf</name> <index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content> 
                            <comment type="line">// W(i) is a new entry</comment>
                            <expr_stmt><expr><call><name>GB_HX_WRITE</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>    <comment type="line">// Hx(i) = t</comment>
                            <expr_stmt><expr><name><name>Hf</name> <index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <block>{<block_content> 
                            <comment type="line">// W(i) is already present</comment>
                            <expr_stmt><expr><call><name>GB_HX_UPDATE</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>   <comment type="line">// Hx(i) += t</comment>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></for>
            </block_content>}</block></for>
        </block_content>}</block></for>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// second phase: C&lt;#M&gt; += reduce (W)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nthreads</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>dynamic</omp:expr></omp:argument>,<omp:argument><omp:expr>1</omp:expr></omp:argument>)</omp:argument_list></omp:clause> \
            <omp:clause><omp:name>reduction</omp:name><omp:argument_list>(<omp:argument><omp:expr>+:cnvals</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nthreads</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>dynamic</omp:expr></omp:argument>,<omp:argument><omp:expr>1</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <for>for <control>(<init><expr><name>tid</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>tid</name> <operator>&lt;</operator> <name>ntasks</name></expr> ;</condition> <incr><expr><name>tid</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// determine the W and C for this fine task</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <comment type="line">// The fine task operates on C(i1:i2,j) and W(i1:i2,w1:w2), where</comment>
            <comment type="line">// i1:i2 is defined by the fine task id.  Its fine task id ranges</comment>
            <comment type="line">// from 0 to nfine_tasks_per_vector-1.</comment>
            
            <comment type="line">// w1:w2 are the updates to C(:,j), where w1:w2 =</comment>
            <comment type="line">// [j*nfine_tasks_per_vector : (j+1)*nfine_tasks_per_vector-1].</comment>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>j</name>    <init>= <expr><name>tid</name> <operator>/</operator> <name>nfine_tasks_per_vector</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>fine_tid</name> <init>= <expr><name>tid</name> <operator>%</operator> <name>nfine_tasks_per_vector</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>istart</name></decl>, <decl><type ref="prev"/><name>iend</name></decl> ;</decl_stmt>
            <expr_stmt><expr><call><name>GB_PARTITION</name> <argument_list>(<argument><expr><name>istart</name></expr></argument>, <argument><expr><name>iend</name></expr></argument>, <argument><expr><name>cvlen</name></expr></argument>, <argument><expr><name>fine_tid</name></expr></argument>,
                <argument><expr><name>nfine_tasks_per_vector</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pC_start</name> <init>= <expr><name>j</name> <operator>*</operator> <name>cvlen</name></expr></init></decl> ;</decl_stmt>          <comment type="line">// pointer to C(:,j)</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>wstart</name> <init>= <expr><name>j</name> <operator>*</operator> <name>nfine_tasks_per_vector</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>wend</name> <init>= <expr><operator>(</operator><name>j</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>nfine_tasks_per_vector</name></expr></init></decl> ;</decl_stmt>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>task_cnvals</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="line">// Hx = (typecasted) Wcx workspace, use Wf as-is</comment>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator> <operator>!</operator><name>GB_IS_ANY_PAIR_SEMIRING</name> <operator>)</operator></expr></cpp:if>
            <decl_stmt><decl><type><name>GB_CTYPE</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hx</name> <init>= <expr><operator>(</operator><operator>(</operator><name>GB_CTYPE</name> <operator>*</operator><operator>)</operator> <name>Wcx</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_IS_PLUS_FC32_MONOID</name></expr></cpp:if>
            <decl_stmt><decl><type><name>float</name>  <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hx_real</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator> <name>Hx</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>float</name>  <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hx_imag</name> <init>= <expr><name>Hx_real</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>GB_IS_PLUS_FC64_MONOID</name></expr></cpp:elif>
            <decl_stmt><decl><type><name>double</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hx_real</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator> <name>Hx</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>double</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Hx_imag</name> <init>= <expr><name>Hx_real</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// C&lt;#M&gt;(i1:i2,j) += reduce (W (i2:i2, wstart:wend))</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>w</name> <init>= <expr><name>wstart</name></expr></init></decl> ;</init> <condition><expr><name>w</name> <operator>&lt;</operator> <name>wend</name></expr> ;</condition> <incr><expr><name>w</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// C&lt;#M&gt;(i1:i2,j) += W (i1:i2,w)</comment>
                <comment type="line">//--------------------------------------------------------------</comment>
            
                <decl_stmt><decl><type><name>int64_t</name></type> <name>pW_start</name> <init>= <expr><name>w</name> <operator>*</operator> <name>cvlen</name></expr></init></decl> ;</decl_stmt>      <comment type="line">// pointer to W (:,w)</comment>

                <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name>istart</name></expr></init></decl> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>iend</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// get pointer and bitmap C(i,j) and W(i,w)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <decl_stmt><decl><type><name>int64_t</name></type> <name>pW</name> <init>= <expr><name>pW_start</name> <operator>+</operator> <name>i</name></expr></init></decl> ;</decl_stmt>     <comment type="line">// pointer to W(i,w)</comment>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
                    <if_stmt><if>if <condition>(<expr><name><name>Wf</name> <index>[<expr><name>pW</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>    <comment type="line">// skip if not present</comment>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>pC</name> <init>= <expr><name>pC_start</name> <operator>+</operator> <name>i</name></expr></init></decl> ;</decl_stmt>     <comment type="line">// pointer to C(i,j)</comment>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
                    <decl_stmt><decl><type><name>int8_t</name></type> <name>cb</name> <init>= <expr><name><name>Cb</name> <index>[<expr><name>pC</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>           <comment type="line">// bitmap status of C(i,j)</comment>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// M(i,j) already checked, but adjust Cb if M is sparse</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_MASK_IS_SPARSE_OR_HYPER</name></expr></cpp:if>
                    <block>{<block_content> 
                        <comment type="line">// M is sparse or hypersparse</comment>
                        <expr_stmt><expr><name>cb</name> <operator>=</operator> <operator>(</operator><name>cb</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr> ;</expr_stmt>
                    </block_content>}</block>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// C(i,j) += W (i,w)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
                    <if_stmt><if>if <condition>(<expr><name>cb</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// C(i,j) = W(i,w)</comment>
                        <expr_stmt><expr><call><name>GB_CIJ_GATHER</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pW</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><name><name>Cb</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>keep</name></expr> ;</expr_stmt>
                        <expr_stmt><expr><name>task_cnvals</name><operator>++</operator></expr> ;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <block>{<block_content> 
                        <comment type="line">// C(i,j) += W(i,w)</comment>
                        <expr_stmt><expr><call><name>GB_CIJ_GATHER_UPDATE</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pW</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></for>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_C_IS_BITMAP</name></expr></cpp:if>
            <expr_stmt><expr><name>cnvals</name> <operator>+=</operator> <name>task_cnvals</name></expr> ;</expr_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
</block_content>}</block>

</unit>
