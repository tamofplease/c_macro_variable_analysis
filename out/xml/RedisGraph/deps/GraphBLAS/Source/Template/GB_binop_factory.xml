<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/Template/GB_binop_factory.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_binop_factory: switch factory for built-in methods for C=binop(A,B)</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// The #include'ing file defines the GB_BINOP_WORKER macro, and opcode, xcode,</comment>
<comment type="line">// ycode, and zcode, to call one of 388 builtin binary operators.  The binary</comment>
<comment type="line">// operators are all named GrB_[OPNAME]_[XTYPE], according to the opcode/</comment>
<comment type="line">// opname, and the xtype of the operator.  The type of z and y are not in the</comment>
<comment type="line">// name.  Except for the GxB_BSHIFT_[XTYPE] operators (where y always has type</comment>
<comment type="line">// int8), the types of x and y are the same.</comment>

<block>{<block_content>
    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// launch the switch factory</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// this switch factory does not handle positional operators</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_OPCODE_IS_POSITIONAL</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <switch>switch <condition>(<expr><name>opcode</name></expr>)</condition>
    <block>{<block_content>


        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_MIN_binop_code</name></expr>     :</case>    <comment type="line">// z = min(x,y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// MIN == TIMES == AND for boolean</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_min</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_min</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_min</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_min</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_min</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_min</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_min</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_min</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_min</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_min</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_MAX_binop_code</name></expr>     :</case>    <comment type="line">// z = max(x,y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// MAX == PLUS == OR for boolean</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_max</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_max</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_max</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_max</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_max</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_max</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_max</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_max</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_max</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_max</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_PLUS_binop_code</name></expr>    :</case>    <comment type="line">// z = x + y</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// MAX == PLUS == OR for boolean</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_plus</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_plus</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_plus</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_plus</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_plus</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_plus</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_plus</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_plus</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_plus</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_plus</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_plus</argument>, <argument>_fc32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_plus</argument>, <argument>_fc64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_MINUS_binop_code</name></expr>   :</case>    <comment type="line">// z = x - y</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// MINUS == RMINUS == NE == ISNE == XOR for boolean</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_minus</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_minus</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_minus</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_minus</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_minus</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_minus</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_minus</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_minus</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_minus</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_minus</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_minus</argument>, <argument>_fc32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_minus</argument>, <argument>_fc64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_RMINUS_binop_code</name></expr>   :</case>    <comment type="line">// z = y - x (reverse minus)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// MINUS == RMINUS == NE == ISNE == XOR for boolean</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rminus</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rminus</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rminus</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rminus</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rminus</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rminus</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rminus</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rminus</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rminus</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rminus</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rminus</argument>, <argument>_fc32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rminus</argument>, <argument>_fc64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_TIMES_binop_code</name></expr>   :</case>    <comment type="line">// z = x * y</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// MIN == TIMES == AND for boolean</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_times</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_times</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_times</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_times</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_times</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_times</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_times</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_times</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_times</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_times</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_times</argument>, <argument>_fc32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_times</argument>, <argument>_fc64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_DIV_binop_code</name></expr>   :</case>      <comment type="line">// z = x / y</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// FIRST == DIV for boolean</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_div</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_div</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_div</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_div</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_div</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_div</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_div</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_div</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_div</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_div</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_div</argument>, <argument>_fc32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_div</argument>, <argument>_fc64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_RDIV_binop_code</name></expr>   :</case>     <comment type="line">// z = y / x (reverse division)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// SECOND == RDIV for boolean</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rdiv</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rdiv</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rdiv</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rdiv</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rdiv</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rdiv</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rdiv</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rdiv</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rdiv</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rdiv</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rdiv</argument>, <argument>_fc32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_rdiv</argument>, <argument>_fc64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_BINOP_SUBSET</name></cpp:ifndef>

        <comment type="line">// These operators are not used in C+=A+B by GB_dense_eWise3_accum</comment>
        <comment type="line">// when all 3 matrices are dense.</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_NO_FIRST</name></cpp:ifndef>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_FIRST_binop_code</name></expr>   :</case>    <comment type="line">// z = x</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_first</argument>, <argument>_bool</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_first</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_first</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_first</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_first</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_first</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_first</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_first</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_first</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_first</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_first</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_first</argument>, <argument>_fc32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_first</argument>, <argument>_fc64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_NO_SECOND</name></cpp:ifndef>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_SECOND_binop_code</name></expr>  :</case>    <comment type="line">// z = y</comment>
        <case>case <expr><name>GB_ANY_binop_code</name></expr>  :</case>       <comment type="line">// z = y</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_second</argument>, <argument>_bool</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_second</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_second</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_second</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_second</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_second</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_second</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_second</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_second</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_second</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_second</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_second</argument>, <argument>_fc32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_second</argument>, <argument>_fc64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_NO_PAIR</name></cpp:ifndef>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_PAIR_binop_code</name></expr>   :</case>    <comment type="line">// z = 1</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pair</argument>, <argument>_bool</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pair</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pair</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pair</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pair</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pair</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pair</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pair</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pair</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pair</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pair</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pair</argument>, <argument>_fc32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pair</argument>, <argument>_fc64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_ISEQ_binop_code</name></expr>    :</case>    <comment type="line">// z = (x == y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// ISEQ == EQ for boolean</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_iseq</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_iseq</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_iseq</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_iseq</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_iseq</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_iseq</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_iseq</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_iseq</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_iseq</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_iseq</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_BINOP_IS_SEMIRING_MULTIPLIER</name></cpp:ifndef>
                <comment type="line">// ISEQ does not appear in a builtin complex semiring</comment>
                <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_iseq</argument>, <argument>_fc32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_iseq</argument>, <argument>_fc64</argument>  )</argument_list></macro>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_ISNE_binop_code</name></expr>    :</case>    <comment type="line">// z = (x != y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// MINUS == RMINUS == NE == ISNE == XOR for boolean</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isne</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isne</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isne</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isne</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isne</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isne</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isne</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isne</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isne</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isne</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_BINOP_IS_SEMIRING_MULTIPLIER</name></cpp:ifndef>
                <comment type="line">// ISNE does not appear in a builtin complex semiring</comment>
                <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isne</argument>, <argument>_fc32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isne</argument>, <argument>_fc64</argument>  )</argument_list></macro>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_ISGT_binop_code</name></expr>    :</case>    <comment type="line">// z = (x &gt;  y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// ISGT == GT for boolean.  no complex case</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isgt</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isgt</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isgt</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isgt</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isgt</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isgt</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isgt</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isgt</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isgt</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isgt</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_ISLT_binop_code</name></expr>    :</case>    <comment type="line">// z = (x &lt;  y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// ISLT == LT for boolean.  no complex case</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_islt</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_islt</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_islt</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_islt</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_islt</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_islt</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_islt</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_islt</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_islt</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_islt</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_ISGE_binop_code</name></expr>    :</case>    <comment type="line">// z = (x &gt;= y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// POW == ISGE == GE for boolean. no complex case.</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isge</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isge</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isge</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isge</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isge</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isge</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isge</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isge</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isge</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isge</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_ISLE_binop_code</name></expr>     :</case>    <comment type="line">// z = (x &lt;= y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// ISLE == LE for boolean.  no complex case</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isle</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isle</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isle</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isle</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isle</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isle</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isle</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isle</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isle</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_isle</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_EQ_binop_code</name></expr>      :</case>    <comment type="line">// z = (x == y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_eq</argument>, <argument>_bool</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_eq</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_eq</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_eq</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_eq</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_eq</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_eq</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_eq</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_eq</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_eq</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_eq</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_BINOP_IS_SEMIRING_MULTIPLIER</name></cpp:ifndef>
                <comment type="line">// EQ does not appear in a builtin complex semiring</comment>
                <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_eq</argument>, <argument>_fc32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_eq</argument>, <argument>_fc64</argument>  )</argument_list></macro>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_NE_binop_code</name></expr>      :</case>    <comment type="line">// z = (x != y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// MINUS == RMINUS == NE == ISNE == XOR for boolean</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ne</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ne</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ne</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ne</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ne</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ne</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ne</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ne</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ne</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ne</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_BINOP_IS_SEMIRING_MULTIPLIER</name></cpp:ifndef>
                <comment type="line">// NE does not appear in a builtin complex semiring</comment>
                <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ne</argument>, <argument>_fc32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ne</argument>, <argument>_fc64</argument>  )</argument_list></macro>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_GT_binop_code</name></expr>      :</case>    <comment type="line">// z = (x &gt;  y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// no complex case</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_gt</argument>, <argument>_bool</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_gt</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_gt</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_gt</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_gt</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_gt</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_gt</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_gt</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_gt</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_gt</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_gt</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_LT_binop_code</name></expr>      :</case>    <comment type="line">// z = (x &lt;  y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// no complex case</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lt</argument>, <argument>_bool</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lt</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lt</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lt</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lt</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lt</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lt</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lt</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lt</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lt</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lt</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_GE_binop_code</name></expr>      :</case>    <comment type="line">// z = (x &gt;= y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// no complex case</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ge</argument>, <argument>_bool</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ge</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ge</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ge</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ge</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ge</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ge</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ge</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ge</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ge</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ge</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_LE_binop_code</name></expr>      :</case>    <comment type="line">// z = (x &lt;= y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// no complex case</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_le</argument>, <argument>_bool</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_le</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_le</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_le</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_le</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_le</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_le</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_le</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_le</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_le</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_le</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_LOR_binop_code</name></expr>     :</case>    <comment type="line">// z = x || y</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// no complex case</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lor</argument>, <argument>_bool</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lor</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lor</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lor</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lor</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lor</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lor</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lor</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lor</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lor</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lor</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_LAND_binop_code</name></expr>    :</case>    <comment type="line">// z = x &amp;&amp; y</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// no complex case</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_land</argument>, <argument>_bool</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_land</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_land</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_land</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_land</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_land</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_land</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_land</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_land</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_land</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_land</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_LXOR_binop_code</name></expr>    :</case>    <comment type="line">// z = x != y</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// no complex case</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lxor</argument>, <argument>_bool</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lxor</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lxor</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lxor</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lxor</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lxor</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lxor</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lxor</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lxor</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lxor</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_lxor</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_BINOP_IS_SEMIRING_MULTIPLIER</name></cpp:ifndef>

        <comment type="line">// pow, atan2, hypot, ... are not used as multiplicative operators in</comment>
        <comment type="line">// any semiring, so they are not called by GB_AxB_rowscale or</comment>
        <comment type="line">// GB_AxB_colscale.</comment>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_POW_binop_code</name></expr>    :</case>    <comment type="line">// z = x ^ y</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// POW == ISGE == GE for boolean</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pow</argument>, <argument>_int8</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pow</argument>, <argument>_int16</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pow</argument>, <argument>_int32</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pow</argument>, <argument>_int64</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pow</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pow</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pow</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pow</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pow</argument>, <argument>_fp32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pow</argument>, <argument>_fp64</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pow</argument>, <argument>_fc32</argument>  )</argument_list></macro>
                <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_pow</argument>, <argument>_fc64</argument>  )</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_ATAN2_binop_code</name></expr>    :</case>    <comment type="line">// z = atan2 (x,y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_FP32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_atan2</argument>, <argument>_fp32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_atan2</argument>, <argument>_fp64</argument>)</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_HYPOT_binop_code</name></expr>    :</case>    <comment type="line">// z = hypot (x,y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_FP32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_hypot</argument>, <argument>_fp32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_hypot</argument>, <argument>_fp64</argument>)</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_FMOD_binop_code</name></expr>    :</case>    <comment type="line">// z = fmod (x,y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_FP32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_fmod</argument>, <argument>_fp32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_fmod</argument>, <argument>_fp64</argument>)</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_REMAINDER_binop_code</name></expr>    :</case>    <comment type="line">// z = remainder (x,y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_FP32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_remainder</argument>, <argument>_fp32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_remainder</argument>, <argument>_fp64</argument>)</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_LDEXP_binop_code</name></expr>    :</case>    <comment type="line">// z = ldexp (x,y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_FP32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ldexp</argument>, <argument>_fp32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_ldexp</argument>, <argument>_fp64</argument>)</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_COPYSIGN_binop_code</name></expr>    :</case>    <comment type="line">// z = copysign (x,y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_FP32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_copysign</argument>, <argument>_fp32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_copysign</argument>, <argument>_fp64</argument>)</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_CMPLX_binop_code</name></expr>    :</case>    <comment type="line">// z = cmplx (x,y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_FP32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_cmplx</argument>, <argument>_fp32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_FP64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_cmplx</argument>, <argument>_fp64</argument>)</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_BGET_binop_code</name></expr> :</case>   <comment type="line">// z = bitget (x,y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bget</argument>, <argument>_int8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bget</argument>, <argument>_int16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bget</argument>, <argument>_int32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bget</argument>, <argument>_int64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bget</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bget</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bget</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bget</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_BSET_binop_code</name></expr> :</case>   <comment type="line">// z = bitset (x,y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bset</argument>, <argument>_int8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bset</argument>, <argument>_int16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bset</argument>, <argument>_int32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bset</argument>, <argument>_int64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bset</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bset</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bset</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bset</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_BCLR_binop_code</name></expr> :</case>   <comment type="line">// z = bitclr (x,y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bclr</argument>, <argument>_int8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bclr</argument>, <argument>_int16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bclr</argument>, <argument>_int32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bclr</argument>, <argument>_int64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bclr</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bclr</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bclr</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bclr</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_BSHIFT_binop_code</name></expr> :</case>   <comment type="line">// z = bitshift (x,y)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <comment type="line">// y is always int8; z and x have int* or uint* type</comment>
            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bshift</argument>, <argument>_int8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bshift</argument>, <argument>_int16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bshift</argument>, <argument>_int32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bshift</argument>, <argument>_int64</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bshift</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bshift</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bshift</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bshift</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_BOR_binop_code</name></expr> :</case>     <comment type="line">// z = (x | y), bitwise or</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_BINOP_IS_SEMIRING_MULTIPLIER</name></cpp:ifndef>
                <comment type="line">// BOR for signed integers is not in any builtin semiring</comment>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bor</argument>, <argument>_int8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bor</argument>, <argument>_int16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bor</argument>, <argument>_int32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bor</argument>, <argument>_int64</argument>)</argument_list></macro>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bor</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bor</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bor</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bor</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_BAND_binop_code</name></expr> :</case>    <comment type="line">// z = (x &amp; y), bitwise and</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_BINOP_IS_SEMIRING_MULTIPLIER</name></cpp:ifndef>
                <comment type="line">// BAND for signed integers is not in any builtin semiring</comment>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_band</argument>, <argument>_int8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_band</argument>, <argument>_int16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_band</argument>, <argument>_int32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_band</argument>, <argument>_int64</argument>)</argument_list></macro>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_band</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_band</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_band</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_band</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_BXOR_binop_code</name></expr> :</case>    <comment type="line">// z = (x ^ y), bitwise xor</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_BINOP_IS_SEMIRING_MULTIPLIER</name></cpp:ifndef>
                <comment type="line">// BXOR for signed integers is not in any builtin semiring</comment>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bxor</argument>, <argument>_int8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bxor</argument>, <argument>_int16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bxor</argument>, <argument>_int32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bxor</argument>, <argument>_int64</argument>)</argument_list></macro>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bxor</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bxor</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bxor</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bxor</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <case>case <expr><name>GB_BXNOR_binop_code</name></expr> :</case>   <comment type="line">// z = ~(x ^ y), bitwise xnor</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

            <switch>switch <condition>(<expr><name>xcode</name></expr>)</condition>
            <block>{<block_content>
                <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_BINOP_IS_SEMIRING_MULTIPLIER</name></cpp:ifndef>
                <comment type="line">// BXNOR for signed integers is not in any builtin semiring</comment>
                <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bxnor</argument>, <argument>_int8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bxnor</argument>, <argument>_int16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bxnor</argument>, <argument>_int32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bxnor</argument>, <argument>_int64</argument>)</argument_list></macro>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bxnor</argument>, <argument>_uint8</argument> )</argument_list></macro>
                <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bxnor</argument>, <argument>_uint16</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bxnor</argument>, <argument>_uint32</argument>)</argument_list></macro>
                <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_BINOP_WORKER</name> <argument_list>(<argument>_bxnor</argument>, <argument>_uint64</argument>)</argument_list></macro>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
            <break>break ;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <default>default:</default> <empty_stmt>;</empty_stmt>
    </block_content>}</block></switch>
</block_content>}</block>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_NO_FIRST</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_NO_SECOND</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_NO_PAIR</name></cpp:undef>

</unit>
