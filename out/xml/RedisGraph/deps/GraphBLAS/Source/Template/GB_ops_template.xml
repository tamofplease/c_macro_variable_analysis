<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/Template/GB_ops_template.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_ops_template.c: built-in unary and binary functions and operators</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// This file is #include'd many times in GB_ops.c to define the built-in unary</comment>
<comment type="line">// and binary operators.  In that file, GB_TYPE is a built-in C type (bool,</comment>
<comment type="line">// int8_t, uint64_t, double, etc) for the inputs x and y, and GB_XTYPE is</comment>
<comment type="line">// corresponding GraphBLAS type, without the prefix (BOOL, INT8, etc).</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// unary functions z=f(x) where z and x have the same type</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>ONE</name></expr></argument>, <argument><expr><literal type="string">"one"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_COMPLEX</name></expr></argument> )</argument_list></call></expr></cpp:if>

    <comment type="line">// complex types</comment>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>IDENTITY</name></expr></argument> , <argument><expr><literal type="string">"identity"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>AINV</name></expr></argument>     , <argument><expr><literal type="string">"ainv"</literal></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>MINV</name></expr></argument>     , <argument><expr><literal type="string">"minv"</literal></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

    <comment type="line">// real types</comment>
    <expr_stmt><expr><call><name>GRB_OP1</name> <argument_list>(<argument><expr><name>IDENTITY</name></expr></argument> , <argument><expr><literal type="string">"identity"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_OP1</name> <argument_list>(<argument><expr><name>AINV</name></expr></argument>     , <argument><expr><literal type="string">"ainv"</literal></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_OP1</name> <argument_list>(<argument><expr><name>MINV</name></expr></argument>     , <argument><expr><literal type="string">"minv"</literal></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// z=abs(x), z and x have the same type</comment>
    <expr_stmt><expr><call><name>GRB_OP1</name> <argument_list>(<argument><expr><name>ABS</name></expr></argument>      , <argument><expr><literal type="string">"abs"</literal></expr></argument>      )</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// GxB_ABS_* is now GrB_ABS_*, and GxB_ABS_* is historical.</comment>
    <comment type="line">// The new name is preferred.  The old name will be kept for historical</comment>
    <comment type="line">// compatibility.</comment>
    <expr_stmt><expr><call><name>GXB_OP1_RENAME</name> <argument_list>(<argument><expr><name>ABS</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// LNOT is only defined for real types, not complex</comment>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>LNOT</name></expr></argument>     , <argument><expr><literal type="string">"not"</literal></expr></argument>      )</argument_list></call></expr> ;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_FLOATING_POINT</name></expr></argument> )</argument_list></call></expr></cpp:if>

    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>SQRT</name></expr></argument>     , <argument><expr><literal type="string">"sqrt"</literal></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>LOG</name></expr></argument>      , <argument><expr><literal type="string">"log"</literal></expr></argument>      )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>EXP</name></expr></argument>      , <argument><expr><literal type="string">"exp"</literal></expr></argument>      )</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>SIN</name></expr></argument>      , <argument><expr><literal type="string">"sin"</literal></expr></argument>      )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>COS</name></expr></argument>      , <argument><expr><literal type="string">"cos"</literal></expr></argument>      )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>TAN</name></expr></argument>      , <argument><expr><literal type="string">"tan"</literal></expr></argument>      )</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>ASIN</name></expr></argument>     , <argument><expr><literal type="string">"asin"</literal></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>ACOS</name></expr></argument>     , <argument><expr><literal type="string">"acos"</literal></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>ATAN</name></expr></argument>     , <argument><expr><literal type="string">"atan"</literal></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>SINH</name></expr></argument>     , <argument><expr><literal type="string">"sinh"</literal></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>COSH</name></expr></argument>     , <argument><expr><literal type="string">"cosh"</literal></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>TANH</name></expr></argument>     , <argument><expr><literal type="string">"tanh"</literal></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>ASINH</name></expr></argument>    , <argument><expr><literal type="string">"asinh"</literal></expr></argument>    )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>ACOSH</name></expr></argument>    , <argument><expr><literal type="string">"acosh"</literal></expr></argument>    )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>ATANH</name></expr></argument>    , <argument><expr><literal type="string">"atanh"</literal></expr></argument>    )</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>SIGNUM</name></expr></argument>   , <argument><expr><literal type="string">"signum"</literal></expr></argument>   )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>CEIL</name></expr></argument>     , <argument><expr><literal type="string">"ceil"</literal></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>FLOOR</name></expr></argument>    , <argument><expr><literal type="string">"floor"</literal></expr></argument>    )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>ROUND</name></expr></argument>    , <argument><expr><literal type="string">"round"</literal></expr></argument>    )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>TRUNC</name></expr></argument>    , <argument><expr><literal type="string">"trunc"</literal></expr></argument>    )</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>EXP2</name></expr></argument>     , <argument><expr><literal type="string">"exp2"</literal></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>EXPM1</name></expr></argument>    , <argument><expr><literal type="string">"expm1"</literal></expr></argument>    )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>LOG10</name></expr></argument>    , <argument><expr><literal type="string">"log10"</literal></expr></argument>    )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>LOG1P</name></expr></argument>    , <argument><expr><literal type="string">"log1p"</literal></expr></argument>    )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>LOG2</name></expr></argument>     , <argument><expr><literal type="string">"log2"</literal></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_COMPLEX</name></expr></argument> )</argument_list></call></expr></cpp:if>
    <comment type="line">// complex only</comment>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>CONJ</name></expr></argument>     , <argument><expr><literal type="string">"conj"</literal></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="line">// real only</comment>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>LGAMMA</name></expr></argument>   , <argument><expr><literal type="string">"lgamma"</literal></expr></argument>   )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>TGAMMA</name></expr></argument>   , <argument><expr><literal type="string">"tgamma"</literal></expr></argument>   )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>ERF</name></expr></argument>      , <argument><expr><literal type="string">"erf"</literal></expr></argument>      )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>ERFC</name></expr></argument>     , <argument><expr><literal type="string">"erfc"</literal></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>CBRT</name></expr></argument>     , <argument><expr><literal type="string">"cbrt"</literal></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>FREXPX</name></expr></argument>   , <argument><expr><literal type="string">"frexpx"</literal></expr></argument>   )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1</name> <argument_list>(<argument><expr><name>FREXPE</name></expr></argument>   , <argument><expr><literal type="string">"frexpe"</literal></expr></argument>   )</argument_list></call></expr> ;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_SIGNED_INT</name></expr></argument> )</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>( <argument><expr><name>GB_UNSIGNED_INT</name></expr></argument> )</argument_list></call></expr></cpp:if>

    <comment type="line">// bitwise complement</comment>
    <expr_stmt><expr><call><name>GRB_OP1</name> <argument_list>(<argument><expr><name>BNOT</name></expr></argument>     , <argument><expr><literal type="string">"bnot"</literal></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// unary functions z=f(x) where z and x can have different types</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_FLOAT</name></expr></argument> )</argument_list></call></expr></cpp:if>

    <comment type="line">// z = f(x) where x is float, and z is bool</comment>
    <expr_stmt><expr><call><name>GXB_OP1z</name> <argument_list>(<argument><expr><name>ISINF</name></expr></argument>     , <argument><expr><literal type="string">"isinf"</literal></expr></argument>     , <argument><expr><name>bool</name></expr></argument>   , <argument><expr><name>BOOL</name></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1z</name> <argument_list>(<argument><expr><name>ISNAN</name></expr></argument>     , <argument><expr><literal type="string">"isnan"</literal></expr></argument>     , <argument><expr><name>bool</name></expr></argument>   , <argument><expr><name>BOOL</name></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1z</name> <argument_list>(<argument><expr><name>ISFINITE</name></expr></argument>  , <argument><expr><literal type="string">"isfinite"</literal></expr></argument>  , <argument><expr><name>bool</name></expr></argument>   , <argument><expr><name>BOOL</name></expr></argument> )</argument_list></call></expr> ;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOUBLE</name></expr></argument> )</argument_list></call></expr></cpp:elif>

    <comment type="line">// z = f(x) where x is double, and z is bool</comment>
    <expr_stmt><expr><call><name>GXB_OP1z</name> <argument_list>(<argument><expr><name>ISINF</name></expr></argument>     , <argument><expr><literal type="string">"isinf"</literal></expr></argument>     , <argument><expr><name>bool</name></expr></argument>   , <argument><expr><name>BOOL</name></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1z</name> <argument_list>(<argument><expr><name>ISNAN</name></expr></argument>     , <argument><expr><literal type="string">"isnan"</literal></expr></argument>     , <argument><expr><name>bool</name></expr></argument>   , <argument><expr><name>BOOL</name></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1z</name> <argument_list>(<argument><expr><name>ISFINITE</name></expr></argument>  , <argument><expr><literal type="string">"isfinite"</literal></expr></argument>  , <argument><expr><name>bool</name></expr></argument>   , <argument><expr><name>BOOL</name></expr></argument> )</argument_list></call></expr> ;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_FLOAT_COMPLEX</name></expr></argument> )</argument_list></call></expr></cpp:elif>

    <comment type="line">// z = f(x) where x is float complex, and the type of z is listed below:</comment>
    <expr_stmt><expr><call><name>GXB_OP1z</name> <argument_list>(<argument><expr><name>ABS</name></expr></argument>       , <argument><expr><literal type="string">"abs"</literal></expr></argument>       , <argument><expr><name>float</name></expr></argument>  , <argument><expr><name>FP32</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1z</name> <argument_list>(<argument><expr><name>ISINF</name></expr></argument>     , <argument><expr><literal type="string">"isinf"</literal></expr></argument>     , <argument><expr><name>bool</name></expr></argument>   , <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1z</name> <argument_list>(<argument><expr><name>ISNAN</name></expr></argument>     , <argument><expr><literal type="string">"isnan"</literal></expr></argument>     , <argument><expr><name>bool</name></expr></argument>   , <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1z</name> <argument_list>(<argument><expr><name>ISFINITE</name></expr></argument>  , <argument><expr><literal type="string">"isfinite"</literal></expr></argument>  , <argument><expr><name>bool</name></expr></argument>   , <argument><expr><name>BOOL</name></expr></argument> )</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GXB_OP1z</name> <argument_list>(<argument><expr><name>CREAL</name></expr></argument>     , <argument><expr><literal type="string">"creal"</literal></expr></argument>     , <argument><expr><name>float</name></expr></argument>  , <argument><expr><name>FP32</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1z</name> <argument_list>(<argument><expr><name>CIMAG</name></expr></argument>     , <argument><expr><literal type="string">"cimag"</literal></expr></argument>     , <argument><expr><name>float</name></expr></argument>  , <argument><expr><name>FP32</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1z</name> <argument_list>(<argument><expr><name>CARG</name></expr></argument>      , <argument><expr><literal type="string">"carg"</literal></expr></argument>      , <argument><expr><name>float</name></expr></argument>  , <argument><expr><name>FP32</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOUBLE_COMPLEX</name></expr></argument> )</argument_list></call></expr></cpp:elif>

    <comment type="line">// z = f(x) where x is double complex, and the type of z is listed below:</comment>
    <expr_stmt><expr><call><name>GXB_OP1z</name> <argument_list>(<argument><expr><name>ABS</name></expr></argument>       , <argument><expr><literal type="string">"abs"</literal></expr></argument>       , <argument><expr><name>double</name></expr></argument> , <argument><expr><name>FP64</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1z</name> <argument_list>(<argument><expr><name>ISINF</name></expr></argument>     , <argument><expr><literal type="string">"isinf"</literal></expr></argument>     , <argument><expr><name>bool</name></expr></argument>   , <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1z</name> <argument_list>(<argument><expr><name>ISNAN</name></expr></argument>     , <argument><expr><literal type="string">"isnan"</literal></expr></argument>     , <argument><expr><name>bool</name></expr></argument>   , <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1z</name> <argument_list>(<argument><expr><name>ISFINITE</name></expr></argument>  , <argument><expr><literal type="string">"isfinite"</literal></expr></argument>  , <argument><expr><name>bool</name></expr></argument>   , <argument><expr><name>BOOL</name></expr></argument> )</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GXB_OP1z</name> <argument_list>(<argument><expr><name>CREAL</name></expr></argument>     , <argument><expr><literal type="string">"creal"</literal></expr></argument>     , <argument><expr><name>double</name></expr></argument> , <argument><expr><name>FP64</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1z</name> <argument_list>(<argument><expr><name>CIMAG</name></expr></argument>     , <argument><expr><literal type="string">"cimag"</literal></expr></argument>     , <argument><expr><name>double</name></expr></argument> , <argument><expr><name>FP64</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP1z</name> <argument_list>(<argument><expr><name>CARG</name></expr></argument>      , <argument><expr><literal type="string">"carg"</literal></expr></argument>      , <argument><expr><name>double</name></expr></argument> , <argument><expr><name>FP64</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// binary functions z=f(x,y) where z, x, and y all have the same type</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>RMINUS</name></expr></argument> , <argument><expr><literal type="string">"rminus"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
<expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>RDIV</name></expr></argument>   , <argument><expr><literal type="string">"rdiv"</literal></expr></argument>  )</argument_list></call></expr> ;</expr_stmt>
<expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>PAIR</name></expr></argument>   , <argument><expr><literal type="string">"pair"</literal></expr></argument>  )</argument_list></call></expr> ;</expr_stmt>
<expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>ANY</name></expr></argument>    , <argument><expr><literal type="string">"any"</literal></expr></argument>   )</argument_list></call></expr> ;</expr_stmt>
<expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>ISEQ</name></expr></argument>   , <argument><expr><literal type="string">"iseq"</literal></expr></argument>  )</argument_list></call></expr> ;</expr_stmt>
<expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>ISNE</name></expr></argument>   , <argument><expr><literal type="string">"isne"</literal></expr></argument>  )</argument_list></call></expr> ;</expr_stmt>
<expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>POW</name></expr></argument>    , <argument><expr><literal type="string">"pow"</literal></expr></argument>   )</argument_list></call></expr> ;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_COMPLEX</name></expr></argument> )</argument_list></call></expr></cpp:if> 

    <comment type="line">// complex types</comment>
    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>FIRST</name></expr></argument>  , <argument><expr><literal type="string">"first"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>SECOND</name></expr></argument> , <argument><expr><literal type="string">"second"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>PLUS</name></expr></argument>   , <argument><expr><literal type="string">"plus"</literal></expr></argument>  )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>MINUS</name></expr></argument>  , <argument><expr><literal type="string">"minus"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>TIMES</name></expr></argument>  , <argument><expr><literal type="string">"times"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>DIV</name></expr></argument>    , <argument><expr><literal type="string">"div"</literal></expr></argument>   )</argument_list></call></expr> ;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

    <comment type="line">// real types</comment>
    <expr_stmt><expr><call><name>GRB_OP2</name> <argument_list>(<argument><expr><name>FIRST</name></expr></argument>  , <argument><expr><literal type="string">"first"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_OP2</name> <argument_list>(<argument><expr><name>SECOND</name></expr></argument> , <argument><expr><literal type="string">"second"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_OP2</name> <argument_list>(<argument><expr><name>PLUS</name></expr></argument>   , <argument><expr><literal type="string">"plus"</literal></expr></argument>  )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_OP2</name> <argument_list>(<argument><expr><name>MINUS</name></expr></argument>  , <argument><expr><literal type="string">"minus"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_OP2</name> <argument_list>(<argument><expr><name>TIMES</name></expr></argument>  , <argument><expr><literal type="string">"times"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_OP2</name> <argument_list>(<argument><expr><name>DIV</name></expr></argument>    , <argument><expr><literal type="string">"div"</literal></expr></argument>   )</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GRB_OP2</name> <argument_list>(<argument><expr><name>MIN</name></expr></argument>    , <argument><expr><literal type="string">"min"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_OP2</name> <argument_list>(<argument><expr><name>MAX</name></expr></argument>    , <argument><expr><literal type="string">"max"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>LOR</name></expr></argument>    , <argument><expr><literal type="string">"or"</literal></expr></argument>  )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>LAND</name></expr></argument>   , <argument><expr><literal type="string">"and"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>LXOR</name></expr></argument>   , <argument><expr><literal type="string">"xor"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>ISGT</name></expr></argument>   , <argument><expr><literal type="string">"isgt"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>ISLT</name></expr></argument>   , <argument><expr><literal type="string">"islt"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>ISGE</name></expr></argument>   , <argument><expr><literal type="string">"isge"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>ISLE</name></expr></argument>   , <argument><expr><literal type="string">"isle"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>GB_FLOAT</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>GB_DOUBLE</name></expr></argument>)</argument_list></call></expr></cpp:if>

    <comment type="line">// these operators are only defined for float and double</comment>
    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>ATAN2</name></expr></argument>    , <argument><expr><literal type="string">"atan2"</literal></expr></argument>    )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>HYPOT</name></expr></argument>    , <argument><expr><literal type="string">"hypot"</literal></expr></argument>    )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>FMOD</name></expr></argument>     , <argument><expr><literal type="string">"fmod"</literal></expr></argument>     )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>REMAINDER</name></expr></argument>, <argument><expr><literal type="string">"remainder"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>COPYSIGN</name></expr></argument> , <argument><expr><literal type="string">"copysign"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>LDEXP</name></expr></argument>    , <argument><expr><literal type="string">"ldexp"</literal></expr></argument>    )</argument_list></call></expr> ;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_SIGNED_INT</name></expr></argument> )</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>( <argument><expr><name>GB_UNSIGNED_INT</name></expr></argument> )</argument_list></call></expr></cpp:if>

    <comment type="line">// bitwise binary operators</comment>
    <expr_stmt><expr><call><name>GRB_OP2</name> <argument_list>(<argument><expr><name>BOR</name></expr></argument>      , <argument><expr><literal type="string">"bitor"</literal></expr></argument>   )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_OP2</name> <argument_list>(<argument><expr><name>BAND</name></expr></argument>     , <argument><expr><literal type="string">"bitand"</literal></expr></argument>  )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_OP2</name> <argument_list>(<argument><expr><name>BXOR</name></expr></argument>     , <argument><expr><literal type="string">"bitxor"</literal></expr></argument>  )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_OP2</name> <argument_list>(<argument><expr><name>BXNOR</name></expr></argument>    , <argument><expr><literal type="string">"bitxnor"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>BGET</name></expr></argument>     , <argument><expr><literal type="string">"bitget"</literal></expr></argument>   )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>BSET</name></expr></argument>     , <argument><expr><literal type="string">"bitset"</literal></expr></argument>   )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP2</name> <argument_list>(<argument><expr><name>BCLR</name></expr></argument>     , <argument><expr><literal type="string">"bitclear"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GXB_OP2shift</name> <argument_list>(<argument><expr><name>BSHIFT</name></expr></argument>, <argument><expr><literal type="string">"bitshift"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// binary functions z=f(x,y) where z, x, and y can have different types</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_FLOAT</name></expr></argument> )</argument_list></call></expr></cpp:if>

    <comment type="line">// z = cmplx(x,y) where z is float complex, x and y are float</comment>
    <expr_stmt><expr><call><name>GXB_OP2z</name> <argument_list>(<argument><expr><name>CMPLX</name></expr></argument>, <argument><expr><literal type="string">"cmplx"</literal></expr></argument>, <argument><expr><name>GxB_FC32_t</name></expr></argument>, <argument><expr><name>FC32</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOUBLE</name></expr></argument> )</argument_list></call></expr></cpp:if>

    <comment type="line">// z = cmplx(x,y) where z is double complex, x and y are double</comment>
    <expr_stmt><expr><call><name>GXB_OP2z</name> <argument_list>(<argument><expr><name>CMPLX</name></expr></argument>, <argument><expr><literal type="string">"cmplx"</literal></expr></argument>, <argument><expr><name>GxB_FC64_t</name></expr></argument>, <argument><expr><name>FC64</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_COMPLEX</name></expr></argument> )</argument_list></call></expr></cpp:if>

    <comment type="line">// complex types</comment>
    <expr_stmt><expr><call><name>GXB_OP2z</name> <argument_list>(<argument><expr><name>EQ</name></expr></argument>, <argument><expr><literal type="string">"eq"</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>, <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_OP2z</name> <argument_list>(<argument><expr><name>NE</name></expr></argument>, <argument><expr><literal type="string">"ne"</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>, <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

    <comment type="line">// real types</comment>
    <expr_stmt><expr><call><name>GRB_OP2z</name> <argument_list>(<argument><expr><name>EQ</name></expr></argument>, <argument><expr><literal type="string">"eq"</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>, <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_OP2z</name> <argument_list>(<argument><expr><name>NE</name></expr></argument>, <argument><expr><literal type="string">"ne"</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>, <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_OP2z</name> <argument_list>(<argument><expr><name>GT</name></expr></argument>, <argument><expr><literal type="string">"gt"</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>, <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_OP2z</name> <argument_list>(<argument><expr><name>LT</name></expr></argument>, <argument><expr><literal type="string">"lt"</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>, <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_OP2z</name> <argument_list>(<argument><expr><name>LE</name></expr></argument>, <argument><expr><literal type="string">"le"</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>, <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_OP2z</name> <argument_list>(<argument><expr><name>GE</name></expr></argument>, <argument><expr><literal type="string">"ge"</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>, <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// index_unary functions z=f(x,i,j,y)</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_SIGNED_INDEX</name></expr></argument> )</argument_list></call></expr></cpp:if>

    <comment type="line">// z = f (x, i, j, y) where z and y have type int32 or int64</comment>
    <expr_stmt><expr><call><name>GRB_IDXOP_POSITIONAL</name> <argument_list>(<argument><expr><name>ROWINDEX</name></expr></argument>,  <argument><expr><literal type="string">"rowindex"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_IDXOP_POSITIONAL</name> <argument_list>(<argument><expr><name>COLINDEX</name></expr></argument>,  <argument><expr><literal type="string">"colindex"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_IDXOP_POSITIONAL</name> <argument_list>(<argument><expr><name>DIAGINDEX</name></expr></argument>, <argument><expr><literal type="string">"diagindex"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_IDXOP_POSITIONAL</name> <argument_list>(<argument><expr><name>FLIPDIAGINDEX</name></expr></argument>, <argument><expr><literal type="string">"flipdiagindex"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_SIGNED_INDEX64</name></expr></argument> )</argument_list></call></expr></cpp:if>

    <comment type="line">// z = f (x, i, j, y) where z is bool; y has type int64 only</comment>
    <expr_stmt><expr><call><name>GRB_IDXOP_POSITIONAL_BOOL</name> <argument_list>(<argument><expr><name>TRIL</name></expr></argument>,    <argument><expr><literal type="string">"tril"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_IDXOP_POSITIONAL_BOOL</name> <argument_list>(<argument><expr><name>TRIU</name></expr></argument>,    <argument><expr><literal type="string">"triu"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_IDXOP_POSITIONAL_BOOL</name> <argument_list>(<argument><expr><name>DIAG</name></expr></argument>,    <argument><expr><literal type="string">"diag"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_IDXOP_POSITIONAL_BOOL</name> <argument_list>(<argument><expr><name>OFFDIAG</name></expr></argument>, <argument><expr><literal type="string">"offdiag"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_IDXOP_POSITIONAL_BOOL</name> <argument_list>(<argument><expr><name>COLLE</name></expr></argument>,   <argument><expr><literal type="string">"colle"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_IDXOP_POSITIONAL_BOOL</name> <argument_list>(<argument><expr><name>COLGT</name></expr></argument>,   <argument><expr><literal type="string">"colgt"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_IDXOP_POSITIONAL_BOOL</name> <argument_list>(<argument><expr><name>ROWLE</name></expr></argument>,   <argument><expr><literal type="string">"rowle"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_IDXOP_POSITIONAL_BOOL</name> <argument_list>(<argument><expr><name>ROWGT</name></expr></argument>,   <argument><expr><literal type="string">"rowgt"</literal></expr></argument> )</argument_list></call></expr> ;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_COMPLEX</name></expr></argument> )</argument_list></call></expr></cpp:if>

    <comment type="line">// z = f (x, i, j, y) where z is bool; y is complex</comment>
    <expr_stmt><expr><call><name>GXB_IDXOP_VALUE</name> <argument_list>(<argument><expr><name>VALUEEQ</name></expr></argument>, <argument><expr><literal type="string">"valueeq"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GXB_IDXOP_VALUE</name> <argument_list>(<argument><expr><name>VALUENE</name></expr></argument>, <argument><expr><literal type="string">"valuene"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

    <comment type="line">// z = f (x, i, j, y) where z is bool; y is real</comment>
    <expr_stmt><expr><call><name>GRB_IDXOP_VALUE</name> <argument_list>(<argument><expr><name>VALUEEQ</name></expr></argument>, <argument><expr><literal type="string">"valueeq"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_IDXOP_VALUE</name> <argument_list>(<argument><expr><name>VALUENE</name></expr></argument>, <argument><expr><literal type="string">"valuene"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_IDXOP_VALUE</name> <argument_list>(<argument><expr><name>VALUELT</name></expr></argument>, <argument><expr><literal type="string">"valuelt"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_IDXOP_VALUE</name> <argument_list>(<argument><expr><name>VALUELE</name></expr></argument>, <argument><expr><literal type="string">"valuele"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_IDXOP_VALUE</name> <argument_list>(<argument><expr><name>VALUEGT</name></expr></argument>, <argument><expr><literal type="string">"valuegt"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GRB_IDXOP_VALUE</name> <argument_list>(<argument><expr><name>VALUEGE</name></expr></argument>, <argument><expr><literal type="string">"valuege"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// clear macros for next use of this file</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_TYPE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_XTYPE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_FLOATING_POINT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_COMPLEX</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_FLOAT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_DOUBLE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_FLOAT_COMPLEX</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_DOUBLE_COMPLEX</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_SIGNED_INT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_UNSIGNED_INT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_SIGNED_INDEX</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_SIGNED_INDEX64</name></cpp:undef>

</unit>
