<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/Template/GB_AxB_dot_generic.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_AxB_dot_generic: generic template for all dot-product methods</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// This template serves the dot2 and dot3 methods, but not dot4.  The</comment>
<comment type="line">// #including file defines GB_DOT2_GENERIC or GB_DOT3_GENERIC.</comment>

<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get operators, functions, workspace, contents of A, B, C</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name><name>C</name><operator>-&gt;</operator><name>iso</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <decl_stmt><decl><type><name>GxB_binary_function</name></type> <name>fmult</name> <init>= <expr><name><name>mult</name><operator>-&gt;</operator><name>binop_function</name></name></expr></init></decl> ;</decl_stmt>    <comment type="line">// NULL if positional</comment>
    <decl_stmt><decl><type><name>GxB_binary_function</name></type> <name>fadd</name>  <init>= <expr><name><name>add</name><operator>-&gt;</operator><name>op</name><operator>-&gt;</operator><name>binop_function</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_Opcode</name></type> <name>opcode</name> <init>= <expr><name><name>mult</name><operator>-&gt;</operator><name>opcode</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>op_is_positional</name> <init>= <expr><call><name>GB_OPCODE_IS_POSITIONAL</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>csize</name> <init>= <expr><name><name>C</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>asize</name> <init>= <expr><ternary><condition><expr><name>A_is_pattern</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>A</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>size</name></name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>bsize</name> <init>= <expr><ternary><condition><expr><name>B_is_pattern</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>B</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>size</name></name></expr></else></ternary></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>xsize</name> <init>= <expr><name><name>mult</name><operator>-&gt;</operator><name>xtype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>ysize</name> <init>= <expr><name><name>mult</name><operator>-&gt;</operator><name>ytype</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl> ;</decl_stmt>

    <comment type="line">// scalar workspace: because of typecasting, the x/y types need not</comment>
    <comment type="line">// be the same as the size of the A and B types.</comment>
    <comment type="line">// flipxy false: aki = (xtype) A(k,i) and bkj = (ytype) B(k,j)</comment>
    <comment type="line">// flipxy true:  aki = (ytype) A(k,i) and bkj = (xtype) B(k,j)</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>aki_size</name> <init>= <expr><ternary><condition><expr><name>flipxy</name></expr> ?</condition><then> <expr><name>ysize</name></expr> </then><else>: <expr><name>xsize</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>bkj_size</name> <init>= <expr><ternary><condition><expr><name>flipxy</name></expr> ?</condition><then> <expr><name>xsize</name></expr> </then><else>: <expr><name>ysize</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>GB_void</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>terminal</name> <init>= <expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name><name>add</name><operator>-&gt;</operator><name>terminal</name></name></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>GB_cast_function</name></type> <name>cast_A</name></decl>, <decl><type ref="prev"/><name>cast_B</name></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>flipxy</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// A is typecasted to y, and B is typecasted to x</comment>
        <expr_stmt><expr><name>cast_A</name> <operator>=</operator> <ternary><condition><expr><name>A_is_pattern</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: 
                 <expr><call><name>GB_cast_factory</name> <argument_list>(<argument><expr><name><name>mult</name><operator>-&gt;</operator><name>ytype</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
        <expr_stmt><expr><name>cast_B</name> <operator>=</operator> <ternary><condition><expr><name>B_is_pattern</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: 
                 <expr><call><name>GB_cast_factory</name> <argument_list>(<argument><expr><name><name>mult</name><operator>-&gt;</operator><name>xtype</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>B</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <comment type="line">// A is typecasted to x, and B is typecasted to y</comment>
        <expr_stmt><expr><name>cast_A</name> <operator>=</operator> <ternary><condition><expr><name>A_is_pattern</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
                 <expr><call><name>GB_cast_factory</name> <argument_list>(<argument><expr><name><name>mult</name><operator>-&gt;</operator><name>xtype</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
        <expr_stmt><expr><name>cast_B</name> <operator>=</operator> <ternary><condition><expr><name>B_is_pattern</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
                 <expr><call><name>GB_cast_factory</name> <argument_list>(<argument><expr><name><name>mult</name><operator>-&gt;</operator><name>ytype</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>B</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// C = A'*B via dot products, function pointers, and typecasting</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_ATYPE</name></cpp:macro> <cpp:value>GB_void</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_BTYPE</name></cpp:macro> <cpp:value>GB_void</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_PHASE_2_OF_2</name></cpp:macro></cpp:define>

    <comment type="line">// no vectorization</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_PRAGMA_SIMD_VECTORIZE</name></cpp:macro> <cpp:value>;</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_PRAGMA_SIMD_DOT</name><parameter_list>(<parameter><type><name>cij</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>;</cpp:value></cpp:define>

    <comment type="line">// no special semirings or operators</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_PAIR_MULTIPLIER</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_ANY_PAIR_SEMIRING</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_IMIN_MONOID</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_IMAX_MONOID</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_FIRSTJ_MULTIPLIER</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

    <if_stmt><if>if <condition>(<expr><name>op_is_positional</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// generic semirings with positional multiply operators</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>flipxy</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">// aki = A(i,k), located in Ax [A_iso?0:(pA)], but value not used</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_A_IS_PATTERN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_GETA</name><parameter_list>(<parameter><type><name>aki</name></type></parameter>,<parameter><type><name>Ax</name></type></parameter>,<parameter><type><name>pA</name></type></parameter>,<parameter><type><name>A_iso</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>;</cpp:value></cpp:define>

        <comment type="line">// bkj = B(k,j), located in Bx [B_iso?0:pB], but value not used</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_B_IS_PATTERN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_GETB</name><parameter_list>(<parameter><type><name>bkj</name></type></parameter>,<parameter><type><name>Bx</name></type></parameter>,<parameter><type><name>pB</name></type></parameter>,<parameter><type><name>B_iso</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>;</cpp:value></cpp:define>

        <comment type="line">// define cij for each task</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CIJ_DECLARE</name><parameter_list>(<parameter><type><name>cij</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GB_CTYPE cij</cpp:value></cpp:define>

        <comment type="line">// address of Cx [p]</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CX</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;Cx [p])</cpp:value></cpp:define>

        <comment type="line">// Cx [p] = cij</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_PUTC</name><parameter_list>(<parameter><type><name>cij</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Cx [p] = cij</cpp:value></cpp:define>

        <comment type="line">// break if cij reaches the terminal value</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_DOT_TERMINAL</name><parameter_list>(<parameter><type><name>cij</name></type></parameter>)</parameter_list></cpp:macro>                                    \
            <cpp:value>if (is_terminal &amp;&amp; cij == cij_terminal)                     \
            {                                                           \
                break ;                                                 \
            }</cpp:value></cpp:define>

        <comment type="line">// C(i,j) += (A')(i,k) * B(k,j)</comment>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULTADD</name><parameter_list>(<parameter><type><name>cij</name></type></parameter>, <parameter><type><name>aki</name></type></parameter>, <parameter><type><name>bkj</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro>                      \
            <cpp:value>GB_CTYPE zwork ;                                            \
            GB_MULT (zwork, aki, bkj, i, k, j) ;                        \
            fadd (&amp;cij, &amp;cij, &amp;zwork)</cpp:value></cpp:define>

        <decl_stmt><decl><type><name>int64_t</name></type> <name>offset</name> <init>= <expr><call><name>GB_positional_offset</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>mult</name><operator>-&gt;</operator><name>ztype</name></name> <operator>==</operator> <name>GrB_INT64</name></expr>)</condition>
        <block>{<block_content>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CTYPE</name></cpp:macro> <cpp:value>int64_t</cpp:value></cpp:define>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>cij_terminal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>is_terminal</name> <init>= <expr><operator>(</operator><name>terminal</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>is_terminal</name></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>cij_terminal</name></expr></argument>, <argument><expr><name>terminal</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <switch>switch <condition>(<expr><name>opcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_FIRSTI_binop_code</name></expr>   :</case>   <comment type="line">// first_i(A'(i,k),y) == i</comment>
                <case>case <expr><name>GB_FIRSTI1_binop_code</name></expr>  :</case>   <comment type="line">// first_i1(A'(i,k),y) == i+1</comment>
                    <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_MULT</name></cpp:undef>
                    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>aki</name></type></parameter>, <parameter><type><name>bkj</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>t = i + offset</cpp:value></cpp:define>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOT2_GENERIC</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot2_meta.c"</cpp:file></cpp:include>
                    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOT3_GENERIC</name></expr></argument> )</argument_list></call></expr></cpp:elif>
                    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot3_meta.c"</cpp:file></cpp:include>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break ;</break>
                <case>case <expr><name>GB_FIRSTJ_binop_code</name></expr>   :</case>   <comment type="line">// first_j(A'(i,k),y) == k</comment>
                <case>case <expr><name>GB_FIRSTJ1_binop_code</name></expr>  :</case>   <comment type="line">// first_j1(A'(i,k),y) == k+1</comment>
                <case>case <expr><name>GB_SECONDI_binop_code</name></expr>  :</case>   <comment type="line">// second_i(x,B(k,j)) == k</comment>
                <case>case <expr><name>GB_SECONDI1_binop_code</name></expr> :</case>   <comment type="line">// second_i1(x,B(k,j)) == k+1</comment>
                    <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_MULT</name></cpp:undef>
                    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>aki</name></type></parameter>, <parameter><type><name>bkj</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>t = k + offset</cpp:value></cpp:define>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOT2_GENERIC</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot2_meta.c"</cpp:file></cpp:include>
                    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOT3_GENERIC</name></expr></argument> )</argument_list></call></expr></cpp:elif>
                    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot3_meta.c"</cpp:file></cpp:include>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break ;</break>
                <case>case <expr><name>GB_SECONDJ_binop_code</name></expr>  :</case>   <comment type="line">// second_j(x,B(k,j)) == j</comment>
                <case>case <expr><name>GB_SECONDJ1_binop_code</name></expr> :</case>   <comment type="line">// second_j1(x,B(k,j)) == j+1</comment>
                    <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_MULT</name></cpp:undef>
                    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>aki</name></type></parameter>, <parameter><type><name>bkj</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>t = j + offset</cpp:value></cpp:define>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOT2_GENERIC</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot2_meta.c"</cpp:file></cpp:include>
                    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOT3_GENERIC</name></expr></argument> )</argument_list></call></expr></cpp:elif>
                    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot3_meta.c"</cpp:file></cpp:include>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break ;</break>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_CTYPE</name></cpp:undef>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CTYPE</name></cpp:macro> <cpp:value>int32_t</cpp:value></cpp:define>
            <decl_stmt><decl><type><name>int32_t</name></type> <name>cij_terminal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>is_terminal</name> <init>= <expr><operator>(</operator><name>terminal</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>is_terminal</name></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>cij_terminal</name></expr></argument>, <argument><expr><name>terminal</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>int32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <switch>switch <condition>(<expr><name>opcode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_FIRSTI_binop_code</name></expr>   :</case>   <comment type="line">// first_i(A'(i,k),y) == i</comment>
                <case>case <expr><name>GB_FIRSTI1_binop_code</name></expr>  :</case>   <comment type="line">// first_i1(A'(i,k),y) == i+1</comment>
                    <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_MULT</name></cpp:undef>
                    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>aki</name></type></parameter>,<parameter><type><name>bkj</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>k</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>t = (int32_t) (i + offset)</cpp:value></cpp:define>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOT2_GENERIC</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot2_meta.c"</cpp:file></cpp:include>
                    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOT3_GENERIC</name></expr></argument> )</argument_list></call></expr></cpp:elif>
                    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot3_meta.c"</cpp:file></cpp:include>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break ;</break>
                <case>case <expr><name>GB_FIRSTJ_binop_code</name></expr>   :</case>   <comment type="line">// first_j(A'(i,k),y) == k</comment>
                <case>case <expr><name>GB_FIRSTJ1_binop_code</name></expr>  :</case>   <comment type="line">// first_j1(A'(i,k),y) == k+1</comment>
                <case>case <expr><name>GB_SECONDI_binop_code</name></expr>  :</case>   <comment type="line">// second_i(x,B(k,j)) == k</comment>
                <case>case <expr><name>GB_SECONDI1_binop_code</name></expr> :</case>   <comment type="line">// second_i1(x,B(k,j)) == k+1</comment>
                    <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_MULT</name></cpp:undef>
                    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>aki</name></type></parameter>,<parameter><type><name>bkj</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>k</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>t = (int32_t) (k + offset)</cpp:value></cpp:define>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOT2_GENERIC</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot2_meta.c"</cpp:file></cpp:include>
                    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOT3_GENERIC</name></expr></argument> )</argument_list></call></expr></cpp:elif>
                    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot3_meta.c"</cpp:file></cpp:include>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break ;</break>
                <case>case <expr><name>GB_SECONDJ_binop_code</name></expr>  :</case>   <comment type="line">// second_j(x,B(k,j)) == j</comment>
                <case>case <expr><name>GB_SECONDJ1_binop_code</name></expr> :</case>   <comment type="line">// second_j1(x,B(k,j)) == j+1</comment>
                    <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_MULT</name></cpp:undef>
                    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>aki</name></type></parameter>,<parameter><type><name>bkj</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>k</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>t = (int32_t) (j + offset)</cpp:value></cpp:define>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOT2_GENERIC</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot2_meta.c"</cpp:file></cpp:include>
                    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOT3_GENERIC</name></expr></argument> )</argument_list></call></expr></cpp:elif>
                    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot3_meta.c"</cpp:file></cpp:include>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break ;</break>
                <default>default:</default> <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></else></if_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// generic semirings with standard multiply operators</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// aki = A(i,k), located in Ax [A_iso?0:(pA)]</comment>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_A_IS_PATTERN</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_A_IS_PATTERN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_GETA</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_GETA</name><parameter_list>(<parameter><type><name>aki</name></type></parameter>,<parameter><type><name>Ax</name></type></parameter>,<parameter><type><name>pA</name></type></parameter>,<parameter><type><name>A_iso</name></type></parameter>)</parameter_list></cpp:macro>                                \
            <cpp:value>GB_void aki [GB_VLA(aki_size)] ;                            \
            if (!A_is_pattern) cast_A (aki, Ax +((A_iso) ? 0:(pA)*asize), asize)</cpp:value></cpp:define>

        <comment type="line">// bkj = B(k,j), located in Bx [B_iso?0:pB]</comment>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_B_IS_PATTERN</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_B_IS_PATTERN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_GETB</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_GETB</name><parameter_list>(<parameter><type><name>bkj</name></type></parameter>,<parameter><type><name>Bx</name></type></parameter>,<parameter><type><name>pB</name></type></parameter>,<parameter><type><name>B_iso</name></type></parameter>)</parameter_list></cpp:macro>                                \
            <cpp:value>GB_void bkj [GB_VLA(bkj_size)] ;                            \
            if (!B_is_pattern) cast_B (bkj, Bx +((B_iso) ? 0:(pB)*bsize), bsize)</cpp:value></cpp:define>

        <comment type="line">// define cij for each task</comment>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_CIJ_DECLARE</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CIJ_DECLARE</name><parameter_list>(<parameter><type><name>cij</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GB_void cij [GB_VLA(csize)]</cpp:value></cpp:define>

        <comment type="line">// address of Cx [p]</comment>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_CX</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CX</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Cx +((p)*csize)</cpp:value></cpp:define>

        <comment type="line">// Cx [p] = cij</comment>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_PUTC</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_PUTC</name><parameter_list>(<parameter><type><name>cij</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy (GB_CX (p), cij, csize)</cpp:value></cpp:define>

        <comment type="line">// break if cij reaches the terminal value</comment>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_DOT_TERMINAL</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_DOT_TERMINAL</name><parameter_list>(<parameter><type><name>cij</name></type></parameter>)</parameter_list></cpp:macro>                                    \
            <cpp:value>if (terminal != NULL &amp;&amp; memcmp (cij, terminal, csize) == 0) \
            {                                                           \
                break ;                                                 \
            }</cpp:value></cpp:define>

        <comment type="line">// C(i,j) += (A')(i,k) * B(k,j)</comment>
        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_MULTADD</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULTADD</name><parameter_list>(<parameter><type><name>cij</name></type></parameter>, <parameter><type><name>aki</name></type></parameter>, <parameter><type><name>bkj</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro>                      \
            <cpp:value>GB_void zwork [GB_VLA(csize)] ;                             \
            GB_MULT (zwork, aki, bkj, i, k, j) ;                        \
            fadd (cij, cij, zwork)</cpp:value></cpp:define>

        <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_CTYPE</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_CTYPE</name></cpp:macro> <cpp:value>GB_void</cpp:value></cpp:define>

        <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>GB_FIRST_binop_code</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// t = A(i,k)</comment>
            <comment type="line">// fmult is not used and can be NULL (for user-defined types)</comment>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>flipxy</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>B_is_pattern</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_MULT</name></cpp:undef>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>aik</name></type></parameter>, <parameter><type><name>bkj</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy (t, aik, csize)</cpp:value></cpp:define>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOT2_GENERIC</name></expr></argument> )</argument_list></call></expr></cpp:if>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot2_meta.c"</cpp:file></cpp:include>
            <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOT3_GENERIC</name></expr></argument> )</argument_list></call></expr></cpp:elif>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot3_meta.c"</cpp:file></cpp:include>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>GB_SECOND_binop_code</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// t = B(i,k)</comment>
            <comment type="line">// fmult is not used and can be NULL (for user-defined types)</comment>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>flipxy</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>A_is_pattern</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_MULT</name></cpp:undef>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>aik</name></type></parameter>, <parameter><type><name>bkj</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy (t, bkj, csize)</cpp:value></cpp:define>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOT2_GENERIC</name></expr></argument> )</argument_list></call></expr></cpp:if>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot2_meta.c"</cpp:file></cpp:include>
            <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOT3_GENERIC</name></expr></argument> )</argument_list></call></expr></cpp:elif>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot3_meta.c"</cpp:file></cpp:include>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>flipxy</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// t = B(k,j) * (A')(i,k)</comment>
            <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_MULT</name></cpp:undef>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>aki</name></type></parameter>, <parameter><type><name>bkj</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fmult (t, bkj, aki)</cpp:value></cpp:define>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOT2_GENERIC</name></expr></argument> )</argument_list></call></expr></cpp:if>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot2_meta.c"</cpp:file></cpp:include>
            <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOT3_GENERIC</name></expr></argument> )</argument_list></call></expr></cpp:elif>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot3_meta.c"</cpp:file></cpp:include>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// t = (A')(i,k) * B(k,j)</comment>
            <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_MULT</name></cpp:undef>
            <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_MULT</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>aki</name></type></parameter>, <parameter><type><name>bkj</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fmult (t, aki, bkj)</cpp:value></cpp:define>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOT2_GENERIC</name></expr></argument> )</argument_list></call></expr></cpp:if>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot2_meta.c"</cpp:file></cpp:include>
            <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_DOT3_GENERIC</name></expr></argument> )</argument_list></call></expr></cpp:elif>
            <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_AxB_dot3_meta.c"</cpp:file></cpp:include>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block>

</unit>
