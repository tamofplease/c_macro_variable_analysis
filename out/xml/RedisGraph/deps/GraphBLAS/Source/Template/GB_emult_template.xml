<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" xmlns:omp="http://www.srcML.org/srcML/openmp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/Template/GB_emult_template.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_emult_template: C=A.*B, C&lt;M or !M&gt;=A.*B when C is sparse/hyper</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// Computes C=A.*B, C&lt;M&gt;=A.*B, or C&lt;!M&gt;=A.*B when C is sparse or hypersparse:</comment>

<comment type="line">// phase1: does not compute C itself, but just counts the # of entries in each</comment>
<comment type="line">// vector of C.  Fine tasks compute the # of entries in their slice of a</comment>
<comment type="line">// single vector of C, and the results are cumsum'd.</comment>

<comment type="line">// phase2: computes C, using the counts computed by phase1.</comment>

<comment type="line">// No input matrix can be jumbled, and C is constructed as unjumbled.</comment>

<comment type="line">// The following cases are handled:</comment>

        <comment type="line">//      ------------------------------------------</comment>
        <comment type="line">//      C       =           A       .*      B</comment>
        <comment type="line">//      ------------------------------------------</comment>
        <comment type="line">//      sparse  .           sparse          sparse  (method: 8)</comment>

        <comment type="line">//      ------------------------------------------</comment>
        <comment type="line">//      C       &lt;M&gt;=        A       .*      B</comment>
        <comment type="line">//      ------------------------------------------</comment>
        <comment type="line">//      sparse  sparse      sparse          sparse  (method: 8)</comment>
        <comment type="line">//      sparse  bitmap      sparse          sparse  (method: 8)</comment>
        <comment type="line">//      sparse  full        sparse          sparse  (method: 8)</comment>
        <comment type="line">//      sparse  sparse      sparse          bitmap  (9 or 2)</comment>
        <comment type="line">//      sparse  sparse      sparse          full    (9 or 2)</comment>
        <comment type="line">//      sparse  sparse      bitmap          sparse  (10 or 3)</comment>
        <comment type="line">//      sparse  sparse      full            sparse  (10 or 3)</comment>

        <comment type="line">//      ------------------------------------------</comment>
        <comment type="line">//      C       &lt;!M&gt;=       A       .*      B</comment>
        <comment type="line">//      ------------------------------------------</comment>
        <comment type="line">//      sparse  sparse      sparse          sparse  (8: M later)</comment>
        <comment type="line">//      sparse  bitmap      sparse          sparse  (method: 8)</comment>
        <comment type="line">//      sparse  full        sparse          sparse  (method: 8)</comment>

<comment type="line">// Methods 9 and 10 are not yet implemented, and are currently handled by this</comment>
<comment type="line">// Method 8 instead.  those cases.  Methods 2 and 3 can be used as well, but</comment>
<comment type="line">// only if M is applied later.  See GB_emult_sparsity for this decision.</comment>

<block>{<block_content>

    <decl_stmt><decl><type><name>int</name></type> <name>taskid</name></decl> ;</decl_stmt>
    <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>C_nthreads</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>dynamic</omp:expr></omp:argument>,<omp:argument><omp:expr>1</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
    <for>for <control>(<init><expr><name>taskid</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>taskid</name> <operator>&lt;</operator> <name>C_ntasks</name></expr> ;</condition> <incr><expr><name>taskid</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// get the task descriptor</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><name>int64_t</name></type> <name>kfirst</name> <init>= <expr><name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>kfirst</name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>klast</name>  <init>= <expr><name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>klast</name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>fine_task</name> <init>= <expr><operator>(</operator><name>klast</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>len</name></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>fine_task</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// a fine task operates on a slice of a single vector</comment>
            <expr_stmt><expr><name>klast</name> <operator>=</operator> <name>kfirst</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>len</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// a coarse task operates on one or more whole vectors</comment>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <name>vlen</name></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// compute all vectors in this task</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><name>kfirst</name></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;=</operator> <name>klast</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// get j, the kth vector of C</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>j</name> <init>= <expr><call><name>GBH</name> <argument_list>(<argument><expr><name>Ch</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>cjnz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pC</name></decl>, <decl><type ref="prev"/><name>pC_end</name></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>fine_task</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// A fine task computes a slice of C(:,j)</comment>
                <expr_stmt><expr><name>pC</name>     <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>  ]</index></name><operator>.</operator><name>pC</name></expr> ;</expr_stmt>
                <expr_stmt><expr><name>pC_end</name> <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pC</name></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>Cp</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>&lt;=</operator> <name>pC</name> <operator>&amp;&amp;</operator> <name>pC</name> <operator>&lt;=</operator> <name>pC_end</name> <operator>&amp;&amp;</operator> <name>pC_end</name> <operator>&lt;=</operator> <name><name>Cp</name> <index>[<expr><name>k</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <comment type="line">// The vectors of C are never sliced for a coarse task.</comment>
                <expr_stmt><expr><name>pC</name>     <operator>=</operator> <name><name>Cp</name> <index>[<expr><name>k</name></expr>]</index></name></expr> ;</expr_stmt>
                <expr_stmt><expr><name>pC_end</name> <operator>=</operator> <name><name>Cp</name> <index>[<expr><name>k</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>cjnz</name> <init>= <expr><name>pC_end</name> <operator>-</operator> <name>pC</name></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>cjnz</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// get A(:,j)</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>pA</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>pA_end</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>fine_task</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// A fine task operates on Ai,Ax [pA...pA_end-1], which is</comment>
                <comment type="line">// a subset of the vector A(:,j)</comment>
                <expr_stmt><expr><name>pA</name>     <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>pA</name></expr> ;</expr_stmt>
                <expr_stmt><expr><name>pA_end</name> <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>pA_end</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="line">// A coarse task operates on the entire vector A (:,j)</comment>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>kA</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>Ch</name> <operator>==</operator> <name>Ah</name><operator>)</operator></expr> ?</condition><then> <expr><name>k</name></expr> </then><else>:
                            <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>C_to_A</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>j</name></expr> </then><else>: <expr><name><name>C_to_A</name> <index>[<expr><name>k</name></expr>]</index></name></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>kA</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><name>pA</name>     <operator>=</operator> <call><name>GBP</name> <argument_list>(<argument><expr><name>Ap</name></expr></argument>, <argument><expr><name>kA</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>pA_end</name> <operator>=</operator> <call><name>GBP</name> <argument_list>(<argument><expr><name>Ap</name></expr></argument>, <argument><expr><name>kA</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>ajnz</name> <init>= <expr><name>pA_end</name> <operator>-</operator> <name>pA</name></expr></init></decl> ;</decl_stmt>        <comment type="line">// nnz in A(:,j) for this slice</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pA_start</name> <init>= <expr><name>pA</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>adense</name> <init>= <expr><operator>(</operator><name>ajnz</name> <operator>==</operator> <name>len</name><operator>)</operator></expr></init></decl> ;</decl_stmt>

            <comment type="line">// get the first and last indices in A(:,j) for this vector</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>iA_first</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>ajnz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><name>iA_first</name> <operator>=</operator> <call><name>GBI</name> <argument_list>(<argument><expr><name>Ai</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>( <argument><expr><name>GB_DEBUG</name></expr></argument> )</argument_list></call></expr></cpp:if>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>iA_last</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>ajnz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><name>iA_last</name>  <operator>=</operator> <call><name>GBI</name> <argument_list>(<argument><expr><name>Ai</name></expr></argument>, <argument><expr><name>pA_end</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// get B(:,j)</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>pB</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>pB_end</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>fine_task</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// A fine task operates on Bi,Bx [pB...pB_end-1], which is</comment>
                <comment type="line">// a subset of the vector B(:,j)</comment>
                <expr_stmt><expr><name>pB</name>     <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>pB</name></expr> ;</expr_stmt>
                <expr_stmt><expr><name>pB_end</name> <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>pB_end</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="line">// A coarse task operates on the entire vector B (:,j)</comment>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>kB</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>Ch</name> <operator>==</operator> <name>Bh</name><operator>)</operator></expr> ?</condition><then> <expr><name>k</name></expr> </then><else>:
                            <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>C_to_B</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>j</name></expr> </then><else>: <expr><name><name>C_to_B</name> <index>[<expr><name>k</name></expr>]</index></name></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>kB</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><name>pB</name>     <operator>=</operator> <call><name>GBP</name> <argument_list>(<argument><expr><name>Bp</name></expr></argument>, <argument><expr><name>kB</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>pB_end</name> <operator>=</operator> <call><name>GBP</name> <argument_list>(<argument><expr><name>Bp</name></expr></argument>, <argument><expr><name>kB</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>bjnz</name> <init>= <expr><name>pB_end</name> <operator>-</operator> <name>pB</name></expr></init></decl> ;</decl_stmt>        <comment type="line">// nnz in B(:,j) for this slice</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pB_start</name> <init>= <expr><name>pB</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>bdense</name> <init>= <expr><operator>(</operator><name>bjnz</name> <operator>==</operator> <name>len</name><operator>)</operator></expr></init></decl> ;</decl_stmt>

            <comment type="line">// get the first and last indices in B(:,j) for this vector</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>iB_first</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>bjnz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><name>iB_first</name> <operator>=</operator> <call><name>GBI</name> <argument_list>(<argument><expr><name>Bi</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>( <argument><expr><name>GB_DEBUG</name></expr></argument> )</argument_list></call></expr></cpp:if>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>iB_last</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>bjnz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><name>iB_last</name>  <operator>=</operator> <call><name>GBI</name> <argument_list>(<argument><expr><name>Bi</name></expr></argument>, <argument><expr><name>pB_end</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// get M(:,j) if M is sparse or hypersparse</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>pM</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pM_end</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>M_is_sparse_or_hyper</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>fine_task</name></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// A fine task operates on Mi,Mx [pM...pM_end-1], which is</comment>
                    <comment type="line">// a subset of the vector M(:,j)</comment>
                    <expr_stmt><expr><name>pM</name>     <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>pM</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>pM_end</name> <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>pM_end</name></expr> ;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>kM</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>Ch</name> <operator>==</operator> <name>Mh</name></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// Ch is the same as Mh (a shallow copy), or both NULL</comment>
                        <expr_stmt><expr><name>kM</name> <operator>=</operator> <name>k</name></expr> ;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content> 
                        <expr_stmt><expr><name>kM</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>C_to_M</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>j</name></expr> </then><else>: <expr><name><name>C_to_M</name> <index>[<expr><name>k</name></expr>]</index></name></expr></else></ternary></expr> ;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name>kM</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content> 
                        <expr_stmt><expr><name>pM</name>     <operator>=</operator> <call><name>GBP</name> <argument_list>(<argument><expr><name>Mp</name></expr></argument>, <argument><expr><name>kM</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><name>pM_end</name> <operator>=</operator> <call><name>GBP</name> <argument_list>(<argument><expr><name>Mp</name></expr></argument>, <argument><expr><name>kM</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// C(:,j)&lt;optional mask&gt; = A (:,j) .* B (:,j) or subvector</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>

            <if_stmt><if>if <condition>(<expr><name>ajnz</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>bjnz</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content> 

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// Method8(a): A(:,j) and/or B(:,j) are empty</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <empty_stmt>;</empty_stmt>

            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>iA_last</name> <operator>&lt;</operator> <name>iB_first</name> <operator>||</operator> <name>iB_last</name> <operator>&lt;</operator> <name>iA_first</name></expr>)</condition>
            <block>{<block_content> 

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// Method8(a): intersection of A(:,j) and B(:,j) is empty</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <comment type="line">// the last entry of A(:,j) comes before the first entry</comment>
                <comment type="line">// of B(:,j), or visa versa</comment>
                <empty_stmt>;</empty_stmt>

            </block_content>}</block></if>
            <if type="elseif">else

            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            if <condition>(<expr><name>M</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// Method8(b,c,d): C = A.*B, no mask</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <comment type="line">//      ------------------------------------------</comment>
                <comment type="line">//      C       =           A       .*      B</comment>
                <comment type="line">//      ------------------------------------------</comment>
                <comment type="line">//      sparse  .           sparse          sparse  (method: 8)</comment>
                <comment type="line">//      sparse  sparse      sparse          sparse  (8, M later)</comment>

                <comment type="line">// both A and B are sparse/hyper</comment>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>A_is_sparse</name> <operator>||</operator> <name>A_is_hyper</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>B_is_sparse</name> <operator>||</operator> <name>B_is_hyper</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>ajnz</name> <operator>&gt;</operator> <literal type="number">32</literal> <operator>*</operator> <name>bjnz</name></expr>)</condition>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method8(b): A(:,j) is much denser than B(:,j)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <for>for <control>( <init>;</init> <condition><expr><name>pB</name> <operator>&lt;</operator> <name>pB_end</name></expr> ;</condition> <incr><expr><name>pB</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Bi</name> <index>[<expr><name>pB</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <comment type="line">// find i in A(:,j)</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>pright</name> <init>= <expr><name>pA_end</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_BINARY_SEARCH</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>Ai</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>pright</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = A (i,j) .* B (i,j)</comment>
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                            <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>&lt;</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                            <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_EMULT</name></cpp:ifndef>
                            <expr_stmt><expr><call><name>GB_GETA</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_2_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>==</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>bjnz</name> <operator>&gt;</operator> <literal type="number">32</literal> <operator>*</operator> <name>ajnz</name></expr>)</condition>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method8(c): B(:,j) is much denser than A(:,j)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <for>for <control>( <init>;</init> <condition><expr><name>pA</name> <operator>&lt;</operator> <name>pA_end</name></expr> ;</condition> <incr><expr><name>pA</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <comment type="line">// find i in B(:,j)</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>pright</name> <init>= <expr><name>pB_end</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_BINARY_SEARCH</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>Bi</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>pright</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = A (i,j) .* B (i,j)</comment>
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                            <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>&lt;</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                            <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_EMULT</name></cpp:ifndef>
                            <expr_stmt><expr><call><name>GB_GETA</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_2_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>==</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                </block_content>}</block></if>
                <else>else
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method8(d): A(:,j) and B(:,j) about the sparsity</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <comment type="line">// linear-time scan of A(:,j) and B(:,j)</comment>

                    <while>while <condition>(<expr><name>pA</name> <operator>&lt;</operator> <name>pA_end</name> <operator>&amp;&amp;</operator> <name>pB</name> <operator>&lt;</operator> <name>pB_end</name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>iA</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>iB</name> <init>= <expr><name><name>Bi</name> <index>[<expr><name>pB</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>iA</name> <operator>&lt;</operator> <name>iB</name></expr>)</condition>
                        <block>{<block_content> 
                            <comment type="line">// A(i,j) exists but not B(i,j)</comment>
                            <expr_stmt><expr><name>pA</name><operator>++</operator></expr> ;</expr_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><name>iB</name> <operator>&lt;</operator> <name>iA</name></expr>)</condition>
                        <block>{<block_content> 
                            <comment type="line">// B(i,j) exists but not A(i,j)</comment>
                            <expr_stmt><expr><name>pB</name><operator>++</operator></expr> ;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content> 
                            <comment type="line">// both A(i,j) and B(i,j) exist</comment>
                            <comment type="line">// C (i,j) = A (i,j) .* B (i,j)</comment>
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                            <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>&lt;</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>iB</name></expr> ;</expr_stmt>
                            <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_EMULT</name></cpp:ifndef>
                            <expr_stmt><expr><call><name>GB_GETA</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>, <argument><expr><name>iB</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <expr_stmt><expr><name>pA</name><operator>++</operator></expr> ;</expr_stmt>
                            <expr_stmt><expr><name>pB</name><operator>++</operator></expr> ;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></while>

                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_2_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>==</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></else></if_stmt>

            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>M_is_sparse_or_hyper</name></expr>)</condition>
            <block>{<block_content>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// Method8(e): C and M are sparse or hypersparse</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <comment type="line">//      ------------------------------------------</comment>
                <comment type="line">//      C       &lt;M&gt;=        A       .*      B</comment>
                <comment type="line">//      ------------------------------------------</comment>
                <comment type="line">//      sparse  sparse      sparse          sparse  (method: 8)</comment>
                <comment type="line">//      sparse  sparse      sparse          bitmap  (9 or 2)</comment>
                <comment type="line">//      sparse  sparse      sparse          full    (9 or 2)</comment>
                <comment type="line">//      sparse  sparse      bitmap          sparse  (10 or 3)</comment>
                <comment type="line">//      sparse  sparse      full            sparse  (10 or 3)</comment>

                <comment type="line">// Methods 9 and 10 are not yet implemented; using Method 8</comment>
                <comment type="line">// (GB_emult_phase[123]) instead.</comment>

                <comment type="line">// ether A or B are sparse/hyper</comment>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>A_is_sparse</name> <operator>||</operator> <name>A_is_hyper</name> <operator>||</operator> <name>B_is_sparse</name> <operator>||</operator> <name>B_is_hyper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <for>for <control>( <init>;</init> <condition><expr><name>pM</name> <operator>&lt;</operator> <name>pM_end</name></expr> ;</condition> <incr><expr><name>pM</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// get M(i,j) for A(i,j) .* B (i,j)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><call><name>GBI</name> <argument_list>(<argument><expr><name>Mi</name></expr></argument>, <argument><expr><name>pM</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type> <name>mij</name> <init>= <expr><call><name>GB_mcast</name> <argument_list>(<argument><expr><name>Mx</name></expr></argument>, <argument><expr><name>pM</name></expr></argument>, <argument><expr><name>msize</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>mij</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// get A(i,j)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <decl_stmt><decl><type><name>bool</name></type> <name>afound</name></decl> ;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>adense</name></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// A(:,j) is dense, bitmap, or full; use quick lookup</comment>
                        <expr_stmt><expr><name>pA</name> <operator>=</operator> <name>pA_start</name> <operator>+</operator> <name>i</name> <operator>-</operator> <name>iA_first</name></expr> ;</expr_stmt>
                        <expr_stmt><expr><name>afound</name> <operator>=</operator> <call><name>GBB</name> <argument_list>(<argument><expr><name>Ab</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content> 
                        <comment type="line">// A(:,j) is sparse; use binary search for A(i,j)</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>apright</name> <init>= <expr><name>pA_end</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_BINARY_SEARCH</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>Ai</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>apright</name></expr></argument>, <argument><expr><name>afound</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>afound</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GBI</name> <argument_list>(<argument><expr><name>Ai</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// get B(i,j)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <decl_stmt><decl><type><name>bool</name></type> <name>bfound</name></decl> ;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>bdense</name></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// B(:,j) is dense; use direct lookup for B(i,j)</comment>
                        <expr_stmt><expr><name>pB</name> <operator>=</operator> <name>pB_start</name> <operator>+</operator> <name>i</name> <operator>-</operator> <name>iB_first</name></expr> ;</expr_stmt>
                        <expr_stmt><expr><name>bfound</name> <operator>=</operator> <call><name>GBB</name> <argument_list>(<argument><expr><name>Bb</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content> 
                        <comment type="line">// B(:,j) is sparse; use binary search for B(i,j)</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>bpright</name> <init>= <expr><name>pB_end</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_BINARY_SEARCH</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>Bi</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>bpright</name></expr></argument>, <argument><expr><name>bfound</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>bfound</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GBI</name> <argument_list>(<argument><expr><name>Bi</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// C(i,j) = A(i,j) .* B(i,j)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <comment type="line">// C (i,j) = A (i,j) .* B (i,j)</comment>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                    <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_EMULT</name></cpp:ifndef>
                    <expr_stmt><expr><call><name>GB_GETA</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></for>

                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_2_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>==</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            </block_content>}</block></if>
            <else>else
            <block>{<block_content>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// M is bitmap or full, for either C&lt;M&gt;=A.*B or C&lt;!M&gt;=A.*B</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <comment type="line">//      ------------------------------------------</comment>
                <comment type="line">//      C       &lt;M&gt;=        A       .*      B</comment>
                <comment type="line">//      ------------------------------------------</comment>
                <comment type="line">//      sparse  bitmap      sparse          sparse  (method: 8)</comment>
                <comment type="line">//      sparse  full        sparse          sparse  (method: 8)</comment>

                <comment type="line">//      ------------------------------------------</comment>
                <comment type="line">//      C       &lt;!M&gt;=       A       .*      B</comment>
                <comment type="line">//      ------------------------------------------</comment>
                <comment type="line">//      sparse  bitmap      sparse          sparse  (method: 8)</comment>
                <comment type="line">//      sparse  full        sparse          sparse  (method: 8)</comment>

                <comment type="line">// GB_GET_MIJ: get M(i,j) where M is bitmap or full</comment>
                <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_GET_MIJ</name></cpp:undef>
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_GET_MIJ</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>                                     \
                    <cpp:value>int64_t pM = pM_start + i ;                           \
                    bool mij = GBB (Mb, pM) &amp;&amp; GB_mcast (Mx, pM, msize) ; \
                    if (Mask_comp) mij = !mij ;</cpp:value></cpp:define>

                <comment type="line">// both A and B are sparse/hyper</comment>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>A_is_sparse</name> <operator>||</operator> <name>A_is_hyper</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>B_is_sparse</name> <operator>||</operator> <name>B_is_hyper</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

                <decl_stmt><decl><type><name>int64_t</name></type> <name>pM_start</name> <init>= <expr><name>j</name> <operator>*</operator> <name>vlen</name></expr></init></decl> ;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>ajnz</name> <operator>&gt;</operator> <literal type="number">32</literal> <operator>*</operator> <name>bjnz</name></expr>)</condition>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method8(f): A(:,j) much denser than B(:,j), M bitmap/full</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <for>for <control>( <init>;</init> <condition><expr><name>pB</name> <operator>&lt;</operator> <name>pB_end</name></expr> ;</condition> <incr><expr><name>pB</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Bi</name> <index>[<expr><name>pB</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_GET_MIJ</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>mij</name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="line">// find i in A(:,j)</comment>
                            <decl_stmt><decl><type><name>int64_t</name></type> <name>pright</name> <init>= <expr><name>pA_end</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                            <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl> ;</decl_stmt>
                            <expr_stmt><expr><call><name>GB_BINARY_SEARCH</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>Ai</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>pright</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
                            <block>{<block_content> 
                                <comment type="line">// C (i,j) = A (i,j) .* B (i,j)</comment>
                                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                                <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                                <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>&lt;</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                                <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_EMULT</name></cpp:ifndef>
                                <expr_stmt><expr><call><name>GB_GETA</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>

                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_2_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>==</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>bjnz</name> <operator>&gt;</operator> <literal type="number">32</literal> <operator>*</operator> <name>ajnz</name></expr>)</condition>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method8(g): B(:,j) much denser than A(:,j), M bitmap/full</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <for>for <control>( <init>;</init> <condition><expr><name>pA</name> <operator>&lt;</operator> <name>pA_end</name></expr> ;</condition> <incr><expr><name>pA</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_GET_MIJ</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>mij</name></expr>)</condition>
                        <block>{<block_content>

                            <comment type="line">// find i in B(:,j)</comment>
                            <decl_stmt><decl><type><name>int64_t</name></type> <name>pright</name> <init>= <expr><name>pB_end</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                            <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl> ;</decl_stmt>
                            <expr_stmt><expr><call><name>GB_BINARY_SEARCH</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>Bi</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>pright</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
                            <block>{<block_content> 
                                <comment type="line">// C (i,j) = A (i,j) .* B (i,j)</comment>
                                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                                <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                                <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>&lt;</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                                <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_EMULT</name></cpp:ifndef>
                                <expr_stmt><expr><call><name>GB_GETA</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>

                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_2_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>==</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                </block_content>}</block></if>
                <else>else
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method8(h): A(:,j) and B(:,j) about same, M bitmap/full</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <comment type="line">// linear-time scan of A(:,j) and B(:,j)</comment>

                    <while>while <condition>(<expr><name>pA</name> <operator>&lt;</operator> <name>pA_end</name> <operator>&amp;&amp;</operator> <name>pB</name> <operator>&lt;</operator> <name>pB_end</name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>iA</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>iB</name> <init>= <expr><name><name>Bi</name> <index>[<expr><name>pB</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>iA</name> <operator>&lt;</operator> <name>iB</name></expr>)</condition>
                        <block>{<block_content> 
                            <comment type="line">// A(i,j) exists but not B(i,j)</comment>
                            <expr_stmt><expr><name>pA</name><operator>++</operator></expr> ;</expr_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><name>iB</name> <operator>&lt;</operator> <name>iA</name></expr>)</condition>
                        <block>{<block_content> 
                            <comment type="line">// B(i,j) exists but not A(i,j)</comment>
                            <expr_stmt><expr><name>pB</name><operator>++</operator></expr> ;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <comment type="line">// both A(i,j) and B(i,j) exist</comment>
                            <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name>iA</name></expr></init></decl> ;</decl_stmt>
                            <expr_stmt><expr><call><name>GB_GET_MIJ</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>mij</name></expr>)</condition>
                            <block>{<block_content> 
                                <comment type="line">// C (i,j) = A (i,j) .* B (i,j)</comment>
                                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                                <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                                <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>&lt;</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                                <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_EMULT</name></cpp:ifndef>
                                <expr_stmt><expr><call><name>GB_GETA</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>, <argument><expr><name>iB</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            </block_content>}</block></if></if_stmt>
                            <expr_stmt><expr><name>pA</name><operator>++</operator></expr> ;</expr_stmt>
                            <expr_stmt><expr><name>pB</name><operator>++</operator></expr> ;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></while>

                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_2_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>==</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// final count of nnz (C (:,j))</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
            <if_stmt><if>if <condition>(<expr><name>fine_task</name></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>pC</name> <operator>=</operator> <name>cjnz</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <expr_stmt><expr><name><name>Cp</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>cjnz</name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></for>
    </block_content>}</block></for>
</block_content>}</block>

</unit>
