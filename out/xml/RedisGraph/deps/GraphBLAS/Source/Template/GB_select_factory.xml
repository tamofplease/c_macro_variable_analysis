<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/Template/GB_select_factory.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_select_factory: switch factory for C=select(A,thunk)</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<switch>switch <condition>(<expr><name>opcode</name></expr>)</condition>
<block>{<block_content>

    <case>case <expr><name>GB_TRIL_selop_code</name></expr>          :</case>  <comment type="line">// C = tril (A,k)</comment>

        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_SELECT_PHASE1</name></cpp:ifdef>
        <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_tril</argument>, <argument>_iso</argument>, <argument>GB_void</argument>)</argument_list></macro>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_ignore_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_tril</argument>, <argument>_iso</argument>, <argument>GB_void</argument>)</argument_list></macro>
            <default>default              :</default> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_tril</argument>, <argument>_any</argument>, <argument>GB_void</argument>)</argument_list></macro>
        </block_content>}</block></switch>
        <break>break ;</break>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>GB_TRIU_selop_code</name></expr>          :</case>  <comment type="line">// C = triu (A,k)</comment>

        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_SELECT_PHASE1</name></cpp:ifdef>
        <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_triu</argument>, <argument>_iso</argument>, <argument>GB_void</argument>)</argument_list></macro>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_ignore_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_triu</argument>, <argument>_iso</argument>, <argument>GB_void</argument>)</argument_list></macro>
            <default>default              :</default> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_triu</argument>, <argument>_any</argument>, <argument>GB_void</argument>)</argument_list></macro>
        </block_content>}</block></switch>
        <break>break ;</break>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>GB_DIAG_selop_code</name></expr>          :</case>  <comment type="line">// C = diag (A,k)</comment>

        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_SELECT_PHASE1</name></cpp:ifdef>
        <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_diag</argument>, <argument>_iso</argument>, <argument>GB_void</argument>)</argument_list></macro>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_ignore_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_diag</argument>, <argument>_iso</argument>, <argument>GB_void</argument>)</argument_list></macro>
            <default>default              :</default> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_diag</argument>, <argument>_any</argument>, <argument>GB_void</argument>)</argument_list></macro>
        </block_content>}</block></switch>
        <break>break ;</break>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>GB_OFFDIAG_selop_code</name></expr>       :</case>  <comment type="line">// C = offdiag (A,k)</comment>

        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_SELECT_PHASE1</name></cpp:ifdef>
        <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_offdiag</argument>, <argument>_iso</argument>, <argument>GB_void</argument>)</argument_list></macro>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_ignore_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_offdiag</argument>, <argument>_iso</argument>, <argument>GB_void</argument>)</argument_list></macro>
            <default>default              :</default> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_offdiag</argument>, <argument>_any</argument>, <argument>GB_void</argument>)</argument_list></macro>
        </block_content>}</block></switch>
        <break>break ;</break>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>GB_ROWINDEX_idxunop_code</name></expr>     :</case>  <comment type="line">// C = rowindex (A,k)</comment>

        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_SELECT_PHASE1</name></cpp:ifdef>
        <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_rowindex</argument>, <argument>_iso</argument>, <argument>GB_void</argument>)</argument_list></macro>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_ignore_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_rowindex</argument>, <argument>_iso</argument>, <argument>GB_void</argument>)</argument_list></macro>
            <default>default              :</default> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_rowindex</argument>, <argument>_any</argument>, <argument>GB_void</argument>)</argument_list></macro>
        </block_content>}</block></switch>
        <break>break ;</break>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>GB_ROWLE_idxunop_code</name></expr>     :</case>  <comment type="line">// C = rowle (A,k)</comment>

        <comment type="line">// also used for resize</comment>
        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_SELECT_PHASE1</name></cpp:ifdef>
        <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_rowle</argument>, <argument>_iso</argument>, <argument>GB_void</argument>)</argument_list></macro>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_ignore_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_rowle</argument>, <argument>_iso</argument>, <argument>GB_void</argument>)</argument_list></macro>
            <default>default              :</default> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_rowle</argument>, <argument>_any</argument>, <argument>GB_void</argument>)</argument_list></macro>
        </block_content>}</block></switch>
        <break>break ;</break>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>GB_ROWGT_idxunop_code</name></expr>     :</case>  <comment type="line">// C = rowgt (A,k)</comment>

        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_SELECT_PHASE1</name></cpp:ifdef>
        <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_rowgt</argument>, <argument>_iso</argument>, <argument>GB_void</argument>)</argument_list></macro>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_ignore_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_rowgt</argument>, <argument>_iso</argument>, <argument>GB_void</argument>)</argument_list></macro>
            <default>default              :</default> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_rowgt</argument>, <argument>_any</argument>, <argument>GB_void</argument>)</argument_list></macro>
        </block_content>}</block></switch>
        <break>break ;</break>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>GB_VALUEEQ_idxunop_code</name></expr> :</case> <comment type="line">// C = value_select (A,k)</comment>
    <case>case <expr><name>GB_VALUENE_idxunop_code</name></expr> :</case>
    <case>case <expr><name>GB_VALUEGT_idxunop_code</name></expr> :</case> 
    <case>case <expr><name>GB_VALUEGE_idxunop_code</name></expr> :</case> 
    <case>case <expr><name>GB_VALUELT_idxunop_code</name></expr> :</case> 
    <case>case <expr><name>GB_VALUELE_idxunop_code</name></expr> :</case> 

        <comment type="line">// A is not iso, and typecasting is required, so use the</comment>
        <comment type="line">// idxunop_function, just as if this were a user-defined operator.</comment>
        <comment type="line">// Typecasting is costly; both the typecast and the idxunop function</comment>
        <comment type="line">// are used via function pointers, so this is a generic method.</comment>
        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_SELECT_PHASE1</name></cpp:ifdef>
        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(generic select) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>op</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>ztype</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>xtype</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>ytype</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_idxunop_cast</argument>, <argument>_any</argument>, <argument>GB_void</argument>)</argument_list></macro>

    <case>case <expr><name>GB_USER_idxunop_code</name></expr>   :</case> <comment type="line">// C = user_idxunop (A,k)</comment>

        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>op</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>ztype</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>xtype</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>ytype</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>ztype</name></name> <operator>!=</operator> <name>GrB_BOOL</name><operator>)</operator> <operator>||</operator>
           <operator>(</operator><operator>(</operator><name>typecode</name> <operator>!=</operator> <name>GB_ignore_code</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>xtype</name></name> <operator>!=</operator> <name><name>A</name><operator>-&gt;</operator><name>type</name></name><operator>)</operator><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// typecasting is required</comment>
            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_SELECT_PHASE1</name></cpp:ifdef>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(generic select) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_ignore_code</name></expr> :</case>   <comment type="line">// A is iso</comment>
                    <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_idxunop_cast</argument>, <argument>_iso</argument>, <argument>GB_void</argument>)</argument_list></macro>
                <default>default             :</default>   <comment type="line">// A is non-iso</comment>
                    <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_idxunop_cast</argument>, <argument>_any</argument>, <argument>GB_void</argument>)</argument_list></macro>
            </block_content>}</block></switch>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// no typecasting</comment>
            <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GB_ignore_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_idxunop</argument>, <argument>_iso</argument>, <argument>GB_void</argument>)</argument_list></macro>
                <default>default             :</default> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_idxunop</argument>, <argument>_any</argument>, <argument>GB_void</argument>)</argument_list></macro>
            </block_content>}</block></switch>
        </block_content>}</block></else></if_stmt>
        <break>break ;</break>

    <case>case <expr><name>GB_USER_selop_code</name></expr>     :</case> <comment type="line">// C = user_select (A,k)</comment>

        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_ignore_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_user</argument>, <argument>_iso</argument>, <argument>GB_void</argument>)</argument_list></macro>
            <default>default              :</default> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_user</argument>, <argument>_any</argument>, <argument>GB_void</argument>)</argument_list></macro>
        </block_content>}</block></switch>
        <break>break ;</break>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// COL selectors are used only for the bitmap case</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_BITMAP_SELECTOR</name></cpp:ifdef>

    <case>case <expr><name>GB_COLINDEX_idxunop_code</name></expr>     :</case>  <comment type="line">// C = colindex (A,k)</comment>

        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_ignore_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_colindex</argument>, <argument>_iso</argument>, <argument>GB_void</argument>)</argument_list></macro>
            <default>default              :</default> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_colindex</argument>, <argument>_any</argument>, <argument>GB_void</argument>)</argument_list></macro>
        </block_content>}</block></switch>
        <break>break ;</break>

    <case>case <expr><name>GB_COLLE_idxunop_code</name></expr>     :</case>  <comment type="line">// C = colle (A,k)</comment>

        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_ignore_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_colle</argument>, <argument>_iso</argument>, <argument>GB_void</argument>)</argument_list></macro>
            <default>default              :</default> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_colle</argument>, <argument>_any</argument>, <argument>GB_void</argument>)</argument_list></macro>
        </block_content>}</block></switch>
        <break>break ;</break>

    <case>case <expr><name>GB_COLGT_idxunop_code</name></expr>     :</case>  <comment type="line">// C = colgt (A,k)</comment>

        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_ignore_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_colgt</argument>, <argument>_iso</argument>, <argument>GB_void</argument>)</argument_list></macro>
            <default>default              :</default> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_colgt</argument>, <argument>_any</argument>, <argument>GB_void</argument>)</argument_list></macro>
        </block_content>}</block></switch>
        <break>break ;</break>

    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// nonzombie selectors are not used for the bitmap case</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_BITMAP_SELECTOR</name></cpp:ifndef>

    <case>case <expr><name>GB_NONZOMBIE_selop_code</name></expr>     :</case>  <comment type="line">// C = all entries A(i,j) not a zombie</comment>

        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_SELECT_PHASE1</name></cpp:ifdef>
        <comment type="line">// phase1: use a single worker for all types, since the test does not</comment>
        <comment type="line">// depend on the values, just Ai.</comment>
        <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzombie</argument>, <argument>_iso</argument>, <argument>GB_void</argument>)</argument_list></macro>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="line">// phase2:</comment>
        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzombie</argument>, <argument>_bool</argument>  , <argument>bool</argument>    )</argument_list></macro>
            <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzombie</argument>, <argument>_int8</argument>  , <argument>int8_t</argument>  )</argument_list></macro>
            <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzombie</argument>, <argument>_int16</argument> , <argument>int16_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzombie</argument>, <argument>_int32</argument> , <argument>int32_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzombie</argument>, <argument>_int64</argument> , <argument>int64_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzombie</argument>, <argument>_uint8</argument> , <argument>uint8_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzombie</argument>, <argument>_uint16</argument>, <argument>uint16_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzombie</argument>, <argument>_uint32</argument>, <argument>uint32_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzombie</argument>, <argument>_uint64</argument>, <argument>uint64_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzombie</argument>, <argument>_fp32</argument>  , <argument>float</argument>   )</argument_list></macro>
            <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzombie</argument>, <argument>_fp64</argument>  , <argument>double</argument>  )</argument_list></macro>
            <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzombie</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzombie</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UDT_code</name></expr>    :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzombie</argument>, <argument>_any</argument>   , <argument>GB_void</argument> )</argument_list></macro>
            <case>case <expr><name>GB_ignore_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzombie</argument>, <argument>_iso</argument>   , <argument>GB_void</argument> )</argument_list></macro>
            <default>default:</default> <empty_stmt>;</empty_stmt>          <comment type="line">// not used</comment>
        </block_content>}</block></switch>
        <break>break ;</break>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// none of these selectop workers are needed when A is iso</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <case>case <expr><name>GB_NONZERO_selop_code</name></expr>   :</case>  <comment type="line">// A(i,j) != 0</comment>

        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzero</argument>, <argument>_bool</argument>  , <argument>bool</argument>    )</argument_list></macro>
            <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzero</argument>, <argument>_int8</argument>  , <argument>int8_t</argument>  )</argument_list></macro>
            <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzero</argument>, <argument>_int16</argument> , <argument>int16_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzero</argument>, <argument>_int32</argument> , <argument>int32_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzero</argument>, <argument>_int64</argument> , <argument>int64_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzero</argument>, <argument>_uint8</argument> , <argument>uint8_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzero</argument>, <argument>_uint16</argument>, <argument>uint16_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzero</argument>, <argument>_uint32</argument>, <argument>uint32_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzero</argument>, <argument>_uint64</argument>, <argument>uint64_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzero</argument>, <argument>_fp32</argument>  , <argument>float</argument>   )</argument_list></macro>
            <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzero</argument>, <argument>_fp64</argument>  , <argument>double</argument>  )</argument_list></macro>
            <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzero</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzero</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UDT_code</name></expr>    :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_nonzero</argument>, <argument>_any</argument>   , <argument>GB_void</argument> )</argument_list></macro>
            <default>default:</default> <empty_stmt>;</empty_stmt>          <comment type="line">// not used</comment>
        </block_content>}</block></switch>
        <break>break ;</break>

    <case>case <expr><name>GB_EQ_ZERO_selop_code</name></expr>   :</case>  <comment type="line">// A(i,j) == 0</comment>

        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_zero</argument>, <argument>_bool</argument>  , <argument>bool</argument>    )</argument_list></macro>
            <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_zero</argument>, <argument>_int8</argument>  , <argument>int8_t</argument>  )</argument_list></macro>
            <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_zero</argument>, <argument>_int16</argument> , <argument>int16_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_zero</argument>, <argument>_int32</argument> , <argument>int32_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_zero</argument>, <argument>_int64</argument> , <argument>int64_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_zero</argument>, <argument>_uint8</argument> , <argument>uint8_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_zero</argument>, <argument>_uint16</argument>, <argument>uint16_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_zero</argument>, <argument>_uint32</argument>, <argument>uint32_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_zero</argument>, <argument>_uint64</argument>, <argument>uint64_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_zero</argument>, <argument>_fp32</argument>  , <argument>float</argument>   )</argument_list></macro>
            <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_zero</argument>, <argument>_fp64</argument>  , <argument>double</argument>  )</argument_list></macro>
            <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_zero</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_zero</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UDT_code</name></expr>    :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_zero</argument>, <argument>_any</argument>   , <argument>GB_void</argument> )</argument_list></macro>
            <default>default:</default> <empty_stmt>;</empty_stmt>          <comment type="line">// not used</comment>
        </block_content>}</block></switch>
        <break>break ;</break>

    <case>case <expr><name>GB_GT_ZERO_selop_code</name></expr>   :</case>  <comment type="line">// A(i,j) &gt; 0</comment>

        <comment type="line">// bool and uint: renamed GxB_GT_ZERO to GxB_NONZERO</comment>
        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_gt_zero</argument>, <argument>_int8</argument>  , <argument>int8_t</argument>  )</argument_list></macro>
            <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_gt_zero</argument>, <argument>_int16</argument> , <argument>int16_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_gt_zero</argument>, <argument>_int32</argument> , <argument>int32_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_gt_zero</argument>, <argument>_int64</argument> , <argument>int64_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_gt_zero</argument>, <argument>_fp32</argument>  , <argument>float</argument>   )</argument_list></macro>
            <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_gt_zero</argument>, <argument>_fp64</argument>  , <argument>double</argument>  )</argument_list></macro>
            <default>default:</default> <empty_stmt>;</empty_stmt>          <comment type="line">// not used</comment>
        </block_content>}</block></switch>
        <break>break ;</break>

    <case>case <expr><name>GB_GE_ZERO_selop_code</name></expr>   :</case>  <comment type="line">// A(i,j) &gt;= 0</comment>

        <comment type="line">// bool and uint: always true; use GB_dup</comment>
        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ge_zero</argument>, <argument>_int8</argument>  , <argument>int8_t</argument>  )</argument_list></macro>
            <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ge_zero</argument>, <argument>_int16</argument> , <argument>int16_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ge_zero</argument>, <argument>_int32</argument> , <argument>int32_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ge_zero</argument>, <argument>_int64</argument> , <argument>int64_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ge_zero</argument>, <argument>_fp32</argument>  , <argument>float</argument>   )</argument_list></macro>
            <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ge_zero</argument>, <argument>_fp64</argument>  , <argument>double</argument>  )</argument_list></macro>
            <default>default:</default> <empty_stmt>;</empty_stmt>          <comment type="line">// not used</comment>
        </block_content>}</block></switch>
        <break>break ;</break>

    <case>case <expr><name>GB_LT_ZERO_selop_code</name></expr>   :</case>  <comment type="line">// A(i,j) &lt; 0</comment>

        <comment type="line">// bool and uint: always false; return an empty matrix</comment>
        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_lt_zero</argument>, <argument>_int8</argument>  , <argument>int8_t</argument>  )</argument_list></macro>
            <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_lt_zero</argument>, <argument>_int16</argument> , <argument>int16_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_lt_zero</argument>, <argument>_int32</argument> , <argument>int32_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_lt_zero</argument>, <argument>_int64</argument> , <argument>int64_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_lt_zero</argument>, <argument>_fp32</argument>  , <argument>float</argument>   )</argument_list></macro>
            <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_lt_zero</argument>, <argument>_fp64</argument>  , <argument>double</argument>  )</argument_list></macro>
            <default>default:</default> <empty_stmt>;</empty_stmt>          <comment type="line">// not used</comment>
        </block_content>}</block></switch>
        <break>break ;</break>

    <case>case <expr><name>GB_LE_ZERO_selop_code</name></expr>   :</case>  <comment type="line">// A(i,j) &lt;= 0</comment>

        <comment type="line">// bool and uint: renamed GxB_LE_ZERO to GxB_EQ_ZERO</comment>
        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_le_zero</argument>, <argument>_int8</argument>  , <argument>int8_t</argument>  )</argument_list></macro>
            <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_le_zero</argument>, <argument>_int16</argument> , <argument>int16_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_le_zero</argument>, <argument>_int32</argument> , <argument>int32_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_le_zero</argument>, <argument>_int64</argument> , <argument>int64_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_le_zero</argument>, <argument>_fp32</argument>  , <argument>float</argument>   )</argument_list></macro>
            <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_le_zero</argument>, <argument>_fp64</argument>  , <argument>double</argument>  )</argument_list></macro>
            <default>default:</default> <empty_stmt>;</empty_stmt>          <comment type="line">// not used</comment>
        </block_content>}</block></switch>
        <break>break ;</break>

    <case>case <expr><name>GB_NE_THUNK_selop_code</name></expr>   :</case> <comment type="line">// A(i,j) != thunk</comment>

        <comment type="line">// bool: if thunk is true,  renamed GxB_NE_THUNK to GxB_EQ_ZERO </comment>
        <comment type="line">//       if thunk is false, renamed GxB_NE_THUNK to GxB_NONZERO </comment>
        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ne_thunk</argument>, <argument>_int8</argument>  , <argument>int8_t</argument>  )</argument_list></macro>
            <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ne_thunk</argument>, <argument>_int16</argument> , <argument>int16_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ne_thunk</argument>, <argument>_int32</argument> , <argument>int32_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ne_thunk</argument>, <argument>_int64</argument> , <argument>int64_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ne_thunk</argument>, <argument>_uint8</argument> , <argument>uint8_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ne_thunk</argument>, <argument>_uint16</argument>, <argument>uint16_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ne_thunk</argument>, <argument>_uint32</argument>, <argument>uint32_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ne_thunk</argument>, <argument>_uint64</argument>, <argument>uint64_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ne_thunk</argument>, <argument>_fp32</argument>  , <argument>float</argument>   )</argument_list></macro>
            <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ne_thunk</argument>, <argument>_fp64</argument>  , <argument>double</argument>  )</argument_list></macro>
            <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ne_thunk</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ne_thunk</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UDT_code</name></expr>    :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ne_thunk</argument>, <argument>_any</argument>   , <argument>GB_void</argument> )</argument_list></macro>
            <default>default:</default> <empty_stmt>;</empty_stmt>          <comment type="line">// not used</comment>
        </block_content>}</block></switch>
        <break>break ;</break>

    <case>case <expr><name>GB_EQ_THUNK_selop_code</name></expr>   :</case> <comment type="line">// A(i,j) == thunk</comment>

        <comment type="line">// bool: if thunk is true,  renamed GxB_NE_THUNK to GxB_NONZERO </comment>
        <comment type="line">//       if thunk is false, renamed GxB_NE_THUNK to GxB_EQ_ZERO </comment>
        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_thunk</argument>, <argument>_int8</argument>  , <argument>int8_t</argument>  )</argument_list></macro>
            <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_thunk</argument>, <argument>_int16</argument> , <argument>int16_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_thunk</argument>, <argument>_int32</argument> , <argument>int32_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_thunk</argument>, <argument>_int64</argument> , <argument>int64_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_thunk</argument>, <argument>_uint8</argument> , <argument>uint8_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_thunk</argument>, <argument>_uint16</argument>, <argument>uint16_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_thunk</argument>, <argument>_uint32</argument>, <argument>uint32_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_thunk</argument>, <argument>_uint64</argument>, <argument>uint64_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_thunk</argument>, <argument>_fp32</argument>  , <argument>float</argument>   )</argument_list></macro>
            <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_thunk</argument>, <argument>_fp64</argument>  , <argument>double</argument>  )</argument_list></macro>
            <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_thunk</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_thunk</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UDT_code</name></expr>    :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_eq_thunk</argument>, <argument>_any</argument>   , <argument>GB_void</argument> )</argument_list></macro>
            <default>default:</default> <empty_stmt>;</empty_stmt>          <comment type="line">// not used</comment>
        </block_content>}</block></switch>
        <break>break ;</break>

    <case>case <expr><name>GB_GT_THUNK_selop_code</name></expr>   :</case> <comment type="line">// A(i,j) &gt; thunk</comment>

        <comment type="line">// bool: if thunk is false, renamed GxB_GT_THUNK to GxB_NONZERO</comment>
        <comment type="line">//       if thunk is true,  return an empty matrix</comment>
        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_gt_thunk</argument>, <argument>_int8</argument>  , <argument>int8_t</argument>  )</argument_list></macro>
            <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_gt_thunk</argument>, <argument>_int16</argument> , <argument>int16_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_gt_thunk</argument>, <argument>_int32</argument> , <argument>int32_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_gt_thunk</argument>, <argument>_int64</argument> , <argument>int64_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_gt_thunk</argument>, <argument>_uint8</argument> , <argument>uint8_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_gt_thunk</argument>, <argument>_uint16</argument>, <argument>uint16_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_gt_thunk</argument>, <argument>_uint32</argument>, <argument>uint32_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_gt_thunk</argument>, <argument>_uint64</argument>, <argument>uint64_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_gt_thunk</argument>, <argument>_fp32</argument>  , <argument>float</argument>   )</argument_list></macro>
            <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_gt_thunk</argument>, <argument>_fp64</argument>  , <argument>double</argument>  )</argument_list></macro>
            <default>default:</default> <empty_stmt>;</empty_stmt>          <comment type="line">// not used</comment>
        </block_content>}</block></switch>
        <break>break ;</break>

    <case>case <expr><name>GB_GE_THUNK_selop_code</name></expr>   :</case> <comment type="line">// A(i,j) &gt;= thunk</comment>

        <comment type="line">// bool: if thunk is false, use GB_dup</comment>
        <comment type="line">//       if thunk is true,  renamed GxB_GE_THUNK to GxB_NONZERO</comment>
        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ge_thunk</argument>, <argument>_int8</argument>  , <argument>int8_t</argument>  )</argument_list></macro>
            <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ge_thunk</argument>, <argument>_int16</argument> , <argument>int16_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ge_thunk</argument>, <argument>_int32</argument> , <argument>int32_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ge_thunk</argument>, <argument>_int64</argument> , <argument>int64_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ge_thunk</argument>, <argument>_uint8</argument> , <argument>uint8_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ge_thunk</argument>, <argument>_uint16</argument>, <argument>uint16_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ge_thunk</argument>, <argument>_uint32</argument>, <argument>uint32_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ge_thunk</argument>, <argument>_uint64</argument>, <argument>uint64_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ge_thunk</argument>, <argument>_fp32</argument>  , <argument>float</argument>   )</argument_list></macro>
            <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_ge_thunk</argument>, <argument>_fp64</argument>  , <argument>double</argument>  )</argument_list></macro>
            <default>default:</default> <empty_stmt>;</empty_stmt>          <comment type="line">// not used</comment>
        </block_content>}</block></switch>
        <break>break ;</break>

    <case>case <expr><name>GB_LT_THUNK_selop_code</name></expr>   :</case> <comment type="line">// A(i,j) &lt; thunk</comment>

        <comment type="line">// bool: if thunk is true,  renamed GxB_LT_THUNK to GxB_EQ_ZERO</comment>
        <comment type="line">//       if thunk is false, return an empty matrix</comment>
        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_lt_thunk</argument>, <argument>_int8</argument>  , <argument>int8_t</argument>  )</argument_list></macro>
            <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_lt_thunk</argument>, <argument>_int16</argument> , <argument>int16_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_lt_thunk</argument>, <argument>_int32</argument> , <argument>int32_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_lt_thunk</argument>, <argument>_int64</argument> , <argument>int64_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_lt_thunk</argument>, <argument>_uint8</argument> , <argument>uint8_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_lt_thunk</argument>, <argument>_uint16</argument>, <argument>uint16_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_lt_thunk</argument>, <argument>_uint32</argument>, <argument>uint32_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_lt_thunk</argument>, <argument>_uint64</argument>, <argument>uint64_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_lt_thunk</argument>, <argument>_fp32</argument>  , <argument>float</argument>   )</argument_list></macro>
            <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_lt_thunk</argument>, <argument>_fp64</argument>  , <argument>double</argument>  )</argument_list></macro>
            <default>default:</default> <empty_stmt>;</empty_stmt>          <comment type="line">// not used</comment>
        </block_content>}</block></switch>
        <break>break ;</break>

    <case>case <expr><name>GB_LE_THUNK_selop_code</name></expr>   :</case> <comment type="line">// A(i,j) &lt;= thunk</comment>

        <comment type="line">// bool: if thunk is true,  use GB_dup</comment>
        <comment type="line">//       if thunk is false, renamed GxB_LE_ZERO to GxB_EQ_ZERO</comment>
        <switch>switch <condition>(<expr><name>typecode</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_le_thunk</argument>, <argument>_int8</argument>  , <argument>int8_t</argument>  )</argument_list></macro>
            <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_le_thunk</argument>, <argument>_int16</argument> , <argument>int16_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_le_thunk</argument>, <argument>_int32</argument> , <argument>int32_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_le_thunk</argument>, <argument>_int64</argument> , <argument>int64_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_le_thunk</argument>, <argument>_uint8</argument> , <argument>uint8_t</argument> )</argument_list></macro>
            <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_le_thunk</argument>, <argument>_uint16</argument>, <argument>uint16_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_le_thunk</argument>, <argument>_uint32</argument>, <argument>uint32_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_le_thunk</argument>, <argument>_uint64</argument>, <argument>uint64_t</argument>)</argument_list></macro>
            <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_le_thunk</argument>, <argument>_fp32</argument>  , <argument>float</argument>   )</argument_list></macro>
            <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_SEL_WORKER</name> <argument_list>(<argument>_le_thunk</argument>, <argument>_fp64</argument>  , <argument>double</argument>  )</argument_list></macro>
            <default>default:</default> <empty_stmt>;</empty_stmt>          <comment type="line">// not used</comment>
        </block_content>}</block></switch>
        <break>break ;</break>

    <default>default:</default> <empty_stmt>;</empty_stmt>
</block_content>}</block></switch>

</unit>
