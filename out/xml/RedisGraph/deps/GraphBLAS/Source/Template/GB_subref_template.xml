<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" xmlns:omp="http://www.srcML.org/srcML/openmp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/Template/GB_subref_template.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_subref_template: C = A(I,J)</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// GB_subref_templat extracts a submatrix, C = A(I,J).  The method is done in</comment>
<comment type="line">// two phases.  Phase 1 just counts the entries in C, and phase 2 constructs</comment>
<comment type="line">// the pattern and values of C.  There are 3 kinds of subref:</comment>
<comment type="line">//</comment>
<comment type="line">//      symbolic:  C(i,j) is the position of A(I(i),J(j)) in the matrix A</comment>
<comment type="line">//      iso:     C = A(I,J), extracting the pattern only, not the values</comment>
<comment type="line">//      numeric: C = A(I,J), extracting the pattern and values</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_SYMBOLIC</name></expr></argument> )</argument_list></call></expr></cpp:if>

    <comment type="line">// symbolic method must tolerate zombies</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_Ai</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GBI_UNFLIP (Ai, p, avlen)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

    <comment type="line">// iso and non-iso numeric methods will not see any zombies</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_Ai</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GBI (Ai, p, avlen)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// to iterate across all entries in a bucket:</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_for_each_index_in_bucket</name><parameter_list>(<parameter><type><name>inew</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>     \
    <cpp:value>for (int64_t inew = Mark [i] - 1 ; inew &gt;= 0 ; inew = Inext [inew])</cpp:value></cpp:define>

<comment type="line">//------------------------------------------------------------------------------</comment>

<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get A and I</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>Ai</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>i</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>avlen</name> <init>= <expr><name><name>A</name><operator>-&gt;</operator><name>vlen</name></name></expr></init></decl> ;</decl_stmt>

    <comment type="line">// these values are ignored if Ikind == GB_LIST</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>ibegin</name> <init>= <expr><name><name>Icolon</name> <index>[<expr><name>GxB_BEGIN</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>iinc</name>   <init>= <expr><name><name>Icolon</name> <index>[<expr><name>GxB_INC</name></expr>  ]</index></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>inc</name>    <init>= <expr><ternary><condition><expr><operator>(</operator><name>iinc</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><operator>-</operator><name>iinc</name><operator>)</operator></expr> </then><else>: <expr><name>iinc</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>iend</name>   <init>= <expr><name><name>Icolon</name> <index>[<expr><name>GxB_END</name></expr>  ]</index></name></expr></init></decl> ;</decl_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// phase1: count entries in each C(:,kC); phase2: compute C</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>taskid</name></decl> ;</decl_stmt>
    <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nthreads</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>dynamic</omp:expr></omp:argument>,<omp:argument><omp:expr>1</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
    <for>for <control>(<init><expr><name>taskid</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>taskid</name> <operator>&lt;</operator> <name>ntasks</name></expr> ;</condition> <incr><expr><name>taskid</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// get the task descriptor</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><name>int64_t</name></type> <name>kfirst</name> <init>= <expr><name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>kfirst</name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>klast</name>  <init>= <expr><name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>klast</name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>fine_task</name> <init>= <expr><operator>(</operator><name>klast</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>fine_task</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// a fine task operates on a slice of a single vector</comment>
            <expr_stmt><expr><name>klast</name> <operator>=</operator> <name>kfirst</name></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// a coarse task accesses all of I for all its vectors</comment>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>pI</name>     <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>pI_end</name> <init>= <expr><name>nI</name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>ilen</name>   <init>= <expr><name>nI</name></expr></init></decl> ;</decl_stmt>

        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>kfirst</name> <operator>&amp;&amp;</operator> <name>kfirst</name> <operator>&lt;=</operator> <name>klast</name> <operator>&amp;&amp;</operator> <name>klast</name> <operator>&lt;</operator> <name>Cnvec</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// compute all vectors C(:,kfirst:klast) for this task</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>kC</name> <init>= <expr><name>kfirst</name></expr></init></decl> ;</init> <condition><expr><name>kC</name> <operator>&lt;=</operator> <name>klast</name></expr> ;</condition> <incr><expr><name>kC</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// get C(:,kC)</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_ANALYSIS_PHASE</name></expr></argument> )</argument_list></call></expr></cpp:if>
            <comment type="line">// phase1 simply counts the # of entries in C(*,kC).</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>clen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <comment type="line">// This task computes all or part of C(:,kC), which are the entries</comment>
            <comment type="line">// in Ci,Cx [pC:pC_end-1].</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pC</name></decl>, <decl><type ref="prev"/><name>pC_end</name></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>fine_task</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// A fine task computes a slice of C(:,kC)</comment>
                <expr_stmt><expr><name>pC</name>     <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>  ]</index></name><operator>.</operator><name>pC</name></expr> ;</expr_stmt>
                <expr_stmt><expr><name>pC_end</name> <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pC</name></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>Cp</name> <index>[<expr><name>kC</name></expr>]</index></name> <operator>&lt;=</operator> <name>pC</name> <operator>&amp;&amp;</operator> <name>pC</name> <operator>&lt;=</operator> <name>pC_end</name> <operator>&amp;&amp;</operator> <name>pC_end</name> <operator>&lt;=</operator> <name><name>Cp</name> <index>[<expr><name>kC</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <comment type="line">// The vectors of C are never sliced for a coarse task, so this</comment>
                <comment type="line">// task computes all of C(:,kC).</comment>
                <expr_stmt><expr><name>pC</name>     <operator>=</operator> <name><name>Cp</name> <index>[<expr><name>kC</name></expr>]</index></name></expr> ;</expr_stmt>
                <expr_stmt><expr><name>pC_end</name> <operator>=</operator> <name><name>Cp</name> <index>[<expr><name>kC</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>clen</name> <init>= <expr><name>pC_end</name> <operator>-</operator> <name>pC</name></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// get A(:,kA)</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>pA</name></decl>, <decl><type ref="prev"/><name>pA_end</name></decl> ;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>fine_task</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// a fine task computes a slice of a single vector C(:,kC).</comment>
                <comment type="line">// The task accesses Ai,Ax [pA:pA_end-1], which holds either</comment>
                <comment type="line">// the entire vector A(imin:imax,kA) for method 6, the entire</comment>
                <comment type="line">// dense A(:,kA) for methods 1 and 2, or a slice of the</comment>
                <comment type="line">// A(imin:max,kA) vector for all other methods.</comment>
                <expr_stmt><expr><name>pA</name>     <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>pA</name></expr> ;</expr_stmt>
                <expr_stmt><expr><name>pA_end</name> <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>pA_end</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <comment type="line">// a coarse task computes the entire vector C(:,kC).  The task</comment>
                <comment type="line">// accesses all of A(imin:imax,kA), for most methods, or all of</comment>
                <comment type="line">// A(:,kA) for methods 1 and 2.  The vector A(*,kA) appears in</comment>
                <comment type="line">// Ai,Ax [pA:pA_end-1].</comment>
                <expr_stmt><expr><name>pA</name>     <operator>=</operator> <name><name>Ap_start</name> <index>[<expr><name>kC</name></expr>]</index></name></expr> ;</expr_stmt>
                <expr_stmt><expr><name>pA_end</name> <operator>=</operator> <name><name>Ap_end</name>   <index>[<expr><name>kC</name></expr>]</index></name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>alen</name> <init>= <expr><name>pA_end</name> <operator>-</operator> <name>pA</name></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>alen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// get I</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <if_stmt><if>if <condition>(<expr><name>fine_task</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// A fine task accesses I [pI:pI_end-1].  For methods 2 and 6,</comment>
                <comment type="line">// pI:pI_end is a subset of the entire 0:nI-1 list.  For all</comment>
                <comment type="line">// other methods, pI = 0 and pI_end = nI, and the task can</comment>
                <comment type="line">// access all of I.</comment>
                <expr_stmt><expr><name>pI</name>     <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>pB</name></expr> ;</expr_stmt>
                <expr_stmt><expr><name>pI_end</name> <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>pB_end</name></expr> ;</expr_stmt>
                <expr_stmt><expr><name>ilen</name>   <operator>=</operator> <name>pI_end</name> <operator>-</operator> <name>pI</name></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// determine the method to use</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <decl_stmt><decl><type><name>int</name></type> <name>method</name></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>fine_task</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// The method that the fine task uses for its slice of A(*,kA)</comment>
                <comment type="line">// and C(*,kC) has already been determined by GB_subref_slice.</comment>
                <expr_stmt><expr><name>method</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>-</operator><name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>klast</name><operator>)</operator></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <comment type="line">// determine the method based on A(*,kA) and I</comment>
                <expr_stmt><expr><name>method</name> <operator>=</operator> <call><name>GB_subref_method</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>alen</name></expr></argument>, <argument><expr><name>avlen</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>Mark</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></argument>, <argument><expr><name>need_qsort</name></expr></argument>, <argument><expr><name>iinc</name></expr></argument>, <argument><expr><name>nduplicates</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// extract C (:,kC) = A (I,kA): consider all cases</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <switch>switch <condition>(<expr><name>method</name></expr>)</condition>
            <block>{<block_content>

                <comment type="line">//--------------------------------------------------------------</comment>
                <case>case <expr><literal type="number">1</literal></expr> :</case> <comment type="line">// C(:,kC) = A(:,kA) where A(:,kA) is dense</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                    <comment type="line">// A (:,kA) has not been sliced</comment>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Ikind</name> <operator>==</operator> <name>GB_ALL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pA</name>     <operator>==</operator> <name><name>Ap_start</name> <index>[<expr><name>kC</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pA_end</name> <operator>==</operator> <name><name>Ap_end</name>   <index>[<expr><name>kC</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <comment type="line">// copy the entire vector and construct indices</comment>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_ANALYSIS_PHASE</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><name>clen</name> <operator>=</operator> <name>ilen</name></expr> ;</expr_stmt>
                    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>ilen</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content> 
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>inew</name> <init>= <expr><name>k</name> <operator>+</operator> <name>pI</name></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>inew</name> <operator>==</operator> <call><name>GB_ijlist</name> <argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>inew</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>inew</name> <operator>==</operator> <call><name>GB_Ai</name> <argument_list>(<argument><expr><name>pA</name> <operator>+</operator> <name>inew</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name> <operator>+</operator> <name>k</name></expr>]</index></name> <operator>=</operator> <name>inew</name></expr> ;</expr_stmt>
                    </block_content>}</block></for>
                    <expr_stmt><expr><call><name>GB_COPY_RANGE</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pA</name> <operator>+</operator> <name>pI</name></expr></argument>, <argument><expr><name>ilen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break ;</break>

                <comment type="line">//--------------------------------------------------------------</comment>
                <case>case <expr><literal type="number">2</literal></expr> :</case> <comment type="line">// C(:,kC) = A(I,kA) where A(I,kA) is dense</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                    <comment type="line">// This method handles any kind of list I, but A(:,kA)</comment>
                    <comment type="line">// must be dense.  A(:,kA) has not been sliced.</comment>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pA</name>     <operator>==</operator> <name><name>Ap_start</name> <index>[<expr><name>kC</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pA_end</name> <operator>==</operator> <name><name>Ap_end</name>   <index>[<expr><name>kC</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <comment type="line">// scan I and get the entry in A(:,kA) via direct lookup</comment>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_ANALYSIS_PHASE</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><name>clen</name> <operator>=</operator> <name>ilen</name></expr> ;</expr_stmt>
                    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>ilen</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content> 
                        <comment type="line">// C(inew,kC) =  A(i,kA), and it always exists.</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>inew</name> <init>= <expr><name>k</name> <operator>+</operator> <name>pI</name></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><call><name>GB_ijlist</name> <argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>inew</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>i</name> <operator>==</operator> <call><name>GB_Ai</name> <argument_list>(<argument><expr><name>pA</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name> <operator>+</operator> <name>k</name></expr>]</index></name> <operator>=</operator> <name>inew</name></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_COPY_ENTRY</name> <argument_list>(<argument><expr><name>pC</name> <operator>+</operator> <name>k</name></expr></argument>, <argument><expr><name>pA</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block></for>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break ;</break>

                <comment type="line">//--------------------------------------------------------------</comment>
                <case>case <expr><literal type="number">3</literal></expr> :</case> <comment type="line">// the list I has a single index, ibegin</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                    <comment type="line">// binary search in GB_subref_phase0 has already found it.</comment>
                    <comment type="line">// This can be any Ikind with nI=1: GB_ALL with A-&gt;vlen=1,</comment>
                    <comment type="line">// GB_RANGE with ibegin==iend, GB_STRIDE such as 0:-1:0</comment>
                    <comment type="line">// (with length 1), or a GB_LIST with ni=1.</comment>

                    <comment type="line">// Time: 50x faster</comment>

                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>fine_task</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>alen</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>nI</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_Ai</name> <argument_list>(<argument><expr><name>pA</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>GB_ijlist</name> <argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_ANALYSIS_PHASE</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><name>clen</name> <operator>=</operator> <literal type="number">1</literal></expr> ;</expr_stmt>
                    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>GB_COPY_ENTRY</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break ;</break>

                <comment type="line">//--------------------------------------------------------------</comment>
                <case>case <expr><literal type="number">4</literal></expr> :</case> <comment type="line">// Ikind is ":", thus C(:,kC) = A (:,kA)</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                    <comment type="line">// Time: 1x faster but low speedup on the Mac.  Why?</comment>
                    <comment type="line">// Probably memory bound since it is just memcpy's.</comment>

                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Ikind</name> <operator>==</operator> <name>GB_ALL</name> <operator>&amp;&amp;</operator> <name>ibegin</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_ANALYSIS_PHASE</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><name>clen</name> <operator>=</operator> <name>alen</name></expr> ;</expr_stmt>
                    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_SYMBOLIC</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <if_stmt><if>if <condition>(<expr><name>nzombies</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content> 
                        <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>Ci</name> <operator>+</operator> <name>pC</name></expr></argument>, <argument><expr><name>Ai</name> <operator>+</operator> <name>pA</name></expr></argument>, <argument><expr><name>alen</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="line">// with zombies</comment>
                        <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>alen</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content> 
                            <comment type="line">// symbolic C(:,kC) = A(:,kA) where A has zombies</comment>
                            <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><call><name>GB_Ai</name> <argument_list>(<argument><expr><name>pA</name> <operator>+</operator> <name>k</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>i</name> <operator>==</operator> <call><name>GB_ijlist</name> <argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name> <operator>+</operator> <name>k</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                        </block_content>}</block></for>
                    </block_content>}</block></else></if_stmt>
                    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>Ci</name> <operator>+</operator> <name>pC</name></expr></argument>, <argument><expr><name>Ai</name> <operator>+</operator> <name>pA</name></expr></argument>, <argument><expr><name>alen</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><call><name>GB_COPY_RANGE</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>alen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break ;</break>

                <comment type="line">//--------------------------------------------------------------</comment>
                <case>case <expr><literal type="number">5</literal></expr> :</case> <comment type="line">// Ikind is GB_RANGE = ibegin:iend</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                    <comment type="line">// Time: much faster.  Good speedup too.</comment>

                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Ikind</name> <operator>==</operator> <name>GB_RANGE</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_ANALYSIS_PHASE</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><name>clen</name> <operator>=</operator> <name>alen</name></expr> ;</expr_stmt>
                    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>alen</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content> 
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><call><name>GB_Ai</name> <argument_list>(<argument><expr><name>pA</name> <operator>+</operator> <name>k</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>inew</name> <init>= <expr><name>i</name> <operator>-</operator> <name>ibegin</name></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>i</name> <operator>==</operator> <call><name>GB_ijlist</name> <argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>inew</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name> <operator>+</operator> <name>k</name></expr>]</index></name> <operator>=</operator> <name>inew</name></expr> ;</expr_stmt>
                    </block_content>}</block></for>
                    <expr_stmt><expr><call><name>GB_COPY_RANGE</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>alen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break ;</break>

                <comment type="line">//--------------------------------------------------------------</comment>
                <case>case <expr><literal type="number">6</literal></expr> :</case> <comment type="line">// I is short vs nnz (A (:,kA)), use binary search</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                    <comment type="line">// Time: very slow unless I is very short and A(:,kA) is</comment>
                    <comment type="line">// very long.</comment>

                    <comment type="line">// This case can handle any kind of I, and A(:,kA) of any</comment>
                    <comment type="line">// properties.  For a fine task, A(:,kA) has not been</comment>
                    <comment type="line">// sliced; I has been sliced instead.</comment>

                    <comment type="line">// If the I bucket inverse has not been created, this</comment>
                    <comment type="line">// method is the only option.  Alternatively, if nI =</comment>
                    <comment type="line">// length (I) is &lt;&lt; nnz (A (:,kA)), then scanning I and</comment>
                    <comment type="line">// doing a binary search of A (:,kA) is faster than doing a</comment>
                    <comment type="line">// linear-time search of A(:,kA) and a lookup into the I</comment>
                    <comment type="line">// bucket inverse.</comment>

                    <comment type="line">// The vector of C is constructed in sorted order, so no</comment>
                    <comment type="line">// sort is needed.</comment>

                    <comment type="line">// A(:,kA) has not been sliced.</comment>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pA</name>     <operator>==</operator> <name><name>Ap_start</name> <index>[<expr><name>kC</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pA_end</name> <operator>==</operator> <name><name>Ap_end</name>   <index>[<expr><name>kC</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

                    <comment type="line">// scan I, in order, and search for the entry in A(:,kA)</comment>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>ilen</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <comment type="line">// C(inew,kC) = A (i,kA), if it exists.</comment>
                        <comment type="line">// i = I [inew] ; or from a colon expression</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>inew</name> <init>= <expr><name>k</name> <operator>+</operator> <name>pI</name></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><call><name>GB_ijlist</name> <argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>inew</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>pleft</name> <init>= <expr><name>pA</name></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>pright</name> <init>= <expr><name>pA_end</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_SYMBOLIC</name></expr></argument> )</argument_list></call></expr></cpp:if>
                        <decl_stmt><decl><type><name>bool</name></type> <name>is_zombie</name></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_BINARY_SEARCH_ZOMBIE</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>Ai</name></expr></argument>, <argument><expr><name>pleft</name></expr></argument>, <argument><expr><name>pright</name></expr></argument>, <argument><expr><name>found</name></expr></argument>,
                            <argument><expr><name>nzombies</name></expr></argument>, <argument><expr><name>is_zombie</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <expr_stmt><expr><call><name>GB_BINARY_SEARCH</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>Ai</name></expr></argument>, <argument><expr><name>pleft</name></expr></argument>, <argument><expr><name>pright</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
                        <block>{<block_content> 
                            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>i</name> <operator>==</operator> <call><name>GB_Ai</name> <argument_list>(<argument><expr><name>pleft</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_ANALYSIS_PHASE</name></expr></argument> )</argument_list></call></expr></cpp:if>
                            <expr_stmt><expr><name>clen</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>&lt;</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>inew</name></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_COPY_ENTRY</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pleft</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_2_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>==</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break ;</break>

                <comment type="line">//--------------------------------------------------------------</comment>
                <case>case <expr><literal type="number">7</literal></expr> :</case> <comment type="line">// I is ibegin:iinc:iend with iinc &gt; 1</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                    <comment type="line">// Time: 1 thread: C=A(1:2:n,:) is 3x slower</comment>
                    <comment type="line">// but has good speedup.  About as fast with</comment>
                    <comment type="line">// enough threads.</comment>

                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Ikind</name> <operator>==</operator> <name>GB_STRIDE</name> <operator>&amp;&amp;</operator> <name>iinc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>alen</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <comment type="line">// A(i,kA) present; see if it is in ibegin:iinc:iend</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><call><name>GB_Ai</name> <argument_list>(<argument><expr><name>pA</name> <operator>+</operator> <name>k</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>ibegin</name> <operator>&lt;=</operator> <name>i</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;=</operator> <name>iend</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><name>i</name> <operator>=</operator> <name>i</name> <operator>-</operator> <name>ibegin</name></expr> ;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <name>iinc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content> 
                            <comment type="line">// i is in the sequence ibegin:iinc:iend</comment>
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_ANALYSIS_PHASE</name></expr></argument> )</argument_list></call></expr></cpp:if>
                            <expr_stmt><expr><name>clen</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <decl_stmt><decl><type><name>int64_t</name></type> <name>inew</name> <init>= <expr><name>i</name> <operator>/</operator> <name>iinc</name></expr></init></decl> ;</decl_stmt>
                            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>&lt;</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>inew</name></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_COPY_ENTRY</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pA</name> <operator>+</operator> <name>k</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_2_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>==</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break ;</break>

                <comment type="line">//----------------------------------------------------------</comment>
                <case>case <expr><literal type="number">8</literal></expr> :</case> <comment type="line">// I = ibegin:(-iinc):iend, with iinc &lt; -1</comment>
                <comment type="line">//----------------------------------------------------------</comment>

                    <comment type="line">// Time: 2x slower for iinc = -2 or -8.</comment>
                    <comment type="line">// Good speedup though.  Faster for</comment>
                    <comment type="line">// large values (iinc = -128).</comment>
                
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Ikind</name> <operator>==</operator> <name>GB_STRIDE</name> <operator>&amp;&amp;</operator> <name>iinc</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><name>alen</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ;</condition> <incr><expr><name>k</name><operator>--</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <comment type="line">// A(i,kA) present; see if it is in ibegin:iinc:iend</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><call><name>GB_Ai</name> <argument_list>(<argument><expr><name>pA</name> <operator>+</operator> <name>k</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>iend</name> <operator>&lt;=</operator> <name>i</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;=</operator> <name>ibegin</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><name>i</name> <operator>=</operator> <name>ibegin</name> <operator>-</operator> <name>i</name></expr> ;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <name>inc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content> 
                            <comment type="line">// i is in the sequence ibegin:iinc:iend</comment>
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_ANALYSIS_PHASE</name></expr></argument> )</argument_list></call></expr></cpp:if>
                            <expr_stmt><expr><name>clen</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <decl_stmt><decl><type><name>int64_t</name></type> <name>inew</name> <init>= <expr><name>i</name> <operator>/</operator> <name>inc</name></expr></init></decl> ;</decl_stmt>
                            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>&lt;</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>inew</name></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_COPY_ENTRY</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pA</name> <operator>+</operator> <name>k</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_2_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>==</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break ;</break>

                <comment type="line">//----------------------------------------------------------</comment>
                <case>case <expr><literal type="number">9</literal></expr> :</case> <comment type="line">// I = ibegin:(-1):iend</comment>
                <comment type="line">//----------------------------------------------------------</comment>

                    <comment type="line">// Time: much faster.  Good speedup.</comment>

                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Ikind</name> <operator>==</operator> <name>GB_STRIDE</name> <operator>&amp;&amp;</operator> <name>iinc</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_ANALYSIS_PHASE</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><name>clen</name> <operator>=</operator> <name>alen</name></expr> ;</expr_stmt>
                    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><name>alen</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ;</condition> <incr><expr><name>k</name><operator>--</operator></expr></incr>)</control>
                    <block>{<block_content> 
                        <comment type="line">// A(i,kA) is present</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><call><name>GB_Ai</name> <argument_list>(<argument><expr><name>pA</name> <operator>+</operator> <name>k</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>inew</name> <init>= <expr><operator>(</operator><name>ibegin</name> <operator>-</operator> <name>i</name><operator>)</operator></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>i</name> <operator>==</operator> <call><name>GB_ijlist</name> <argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>inew</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>inew</name></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_COPY_ENTRY</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pA</name> <operator>+</operator> <name>k</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                    </block_content>}</block></for>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break ;</break>

                <comment type="line">//--------------------------------------------------------------</comment>
                <case>case <expr><literal type="number">10</literal></expr> :</case> <comment type="line">// I unsorted, and C needs qsort, duplicates OK</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                    <comment type="line">// Time: with one thread: 2x slower, probably</comment>
                    <comment type="line">// because of the qsort.  Good speedup however.  This used</comment>
                    <comment type="line">// if qsort is needed but ndupl == 0.  Try a method that</comment>
                    <comment type="line">// needs qsort, but no duplicates?</comment>

                    <comment type="line">// Case 10 works well when I has many entries and A(:,kA)</comment>
                    <comment type="line">// has few entries. C(:,kC) must be sorted after this pass.</comment>

                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Ikind</name> <operator>==</operator> <name>GB_LIST</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>alen</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <comment type="line">// A(i,kA) present, look it up in the I inverse buckets</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><call><name>GB_Ai</name> <argument_list>(<argument><expr><name>pA</name> <operator>+</operator> <name>k</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                        <comment type="line">// traverse bucket i for all indices inew where</comment>
                        <comment type="line">// i == I [inew] or where i is from a colon expression</comment>
                        <macro><name>GB_for_each_index_in_bucket</name> <argument_list>(<argument>inew</argument>, <argument>i</argument>)</argument_list></macro>
                        <block>{<block_content> 
                            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>inew</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>inew</name> <operator>&lt;</operator> <name>nI</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>i</name> <operator>==</operator> <call><name>GB_ijlist</name> <argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>inew</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_ANALYSIS_PHASE</name></expr></argument> )</argument_list></call></expr></cpp:if>
                            <expr_stmt><expr><name>clen</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>inew</name></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_COPY_ENTRY</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pA</name> <operator>+</operator> <name>k</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block>
                    </block_content>}</block></for>

                    <comment type="line">// TODO: skip the sort if C is allowed to be jumbled on</comment>
                    <comment type="line">// output.  Flag C as jumbled instead.</comment>

                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_2_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>==</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fine_task</name></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// a coarse task owns this entire C(:,kC) vector, so</comment>
                        <comment type="line">// the sort can be done now.  The sort for vectors</comment>
                        <comment type="line">// handled by multiple fine tasks must wait until all</comment>
                        <comment type="line">// task are completed, below in the post sort.</comment>
                        <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>Cp</name> <index>[<expr><name>kC</name></expr>]</index></name></expr> ;</expr_stmt>

                        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_ISO_SUBREF</name></expr></argument> )</argument_list></call></expr></cpp:if>
                        <comment type="line">// iso numeric subref C=A(I,J)</comment>
                        <comment type="line">// just sort the pattern of C(:,kC)</comment>
                        <expr_stmt><expr><call><name>GB_qsort_1</name> <argument_list>(<argument><expr><name>Ci</name> <operator>+</operator> <name>pC</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <comment type="line">// sort the pattern of C(:,kC), and the values</comment>
                        <expr_stmt><expr><call><name>GB_qsort_1b</name> <argument_list>(<argument><expr><name>Ci</name> <operator>+</operator> <name>pC</name></expr></argument>, <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>Cx</name> <operator>+</operator> <name>pC</name><operator>*</operator><name>GB_CSIZE1</name><operator>)</operator></expr></argument>,
                            <argument><expr><name>GB_CSIZE2</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></if></if_stmt>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break ;</break>

                <comment type="line">//--------------------------------------------------------------</comment>
                <case>case <expr><literal type="number">11</literal></expr> :</case> <comment type="line">// I not contiguous, with duplicates. No qsort needed</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                    <comment type="line">// Case 11 works well when I has many entries and A(:,kA)</comment>
                    <comment type="line">// has few entries.  It requires that I be sorted on input,</comment>
                    <comment type="line">// so that no sort is required for C(:,kC).  It is</comment>
                    <comment type="line">// otherwise identical to Case 10.</comment>

                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Ikind</name> <operator>==</operator> <name>GB_LIST</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>alen</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <comment type="line">// A(i,kA) present, look it up in the I inverse buckets</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><call><name>GB_Ai</name> <argument_list>(<argument><expr><name>pA</name> <operator>+</operator> <name>k</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                        <comment type="line">// traverse bucket i for all indices inew where</comment>
                        <comment type="line">// i == I [inew] or where i is from a colon expression</comment>
                        <macro><name>GB_for_each_index_in_bucket</name> <argument_list>(<argument>inew</argument>, <argument>i</argument>)</argument_list></macro>
                        <block>{<block_content> 
                            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>inew</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>inew</name> <operator>&lt;</operator> <name>nI</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>i</name> <operator>==</operator> <call><name>GB_ijlist</name> <argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>inew</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_ANALYSIS_PHASE</name></expr></argument> )</argument_list></call></expr></cpp:if>
                            <expr_stmt><expr><name>clen</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>inew</name></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_COPY_ENTRY</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pA</name> <operator>+</operator> <name>k</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block>
                    </block_content>}</block></for>

                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_2_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>==</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break ;</break>

                <comment type="line">//--------------------------------------------------------------</comment>
                <case>case <expr><literal type="number">12</literal></expr> :</case> <comment type="line">// I not contiguous, no duplicates.  No qsort needed.</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                    <comment type="line">// Identical to Case 11, except GB_for_each_index_in_bucket</comment>
                    <comment type="line">// just needs to iterate 0 or 1 times.  Works well when I</comment>
                    <comment type="line">// has many entries and A(:,kA) has few entries.</comment>

                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Ikind</name> <operator>==</operator> <name>GB_LIST</name> <operator>&amp;&amp;</operator> <name>nduplicates</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>alen</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <comment type="line">// A(i,kA) present, look it up in the I inverse buckets</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><call><name>GB_Ai</name> <argument_list>(<argument><expr><name>pA</name> <operator>+</operator> <name>k</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                        <comment type="line">// bucket i has at most one index inew such that</comment>
                        <comment type="line">// i == I [inew]</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>inew</name> <init>= <expr><name><name>Mark</name> <index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>inew</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content> 
                            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>inew</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>inew</name> <operator>&lt;</operator> <name>nI</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>i</name> <operator>==</operator> <call><name>GB_ijlist</name> <argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>inew</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_ANALYSIS_PHASE</name></expr></argument> )</argument_list></call></expr></cpp:if>
                            <expr_stmt><expr><name>clen</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>inew</name></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_COPY_ENTRY</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pA</name> <operator>+</operator> <name>k</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>

                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_2_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>==</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break ;</break>

                <comment type="line">//--------------------------------------------------------------</comment>
                <default>default:</default> <empty_stmt>;</empty_stmt>
                <comment type="line">//--------------------------------------------------------------</comment>
            </block_content>}</block></switch>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// final count of nnz (C (:,j))</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_ANALYSIS_PHASE</name></expr></argument> )</argument_list></call></expr></cpp:if>
            <if_stmt><if>if <condition>(<expr><name>fine_task</name></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>pC</name> <operator>=</operator> <name>clen</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <expr_stmt><expr><name><name>Cp</name> <index>[<expr><name>kC</name></expr>]</index></name> <operator>=</operator> <name>clen</name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// phase2: post sort for any vectors handled by fine tasks with method 10</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_2_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>post_sort</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>taskid</name></decl> ;</decl_stmt>
            <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>nthreads</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>dynamic</omp:expr></omp:argument>,<omp:argument><omp:expr>1</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
            <for>for <control>(<init><expr><name>taskid</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>taskid</name> <operator>&lt;</operator> <name>ntasks</name></expr> ;</condition> <incr><expr><name>taskid</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>kC</name> <init>= <expr><name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>kfirst</name></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type> <name>do_post_sort</name> <init>= <expr><operator>(</operator><name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>do_post_sort</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// This is the first fine task with method 10 for C(:,kC).</comment>
                    <comment type="line">// The vector C(:,kC) must be sorted, since method 10 left</comment>
                    <comment type="line">// it with unsorted indices.</comment>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>pC</name> <init>= <expr><name><name>Cp</name> <index>[<expr><name>kC</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>clen</name> <init>= <expr><name><name>Cp</name> <index>[<expr><name>kC</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name>pC</name></expr></init></decl> ;</decl_stmt>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_ISO_SUBREF</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <block>{<block_content> 
                        <comment type="line">// iso numeric subref C=A(I,J)</comment>
                        <comment type="line">// just sort the pattern of C(:,kC)</comment>
                        <expr_stmt><expr><call><name>GB_qsort_1</name> <argument_list>(<argument><expr><name>Ci</name> <operator>+</operator> <name>pC</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block>
                    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <block>{<block_content> 
                        <comment type="line">// sort the pattern of C(:,kC), and the values</comment>
                        <expr_stmt><expr><call><name>GB_qsort_1b</name> <argument_list>(<argument><expr><name>Ci</name> <operator>+</operator> <name>pC</name></expr></argument>, <argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>Cx</name> <operator>+</operator> <name>pC</name><operator>*</operator><name>GB_CSIZE1</name><operator>)</operator></expr></argument>,
                            <argument><expr><name>GB_CSIZE2</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_Ai</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_for_each_index_in_bucket</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_COPY_RANGE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_COPY_ENTRY</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_CSIZE1</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_CSIZE2</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_SYMBOLIC</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_ISO_SUBREF</name></cpp:undef>

</unit>
