<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/Template/GB_unop_factory.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_unop_factory.c:  switch factory for unary operators and 2 types</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// Switch factory for applying a non-positional unary operator.  This file is</comment>
<comment type="line">// #include'd into GB_apply_op.c and GB_transpose_op.c, which must define the</comment>
<comment type="line">// GrB_UnaryOp op and the GrB_Type Atype.  This factory does not handle</comment>
<comment type="line">// GrB_BinaryOp or GrB_IndexUnaryOp.</comment>

<comment type="line">// If the op is user-defined, or if the combinations of z and x type are not</comment>
<comment type="line">// handled by the built-in operator, then this switch factory falls through</comment>
<comment type="line">// with no action taken.</comment>

<block>{<block_content>
    <comment type="line">// switch factory for two types, controlled by code1 and code2</comment>
    <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>code1</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>ztype</name><operator>-&gt;</operator><name>code</name></name></expr></init></decl> ;</decl_stmt>      <comment type="line">// defines ztype</comment>
    <decl_stmt><decl><type><name>GB_Type_code</name></type> <name>code2</name> <init>= <expr><name><name>Atype</name><operator>-&gt;</operator><name>code</name></name></expr></init></decl> ;</decl_stmt>          <comment type="line">// defines the type of A</comment>
    <decl_stmt><decl><type><name>GB_Opcode</name></type> <name>opcode</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>opcode</name></name></expr></init></decl> ;</decl_stmt>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>code1</name> <operator>&lt;=</operator> <name>GB_UDT_code</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>code2</name> <operator>&lt;=</operator> <name>GB_UDT_code</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>opcode</name> <operator>!=</operator> <name>GB_ONE_unop_code</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <comment type="line">// C is iso and the factory isn't used</comment>

    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>GB_IDENTITY_unop_code</name></expr>)</condition>
    <block>{<block_content> 

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// z = (ztype) x, with arbitrary typecasting</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// the identity operator is only used with typecasting via this switch</comment>
        <comment type="line">// factory, so code1 is never equal to code2.</comment>

        <macro><name>ASSERT</name> <argument_list>(<argument>code1 != code2</argument>)</argument_list></macro>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_OPNAME</name></cpp:macro> <cpp:value>_identity</cpp:value></cpp:define>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_EXCLUDE_SAME_TYPES</name></cpp:macro></cpp:define>
        <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_2type_factory.c"</cpp:file></cpp:include>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name>code1</name> <operator>==</operator> <name>GB_FP32_code</name> <operator>&amp;&amp;</operator> <name>code2</name> <operator>==</operator> <name>GB_FC32_code</name><operator>)</operator> <operator>||</operator>
             <operator>(</operator><name>code1</name> <operator>==</operator> <name>GB_FP64_code</name> <operator>&amp;&amp;</operator> <name>code2</name> <operator>==</operator> <name>GB_FC64_code</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// z = f (x) where z is real and x is complex (same base type)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <switch>switch <condition>(<expr><name>opcode</name></expr>)</condition>
        <block>{<block_content>

            <case>case <expr><name>GB_ABS_unop_code</name></expr> :</case>     <comment type="line">// z = abs (x), for x complex</comment>

                <switch>switch <condition>(<expr><name>code2</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FC32_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_abs</argument>, <argument>_fp32</argument>, <argument>float</argument> , <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_abs</argument>, <argument>_fp64</argument>, <argument>double</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_CREAL_unop_code</name></expr> :</case>   <comment type="line">// z = creal (x)</comment>

                <switch>switch <condition>(<expr><name>code2</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FC32_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_creal</argument>, <argument>_fp32</argument>, <argument>float</argument> , <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_creal</argument>, <argument>_fp64</argument>, <argument>double</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_CIMAG_unop_code</name></expr> :</case>   <comment type="line">// z = cimag (x)</comment>

                <switch>switch <condition>(<expr><name>code2</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FC32_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_cimag</argument>, <argument>_fp32</argument>, <argument>float</argument> , <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_cimag</argument>, <argument>_fp64</argument>, <argument>double</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_CARG_unop_code</name></expr> :</case>    <comment type="line">// z = carg (x)</comment>

                <switch>switch <condition>(<expr><name>code2</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FC32_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_carg</argument>, <argument>_fp32</argument>, <argument>float</argument> , <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_carg</argument>, <argument>_fp64</argument>, <argument>double</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <default>default:</default> <empty_stmt>;</empty_stmt>
        </block_content>}</block></switch>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>code1</name> <operator>==</operator> <name>GB_BOOL_code</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>code2</name> <operator>&gt;=</operator> <name>GB_FP32_code</name> <operator>&amp;&amp;</operator> <name>code2</name> <operator>&lt;=</operator> <name>GB_FC64_code</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// z = f (x) where z is boolean and x is floating-point</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <switch>switch <condition>(<expr><name>opcode</name></expr>)</condition>
        <block>{<block_content>

            <case>case <expr><name>GB_ISINF_unop_code</name></expr> :</case>   <comment type="line">// z = isinf (x)</comment>

                <switch>switch <condition>(<expr><name>code2</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_isinf</argument>, <argument>_bool</argument>, <argument>bool</argument>, <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_isinf</argument>, <argument>_bool</argument>, <argument>bool</argument>, <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_isinf</argument>, <argument>_bool</argument>, <argument>bool</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_isinf</argument>, <argument>_bool</argument>, <argument>bool</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_ISNAN_unop_code</name></expr> :</case>   <comment type="line">// z = isnan (x)</comment>

                <switch>switch <condition>(<expr><name>code2</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_isnan</argument>, <argument>_bool</argument>, <argument>bool</argument>, <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_isnan</argument>, <argument>_bool</argument>, <argument>bool</argument>, <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_isnan</argument>, <argument>_bool</argument>, <argument>bool</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_isnan</argument>, <argument>_bool</argument>, <argument>bool</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_ISFINITE_unop_code</name></expr> :</case><comment type="line">// z = isfinite (x)</comment>

                <switch>switch <condition>(<expr><name>code2</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_isfinite</argument>, <argument>_bool</argument>, <argument>bool</argument>, <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_isfinite</argument>, <argument>_bool</argument>, <argument>bool</argument>, <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_isfinite</argument>, <argument>_bool</argument>, <argument>bool</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_isfinite</argument>, <argument>_bool</argument>, <argument>bool</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <default>default:</default> <empty_stmt>;</empty_stmt>

        </block_content>}</block></switch>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>code1</name> <operator>==</operator> <name>code2</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// z = f (x) with no typecasting</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <switch>switch <condition>(<expr><name>opcode</name></expr>)</condition>
        <block>{<block_content>

            <case>case <expr><name>GB_AINV_unop_code</name></expr> :</case>      <comment type="line">// z = -x, all 13 types</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_ainv</argument>, <argument>_bool</argument>  , <argument>bool</argument>      , <argument>_bool</argument>  , <argument>bool</argument>      )</argument_list></macro>
                    <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_ainv</argument>, <argument>_int8</argument>  , <argument>int8_t</argument>    , <argument>_int8</argument>  , <argument>int8_t</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_ainv</argument>, <argument>_int16</argument> , <argument>int16_t</argument>   , <argument>_int16</argument> , <argument>int16_t</argument>   )</argument_list></macro>
                    <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_ainv</argument>, <argument>_int32</argument> , <argument>int32_t</argument>   , <argument>_int32</argument> , <argument>int32_t</argument>   )</argument_list></macro>
                    <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_ainv</argument>, <argument>_int64</argument> , <argument>int64_t</argument>   , <argument>_int64</argument> , <argument>int64_t</argument>   )</argument_list></macro>
                    <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_ainv</argument>, <argument>_uint8</argument> , <argument>uint8_t</argument>   , <argument>_uint8</argument> , <argument>uint8_t</argument>   )</argument_list></macro>
                    <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_ainv</argument>, <argument>_uint16</argument>, <argument>uint16_t</argument>  , <argument>_uint16</argument>, <argument>uint16_t</argument>  )</argument_list></macro>
                    <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_ainv</argument>, <argument>_uint32</argument>, <argument>uint32_t</argument>  , <argument>_uint32</argument>, <argument>uint32_t</argument>  )</argument_list></macro>
                    <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_ainv</argument>, <argument>_uint64</argument>, <argument>uint64_t</argument>  , <argument>_uint64</argument>, <argument>uint64_t</argument>  )</argument_list></macro>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_ainv</argument>, <argument>_fp32</argument>  , <argument>float</argument>     , <argument>_fp32</argument>  , <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_ainv</argument>, <argument>_fp64</argument>  , <argument>double</argument>    , <argument>_fp64</argument>  , <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_ainv</argument>, <argument>_fc32</argument>  , <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>  , <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_ainv</argument>, <argument>_fc64</argument>  , <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>  , <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_MINV_unop_code</name></expr> :</case>      <comment type="line">// z = 1/x, all 13 types</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_minv</argument>, <argument>_bool</argument>  , <argument>bool</argument>      , <argument>_bool</argument>  , <argument>bool</argument>      )</argument_list></macro>
                    <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_minv</argument>, <argument>_int8</argument>  , <argument>int8_t</argument>    , <argument>_int8</argument>  , <argument>int8_t</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_minv</argument>, <argument>_int16</argument> , <argument>int16_t</argument>   , <argument>_int16</argument> , <argument>int16_t</argument>   )</argument_list></macro>
                    <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_minv</argument>, <argument>_int32</argument> , <argument>int32_t</argument>   , <argument>_int32</argument> , <argument>int32_t</argument>   )</argument_list></macro>
                    <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_minv</argument>, <argument>_int64</argument> , <argument>int64_t</argument>   , <argument>_int64</argument> , <argument>int64_t</argument>   )</argument_list></macro>
                    <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_minv</argument>, <argument>_uint8</argument> , <argument>uint8_t</argument>   , <argument>_uint8</argument> , <argument>uint8_t</argument>   )</argument_list></macro>
                    <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_minv</argument>, <argument>_uint16</argument>, <argument>uint16_t</argument>  , <argument>_uint16</argument>, <argument>uint16_t</argument>  )</argument_list></macro>
                    <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_minv</argument>, <argument>_uint32</argument>, <argument>uint32_t</argument>  , <argument>_uint32</argument>, <argument>uint32_t</argument>  )</argument_list></macro>
                    <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_minv</argument>, <argument>_uint64</argument>, <argument>uint64_t</argument>  , <argument>_uint64</argument>, <argument>uint64_t</argument>  )</argument_list></macro>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_minv</argument>, <argument>_fp32</argument>  , <argument>float</argument>     , <argument>_fp32</argument>  , <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_minv</argument>, <argument>_fp64</argument>  , <argument>double</argument>    , <argument>_fp64</argument>  , <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_minv</argument>, <argument>_fc32</argument>  , <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>  , <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_minv</argument>, <argument>_fc64</argument>  , <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>  , <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_ABS_unop_code</name></expr> :</case>       <comment type="line">// z = abs (x), for all but complex</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_abs</argument>, <argument>_bool</argument>  , <argument>bool</argument>      , <argument>_bool</argument>  , <argument>bool</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_abs</argument>, <argument>_int8</argument>  , <argument>int8_t</argument>    , <argument>_int8</argument>  , <argument>int8_t</argument>  )</argument_list></macro>
                    <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_abs</argument>, <argument>_int16</argument> , <argument>int16_t</argument>   , <argument>_int16</argument> , <argument>int16_t</argument> )</argument_list></macro>
                    <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_abs</argument>, <argument>_int32</argument> , <argument>int32_t</argument>   , <argument>_int32</argument> , <argument>int32_t</argument> )</argument_list></macro>
                    <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_abs</argument>, <argument>_int64</argument> , <argument>int64_t</argument>   , <argument>_int64</argument> , <argument>int64_t</argument> )</argument_list></macro>
                    <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_abs</argument>, <argument>_uint8</argument> , <argument>uint8_t</argument>   , <argument>_uint8</argument> , <argument>uint8_t</argument> )</argument_list></macro>
                    <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_abs</argument>, <argument>_uint16</argument>, <argument>uint16_t</argument>  , <argument>_uint16</argument>, <argument>uint16_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_abs</argument>, <argument>_uint32</argument>, <argument>uint32_t</argument>  , <argument>_uint32</argument>, <argument>uint32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_abs</argument>, <argument>_uint64</argument>, <argument>uint64_t</argument>  , <argument>_uint64</argument>, <argument>uint64_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_abs</argument>, <argument>_fp32</argument>  , <argument>float</argument>     , <argument>_fp32</argument>  , <argument>float</argument>   )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_abs</argument>, <argument>_fp64</argument>  , <argument>double</argument>    , <argument>_fp64</argument>  , <argument>double</argument>  )</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_LNOT_unop_code</name></expr> :</case>      <comment type="line">// z = ! (x != 0), no complex case</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_BOOL_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_lnot</argument>, <argument>_bool</argument>  , <argument>bool</argument>    , <argument>_bool</argument>  , <argument>bool</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_lnot</argument>, <argument>_int8</argument>  , <argument>int8_t</argument>  , <argument>_int8</argument>  , <argument>int8_t</argument>  )</argument_list></macro>
                    <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_lnot</argument>, <argument>_int16</argument> , <argument>int16_t</argument> , <argument>_int16</argument> , <argument>int16_t</argument> )</argument_list></macro>
                    <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_lnot</argument>, <argument>_int32</argument> , <argument>int32_t</argument> , <argument>_int32</argument> , <argument>int32_t</argument> )</argument_list></macro>
                    <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_lnot</argument>, <argument>_int64</argument> , <argument>int64_t</argument> , <argument>_int64</argument> , <argument>int64_t</argument> )</argument_list></macro>
                    <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_lnot</argument>, <argument>_uint8</argument> , <argument>uint8_t</argument> , <argument>_uint8</argument> , <argument>uint8_t</argument> )</argument_list></macro>
                    <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_lnot</argument>, <argument>_uint16</argument>, <argument>uint16_t</argument>, <argument>_uint16</argument>, <argument>uint16_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_lnot</argument>, <argument>_uint32</argument>, <argument>uint32_t</argument>, <argument>_uint32</argument>, <argument>uint32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_lnot</argument>, <argument>_uint64</argument>, <argument>uint64_t</argument>, <argument>_uint64</argument>, <argument>uint64_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_lnot</argument>, <argument>_fp32</argument>  , <argument>float</argument>   , <argument>_fp32</argument>  , <argument>float</argument>   )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_lnot</argument>, <argument>_fp64</argument>  , <argument>double</argument>  , <argument>_fp64</argument>  , <argument>double</argument>  )</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_BNOT_unop_code</name></expr> :</case>    <comment type="line">// z = ~x (bitwise complement), integers only</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_INT8_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_bnot</argument>, <argument>_int8</argument>  , <argument>int8_t</argument>  , <argument>_int8</argument>  , <argument>int8_t</argument>  )</argument_list></macro>
                    <case>case <expr><name>GB_INT16_code</name></expr>  :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_bnot</argument>, <argument>_int16</argument> , <argument>int16_t</argument> , <argument>_int16</argument> , <argument>int16_t</argument> )</argument_list></macro>
                    <case>case <expr><name>GB_INT32_code</name></expr>  :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_bnot</argument>, <argument>_int32</argument> , <argument>int32_t</argument> , <argument>_int32</argument> , <argument>int32_t</argument> )</argument_list></macro>
                    <case>case <expr><name>GB_INT64_code</name></expr>  :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_bnot</argument>, <argument>_int64</argument> , <argument>int64_t</argument> , <argument>_int64</argument> , <argument>int64_t</argument> )</argument_list></macro>
                    <case>case <expr><name>GB_UINT8_code</name></expr>  :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_bnot</argument>, <argument>_uint8</argument> , <argument>uint8_t</argument> , <argument>_uint8</argument> , <argument>uint8_t</argument> )</argument_list></macro>
                    <case>case <expr><name>GB_UINT16_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_bnot</argument>, <argument>_uint16</argument>, <argument>uint16_t</argument>, <argument>_uint16</argument>, <argument>uint16_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_UINT32_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_bnot</argument>, <argument>_uint32</argument>, <argument>uint32_t</argument>, <argument>_uint32</argument>, <argument>uint32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_UINT64_code</name></expr> :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_bnot</argument>, <argument>_uint64</argument>, <argument>uint64_t</argument>, <argument>_uint64</argument>, <argument>uint64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_SQRT_unop_code</name></expr> :</case>    <comment type="line">// z = sqrt (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_sqrt</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_sqrt</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_sqrt</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_sqrt</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_LOG_unop_code</name></expr> :</case>     <comment type="line">// z = log (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_log</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_log</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_log</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_log</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>


            <case>case <expr><name>GB_EXP_unop_code</name></expr> :</case>     <comment type="line">// z = exp (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_exp</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_exp</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_exp</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_exp</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>


            <case>case <expr><name>GB_SIN_unop_code</name></expr> :</case>     <comment type="line">// z = sin (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_sin</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_sin</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_sin</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_sin</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_COS_unop_code</name></expr> :</case>     <comment type="line">// z = cos (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_cos</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_cos</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_cos</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_cos</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_TAN_unop_code</name></expr> :</case>     <comment type="line">// z = tan (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_tan</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_tan</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_tan</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_tan</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>


            <case>case <expr><name>GB_ASIN_unop_code</name></expr> :</case>    <comment type="line">// z = asin (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_asin</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_asin</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_asin</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_asin</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_ACOS_unop_code</name></expr> :</case>    <comment type="line">// z = acos (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_acos</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_acos</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_acos</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_acos</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_ATAN_unop_code</name></expr> :</case>    <comment type="line">// z = atan (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_atan</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_atan</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_atan</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_atan</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>


            <case>case <expr><name>GB_SINH_unop_code</name></expr> :</case>    <comment type="line">// z = sinh (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_sinh</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_sinh</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_sinh</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_sinh</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_COSH_unop_code</name></expr> :</case>    <comment type="line">// z = cosh (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_cosh</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_cosh</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_cosh</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_cosh</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_TANH_unop_code</name></expr> :</case>    <comment type="line">// z = tanh (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_tanh</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_tanh</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_tanh</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_tanh</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>


            <case>case <expr><name>GB_ASINH_unop_code</name></expr> :</case>   <comment type="line">// z = asinh (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_asinh</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_asinh</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_asinh</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_asinh</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_ACOSH_unop_code</name></expr> :</case>   <comment type="line">// z = acosh (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_acosh</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_acosh</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_acosh</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_acosh</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_ATANH_unop_code</name></expr> :</case>   <comment type="line">// z = atanh (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_atanh</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_atanh</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_atanh</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_atanh</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_SIGNUM_unop_code</name></expr> :</case>  <comment type="line">// z = signum (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_signum</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_signum</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_signum</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_signum</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_CEIL_unop_code</name></expr> :</case>    <comment type="line">// z = ceil (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_ceil</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_ceil</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_ceil</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_ceil</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_FLOOR_unop_code</name></expr> :</case>   <comment type="line">// z = floor (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_floor</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_floor</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_floor</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_floor</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_ROUND_unop_code</name></expr> :</case>   <comment type="line">// z = round (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_round</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_round</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_round</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_round</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_TRUNC_unop_code</name></expr> :</case>   <comment type="line">// z = trunc (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_trunc</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_trunc</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_trunc</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_trunc</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>


            <case>case <expr><name>GB_EXP2_unop_code</name></expr> :</case>    <comment type="line">// z = exp2 (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_exp2</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_exp2</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_exp2</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_exp2</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_EXPM1_unop_code</name></expr> :</case>   <comment type="line">// z = expm1 (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_expm1</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_expm1</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_expm1</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_expm1</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_LOG10_unop_code</name></expr> :</case>   <comment type="line">// z = log10 (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_log10</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_log10</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_log10</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_log10</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_LOG1P_unop_code</name></expr> :</case>   <comment type="line">// z = log1P (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_log1p</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_log1p</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_log1p</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_log1p</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_LOG2_unop_code</name></expr> :</case>    <comment type="line">// z = log2 (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_log2</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument>     )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_log2</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>    )</argument_list></macro>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_log2</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_log2</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_LGAMMA_unop_code</name></expr> :</case>  <comment type="line">// z = lgamma (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_lgamma</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument> )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_lgamma</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_TGAMMA_unop_code</name></expr> :</case>  <comment type="line">// z = tgamma (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_tgamma</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument> )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_tgamma</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_ERF_unop_code</name></expr> :</case>     <comment type="line">// z = erf (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_erf</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument> )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_erf</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_ERFC_unop_code</name></expr> :</case>    <comment type="line">// z = erfc (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_erfc</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument> )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_erfc</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_CBRT_unop_code</name></expr> :</case>    <comment type="line">// z = cbrt (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_cbrt</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument> )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_cbrt</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_FREXPX_unop_code</name></expr> :</case>  <comment type="line">// z = frexpx (x), mantissa from ANSI C11 frexp</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_frexpx</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument> )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_frexpx</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_FREXPE_unop_code</name></expr> :</case>  <comment type="line">// z = frexpe (x), exponent from ANSI C11 frexp</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FP32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_frexpe</argument>, <argument>_fp32</argument>, <argument>float</argument>     , <argument>_fp32</argument>, <argument>float</argument> )</argument_list></macro>
                    <case>case <expr><name>GB_FP64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_frexpe</argument>, <argument>_fp64</argument>, <argument>double</argument>    , <argument>_fp64</argument>, <argument>double</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <case>case <expr><name>GB_CONJ_unop_code</name></expr> :</case>    <comment type="line">// z = conj (x)</comment>

                <switch>switch <condition>(<expr><name>code1</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>GB_FC32_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_conj</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>, <argument>_fc32</argument>, <argument>GxB_FC32_t</argument>)</argument_list></macro>
                    <case>case <expr><name>GB_FC64_code</name></expr>   :</case> <macro><name>GB_WORKER</name> <argument_list>(<argument>_conj</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>, <argument>_fc64</argument>, <argument>GxB_FC64_t</argument>)</argument_list></macro>
                    <default>default:</default> <empty_stmt>;</empty_stmt>
                </block_content>}</block></switch>
                <break>break ;</break>

            <default>default:</default> <empty_stmt>;</empty_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>
</block_content>}</block>

</unit>
