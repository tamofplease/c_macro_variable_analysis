<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/Template/GB_AxB_dot_cij.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_AxB_dot_cij: compute C(i,j) = A(:,i)'*B(:,j)</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// Computes C(i,j) = A (:,i)'*B(:,j) via sparse dot product.  This template is</comment>
<comment type="line">// used for all three cases: C=A'*B, C&lt;M&gt;=A'*B, and C&lt;!M&gt;=A'*B in dot2 when C</comment>
<comment type="line">// is bitmap, and for C&lt;M&gt;=A'*B when C and M are sparse or hyper in dot3.</comment>

<comment type="line">// if A_NOT_TRANSPOSED is #defined, then dot2 is computing A(i,:)*B(:,j)</comment>
<comment type="line">// for C&lt;#M&gt;=A*B.  In this case A is either bitmap or full, and B is always</comment>
<comment type="line">// sparse.</comment>

<comment type="line">// When used as the multiplicative operator, the PAIR operator provides some</comment>
<comment type="line">// useful special cases.  Its output is always one, for any matching pair of</comment>
<comment type="line">// entries A(k,i)'*B(k,j) for some k.  If the monoid is ANY, then C(i,j)=1 if</comment>
<comment type="line">// the intersection for the dot product is non-empty.  This intersection has to</comment>
<comment type="line">// be found, in general.  However, suppose B(:,j) is dense.  Then every entry</comment>
<comment type="line">// in the pattern of A(:,i)' will produce a 1 from the PAIR operator.  If the</comment>
<comment type="line">// monoid is ANY, then C(i,j)=1 if A(:,i)' is nonempty.  If the monoid is PLUS,</comment>
<comment type="line">// then C(i,j) is simply nnz(A(:,i)), assuming no overflow.  The XOR monoid</comment>
<comment type="line">// acts like a 1-bit summation, so the result of the XOR_PAIR_BOOL semiring</comment>
<comment type="line">// will be C(i,j) = mod (nnz(A(:,i)'*B(:,j)),2).</comment>

<comment type="line">// If both A(:,i) and B(:,j) are sparse, then the intersection must still be</comment>
<comment type="line">// found, so these optimizations can be used only if A(:,i) and/or B(:,j) are</comment>
<comment type="line">// entirely populated.</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GB_A_INDEX</name></cpp:undef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_A_NOT_TRANSPOSED</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_A_INDEX</name><parameter_list>(<parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(pA+(k)*vlen)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_A_INDEX</name><parameter_list>(<parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(pA+(k))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// MIN_FIRSTJ or MIN_FIRSTJ1 semirings:</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_MIN_FIRSTJ_SEMIRING</name></cpp:macro> <cpp:value>(GB_IS_IMIN_MONOID &amp;&amp; GB_IS_FIRSTJ_MULTIPLIER)</cpp:value></cpp:define>
<comment type="line">// MAX_FIRSTJ or MAX_FIRSTJ1 semirings:</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_IS_MAX_FIRSTJ_SEMIRING</name></cpp:macro> <cpp:value>(GB_IS_IMAX_MONOID &amp;&amp; GB_IS_FIRSTJ_MULTIPLIER)</cpp:value></cpp:define>
<comment type="line">// GB_OFFSET is 1 for the MIN/MAX_FIRSTJ1 semirings, and 0 otherwise.</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// C(i,j) = A(:,i)'*B(:,j): a single dot product</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>pB</name> <init>= <expr><name>pB_start</name></expr></init></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>vlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator> <name>GB_B_IS_SPARSE</name> <operator>||</operator> <name>GB_B_IS_HYPER</name> <operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>bjnz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator> <name>GB_A_IS_SPARSE</name> <operator>||</operator> <name>GB_A_IS_HYPER</name> <operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>ainz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator> <name>GB_A_IS_FULL</name> <operator>&amp;&amp;</operator> <name>GB_B_IS_FULL</name> <operator>)</operator></expr></cpp:if>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// both A and B are full</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_IS_PAIR_MULTIPLIER</name></expr></cpp:if>
        <block>{<block_content> 
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator> <name>GB_IS_ANY_PAIR_SEMIRING</name> <operator>)</operator></expr></cpp:if>
            <comment type="line">// nothing to do; C is iso</comment>
            <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><name>GB_CTYPE_BITS</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></cpp:elif>
            <comment type="line">// PLUS, XOR monoids: A(:,i)'*B(:,j) is nnz(A(:,i)),</comment>
            <comment type="line">// for bool, 8-bit, 16-bit, or 32-bit integer</comment>
            <expr_stmt><expr><name>cij</name> <operator>=</operator> <operator>(</operator><name>GB_CTYPE</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name>vlen</name><operator>)</operator> <operator>&amp;</operator> <name>GB_CTYPE_BITS</name><operator>)</operator></expr> ;</expr_stmt>
            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <comment type="line">// PLUS monoid for float, double, or 64-bit integers </comment>
            <expr_stmt><expr><name>cij</name> <operator>=</operator> <call><name>GB_CTYPE_CAST</name> <argument_list>(<argument><expr><name>vlen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block>
        <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>GB_IS_MIN_FIRSTJ_SEMIRING</name></expr></cpp:elif>
        <block>{<block_content> 
            <comment type="line">// MIN_FIRSTJ semiring: take the first entry</comment>
            <expr_stmt><expr><name>cij</name> <operator>=</operator> <name>GB_OFFSET</name></expr> ;</expr_stmt>
        </block_content>}</block>
        <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>GB_IS_MAX_FIRSTJ_SEMIRING</name></expr></cpp:elif>
        <block>{<block_content> 
            <comment type="line">// MAX_FIRSTJ semiring: take the last entry</comment>
            <expr_stmt><expr><name>cij</name> <operator>=</operator> <name>vlen</name><operator>-</operator><literal type="number">1</literal> <operator>+</operator> <name>GB_OFFSET</name></expr> ;</expr_stmt>
        </block_content>}</block>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <block>{<block_content>
            <comment type="line">// cij = A(0,i) * B(0,j)</comment>
            <expr_stmt><expr><call><name>GB_GETA</name> <argument_list>(<argument><expr><name>aki</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>      <comment type="line">// aki = A(0,i)</comment>
            <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>bkj</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>      <comment type="line">// bkj = B(0,j)</comment>
            <expr_stmt><expr><call><name>GB_MULT</name> <argument_list>(<argument><expr><name>cij</name></expr></argument>, <argument><expr><name>aki</name></expr></argument>, <argument><expr><name>bkj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>  <comment type="line">// cij = aki * bkj</comment>
            <macro><name>GB_PRAGMA_SIMD_DOT</name> <argument_list>(<argument>cij</argument>)</argument_list></macro>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">1</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>vlen</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content> 
                <expr_stmt><expr><call><name>GB_DOT_TERMINAL</name> <argument_list>(<argument><expr><name>cij</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>             <comment type="line">// break if cij terminal</comment>
                <comment type="line">// cij += A(k,i) * B(k,j)</comment>
                <expr_stmt><expr><call><name>GB_GETA</name> <argument_list>(<argument><expr><name>aki</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name><operator>+</operator><name>k</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>    <comment type="line">// aki = A(k,i)</comment>
                <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>bkj</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name><operator>+</operator><name>k</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>    <comment type="line">// bkj = B(k,j)</comment>
                <expr_stmt><expr><call><name>GB_MULTADD</name> <argument_list>(<argument><expr><name>cij</name></expr></argument>, <argument><expr><name>aki</name></expr></argument>, <argument><expr><name>bkj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <comment type="line">// cij += aki * bkj</comment>
            </block_content>}</block></for>
        </block_content>}</block>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>GB_DOT_ALWAYS_SAVE_CIJ</name></expr> ;</expr_stmt>

    </block_content>}</block>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator> <name>GB_A_IS_FULL</name> <operator>&amp;&amp;</operator> <name>GB_B_IS_BITMAP</name> <operator>)</operator></expr></cpp:elif>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// A is full and B is bitmap</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_IS_MIN_FIRSTJ_SEMIRING</name></expr></cpp:if>
        <block>{<block_content>
            <comment type="line">// MIN_FIRSTJ semiring: take the first entry in B(:,j)</comment>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>vlen</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>Bb</name> <index>[<expr><name>pB</name><operator>+</operator><name>k</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><name>cij_exists</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>cij</name> <operator>=</operator> <name>k</name> <operator>+</operator> <name>GB_OFFSET</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>GB_IS_MAX_FIRSTJ_SEMIRING</name></expr></cpp:elif>
        <block>{<block_content>
            <comment type="line">// MAX_FIRSTJ semiring: take the last entry in B(:,j)</comment>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><name>vlen</name><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ;</condition> <incr><expr><name>k</name><operator>--</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>Bb</name> <index>[<expr><name>pB</name><operator>+</operator><name>k</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><name>cij_exists</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>cij</name> <operator>=</operator> <name>k</name> <operator>+</operator> <name>GB_OFFSET</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>vlen</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>Bb</name> <index>[<expr><name>pB</name><operator>+</operator><name>k</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><call><name>GB_DOT</name> <argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>pA</name><operator>+</operator><name>k</name></expr></argument>, <argument><expr><name>pB</name><operator>+</operator><name>k</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>GB_DOT_SAVE_CIJ</name></expr> ;</expr_stmt>

    </block_content>}</block>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator> <name>GB_A_IS_FULL</name> <operator>&amp;&amp;</operator> <operator>(</operator> <name>GB_B_IS_SPARSE</name> <operator>||</operator> <name>GB_B_IS_HYPER</name> <operator>)</operator> <operator>)</operator></expr></cpp:elif>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// A is full and B is sparse/hyper (C = A'*B or A*B)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_IS_PAIR_MULTIPLIER</name></expr></cpp:if>
        <block>{<block_content>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator> <name>GB_IS_ANY_PAIR_SEMIRING</name> <operator>)</operator></expr></cpp:if>
            <comment type="line">// nothing to do; C is iso</comment>
            <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><name>GB_CTYPE_BITS</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></cpp:elif>
            <comment type="line">// PLUS, XOR monoids: A(:,i)'*B(:,j) is nnz(A(:,i)),</comment>
            <comment type="line">// for bool, 8-bit, 16-bit, or 32-bit integer</comment>
            <expr_stmt><expr><name>cij</name> <operator>=</operator> <operator>(</operator><name>GB_CTYPE</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name>bjnz</name><operator>)</operator> <operator>&amp;</operator> <name>GB_CTYPE_BITS</name><operator>)</operator></expr> ;</expr_stmt>
            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <comment type="line">// PLUS monoid for float, double, or 64-bit integers </comment>
            <expr_stmt><expr><name>cij</name> <operator>=</operator> <call><name>GB_CTYPE_CAST</name> <argument_list>(<argument><expr><name>bjnz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block>
        <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>GB_IS_MIN_FIRSTJ_SEMIRING</name></expr></cpp:elif>
        <block>{<block_content> 
            <comment type="line">// MIN_FIRSTJ semiring: take the first entry in B(:,j)</comment>
            <expr_stmt><expr><name>cij</name> <operator>=</operator> <name><name>Bi</name> <index>[<expr><name>pB</name></expr>]</index></name> <operator>+</operator> <name>GB_OFFSET</name></expr> ;</expr_stmt>
        </block_content>}</block>
        <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>GB_IS_MAX_FIRSTJ_SEMIRING</name></expr></cpp:elif>
        <block>{<block_content> 
            <comment type="line">// MAX_FIRSTJ semiring: take the last entry in B(:,j)</comment>
            <expr_stmt><expr><name>cij</name> <operator>=</operator> <name><name>Bi</name> <index>[<expr><name>pB_end</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>GB_OFFSET</name></expr> ;</expr_stmt>
        </block_content>}</block>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><name><name>Bi</name> <index>[<expr><name>pB</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>               <comment type="line">// first row index of B(:,j)</comment>
            <comment type="line">// cij = (A(k,i) or A(i,k)) * B(k,j)</comment>
            <expr_stmt><expr><call><name>GB_GETA</name> <argument_list>(<argument><expr><name>aki</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><call><name>GB_A_INDEX</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <comment type="line">// aki = A(k,i) or A(i,k)</comment>
            <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>bkj</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>  , <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>    <comment type="line">// bkj = B(k,j)</comment>
            <expr_stmt><expr><call><name>GB_MULT</name> <argument_list>(<argument><expr><name>cij</name></expr></argument>, <argument><expr><name>aki</name></expr></argument>, <argument><expr><name>bkj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>  <comment type="line">// cij = aki * bkj</comment>
            <macro><name>GB_PRAGMA_SIMD_DOT</name> <argument_list>(<argument>cij</argument>)</argument_list></macro>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><name>pB</name><operator>+</operator><literal type="number">1</literal></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>pB_end</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content> 
                <expr_stmt><expr><call><name>GB_DOT_TERMINAL</name> <argument_list>(<argument><expr><name>cij</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>             <comment type="line">// break if cij terminal</comment>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><name><name>Bi</name> <index>[<expr><name>p</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <comment type="line">// cij += (A(k,i) or A(i,k)) * B(k,j)</comment>
                <expr_stmt><expr><call><name>GB_GETA</name> <argument_list>(<argument><expr><name>aki</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><call><name>GB_A_INDEX</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt> <comment type="line">//aki=A(k,i) or A(i,k)</comment>
                <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>bkj</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>           <comment type="line">// bkj = B(k,j)</comment>
                <expr_stmt><expr><call><name>GB_MULTADD</name> <argument_list>(<argument><expr><name>cij</name></expr></argument>, <argument><expr><name>aki</name></expr></argument>, <argument><expr><name>bkj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>   <comment type="line">// cij += aki * bkj</comment>
            </block_content>}</block></for>
        </block_content>}</block>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>GB_DOT_ALWAYS_SAVE_CIJ</name></expr> ;</expr_stmt>

    </block_content>}</block>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator> <name>GB_A_IS_BITMAP</name> <operator>&amp;&amp;</operator> <name>GB_B_IS_FULL</name> <operator>)</operator></expr></cpp:elif>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// A is bitmap and B is full</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_IS_MIN_FIRSTJ_SEMIRING</name></expr></cpp:if>
        <block>{<block_content>
            <comment type="line">// MIN_FIRSTJ semiring: take the first entry in A(:,i)</comment>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>vlen</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>Ab</name> <index>[<expr><name>pA</name><operator>+</operator><name>k</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><name>cij_exists</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>cij</name> <operator>=</operator> <name>k</name> <operator>+</operator> <name>GB_OFFSET</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>GB_IS_MAX_FIRSTJ_SEMIRING</name></expr></cpp:elif>
        <block>{<block_content>
            <comment type="line">// MAX_FIRSTJ semiring: take the last entry in A(:,i)</comment>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><name>vlen</name><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ;</condition> <incr><expr><name>k</name><operator>--</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>Ab</name> <index>[<expr><name>pA</name><operator>+</operator><name>k</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><name>cij_exists</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>cij</name> <operator>=</operator> <name>k</name> <operator>+</operator> <name>GB_OFFSET</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>vlen</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>Ab</name> <index>[<expr><name>pA</name><operator>+</operator><name>k</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><call><name>GB_DOT</name> <argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>pA</name><operator>+</operator><name>k</name></expr></argument>, <argument><expr><name>pB</name><operator>+</operator><name>k</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>GB_DOT_SAVE_CIJ</name></expr> ;</expr_stmt>

    </block_content>}</block>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator> <name>GB_A_IS_BITMAP</name> <operator>&amp;&amp;</operator> <name>GB_B_IS_BITMAP</name> <operator>)</operator></expr></cpp:elif>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// both A and B are bitmap</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_IS_MIN_FIRSTJ_SEMIRING</name></expr></cpp:if>
        <block>{<block_content>
            <comment type="line">// MIN_FIRSTJ semiring: take the first entry</comment>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>vlen</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>Ab</name> <index>[<expr><name>pA</name><operator>+</operator><name>k</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>Bb</name> <index>[<expr><name>pB</name><operator>+</operator><name>k</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><name>cij_exists</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>cij</name> <operator>=</operator> <name>k</name> <operator>+</operator> <name>GB_OFFSET</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>GB_IS_MAX_FIRSTJ_SEMIRING</name></expr></cpp:elif>
        <block>{<block_content>
            <comment type="line">// MAX_FIRSTJ semiring: take the last entry</comment>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><name>vlen</name><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ;</condition> <incr><expr><name>k</name><operator>--</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>Ab</name> <index>[<expr><name>pA</name><operator>+</operator><name>k</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>Bb</name> <index>[<expr><name>pB</name><operator>+</operator><name>k</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><name>cij_exists</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>cij</name> <operator>=</operator> <name>k</name> <operator>+</operator> <name>GB_OFFSET</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>vlen</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>Ab</name> <index>[<expr><name>pA</name><operator>+</operator><name>k</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>Bb</name> <index>[<expr><name>pB</name><operator>+</operator><name>k</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><call><name>GB_DOT</name> <argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>pA</name><operator>+</operator><name>k</name></expr></argument>, <argument><expr><name>pB</name><operator>+</operator><name>k</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>GB_DOT_SAVE_CIJ</name></expr> ;</expr_stmt>

    </block_content>}</block>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator> <name>GB_A_IS_BITMAP</name> <operator>&amp;&amp;</operator> <operator>(</operator> <name>GB_B_IS_SPARSE</name> <operator>||</operator> <name>GB_B_IS_HYPER</name> <operator>)</operator> <operator>)</operator></expr></cpp:elif>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// A is bitmap and B is sparse/hyper (C = A'*B or A*B)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_IS_MIN_FIRSTJ_SEMIRING</name></expr></cpp:if>
        <block>{<block_content>
            <comment type="line">// MIN_FIRSTJ semiring: take the first entry</comment>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><name>pB</name></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>pB_end</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><name><name>Bi</name> <index>[<expr><name>p</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>Ab</name> <index>[<expr><call><name>GB_A_INDEX</name> <argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><name>cij_exists</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>cij</name> <operator>=</operator> <name>k</name> <operator>+</operator> <name>GB_OFFSET</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>GB_IS_MAX_FIRSTJ_SEMIRING</name></expr></cpp:elif>
        <block>{<block_content>
            <comment type="line">// MAX_FIRSTJ semiring: take the last entry</comment>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><name>pB_end</name><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&gt;=</operator> <name>pB</name></expr> ;</condition> <incr><expr><name>p</name><operator>--</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><name><name>Bi</name> <index>[<expr><name>p</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>Ab</name> <index>[<expr><call><name>GB_A_INDEX</name> <argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><name>cij_exists</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>cij</name> <operator>=</operator> <name>k</name> <operator>+</operator> <name>GB_OFFSET</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><name>pB</name></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>pB_end</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><name><name>Bi</name> <index>[<expr><name>p</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>Ab</name> <index>[<expr><call><name>GB_A_INDEX</name> <argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><call><name>GB_DOT</name> <argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><call><name>GB_A_INDEX</name> <argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>GB_DOT_SAVE_CIJ</name></expr> ;</expr_stmt>

    </block_content>}</block>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator> <operator>(</operator><name>GB_A_IS_SPARSE</name> <operator>||</operator> <name>GB_A_IS_HYPER</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>GB_B_IS_FULL</name> <operator>)</operator></expr></cpp:elif>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// A is sparse/hyper and B is full</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_IS_PAIR_MULTIPLIER</name></expr></cpp:if>
        <block>{<block_content> 
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator> <name>GB_IS_ANY_PAIR_SEMIRING</name> <operator>)</operator></expr></cpp:if>
            <comment type="line">// nothing to do; C is iso</comment>
            <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><name>GB_CTYPE_BITS</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></cpp:elif>
            <comment type="line">// PLUS, XOR monoids: A(:,i)'*B(:,j) is nnz(A(:,i)),</comment>
            <comment type="line">// for bool, 8-bit, 16-bit, or 32-bit integer</comment>
            <expr_stmt><expr><name>cij</name> <operator>=</operator> <operator>(</operator><name>GB_CTYPE</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name>ainz</name><operator>)</operator> <operator>&amp;</operator> <name>GB_CTYPE_BITS</name><operator>)</operator></expr> ;</expr_stmt>
            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <comment type="line">// PLUS monoid for float, double, or 64-bit integers </comment>
            <expr_stmt><expr><name>cij</name> <operator>=</operator> <call><name>GB_CTYPE_CAST</name> <argument_list>(<argument><expr><name>ainz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block>
        <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>GB_IS_MIN_FIRSTJ_SEMIRING</name></expr></cpp:elif>
        <block>{<block_content> 
            <comment type="line">// MIN_FIRSTJ semiring: take the first entry in A(:,i)</comment>
            <expr_stmt><expr><name>cij</name> <operator>=</operator> <name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name> <operator>+</operator> <name>GB_OFFSET</name></expr> ;</expr_stmt>
        </block_content>}</block>
        <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>GB_IS_MAX_FIRSTJ_SEMIRING</name></expr></cpp:elif>
        <block>{<block_content> 
            <comment type="line">// MAX_FIRSTJ semiring: take the last entry in A(:,i)</comment>
            <expr_stmt><expr><name>cij</name> <operator>=</operator> <name><name>Ai</name> <index>[<expr><name>pA_end</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>GB_OFFSET</name></expr> ;</expr_stmt>
        </block_content>}</block>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>               <comment type="line">// first row index of A(:,i)</comment>
            <comment type="line">// cij = A(k,i) * B(k,j)</comment>
            <expr_stmt><expr><call><name>GB_GETA</name> <argument_list>(<argument><expr><name>aki</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>  , <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>    <comment type="line">// aki = A(k,i)</comment>
            <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>bkj</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name><operator>+</operator><name>k</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>    <comment type="line">// bkj = B(k,j)</comment>
            <expr_stmt><expr><call><name>GB_MULT</name> <argument_list>(<argument><expr><name>cij</name></expr></argument>, <argument><expr><name>aki</name></expr></argument>, <argument><expr><name>bkj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>  <comment type="line">// cij = aki * bkj</comment>
            <macro><name>GB_PRAGMA_SIMD_DOT</name> <argument_list>(<argument>cij</argument>)</argument_list></macro>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><name>pA</name><operator>+</operator><literal type="number">1</literal></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>pA_end</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content> 
                <expr_stmt><expr><call><name>GB_DOT_TERMINAL</name> <argument_list>(<argument><expr><name>cij</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>             <comment type="line">// break if cij terminal</comment>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>p</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <comment type="line">// cij += A(k,i) * B(k,j)</comment>
                <expr_stmt><expr><call><name>GB_GETA</name> <argument_list>(<argument><expr><name>aki</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>p</name></expr></argument>   , <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>    <comment type="line">// aki = A(k,i)</comment>
                <expr_stmt><expr><call><name>GB_GETB</name> <argument_list>(<argument><expr><name>bkj</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name><operator>+</operator><name>k</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>    <comment type="line">// bkj = B(k,j)</comment>
                <expr_stmt><expr><call><name>GB_MULTADD</name> <argument_list>(<argument><expr><name>cij</name></expr></argument>, <argument><expr><name>aki</name></expr></argument>, <argument><expr><name>bkj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>   <comment type="line">// cij += aki * bkj</comment>
            </block_content>}</block></for>
        </block_content>}</block>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>GB_DOT_ALWAYS_SAVE_CIJ</name></expr> ;</expr_stmt>

    </block_content>}</block>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator> <operator>(</operator><name>GB_A_IS_SPARSE</name> <operator>||</operator> <name>GB_A_IS_HYPER</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>GB_B_IS_BITMAP</name> <operator>)</operator></expr></cpp:elif>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// A is sparse/hyper and B is bitmap</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_IS_MIN_FIRSTJ_SEMIRING</name></expr></cpp:if>
        <block>{<block_content>
            <comment type="line">// MIN_FIRSTJ semiring: take the first entry</comment>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><name>pA</name></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>pA_end</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>p</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>Bb</name> <index>[<expr><name>pB</name><operator>+</operator><name>k</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><name>cij_exists</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>cij</name> <operator>=</operator> <name>k</name> <operator>+</operator> <name>GB_OFFSET</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>GB_IS_MAX_FIRSTJ_SEMIRING</name></expr></cpp:elif>
        <block>{<block_content>
            <comment type="line">// MAX_FIRSTJ semiring: take the last entry</comment>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><name>pA_end</name><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&gt;=</operator> <name>pA</name></expr> ;</condition> <incr><expr><name>p</name><operator>--</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>p</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>Bb</name> <index>[<expr><name>pB</name><operator>+</operator><name>k</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><name>cij_exists</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>cij</name> <operator>=</operator> <name>k</name> <operator>+</operator> <name>GB_OFFSET</name></expr> ;</expr_stmt>
                    <break>break ;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><name>pA</name></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>pA_end</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>p</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>Bb</name> <index>[<expr><name>pB</name><operator>+</operator><name>k</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><call><name>GB_DOT</name> <argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pB</name><operator>+</operator><name>k</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>GB_DOT_SAVE_CIJ</name></expr> ;</expr_stmt>

    </block_content>}</block>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// both A and B are sparse/hyper</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// The MIN_FIRSTJ semirings are exploited, by terminating as soon as</comment>
        <comment type="line">// any entry is found.  The MAX_FIRSTJ semirings are not treated</comment>
        <comment type="line">// specially here.  They could be done with a backwards traversal of</comment>
        <comment type="line">// the sparse vectors A(:,i) and B(:,j).</comment>

        <if_stmt><if>if <condition>(<expr><name><name>Ai</name> <index>[<expr><name>pA_end</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name>ib_first</name> <operator>||</operator> <name>ib_last</name> <operator>&lt;</operator> <name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content> 

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// pattern of A(:,i) and B(:,j) don't overlap; C(i,j) doesn't exist</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>GB_CIJ_EXISTS</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>ainz</name> <operator>&gt;</operator> <literal type="number">8</literal> <operator>*</operator> <name>bjnz</name></expr>)</condition>
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// B(:,j) is very sparse compared to A(:,i)</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <while>while <condition>(<expr><name>pA</name> <operator>&lt;</operator> <name>pA_end</name> <operator>&amp;&amp;</operator> <name>pB</name> <operator>&lt;</operator> <name>pB_end</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>ia</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>ib</name> <init>= <expr><name><name>Bi</name> <index>[<expr><name>pB</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>ia</name> <operator>&lt;</operator> <name>ib</name></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// A(ia,i) appears before B(ib,j)</comment>
                    <comment type="line">// discard all entries A(ia:ib-1,i)</comment>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>pleft</name> <init>= <expr><name>pA</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>pright</name> <init>= <expr><name>pA_end</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                    <expr_stmt><expr><call><name>GB_TRIM_BINARY_SEARCH</name> <argument_list>(<argument><expr><name>ib</name></expr></argument>, <argument><expr><name>Ai</name></expr></argument>, <argument><expr><name>pleft</name></expr></argument>, <argument><expr><name>pright</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pleft</name> <operator>&gt;</operator> <name>pA</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>pA</name> <operator>=</operator> <name>pleft</name></expr> ;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>ib</name> <operator>&lt;</operator> <name>ia</name></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// B(ib,j) appears before A(ia,i)</comment>
                    <expr_stmt><expr><name>pB</name><operator>++</operator></expr> ;</expr_stmt>
                </block_content>}</block></if>
                <else>else <comment type="line">// ia == ib == k</comment>
                <block>{<block_content> 
                    <comment type="line">// A(k,i) and B(k,j) are the next entries to merge</comment>
                    <expr_stmt><expr><call><name>GB_DOT</name> <argument_list>(<argument><expr><name>ia</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_IS_MIN_FIRSTJ_SEMIRING</name></expr></cpp:if>
                    <break>break ;</break>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><name>pA</name><operator>++</operator></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>pB</name><operator>++</operator></expr> ;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><name>GB_DOT_SAVE_CIJ</name></expr> ;</expr_stmt>

        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>bjnz</name> <operator>&gt;</operator> <literal type="number">8</literal> <operator>*</operator> <name>ainz</name></expr>)</condition>
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// A(:,i) is very sparse compared to B(:,j)</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <while>while <condition>(<expr><name>pA</name> <operator>&lt;</operator> <name>pA_end</name> <operator>&amp;&amp;</operator> <name>pB</name> <operator>&lt;</operator> <name>pB_end</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>ia</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>ib</name> <init>= <expr><name><name>Bi</name> <index>[<expr><name>pB</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>ia</name> <operator>&lt;</operator> <name>ib</name></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// A(ia,i) appears before B(ib,j)</comment>
                    <expr_stmt><expr><name>pA</name><operator>++</operator></expr> ;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>ib</name> <operator>&lt;</operator> <name>ia</name></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// B(ib,j) appears before A(ia,i)</comment>
                    <comment type="line">// discard all entries B(ib:ia-1,j)</comment>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>pleft</name> <init>= <expr><name>pB</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>pright</name> <init>= <expr><name>pB_end</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                    <expr_stmt><expr><call><name>GB_TRIM_BINARY_SEARCH</name> <argument_list>(<argument><expr><name>ia</name></expr></argument>, <argument><expr><name>Bi</name></expr></argument>, <argument><expr><name>pleft</name></expr></argument>, <argument><expr><name>pright</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pleft</name> <operator>&gt;</operator> <name>pB</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>pB</name> <operator>=</operator> <name>pleft</name></expr> ;</expr_stmt>
                </block_content>}</block></if>
                <else>else <comment type="line">// ia == ib == k</comment>
                <block>{<block_content> 
                    <comment type="line">// A(k,i) and B(k,j) are the next entries to merge</comment>
                    <expr_stmt><expr><call><name>GB_DOT</name> <argument_list>(<argument><expr><name>ia</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_IS_MIN_FIRSTJ_SEMIRING</name></expr></cpp:if>
                    <break>break ;</break>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><name>pA</name><operator>++</operator></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>pB</name><operator>++</operator></expr> ;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><name>GB_DOT_SAVE_CIJ</name></expr> ;</expr_stmt>

        </block_content>}</block></if>
        <else>else
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// A(:,i) and B(:,j) have about the same sparsity</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <while>while <condition>(<expr><name>pA</name> <operator>&lt;</operator> <name>pA_end</name> <operator>&amp;&amp;</operator> <name>pB</name> <operator>&lt;</operator> <name>pB_end</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>ia</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>ib</name> <init>= <expr><name><name>Bi</name> <index>[<expr><name>pB</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>ia</name> <operator>&lt;</operator> <name>ib</name></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// A(ia,i) appears before B(ib,j)</comment>
                    <expr_stmt><expr><name>pA</name><operator>++</operator></expr> ;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>ib</name> <operator>&lt;</operator> <name>ia</name></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// B(ib,j) appears before A(ia,i)</comment>
                    <expr_stmt><expr><name>pB</name><operator>++</operator></expr> ;</expr_stmt>
                </block_content>}</block></if>
                <else>else <comment type="line">// ia == ib == k</comment>
                <block>{<block_content> 
                    <comment type="line">// A(k,i) and B(k,j) are the next entries to merge</comment>
                    <expr_stmt><expr><call><name>GB_DOT</name> <argument_list>(<argument><expr><name>ia</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_IS_MIN_FIRSTJ_SEMIRING</name></expr></cpp:if>
                    <break>break ;</break>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><name>pA</name><operator>++</operator></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>pB</name><operator>++</operator></expr> ;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><name>GB_DOT_SAVE_CIJ</name></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>

</unit>
