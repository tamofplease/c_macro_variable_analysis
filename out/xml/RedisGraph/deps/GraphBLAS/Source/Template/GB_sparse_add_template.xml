<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" xmlns:omp="http://www.srcML.org/srcML/openmp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/Template/GB_sparse_add_template.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_sparse_add_template:  C=A+B, C&lt;M&gt;=A+B when C is sparse/hypersparse</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// C is sparse or hypersparse:</comment>

        <comment type="line">//      ------------------------------------------</comment>
        <comment type="line">//      C       =           A       +       B</comment>
        <comment type="line">//      ------------------------------------------</comment>
        <comment type="line">//      sparse  .           sparse          sparse</comment>

        <comment type="line">//      ------------------------------------------</comment>
        <comment type="line">//      C      &lt;M&gt; =        A       +       B</comment>
        <comment type="line">//      ------------------------------------------</comment>
        <comment type="line">//      sparse  sparse      sparse          sparse</comment>
        <comment type="line">//      sparse  sparse      sparse          bitmap</comment>
        <comment type="line">//      sparse  sparse      sparse          full</comment>
        <comment type="line">//      sparse  sparse      bitmap          sparse</comment>
        <comment type="line">//      sparse  sparse      bitmap          bitmap</comment>
        <comment type="line">//      sparse  sparse      bitmap          full</comment>
        <comment type="line">//      sparse  sparse      full            sparse</comment>
        <comment type="line">//      sparse  sparse      full            bitmap</comment>
        <comment type="line">//      sparse  sparse      full            full</comment>

        <comment type="line">//      sparse  bitmap      sparse          sparse</comment>
        <comment type="line">//      sparse  full        sparse          sparse</comment>

        <comment type="line">//      ------------------------------------------</comment>
        <comment type="line">//      C     &lt;!M&gt; =        A       +       B</comment>
        <comment type="line">//      ------------------------------------------</comment>
        <comment type="line">//      sparse  bitmap      sparse          sparse</comment>
        <comment type="line">//      sparse  full        sparse          sparse</comment>

<comment type="line">// If all four matrices are sparse/hypersparse, and C&lt;!M&gt;=A+B is being</comment>
<comment type="line">// computed, then M is passed in as NULL to GB_add_phase*.  GB_add_sparsity</comment>
<comment type="line">// returns apply_mask as false.  The methods below do not handle the case when</comment>
<comment type="line">// C is sparse, M is sparse, and !M is used.  All other uses of !M when M</comment>
<comment type="line">// is sparse result in a bitmap structure for C, and this is handled by</comment>
<comment type="line">// GB_bitmap_add_template.</comment>

        <comment type="line">// For this case: the mask is done later, so C=A+B is computed here:</comment>

        <comment type="line">//      ------------------------------------------</comment>
        <comment type="line">//      C     &lt;!M&gt; =        A       +       B</comment>
        <comment type="line">//      ------------------------------------------</comment>
        <comment type="line">//      sparse  sparse      sparse          sparse      (mask later)</comment>

<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// phase1: count entries in each C(:,j)</comment>
    <comment type="line">// phase2: compute C</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>parallel</omp:name> <omp:name>for</omp:name> <omp:clause><omp:name>num_threads</omp:name><omp:argument_list>(<omp:argument><omp:expr>C_nthreads</omp:expr></omp:argument>)</omp:argument_list></omp:clause> <omp:clause><omp:name>schedule</omp:name><omp:argument_list>(<omp:argument><omp:expr>dynamic</omp:expr></omp:argument>,<omp:argument><omp:expr>1</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
    <for>for <control>(<init><expr><name>taskid</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>taskid</name> <operator>&lt;</operator> <name>C_ntasks</name></expr> ;</condition> <incr><expr><name>taskid</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// get the task descriptor</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <decl_stmt><decl><type><name>int64_t</name></type> <name>kfirst</name> <init>= <expr><name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>kfirst</name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>klast</name>  <init>= <expr><name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>klast</name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>fine_task</name> <init>= <expr><operator>(</operator><name>klast</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>len</name></decl> ;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>fine_task</name></expr>)</condition>
        <block>{<block_content> 
            <comment type="line">// a fine task operates on a slice of a single vector</comment>
            <expr_stmt><expr><name>klast</name> <operator>=</operator> <name>kfirst</name></expr> ;</expr_stmt>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>len</name></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content> 
            <comment type="line">// a coarse task operates on one or more whole vectors</comment>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <name>vlen</name></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// compute all vectors in this task</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><name>kfirst</name></expr></init></decl> ;</init> <condition><expr><name>k</name> <operator>&lt;=</operator> <name>klast</name></expr> ;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// get j, the kth vector of C</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>j</name> <init>= <expr><call><name>GBH</name> <argument_list>(<argument><expr><name>Ch</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>cjnz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pC</name></decl>, <decl><type ref="prev"/><name>pC_end</name></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>fine_task</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// A fine task computes a slice of C(:,j)</comment>
                <expr_stmt><expr><name>pC</name>     <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>  ]</index></name><operator>.</operator><name>pC</name></expr> ;</expr_stmt>
                <expr_stmt><expr><name>pC_end</name> <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pC</name></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>Cp</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>&lt;=</operator> <name>pC</name> <operator>&amp;&amp;</operator> <name>pC</name> <operator>&lt;=</operator> <name>pC_end</name> <operator>&amp;&amp;</operator> <name>pC_end</name> <operator>&lt;=</operator> <name><name>Cp</name> <index>[<expr><name>k</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <comment type="line">// The vectors of C are never sliced for a coarse task.</comment>
                <expr_stmt><expr><name>pC</name>     <operator>=</operator> <name><name>Cp</name> <index>[<expr><name>k</name></expr>  ]</index></name></expr> ;</expr_stmt>
                <expr_stmt><expr><name>pC_end</name> <operator>=</operator> <name><name>Cp</name> <index>[<expr><name>k</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>cjnz</name> <init>= <expr><name>pC_end</name> <operator>-</operator> <name>pC</name></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>cjnz</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// get A(:,j)</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>pA</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>pA_end</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>fine_task</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// A fine task operates on Ai,Ax [pA...pA_end-1], which is</comment>
                <comment type="line">// a subset of the vector A(:,j)</comment>
                <expr_stmt><expr><name>pA</name>     <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>pA</name></expr> ;</expr_stmt>
                <expr_stmt><expr><name>pA_end</name> <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>pA_end</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="line">// A coarse task operates on the entire vector A (:,j)</comment>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>kA</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>C_to_A</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>j</name></expr> </then><else>: <expr><name><name>C_to_A</name> <index>[<expr><name>k</name></expr>]</index></name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>kA</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><name>pA</name>     <operator>=</operator> <call><name>GBP</name> <argument_list>(<argument><expr><name>Ap</name></expr></argument>, <argument><expr><name>kA</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>pA_end</name> <operator>=</operator> <call><name>GBP</name> <argument_list>(<argument><expr><name>Ap</name></expr></argument>, <argument><expr><name>kA</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>ajnz</name> <init>= <expr><name>pA_end</name> <operator>-</operator> <name>pA</name></expr></init></decl> ;</decl_stmt>    <comment type="line">// nnz in A(:,j) for this slice</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pA_start</name> <init>= <expr><name>pA</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>adense</name> <init>= <expr><operator>(</operator><name>ajnz</name> <operator>==</operator> <name>len</name><operator>)</operator></expr></init></decl> ;</decl_stmt>

            <comment type="line">// get the first and last indices in A(:,j) for this vector</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>iA_first</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>iA_last</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>ajnz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><name>iA_first</name> <operator>=</operator> <call><name>GBI</name> <argument_list>(<argument><expr><name>Ai</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><name>iA_last</name>  <operator>=</operator> <call><name>GBI</name> <argument_list>(<argument><expr><name>Ai</name></expr></argument>, <argument><expr><name>pA_end</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// get B(:,j)</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>pB</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>pB_end</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>fine_task</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// A fine task operates on Bi,Bx [pB...pB_end-1], which is</comment>
                <comment type="line">// a subset of the vector B(:,j)</comment>
                <expr_stmt><expr><name>pB</name>     <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>pB</name></expr> ;</expr_stmt>
                <expr_stmt><expr><name>pB_end</name> <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>pB_end</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="line">// A coarse task operates on the entire vector B (:,j)</comment>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>kB</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>C_to_B</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>j</name></expr> </then><else>: <expr><name><name>C_to_B</name> <index>[<expr><name>k</name></expr>]</index></name></expr></else></ternary></expr></init></decl> ;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>kB</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><name>pB</name>     <operator>=</operator> <call><name>GBP</name> <argument_list>(<argument><expr><name>Bp</name></expr></argument>, <argument><expr><name>kB</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>pB_end</name> <operator>=</operator> <call><name>GBP</name> <argument_list>(<argument><expr><name>Bp</name></expr></argument>, <argument><expr><name>kB</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <decl_stmt><decl><type><name>int64_t</name></type> <name>bjnz</name> <init>= <expr><name>pB_end</name> <operator>-</operator> <name>pB</name></expr></init></decl> ;</decl_stmt>    <comment type="line">// nnz in B(:,j) for this slice</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pB_start</name> <init>= <expr><name>pB</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>bdense</name> <init>= <expr><operator>(</operator><name>bjnz</name> <operator>==</operator> <name>len</name><operator>)</operator></expr></init></decl> ;</decl_stmt>

            <comment type="line">// get the first and last indices in B(:,j) for this vector</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>iB_first</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>iB_last</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>bjnz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><name>iB_first</name> <operator>=</operator> <call><name>GBI</name> <argument_list>(<argument><expr><name>Bi</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><name>iB_last</name>  <operator>=</operator> <call><name>GBI</name> <argument_list>(<argument><expr><name>Bi</name></expr></argument>, <argument><expr><name>pB_end</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// get M(:,j) if M is sparse or hypersparse</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <decl_stmt><decl><type><name>bool</name></type> <name>sparse_mask_is_easy</name> <init>= <expr><name>false</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pM</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>pM_end</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>M_is_sparse_or_hyper</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>fine_task</name></expr>)</condition>
                <block>{<block_content> 
                    <comment type="line">// A fine task operates on Mi,Mx [pM...pM_end-1],</comment>
                    <comment type="line">// which is a subset of the vector M(:,j)</comment>
                    <expr_stmt><expr><name>pM</name>     <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>pM</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>pM_end</name> <operator>=</operator> <name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>pM_end</name></expr> ;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>kM</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>Ch_is_Mh</name></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// Ch is the same as Mh (a deep copy)</comment>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Ch</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>M_is_hyper</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>Ch</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>==</operator> <name><name>M</name><operator>-&gt;</operator><name>h</name> <index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><name>kM</name> <operator>=</operator> <name>k</name></expr> ;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content> 
                        <expr_stmt><expr><name>kM</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>C_to_M</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>j</name></expr> </then><else>: <expr><name><name>C_to_M</name> <index>[<expr><name>k</name></expr>]</index></name></expr></else></ternary></expr> ;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name>kM</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content> 
                        <expr_stmt><expr><name>pM</name>     <operator>=</operator> <call><name>GBP</name> <argument_list>(<argument><expr><name>Mp</name></expr></argument>, <argument><expr><name>kM</name></expr></argument>  , <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><name>pM_end</name> <operator>=</operator> <call><name>GBP</name> <argument_list>(<argument><expr><name>Mp</name></expr></argument>, <argument><expr><name>kM</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></else></if_stmt>

                <comment type="line">// The "easy mask" condition requires M to be sparse/hyper</comment>
                <comment type="line">// and structural.  A and B cannot be bitmap.  Also one of</comment>
                <comment type="line">// the following 3 conditions must hold:</comment>
                <comment type="line">// (1) all entries are present in A(:,j) and B == M</comment>
                <comment type="line">// (2) all entries are present in B(:,j) and A == M</comment>
                <comment type="line">// (3) both A and B are aliased to M</comment>
                <expr_stmt><expr><name>sparse_mask_is_easy</name> <operator>=</operator>
                    <name>Mask_struct</name> <operator>&amp;&amp;</operator>          <comment type="line">// M must be structural</comment>
                    <operator>!</operator><name>A_is_bitmap</name> <operator>&amp;&amp;</operator>         <comment type="line">// A must not be bitmap</comment>
                    <operator>!</operator><name>B_is_bitmap</name> <operator>&amp;&amp;</operator>         <comment type="line">// B must not be bitmap</comment>
                    <operator>(</operator><operator>(</operator><name>adense</name> <operator>&amp;&amp;</operator> <name>B</name> <operator>==</operator> <name>M</name><operator>)</operator> <operator>||</operator>  <comment type="line">// one of 3 conditions holds</comment>
                     <operator>(</operator><name>bdense</name> <operator>&amp;&amp;</operator> <name>A</name> <operator>==</operator> <name>M</name><operator>)</operator> <operator>||</operator>
                     <operator>(</operator><name>A</name> <operator>==</operator> <name>M</name> <operator>&amp;&amp;</operator> <name>B</name> <operator>==</operator> <name>M</name><operator>)</operator><operator>)</operator></expr> ;</expr_stmt>

                <comment type="line">// TODO: add the condition above to GB_add_sparsity,</comment>
                <comment type="line">// where adense/bdense are true for the whole matrix</comment>
                <comment type="line">// (adense is true if A is full, or sparse/hypersparse with</comment>
                <comment type="line">// all entries present).  The test here is done vector by</comment>
                <comment type="line">// vector, for each A(:,j) and B(:,j).  This is a finer grain</comment>
                <comment type="line">// test, as compared to a test for all of A and B.</comment>

            </block_content>}</block></if></if_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// C(:,j)&lt;optional mask&gt; = A (:,j) + B (:,j) or subvector</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <if_stmt><if>if <condition>(<expr><name>M</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// M is not present, or !M is sparse but not applied here</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <comment type="line">//      ------------------------------------------</comment>
                <comment type="line">//      C       =           A       +       B</comment>
                <comment type="line">//      ------------------------------------------</comment>
                <comment type="line">//      sparse  .           sparse          sparse</comment>

                <comment type="line">//      ------------------------------------------</comment>
                <comment type="line">//      C     &lt;!M&gt; =        A       +       B</comment>
                <comment type="line">//      ------------------------------------------</comment>
                <comment type="line">//      sparse  sparse      sparse          sparse  (mask later)</comment>

                <comment type="line">// If all four matrices are sparse or hypersparse, and</comment>
                <comment type="line">// Mask_comp is true, the mask M is passed in to this method as</comment>
                <comment type="line">// NULL.  C=A+B is computed with no mask, and !M is applied</comment>
                <comment type="line">// later.</comment>

                <comment type="line">// A and B are both sparse or hypersparse, not bitmap or</comment>
                <comment type="line">// full, but individual vectors of A and B might have all</comment>
                <comment type="line">// entries present (adense and/or bdense).</comment>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>A_is_sparse</name> <operator>||</operator> <name>A_is_hyper</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>B_is_sparse</name> <operator>||</operator> <name>B_is_hyper</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>

                <if_stmt><if>if <condition>(<expr><name>A_and_B_are_disjoint</name></expr>)</condition>
                <block>{<block_content> 

                    <comment type="line">// only used by GB_wait, which computes A+T where T is the</comment>
                    <comment type="line">// matrix of pending tuples for A.  The pattern of pending</comment>
                    <comment type="line">// tuples is always disjoint with the pattern of A.</comment>

                    <expr_stmt><expr><name>cjnz</name> <operator>=</operator> <name>ajnz</name> <operator>+</operator> <name>bjnz</name></expr> ;</expr_stmt>

                </block_content>}</block></if>
                <if type="elseif">else

                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                if <condition>(<expr><name>adense</name> <operator>&amp;&amp;</operator> <name>bdense</name></expr>)</condition>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method01: A(:,j) and B(:,j) dense: thus C(:,j) dense</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>ajnz</name> <operator>==</operator> <name>bjnz</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>iA_first</name> <operator>==</operator> <name>iB_first</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>iA_last</name>  <operator>==</operator> <name>iB_last</name></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><name>cjnz</name> <operator>=</operator> <name>ajnz</name></expr> ;</expr_stmt>
                    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>cjnz</name> <operator>==</operator> <name>ajnz</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <macro><name>GB_PRAGMA_SIMD_VECTORIZE</name></macro>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>ajnz</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content> 
                        <comment type="line">// C (i,j) = A (i,j) + B (i,j)</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name>p</name> <operator>+</operator> <name>iA_first</name></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name> <operator>+</operator> <name>p</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>Ai</name> <index>[<expr><name>pA</name> <operator>+</operator> <name>p</name></expr>]</index></name> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>Bi</name> <index>[<expr><name>pB</name> <operator>+</operator> <name>p</name></expr>]</index></name> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                        <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name> <operator>+</operator> <name>p</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name> <operator>+</operator> <name>p</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name> <operator>+</operator> <name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></for>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>adense</name></expr>)</condition>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method02: A(:,j) dense, B(:,j) sparse: C(:,j) dense</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><name>cjnz</name> <operator>=</operator> <name>ajnz</name></expr> ;</expr_stmt>
                    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>cjnz</name> <operator>==</operator> <name>ajnz</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <macro><name>GB_PRAGMA_SIMD_VECTORIZE</name></macro>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>ajnz</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content> 
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name>p</name> <operator>+</operator> <name>iA_first</name></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name> <operator>+</operator> <name>p</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>Ai</name> <index>[<expr><name>pA</name> <operator>+</operator> <name>p</name></expr>]</index></name> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = A(i,j) + beta</comment>
                            <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name><operator>+</operator><name>p</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name><operator>+</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>beta_scalar</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = A (i,j)</comment>
                            <expr_stmt><expr><call><name>GB_COPY_A_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name><operator>+</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name><operator>+</operator><name>p</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></for>
                    <macro><name>GB_PRAGMA_SIMD_VECTORIZE</name></macro>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>bjnz</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content> 
                        <comment type="line">// C (i,j) = A (i,j) + B (i,j)</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Bi</name> <index>[<expr><name>pB</name> <operator>+</operator> <name>p</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>ii</name> <init>= <expr><name>i</name> <operator>-</operator> <name>iA_first</name></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>Ai</name> <index>[<expr><name>pA</name> <operator>+</operator> <name>ii</name></expr>]</index></name> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                        <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name> <operator>+</operator> <name>ii</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name> <operator>+</operator> <name>p</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name> <operator>+</operator> <name>ii</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></for>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>bdense</name></expr>)</condition>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method03: A(:,j) sparse, B(:,j) dense: C(:,j) dense</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><name>cjnz</name> <operator>=</operator> <name>bjnz</name></expr> ;</expr_stmt>
                    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>cjnz</name> <operator>==</operator> <name>bjnz</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <macro><name>GB_PRAGMA_SIMD_VECTORIZE</name></macro>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>bjnz</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content> 
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name>p</name> <operator>+</operator> <name>iB_first</name></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name> <operator>+</operator> <name>p</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>Bi</name> <index>[<expr><name>pB</name> <operator>+</operator> <name>p</name></expr>]</index></name> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = alpha + B(i,j)</comment>
                            <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name><operator>+</operator><name>p</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name><operator>+</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>alpha_scalar</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = B (i,j)</comment>
                            <expr_stmt><expr><call><name>GB_COPY_B_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name><operator>+</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name><operator>+</operator><name>p</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></for>
                    <macro><name>GB_PRAGMA_SIMD_VECTORIZE</name></macro>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>ajnz</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content> 
                        <comment type="line">// C (i,j) = A (i,j) + B (i,j)</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name> <operator>+</operator> <name>p</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>ii</name> <init>= <expr><name>i</name> <operator>-</operator> <name>iB_first</name></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>Bi</name> <index>[<expr><name>pB</name> <operator>+</operator> <name>ii</name></expr>]</index></name> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                        <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name> <operator>+</operator> <name>p</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name> <operator>+</operator> <name>ii</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name> <operator>+</operator> <name>ii</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></for>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>ajnz</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method04: A(:,j) is empty</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><name>cjnz</name> <operator>=</operator> <name>bjnz</name></expr> ;</expr_stmt>
                    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>cjnz</name> <operator>==</operator> <name>bjnz</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>Ci</name> <operator>+</operator> <name>pC</name></expr></argument>, <argument><expr><name>Bi</name> <operator>+</operator> <name>pB</name></expr></argument>, <argument><expr><name>bjnz</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                    <macro><name>GB_PRAGMA_SIMD_VECTORIZE</name></macro>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>bjnz</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content> 
                        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = alpha + B(i,j)</comment>
                            <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name><operator>+</operator><name>p</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name><operator>+</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>alpha_scalar</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>,
                                <argument><expr><name><name>Bi</name> <index>[<expr><name>pB</name><operator>+</operator><name>p</name></expr>]</index></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = B (i,j)</comment>
                            <expr_stmt><expr><call><name>GB_COPY_B_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name><operator>+</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name><operator>+</operator><name>p</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></for>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>bjnz</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method05: B(:,j) is empty</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><name>cjnz</name> <operator>=</operator> <name>ajnz</name></expr> ;</expr_stmt>
                    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>cjnz</name> <operator>==</operator> <name>ajnz</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>Ci</name> <operator>+</operator> <name>pC</name></expr></argument>, <argument><expr><name>Ai</name> <operator>+</operator> <name>pA</name></expr></argument>, <argument><expr><name>ajnz</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                    <macro><name>GB_PRAGMA_SIMD_VECTORIZE</name></macro>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>ajnz</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content> 
                        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = A(i,j) + beta</comment>
                            <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name><operator>+</operator><name>p</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name><operator>+</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>beta_scalar</name></expr></argument>,
                                <argument><expr><name><name>Ai</name> <index>[<expr><name>pA</name><operator>+</operator><name>p</name></expr>]</index></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = A (i,j)</comment>
                            <expr_stmt><expr><call><name>GB_COPY_A_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name><operator>+</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name><operator>+</operator><name>p</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></for>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>iA_last</name> <operator>&lt;</operator> <name>iB_first</name></expr>)</condition>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method06: last A(:,j) comes before 1st B(:,j)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><name>cjnz</name> <operator>=</operator> <name>ajnz</name> <operator>+</operator> <name>bjnz</name></expr> ;</expr_stmt>
                    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>cjnz</name> <operator>==</operator> <name>ajnz</name> <operator>+</operator> <name>bjnz</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>Ci</name> <operator>+</operator> <name>pC</name></expr></argument>, <argument><expr><name>Ai</name> <operator>+</operator> <name>pA</name></expr></argument>, <argument><expr><name>ajnz</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                    <macro><name>GB_PRAGMA_SIMD_VECTORIZE</name></macro>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>ajnz</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content> 
                        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = A(i,j) + beta</comment>
                            <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name><operator>+</operator><name>p</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name><operator>+</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>beta_scalar</name></expr></argument>,
                                <argument><expr><name><name>Ai</name> <index>[<expr><name>pA</name><operator>+</operator><name>p</name></expr>]</index></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = A (i,j)</comment>
                            <expr_stmt><expr><call><name>GB_COPY_A_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name><operator>+</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name><operator>+</operator><name>p</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></for>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><name>pC</name> <operator>+=</operator> <name>ajnz</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>Ci</name> <operator>+</operator> <name>pC</name></expr></argument>, <argument><expr><name>Bi</name> <operator>+</operator> <name>pB</name></expr></argument>, <argument><expr><name>bjnz</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                    <macro><name>GB_PRAGMA_SIMD_VECTORIZE</name></macro>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>bjnz</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content> 
                        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = alpha + B(i,j)</comment>
                            <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name><operator>+</operator><name>p</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name><operator>+</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>alpha_scalar</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>,
                                <argument><expr><name><name>Bi</name> <index>[<expr><name>pB</name><operator>+</operator><name>p</name></expr>]</index></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = B (i,j)</comment>
                            <expr_stmt><expr><call><name>GB_COPY_B_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name><operator>+</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name><operator>+</operator><name>p</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></for>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>iB_last</name> <operator>&lt;</operator> <name>iA_first</name></expr>)</condition>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method07: last B(:,j) comes before 1st A(:,j)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><name>cjnz</name> <operator>=</operator> <name>ajnz</name> <operator>+</operator> <name>bjnz</name></expr> ;</expr_stmt>
                    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>cjnz</name> <operator>==</operator> <name>ajnz</name> <operator>+</operator> <name>bjnz</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>Ci</name> <operator>+</operator> <name>pC</name></expr></argument>, <argument><expr><name>Bi</name> <operator>+</operator> <name>pB</name></expr></argument>, <argument><expr><name>bjnz</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                    <macro><name>GB_PRAGMA_SIMD_VECTORIZE</name></macro>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>bjnz</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content> 
                        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = alpha + B(i,j)</comment>
                            <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name><operator>+</operator><name>p</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name><operator>+</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>alpha_scalar</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>,
                                <argument><expr><name><name>Bi</name> <index>[<expr><name>pB</name><operator>+</operator><name>p</name></expr>]</index></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = B (i,j)</comment>
                            <expr_stmt><expr><call><name>GB_COPY_B_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name><operator>+</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name><operator>+</operator><name>p</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></for>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><name>pC</name> <operator>+=</operator> <name>bjnz</name></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>Ci</name> <operator>+</operator> <name>pC</name></expr></argument>, <argument><expr><name>Ai</name> <operator>+</operator> <name>pA</name></expr></argument>, <argument><expr><name>ajnz</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                    <macro><name>GB_PRAGMA_SIMD_VECTORIZE</name></macro>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>ajnz</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content> 
                        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = A(i,j) + beta</comment>
                            <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name><operator>+</operator><name>p</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name><operator>+</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>beta_scalar</name></expr></argument>,
                                <argument><expr><name><name>Ai</name> <index>[<expr><name>pA</name><operator>+</operator><name>p</name></expr>]</index></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = A (i,j)</comment>
                            <expr_stmt><expr><call><name>GB_COPY_A_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name><operator>+</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name><operator>+</operator><name>p</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></for>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                </block_content>}</block></if>

                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                <if type="elseif">else if <condition>(<expr><name>ajnz</name> <operator>&gt;</operator> <literal type="number">32</literal> <operator>*</operator> <name>bjnz</name></expr>)</condition>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method08: A(:,j) is much denser than B(:,j)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <comment type="line">// cjnz = ajnz + bjnz - nnz in the intersection</comment>

                    <expr_stmt><expr><name>cjnz</name> <operator>=</operator> <name>ajnz</name> <operator>+</operator> <name>bjnz</name></expr> ;</expr_stmt>
                    <for>for <control>( <init>;</init> <condition><expr><name>pB</name> <operator>&lt;</operator> <name>pB_end</name></expr> ;</condition> <incr><expr><name>pB</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content> 
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Bi</name> <index>[<expr><name>pB</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <comment type="line">// find i in A(:,j)</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>pright</name> <init>= <expr><name>pA_end</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_BINARY_SEARCH</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>Ai</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>pright</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cjnz</name><operator>--</operator></expr> ;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></for>

                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>bjnz</name> <operator>&gt;</operator> <literal type="number">32</literal> <operator>*</operator> <name>ajnz</name></expr>)</condition>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method09: B(:,j) is much denser than A(:,j)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <comment type="line">// cjnz = ajnz + bjnz - nnz in the intersection</comment>

                    <expr_stmt><expr><name>cjnz</name> <operator>=</operator> <name>ajnz</name> <operator>+</operator> <name>bjnz</name></expr> ;</expr_stmt>
                    <for>for <control>( <init>;</init> <condition><expr><name>pA</name> <operator>&lt;</operator> <name>pA_end</name></expr> ;</condition> <incr><expr><name>pA</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content> 
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <comment type="line">// find i in B(:,j)</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>pright</name> <init>= <expr><name>pB_end</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_BINARY_SEARCH</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>Bi</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>pright</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cjnz</name><operator>--</operator></expr> ;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></for>

                </block_content>}</block></if>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <else>else
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method10: A(:,j) and B(:,j) about the same sparsity</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <while>while <condition>(<expr><name>pA</name> <operator>&lt;</operator> <name>pA_end</name> <operator>&amp;&amp;</operator> <name>pB</name> <operator>&lt;</operator> <name>pB_end</name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>iA</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>iB</name> <init>= <expr><name><name>Bi</name> <index>[<expr><name>pB</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>iA</name> <operator>&lt;</operator> <name>iB</name></expr>)</condition>
                        <block>{<block_content> 
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_2_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>iA</name></expr> ;</expr_stmt>
                            <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                            <block>{<block_content> 
                                <comment type="line">// C (iA,j) = A(iA,j) + beta</comment>
                                <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>beta_scalar</name></expr></argument>, <argument><expr><name>iA</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <block>{<block_content> 
                                <comment type="line">// C (iA,j) = A (iA,j)</comment>
                                <expr_stmt><expr><call><name>GB_COPY_A_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <expr_stmt><expr><name>pA</name><operator>++</operator></expr> ;</expr_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><name>iA</name> <operator>&gt;</operator> <name>iB</name></expr>)</condition>
                        <block>{<block_content> 
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_2_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>iB</name></expr> ;</expr_stmt>
                            <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                            <block>{<block_content> 
                                <comment type="line">// C (iB,j) = alpha + B(iB,j)</comment>
                                <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>alpha_scalar</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>,
                                    <argument><expr><name>iB</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <block>{<block_content> 
                                <comment type="line">// C (iB,j) = B (iB,j)</comment>
                                <expr_stmt><expr><call><name>GB_COPY_B_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <expr_stmt><expr><name>pB</name><operator>++</operator></expr> ;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = A (i,j) + B (i,j)</comment>
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_2_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>iB</name></expr> ;</expr_stmt>
                            <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                            <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>, <argument><expr><name>iB</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <expr_stmt><expr><name>pA</name><operator>++</operator></expr> ;</expr_stmt>
                            <expr_stmt><expr><name>pB</name><operator>++</operator></expr> ;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_2_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                        <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></while>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// A (:,j) or B (:,j) have entries left; not both</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <expr_stmt><expr><name>ajnz</name> <operator>=</operator> <operator>(</operator><name>pA_end</name> <operator>-</operator> <name>pA</name><operator>)</operator></expr> ;</expr_stmt>
                    <expr_stmt><expr><name>bjnz</name> <operator>=</operator> <operator>(</operator><name>pB_end</name> <operator>-</operator> <name>pB</name><operator>)</operator></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>ajnz</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>bjnz</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><name>cjnz</name> <operator>+=</operator> <name>ajnz</name> <operator>+</operator> <name>bjnz</name></expr> ;</expr_stmt>
                    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>Ci</name> <operator>+</operator> <name>pC</name></expr></argument>, <argument><expr><name>Ai</name> <operator>+</operator> <name>pA</name></expr></argument>, <argument><expr><name>ajnz</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>ajnz</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content> 
                        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = A(i,j) + beta</comment>
                            <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name><operator>+</operator><name>p</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name><operator>+</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>beta_scalar</name></expr></argument>,
                                <argument><expr><name><name>Ai</name> <index>[<expr><name>pA</name><operator>+</operator><name>p</name></expr>]</index></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = A (i,j)</comment>
                            <expr_stmt><expr><call><name>GB_COPY_A_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name><operator>+</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name><operator>+</operator><name>p</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></for>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>Ci</name> <operator>+</operator> <name>pC</name></expr></argument>, <argument><expr><name>Bi</name> <operator>+</operator> <name>pB</name></expr></argument>, <argument><expr><name>bjnz</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>bjnz</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content> 
                        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = alpha + B(i,j)</comment>
                            <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name><operator>+</operator><name>p</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name><operator>+</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>alpha_scalar</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>,
                                <argument><expr><name><name>Bi</name> <index>[<expr><name>pB</name><operator>+</operator><name>p</name></expr>]</index></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = B (i,j)</comment>
                            <expr_stmt><expr><call><name>GB_COPY_B_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name><operator>+</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name><operator>+</operator><name>p</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></for>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>+</operator> <name>ajnz</name> <operator>+</operator> <name>bjnz</name> <operator>==</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></else></if_stmt>

            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>sparse_mask_is_easy</name></expr>)</condition>
            <block>{<block_content>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// special case: M is present and very easy to use</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <comment type="line">//      ------------------------------------------</comment>
                <comment type="line">//      C      &lt;M&gt; =        A       +       B</comment>
                <comment type="line">//      ------------------------------------------</comment>
                <comment type="line">//      sparse  sparse      sparse          sparse</comment>
                <comment type="line">//      sparse  sparse      sparse          full</comment>
                <comment type="line">//      sparse  sparse      full            sparse</comment>
                <comment type="line">//      sparse  sparse      full            full</comment>

                <comment type="line">// A and B are sparse, hypersparse or full, not bitmap.</comment>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>A_is_bitmap</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><name>B_is_bitmap</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>Mask_struct</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

                <decl_stmt><decl><type><name>int64_t</name></type> <name>mjnz</name> <init>= <expr><name>pM_end</name> <operator>-</operator> <name>pM</name></expr></init></decl> ;</decl_stmt>        <comment type="line">// nnz (M (:,j))</comment>

                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>

                <comment type="line">// M is structural, and sparse or hypersparse, so every entry</comment>
                <comment type="line">// in the mask is guaranteed to appear in A+B.  The symbolic</comment>
                <comment type="line">// count is thus trivial.</comment>

                <expr_stmt><expr><name>cjnz</name> <operator>=</operator> <name>mjnz</name></expr> ;</expr_stmt>

                <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

                <comment type="line">// copy the pattern into C (:,j)</comment>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>pC_start</name> <init>= <expr><name>pC</name></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>pM_start</name> <init>= <expr><name>pM</name></expr></init></decl> ;</decl_stmt>
                <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>Ci</name> <operator>+</operator> <name>pC</name></expr></argument>, <argument><expr><name>Mi</name> <operator>+</operator> <name>pM</name></expr></argument>, <argument><expr><name>mjnz</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>pA_offset</name> <init>= <expr><name>pA_start</name> <operator>-</operator> <name>iA_first</name></expr></init></decl> ;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>pB_offset</name> <init>= <expr><name>pB_start</name> <operator>-</operator> <name>iB_first</name></expr></init></decl> ;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>adense</name> <operator>&amp;&amp;</operator> <name>B</name> <operator>==</operator> <name>M</name></expr>)</condition>
                <block>{<block_content> 

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method11: A dense, B == M</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <macro><name>GB_PRAGMA_SIMD_VECTORIZE</name></macro>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>mjnz</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>pM</name> <init>= <expr><name>p</name> <operator>+</operator> <name>pM_start</name></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>pC</name> <init>= <expr><name>p</name> <operator>+</operator> <name>pC_start</name></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Mi</name> <index>[<expr><name>pM</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_mcast</name> <argument_list>(<argument><expr><name>Mx</name></expr></argument>, <argument><expr><name>pM</name></expr></argument>, <argument><expr><name>msize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GBI</name> <argument_list>(<argument><expr><name>Ai</name></expr></argument>, <argument><expr><name>pA_offset</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GBI</name> <argument_list>(<argument><expr><name>Bi</name></expr></argument>, <argument><expr><name>pM</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                        <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA_offset</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pM</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></for>

                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>bdense</name> <operator>&amp;&amp;</operator> <name>A</name> <operator>==</operator> <name>M</name></expr>)</condition>
                <block>{<block_content> 

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method12: B dense, A == M</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <macro><name>GB_PRAGMA_SIMD_VECTORIZE</name></macro>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>mjnz</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>pM</name> <init>= <expr><name>p</name> <operator>+</operator> <name>pM_start</name></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>pC</name> <init>= <expr><name>p</name> <operator>+</operator> <name>pC_start</name></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Mi</name> <index>[<expr><name>pM</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_mcast</name> <argument_list>(<argument><expr><name>Mx</name></expr></argument>, <argument><expr><name>pM</name></expr></argument>, <argument><expr><name>msize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GBI</name> <argument_list>(<argument><expr><name>Ai</name></expr></argument>, <argument><expr><name>pM</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GBI</name> <argument_list>(<argument><expr><name>Bi</name></expr></argument>, <argument><expr><name>pB_offset</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                        <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pM</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB_offset</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></for>

                </block_content>}</block></if>
                <else>else <comment type="line">// (A == M) &amp;&amp; (B == M)</comment>
                <block>{<block_content> 

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method13: A == M == B: all three matrices the same</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                    <macro><name>GB_PRAGMA_SIMD_VECTORIZE</name></macro>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>mjnz</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>pM</name> <init>= <expr><name>p</name> <operator>+</operator> <name>pM_start</name></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>pC</name> <init>= <expr><name>p</name> <operator>+</operator> <name>pC_start</name></expr></init></decl> ;</decl_stmt>
                        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GB_OP_IS_SECOND</name></expr></cpp:if>
                        <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pM</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pM</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name><name>Mi</name> <index>[<expr><name>pM</name></expr>]</index></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block></for>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                </block_content>}</block></else></if_stmt>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>M_is_sparse_or_hyper</name></expr>)</condition>
            <block>{<block_content>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// Method14: C and M are sparse or hypersparse</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <comment type="line">//      ------------------------------------------</comment>
                <comment type="line">//      C      &lt;M&gt; =        A       +       B</comment>
                <comment type="line">//      ------------------------------------------</comment>
                <comment type="line">//      sparse  sparse      sparse          sparse  (*)</comment>
                <comment type="line">//      sparse  sparse      sparse          bitmap  (*)</comment>
                <comment type="line">//      sparse  sparse      sparse          full    (*)</comment>
                <comment type="line">//      sparse  sparse      bitmap          sparse  (*)</comment>
                <comment type="line">//      sparse  sparse      bitmap          bitmap  (+)</comment>
                <comment type="line">//      sparse  sparse      bitmap          full    (+)</comment>
                <comment type="line">//      sparse  sparse      full            sparse  (*)</comment>
                <comment type="line">//      sparse  sparse      full            bitmap  (+)</comment>
                <comment type="line">//      sparse  sparse      full            full    (+)</comment>

                <comment type="line">// (*) This method is efficient except when either A or B are</comment>
                <comment type="line">// sparse, and when M is sparse but with many entries.  When M</comment>
                <comment type="line">// is sparse and either A or B are sparse, the method is</comment>
                <comment type="line">// designed to be very efficient when M is very sparse compared</comment>
                <comment type="line">// with A and/or B.  It traverses all entries in the sparse M,</comment>
                <comment type="line">// and (for sparse A or B) does a binary search for entries in</comment>
                <comment type="line">// A or B.  In that case, if M has many entries, the mask M</comment>
                <comment type="line">// should be ignored, and C=A+B should be computed without any</comment>
                <comment type="line">// mask.  The test for when to use M here should ignore A or B</comment>
                <comment type="line">// if they are bitmap or full.</comment>

                <comment type="line">// (+) TODO: if C and M are sparse/hyper, and A and B are</comment>
                <comment type="line">// both bitmap/full, then use GB_emult_04_template instead,</comment>
                <comment type="line">// but with (Ab [p] || Bb [p]) instead of (Ab [p] &amp;&amp; Bb [p]).</comment>

                <comment type="line">// A and B can have any sparsity pattern (hypersparse,</comment>
                <comment type="line">// sparse, bitmap, or full).</comment>

                <for>for <control>( <init>;</init> <condition><expr><name>pM</name> <operator>&lt;</operator> <name>pM_end</name></expr> ;</condition> <incr><expr><name>pM</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// get M(i,j) for A(i,j) + B (i,j)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Mi</name> <index>[<expr><name>pM</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type> <name>mij</name> <init>= <expr><call><name>GB_mcast</name> <argument_list>(<argument><expr><name>Mx</name></expr></argument>, <argument><expr><name>pM</name></expr></argument>, <argument><expr><name>msize</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>mij</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue ;</continue></block_content></block></if></if_stmt>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// get A(i,j)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <decl_stmt><decl><type><name>bool</name></type> <name>afound</name></decl> ;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>adense</name></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// A is dense, bitmap, or full; use quick lookup</comment>
                        <expr_stmt><expr><name>pA</name> <operator>=</operator> <name>pA_start</name> <operator>+</operator> <operator>(</operator><name>i</name> <operator>-</operator> <name>iA_first</name><operator>)</operator></expr> ;</expr_stmt>
                        <expr_stmt><expr><name>afound</name> <operator>=</operator> <call><name>GBB</name> <argument_list>(<argument><expr><name>Ab</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>A</name> <operator>==</operator> <name>M</name></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// A is aliased to M</comment>
                        <expr_stmt><expr><name>pA</name> <operator>=</operator> <name>pM</name></expr> ;</expr_stmt>
                        <expr_stmt><expr><name>afound</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content> 
                        <comment type="line">// A is sparse; use binary search.  This is slow unless</comment>
                        <comment type="line">// M is very sparse compared with A.</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>apright</name> <init>= <expr><name>pA_end</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_BINARY_SEARCH</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>Ai</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>apright</name></expr></argument>, <argument><expr><name>afound</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block></else></if_stmt>

                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><name>afound</name></expr></argument>, <argument><expr><call><name>GBI</name> <argument_list>(<argument><expr><name>Ai</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// get B(i,j)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <decl_stmt><decl><type><name>bool</name></type> <name>bfound</name></decl> ;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>bdense</name></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// B is dense; use quick lookup</comment>
                        <expr_stmt><expr><name>pB</name> <operator>=</operator> <name>pB_start</name> <operator>+</operator> <operator>(</operator><name>i</name> <operator>-</operator> <name>iB_first</name><operator>)</operator></expr> ;</expr_stmt>
                        <expr_stmt><expr><name>bfound</name> <operator>=</operator> <call><name>GBB</name> <argument_list>(<argument><expr><name>Bb</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>B</name> <operator>==</operator> <name>M</name></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// B is aliased to M</comment>
                        <expr_stmt><expr><name>pB</name> <operator>=</operator> <name>pM</name></expr> ;</expr_stmt>
                        <expr_stmt><expr><name>bfound</name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content> 
                        <comment type="line">// B is sparse; use binary search.  This is slow unless</comment>
                        <comment type="line">// M is very sparse compared with B.</comment>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>bpright</name> <init>= <expr><name>pB_end</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_BINARY_SEARCH</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>Bi</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>bpright</name></expr></argument>, <argument><expr><name>bfound</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    </block_content>}</block></else></if_stmt>

                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><name>bfound</name></expr></argument>, <argument><expr><call><name>GBI</name> <argument_list>(<argument><expr><name>Bi</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// C(i,j) = A(i,j) + B(i,j)</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <if_stmt><if>if <condition>(<expr><name>afound</name> <operator>&amp;&amp;</operator> <name>bfound</name></expr>)</condition>
                    <block>{<block_content> 
                        <comment type="line">// C (i,j) = A (i,j) + B (i,j)</comment>
                        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                        <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                        <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                        <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>afound</name></expr>)</condition>
                    <block>{<block_content> 
                        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                        <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                        <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = A(i,j) + beta</comment>
                            <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>beta_scalar</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = A (i,j)</comment>
                            <expr_stmt><expr><call><name>GB_COPY_A_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>bfound</name></expr>)</condition>
                    <block>{<block_content> 
                        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                        <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                        <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = alpha + B(i,j)</comment>
                            <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>alpha_scalar</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = B (i,j)</comment>
                            <expr_stmt><expr><call><name>GB_COPY_B_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        </block_content>}</block>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>

                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_2_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>pC</name> <operator>==</operator> <name>pC_end</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            </block_content>}</block></if>
            <else>else
            <block>{<block_content>

                <comment type="line">//--------------------------------------------------------------</comment>
                <comment type="line">// M is bitmap or full, for either C&lt;M&gt;=A+B or C&lt;!M&gt;=A+B</comment>
                <comment type="line">//--------------------------------------------------------------</comment>

                <comment type="line">//      ------------------------------------------</comment>
                <comment type="line">//      C      &lt;M&gt; =        A       +       B</comment>
                <comment type="line">//      ------------------------------------------</comment>
                <comment type="line">//      sparse  bitmap      sparse          sparse</comment>
                <comment type="line">//      sparse  full        sparse          sparse</comment>

                <comment type="line">//      ------------------------------------------</comment>
                <comment type="line">//      C      &lt;!M&gt; =       A       +       B</comment>
                <comment type="line">//      ------------------------------------------</comment>
                <comment type="line">//      sparse  bitmap      sparse          sparse</comment>
                <comment type="line">//      sparse  full        sparse          sparse</comment>

                <comment type="line">// This method is very efficient for any mask, and should</comment>
                <comment type="line">// always be used if M is bitmap or full, even if the mask must</comment>
                <comment type="line">// also be applied later in GB_mask or GB_accum_mask.</comment>
                <comment type="line">// Exploiting the mask here adds no extra search time, and it</comment>
                <comment type="line">// reduces the size of C on output.</comment>

                <comment type="line">// GB_GET_MIJ: get M(i,j) where M is bitmap or full</comment>
                <cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_GET_MIJ</name></cpp:undef>
                <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_GET_MIJ</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>                                     \
                    <cpp:value>int64_t pM = pM_start + i ;                           \
                    bool mij = GBB (Mb, pM) &amp;&amp; GB_mcast (Mx, pM, msize) ; \
                    if (Mask_comp) mij = !mij ;</cpp:value></cpp:define>

                <comment type="line">// A and B are sparse or hypersparse, not bitmap or full,</comment>
                <comment type="line">// but individual vectors of A and B might have all entries</comment>
                <comment type="line">// present (adense and/or bdense).</comment>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>A_is_sparse</name> <operator>||</operator> <name>A_is_hyper</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>B_is_sparse</name> <operator>||</operator> <name>B_is_hyper</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

                <decl_stmt><decl><type><name>int64_t</name></type> <name>pM_start</name> <init>= <expr><name>j</name> <operator>*</operator> <name>vlen</name></expr></init></decl> ;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>adense</name> <operator>&amp;&amp;</operator> <name>bdense</name></expr>)</condition>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method15: A(:,j) and B(:,j) dense, M bitmap/full</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>ajnz</name> <operator>==</operator> <name>bjnz</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>iA_first</name> <operator>==</operator> <name>iB_first</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>iA_last</name>  <operator>==</operator> <name>iB_last</name></expr></argument> )</argument_list></call></expr> ;</expr_stmt>
                    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>ajnz</name></expr> ;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name>p</name> <operator>+</operator> <name>iA_first</name></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>Ai</name> <index>[<expr><name>pA</name> <operator>+</operator> <name>p</name></expr>]</index></name> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>Bi</name> <index>[<expr><name>pB</name> <operator>+</operator> <name>p</name></expr>]</index></name> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <expr_stmt><expr><call><name>GB_GET_MIJ</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>mij</name></expr>)</condition>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = A (i,j) + B (i,j)</comment>
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                            <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                            <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                            <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name> <operator>+</operator> <name>p</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name> <operator>+</operator> <name>p</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>

                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>ajnz</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method16: A(:,j) is empty, M bitmap/full</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <for>for <control>( <init>;</init> <condition><expr><name>pB</name> <operator>&lt;</operator> <name>pB_end</name></expr> ;</condition> <incr><expr><name>pB</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Bi</name> <index>[<expr><name>pB</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_GET_MIJ</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>mij</name></expr>)</condition>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = B (i,j), or alpha + B(i,j)</comment>
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                            <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                            <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                            <block>{<block_content> 
                                <comment type="line">// C (i,j) = alpha + B(i,j)</comment>
                                <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>alpha_scalar</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <block>{<block_content> 
                                <comment type="line">// C (i,j) = B (i,j)</comment>
                                <expr_stmt><expr><call><name>GB_COPY_B_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>

                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>bjnz</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method17: B(:,j) is empty, M bitmap/full</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <for>for <control>( <init>;</init> <condition><expr><name>pA</name> <operator>&lt;</operator> <name>pA_end</name></expr> ;</condition> <incr><expr><name>pA</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_GET_MIJ</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>mij</name></expr>)</condition>
                        <block>{<block_content> 
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                            <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                            <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                            <block>{<block_content> 
                                <comment type="line">// C (i,j) = A(i,j) + beta</comment>
                                <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>beta_scalar</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <block>{<block_content> 
                                <comment type="line">// C (i,j) = A (i,j)</comment>
                                <expr_stmt><expr><call><name>GB_COPY_A_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>

                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>iA_last</name> <operator>&lt;</operator> <name>iB_first</name></expr>)</condition>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method18:last A(:,j) before 1st B(:,j), M bitmap/full</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <for>for <control>( <init>;</init> <condition><expr><name>pA</name> <operator>&lt;</operator> <name>pA_end</name></expr> ;</condition> <incr><expr><name>pA</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_GET_MIJ</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>mij</name></expr>)</condition>
                        <block>{<block_content> 
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                            <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                            <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                            <block>{<block_content> 
                                <comment type="line">// C (i,j) = A(i,j) + beta</comment>
                                <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>beta_scalar</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <block>{<block_content> 
                                <comment type="line">// C (i,j) = A (i,j)</comment>
                                <expr_stmt><expr><call><name>GB_COPY_A_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>

                    <for>for <control>( <init>;</init> <condition><expr><name>pB</name> <operator>&lt;</operator> <name>pB_end</name></expr> ;</condition> <incr><expr><name>pB</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Bi</name> <index>[<expr><name>pB</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_GET_MIJ</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>mij</name></expr>)</condition>
                        <block>{<block_content> 
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                            <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                            <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                            <block>{<block_content> 
                                <comment type="line">// C (i,j) = alpha + B(i,j)</comment>
                                <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>alpha_scalar</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <block>{<block_content> 
                                <comment type="line">// C (i,j) = B (i,j)</comment>
                                <expr_stmt><expr><call><name>GB_COPY_B_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>

                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>iB_last</name> <operator>&lt;</operator> <name>iA_first</name></expr>)</condition>
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method19:last B(:,j) before 1st A(:,j), M bitmap/full</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <for>for <control>( <init>;</init> <condition><expr><name>pB</name> <operator>&lt;</operator> <name>pB_end</name></expr> ;</condition> <incr><expr><name>pB</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Bi</name> <index>[<expr><name>pB</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_GET_MIJ</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>mij</name></expr>)</condition>
                        <block>{<block_content> 
                            <comment type="line">// C (i,j) = B (i,j), or alpha + B(i,j)</comment>
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                            <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                            <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                            <block>{<block_content> 
                                <comment type="line">// C (i,j) = alpha + B(i,j)</comment>
                                <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>alpha_scalar</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <block>{<block_content> 
                                <comment type="line">// C (i,j) = B (i,j)</comment>
                                <expr_stmt><expr><call><name>GB_COPY_B_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>

                    <for>for <control>( <init>;</init> <condition><expr><name>pA</name> <operator>&lt;</operator> <name>pA_end</name></expr> ;</condition> <incr><expr><name>pA</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_GET_MIJ</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>mij</name></expr>)</condition>
                        <block>{<block_content> 
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                            <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr> ;</expr_stmt>
                            <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                            <block>{<block_content> 
                                <comment type="line">// C (i,j) = A(i,j) + beta</comment>
                                <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>beta_scalar</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <block>{<block_content> 
                                <comment type="line">// C (i,j) = A (i,j)</comment>
                                <expr_stmt><expr><call><name>GB_COPY_A_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>

                </block_content>}</block></if>
                <else>else
                <block>{<block_content>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// Method20: merge A(:,j) and B(:,j), M bitmap/full</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <while>while <condition>(<expr><name>pA</name> <operator>&lt;</operator> <name>pA_end</name> <operator>&amp;&amp;</operator> <name>pB</name> <operator>&lt;</operator> <name>pB_end</name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>iA</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>iB</name> <init>= <expr><name><name>Bi</name> <index>[<expr><name>pB</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>iA</name> <operator>&lt;</operator> <name>iB</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>GB_GET_MIJ</name> <argument_list>(<argument><expr><name>iA</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>mij</name></expr>)</condition>
                            <block>{<block_content> 
                                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                                <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                                <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                                <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>iA</name></expr> ;</expr_stmt>
                                <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                                <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                                <block>{<block_content> 
                                    <comment type="line">// C (iA,j) = A(iA,j) + beta</comment>
                                    <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                    <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>beta_scalar</name></expr></argument>,
                                        <argument><expr><name>iA</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block>
                                <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                                <block>{<block_content> 
                                    <comment type="line">// C (iA,j) = A (iA,j)</comment>
                                    <expr_stmt><expr><call><name>GB_COPY_A_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                </block_content>}</block>
                                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            </block_content>}</block></if></if_stmt>
                            <expr_stmt><expr><name>pA</name><operator>++</operator></expr> ;</expr_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><name>iA</name> <operator>&gt;</operator> <name>iB</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>GB_GET_MIJ</name> <argument_list>(<argument><expr><name>iB</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>mij</name></expr>)</condition>
                            <block>{<block_content> 
                                <comment type="line">// C (iB,j) = B (iB,j), or alpha + B(iB,j)</comment>
                                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                                <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                                <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                                <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>iB</name></expr> ;</expr_stmt>
                                <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                                <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                                <block>{<block_content> 
                                    <comment type="line">// C (iB,j) = alpha + B(iB,j)</comment>
                                    <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                    <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>alpha_scalar</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>,
                                        <argument><expr><name>iB</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                </block_content>}</block>
                                <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                                <block>{<block_content> 
                                    <comment type="line">// C (iB,j) = B (iB,j)</comment>
                                    <expr_stmt><expr><call><name>GB_COPY_B_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                </block_content>}</block>
                                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            </block_content>}</block></if></if_stmt>
                            <expr_stmt><expr><name>pB</name><operator>++</operator></expr> ;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>GB_GET_MIJ</name> <argument_list>(<argument><expr><name>iB</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>mij</name></expr>)</condition>
                            <block>{<block_content> 
                                <comment type="line">// C (i,j) = A (i,j) + B (i,j)</comment>
                                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                                <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                                <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                                <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>iB</name></expr> ;</expr_stmt>
                                <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                                <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>, <argument><expr><name>iB</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            </block_content>}</block></if></if_stmt>
                            <expr_stmt><expr><name>pA</name><operator>++</operator></expr> ;</expr_stmt>
                            <expr_stmt><expr><name>pB</name><operator>++</operator></expr> ;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></while>

                    <comment type="line">//----------------------------------------------------------</comment>
                    <comment type="line">// A (:,j) or B (:,j) have entries left; not both</comment>
                    <comment type="line">//----------------------------------------------------------</comment>

                    <for>for <control>( <init>;</init> <condition><expr><name>pA</name> <operator>&lt;</operator> <name>pA_end</name></expr> ;</condition> <incr><expr><name>pA</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>iA</name> <init>= <expr><name><name>Ai</name> <index>[<expr><name>pA</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_GET_MIJ</name> <argument_list>(<argument><expr><name>iA</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>mij</name></expr>)</condition>
                        <block>{<block_content> 
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                            <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>iA</name></expr> ;</expr_stmt>
                            <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                            <block>{<block_content> 
                                <comment type="line">// C (iA,j) = A(iA,j) + beta</comment>
                                <expr_stmt><expr><call><name>GB_LOAD_A</name> <argument_list>(<argument><expr><name>aij</name></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aij</name></expr></argument>, <argument><expr><name>beta_scalar</name></expr></argument>, <argument><expr><name>iA</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <block>{<block_content> 
                                <comment type="line">// C (iA,j) = A (iA,j)</comment>
                                <expr_stmt><expr><call><name>GB_COPY_A_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Ax</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>A_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>

                    <for>for <control>( <init>;</init> <condition><expr><name>pB</name> <operator>&lt;</operator> <name>pB_end</name></expr> ;</condition> <incr><expr><name>pB</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int64_t</name></type> <name>iB</name> <init>= <expr><name><name>Bi</name> <index>[<expr><name>pB</name></expr>]</index></name></expr></init></decl> ;</decl_stmt>
                        <expr_stmt><expr><call><name>GB_GET_MIJ</name> <argument_list>(<argument><expr><name>iB</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>mij</name></expr>)</condition>
                        <block>{<block_content> 
                            <comment type="line">// C (iB,j) = B (iB,j), or alpha + B(iB,j)</comment>
                            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
                            <expr_stmt><expr><name>cjnz</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <expr_stmt><expr><name><name>Ci</name> <index>[<expr><name>pC</name></expr>]</index></name> <operator>=</operator> <name>iB</name></expr> ;</expr_stmt>
                            <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GB_ISO_ADD</name></cpp:ifndef>
                            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GB_EWISEUNION</name></cpp:ifdef>
                            <block>{<block_content> 
                                <comment type="line">// C (iB,j) = alpha + B(iB,j)</comment>
                                <expr_stmt><expr><call><name>GB_LOAD_B</name> <argument_list>(<argument><expr><name>bij</name></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                                <expr_stmt><expr><call><name>GB_BINOP</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>alpha_scalar</name></expr></argument>, <argument><expr><name>bij</name></expr></argument>,
                                    <argument><expr><name>iB</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block>
                            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <block>{<block_content> 
                                <comment type="line">// C (iB,j) = B (iB,j)</comment>
                                <expr_stmt><expr><call><name>GB_COPY_B_TO_C</name> <argument_list>(<argument><expr><call><name>GB_CX</name> <argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Bx</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>B_iso</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                            </block_content>}</block>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <expr_stmt><expr><name>pC</name><operator>++</operator></expr> ;</expr_stmt>
                            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="line">//------------------------------------------------------------------</comment>
            <comment type="line">// final count of nnz (C (:,j))</comment>
            <comment type="line">//------------------------------------------------------------------</comment>

            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>GB_PHASE_1_OF_2</name></expr></argument> )</argument_list></call></expr></cpp:if>
            <if_stmt><if>if <condition>(<expr><name>fine_task</name></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><name><name>TaskList</name> <index>[<expr><name>taskid</name></expr>]</index></name><operator>.</operator><name>pC</name> <operator>=</operator> <name>cjnz</name></expr> ;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content> 
                <expr_stmt><expr><name><name>Cp</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>cjnz</name></expr> ;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></for>
    </block_content>}</block></for>
</block_content>}</block>

</unit>
