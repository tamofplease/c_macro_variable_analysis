<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_subassigner.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_subassigner: C(I,J)&lt;#M&gt; = accum (C(I,J), A)</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// Submatrix assignment: C(I,J)&lt;M&gt; = A, or accum (C (I,J), A), no transpose</comment>

<comment type="line">// All assignment operations rely on this function, including the GrB_*_assign</comment>
<comment type="line">// operations in the spec, and the GxB_*_subassign operations that are a</comment>
<comment type="line">// SuiteSparse:GraphBLAS extension to the spec:</comment>

<comment type="line">// GrB_Matrix_assign,</comment>
<comment type="line">// GrB_Matrix_assign_TYPE,</comment>
<comment type="line">// GrB_Vector_assign,</comment>
<comment type="line">// GrB_Vector_assign_TYPE,</comment>
<comment type="line">// GrB_Row_assign,</comment>
<comment type="line">// GrB_Col_assign</comment>

<comment type="line">// GxB_Matrix_subassign,</comment>
<comment type="line">// GxB_Matrix_subassign_TYPE,</comment>
<comment type="line">// GxB_Vector_subassign,</comment>
<comment type="line">// GxB_Vector_subassign_TYPE,</comment>
<comment type="line">// GxB_Row_subassign,</comment>
<comment type="line">// GxB_Col_subassign</comment>

<comment type="line">// This function handles the accumulator, and the mask M, and the C_replace</comment>
<comment type="line">// option itself, without relying on GB_accum_mask or GB_mask.  The mask M has</comment>
<comment type="line">// the same size as C(I,J) and A.  M(0,0) governs how A(0,0) is assigned</comment>
<comment type="line">// into C(I[0],J[0]).  This is how GxB_subassign operates.  For GrB_assign, the</comment>
<comment type="line">// mask M in this function is the SubMask, constructed via SubMask=M(I,J).</comment>

<comment type="line">// No transposed case is handled.  This function is also agnostic about the</comment>
<comment type="line">// CSR/CSC format of C, A, and M.  The A matrix must have A-&gt;vlen == nI and</comment>
<comment type="line">// A-&gt;vdim == nJ (except for scalar expansion, in which case A is NULL).  The</comment>
<comment type="line">// mask M must be the same size as A, if present.</comment>

<comment type="line">// Any or all of the C, M, and/or A matrices may be hypersparse or standard</comment>
<comment type="line">// non-hypersparse.  Some methods can operate on full and/or bitmap matrices;</comment>
<comment type="line">// see GB_subassigner_method, which checks these conditions.</comment>

<comment type="line">// C is operated on in-place and thus cannot be aliased with the inputs A or M.</comment>

<comment type="line">// Since the pattern of C isn't reallocated here, and entries do not move in</comment>
<comment type="line">// position, C-&gt;p, C-&gt;h, C-&gt;nvec, and C-&gt;nvec_nonempty are not modified.  C-&gt;x</comment>
<comment type="line">// and C-&gt;i can be modified, but only one entry at a time.  No entries are</comment>
<comment type="line">// shifted.  C-&gt;i can be changed by turning an entry into a zombie, or by</comment>
<comment type="line">// bringing a zombie back to life, but no entry in C-&gt;i moves in position, and</comment>
<comment type="line">// the underlying indices in C-&gt;i do not change otherwise.  C-&gt;b can be</comment>
<comment type="line">// modified for a C bitmap.</comment>

<comment type="line">// C-&gt;x and C-&gt;iso have already been computed if C is iso on output, by</comment>
<comment type="line">// GB_assign_prep, so if C-&gt;iso is true, there is no numeric work to do.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_subassign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_subassign_methods.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_dense.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_bitmap_assign.h"</cpp:file></cpp:include>

<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>GB_FREE_ALL</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_ALL</name></cpp:macro> <cpp:value>GB_phybix_free (C) ;</cpp:value></cpp:define>

<function><type><name>GrB_Info</name></type> <name>GB_subassigner</name>             <comment type="line">// C(I,J)&lt;#M&gt; = A or accum (C (I,J), A)</comment>
<parameter_list>(
    <comment type="line">// input/output</comment>
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,                   <comment type="line">// input/output matrix for results</comment>
    <comment type="line">// input</comment>
    <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>subassign_method</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>C_replace</name></decl></parameter>,           <comment type="line">// C matrix descriptor</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>M</name></decl></parameter>,             <comment type="line">// optional mask for C(I,J), unused if NULL</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_comp</name></decl></parameter>,           <comment type="line">// mask descriptor</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_struct</name></decl></parameter>,         <comment type="line">// if true, use the only structure of M</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_BinaryOp</name></type> <name>accum</name></decl></parameter>,       <comment type="line">// optional accum for Z=accum(C(I,J),A)</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,             <comment type="line">// input matrix (NULL for scalar expansion)</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Index</name> <modifier>*</modifier></type><name>I</name></decl></parameter>,             <comment type="line">// list of indices</comment>
    <parameter><decl><type><specifier>const</specifier> <name>int64_t</name></type>   <name>ni</name></decl></parameter>,             <comment type="line">// number of indices</comment>
    <parameter><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>nI</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>Ikind</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name><name>Icolon</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Index</name> <modifier>*</modifier></type><name>J</name></decl></parameter>,             <comment type="line">// list of vector indices</comment>
    <parameter><decl><type><specifier>const</specifier> <name>int64_t</name></type>   <name>nj</name></decl></parameter>,             <comment type="line">// number of column indices</comment>
    <parameter><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>nJ</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>Jkind</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name><name>Jcolon</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>scalar_expansion</name></decl></parameter>,    <comment type="line">// if true, expand scalar to A</comment>
    <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>scalar</name></decl></parameter>,             <comment type="line">// scalar to be expanded</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Type</name></type> <name>atype</name></decl></parameter>,           <comment type="line">// type code of scalar to expand</comment>
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C input for subassigner"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// methods that rely on C and A being dense assume they are not jumbled</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_PENDING</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><operator>!</operator><call><name>GB_ZOMBIES</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>GB_is_dense</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// methods that rely on A being dense assume A is not jumbled</comment>
        <expr_stmt><expr><call><name>GB_MATRIX_WAIT_IF_JUMBLED</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>GB_is_dense</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GB_PENDING_OR_ZOMBIES</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GB_IS_BITMAP</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// C is dense or full</comment>
        <expr_stmt><expr><call><name>GB_MATRIX_WAIT_IF_JUMBLED</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(pending: "</literal> <name>GBd</name> <literal type="string">") "</literal></expr></argument>, <argument><expr><call><name>GB_Pending_n</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//==========================================================================</comment>
    <comment type="line">// submatrix assignment C(I,J)&lt;M&gt; = accum (C(I,J),A): meta-algorithm</comment>
    <comment type="line">//==========================================================================</comment>

    <comment type="line">// There are up to 128 combinations of options, but not all must be</comment>
    <comment type="line">// implemented, because they are either identical to another method</comment>
    <comment type="line">// (C_replace is effectively false if M=NULL and Mask_comp=false), or they</comment>
    <comment type="line">// are not used (the last option, whether or not S is constructed, is</comment>
    <comment type="line">// determined here; it is not a user input).  The first 5 options are</comment>
    <comment type="line">// determined by the input.  The table below has been pruned to remove</comment>
    <comment type="line">// combinations that are not used, or equivalent to other entries in the</comment>
    <comment type="line">// table.  Only 22 unique combinations of the 128 combinations are needed,</comment>
    <comment type="line">// with additional special cases when C(:,:) is dense.</comment>

    <comment type="line">//      M           present or NULL</comment>
    <comment type="line">//      Mask_comp   true or false</comment>
    <comment type="line">//      Mask_struct structural or valued mask</comment>
    <comment type="line">//      C_replace   true or false</comment>
    <comment type="line">//      accum       present or NULL</comment>
    <comment type="line">//      A           scalar (x) or matrix (A)</comment>
    <comment type="line">//      S           constructed or not </comment>

    <comment type="line">// C(I,J)&lt;(M,comp,repl)&gt; ( = , += ) (A, scalar), (with or without S);</comment>
    <comment type="line">// I and J can be anything for any of these methods (":", colon, or list).</comment>

    <comment type="line">// See the "No work to do..." comment above:</comment>
    <comment type="line">// If M is not present, Mask_comp true, C_replace false: no work to do.</comment>
    <comment type="line">// If M is not present, Mask_comp true, C_replace true: use Method 00</comment>
    <comment type="line">// If M is not present, Mask_comp false:  C_replace is now false.</comment>

        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   cmp rpl acc A   S       method: action</comment>
        <comment type="line">//  =====================       ==============</comment>

        <comment type="line">//  -   -   x   -   -   -       21:  C = x, no S, C anything</comment>
        <comment type="line">//  -   -   x   -   A   -       24:  C = A, no S, C and A anything</comment>
        <comment type="line">//  -   -   -   +   -   -       22:  C += x, no S, C dense</comment>
        <comment type="line">//  -   -   -   +   A   -       23:  C += A, no S, C dense</comment>

        <comment type="line">//  -   -   -   -   -   S       01:  C(I,J) = x, with S</comment>
        <comment type="line">//  -   -   -   -   A   S       02:  C(I,J) = A, with S</comment>
        <comment type="line">//  -   -   -   +   -   S       03:  C(I,J) += x, with S</comment>
        <comment type="line">//  -   -   -   +   A   S       04:  C(I,J) += A, with S</comment>
        <comment type="line">//  -   -   r                        uses methods 01, 02, 03, 04</comment>
        <comment type="line">//  -   c   -                        no work to do</comment>
        <comment type="line">//  -   c   r           S       00:  C(I,J)&lt;!,repl&gt; = empty, with S</comment>

        <comment type="line">//  M   -   -   -   -   -       05d: C&lt;M&gt; = x, no S, C dense</comment>
        <comment type="line">//  M   -   -   -   -   -       05e: C&lt;M,s&gt; = x, no S, C empty</comment>
        <comment type="line">//  M   -   -   -   -   -       05f: C&lt;C,s&gt; = x, no S, C == M</comment>
        <comment type="line">//  M   -   -   -   -   -       05:  C(I,J)&lt;M&gt; = x, no S</comment>
        <comment type="line">//  A   -   -   -   A   -       06d: C&lt;A&gt; = A, no S, C dense</comment>
        <comment type="line">//  M   -   -   -   A   -       25:  C&lt;M,s&gt; = A, A dense, C empty</comment>
        <comment type="line">//  M   -   -   -   A   -       06n: C(I,J)&lt;M&gt; = A, no S</comment>
        <comment type="line">//  M   -   -   -   A   S       06s: C(I,J)&lt;M&gt; = A, with S</comment>
        <comment type="line">//  M   -   -   +   -   -       07:  C(I,J)&lt;M&gt; += x, no S</comment>
        <comment type="line">//  M   -   -   +   A   -       08n: C(I,J)&lt;M&gt; += A, no S</comment>
        <comment type="line">//  M   -   -   +   A   -       08s: C(I,J)&lt;M&gt; += A, with S</comment>
        <comment type="line">//  M   -   r   -   -   S       09:  C(I,J)&lt;M,repl&gt; = x, with S</comment>
        <comment type="line">//  M   -   r   -   A   S       10:  C(I,J)&lt;M,repl&gt; = A, with S</comment>
        <comment type="line">//  M   -   r   +   -   S       11:  C(I,J)&lt;M,repl&gt; += x, with S</comment>
        <comment type="line">//  M   -   r   +   A   S       12:  C(I,J)&lt;M,repl&gt; += A, with S</comment>

        <comment type="line">//  M   c   -   -   -   S       13:  C(I,J)&lt;!M&gt; = x, with S</comment>
        <comment type="line">//  M   c   -   -   A   S       14:  C(I,J)&lt;!M&gt; = A, with S</comment>
        <comment type="line">//  M   c   -   +   -   S       15:  C(I,J)&lt;!M&gt; += x, with S</comment>
        <comment type="line">//  M   c   -   +   A   S       16:  C(I,J)&lt;!M&gt; += A, with S</comment>
        <comment type="line">//  M   c   r   -   -   S       17:  C(I,J)&lt;!M,repl&gt; = x, with S</comment>
        <comment type="line">//  M   c   r   -   A   S       18:  C(I,J)&lt;!M,repl&gt; = A, with S</comment>
        <comment type="line">//  M   c   r   +   -   S       19:  C(I,J)&lt;!M,repl&gt; += x, with S</comment>
        <comment type="line">//  M   c   r   +   A   S       20:  C(I,J)&lt;!M,repl&gt; += A, with S</comment>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// FUTURE::: 8 simpler cases when I and J are ":" (S not needed):</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">// These methods could all tolerate C==M and C==A aliasing, assuming no</comment>
        <comment type="line">// binary search or if the binary search of C==M or C==A can be done</comment>
        <comment type="line">// with atomics.  These are all the methods used by GB_accum_mask.</comment>

        <comment type="line">//  M   -   -   -   A   ?       06x: C(:,:)&lt;M&gt; = A</comment>
        <comment type="line">//  M   -   -   +   A   ?       08x: C(:,:)&lt;M&gt; += A</comment>
        <comment type="line">//  M   -   r   -   A   ?       10x: C(:,:)&lt;M,repl&gt; = A</comment>
        <comment type="line">//  M   -   r   +   A   ?       12x: C(:,:)&lt;M,repl&gt; += A</comment>
        <comment type="line">//  M   c   -   -   A   ?       14x: C(:,:)&lt;!M&gt; = A</comment>
        <comment type="line">//  M   c   -   +   A   ?       16x: C(:,:)&lt;!M&gt; += A</comment>
        <comment type="line">//  M   c   r   -   A   ?       18x: C(:,:)&lt;!M,repl&gt; = A</comment>
        <comment type="line">//  M   c   r   +   A   ?       20x: C(:,:)&lt;!M,repl&gt; += A</comment>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// FUTURE::: C&lt;C,s&gt; += x   C == M, update all values, C_replace ignored</comment>
        <comment type="line">// FUTURE::: C&lt;C,s&gt; = A    C == M, A dense, C_replace ignored</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

    <comment type="line">// For the single case C(I,J)&lt;M&gt;=A, two methods can be used: 06n and 06s.</comment>

    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Istring</name></cpp:macro> <cpp:value>((Ikind == GB_ALL) ? ":" : "I")</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Jstring</name></cpp:macro> <cpp:value>((Jkind == GB_ALL) ? ":" : "J")</cpp:value></cpp:define>

    <switch>switch <condition>(<expr><name>subassign_method</name></expr>)</condition>
    <block>{<block_content>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// matrix or scalar subassign via GB_bitmap_assign</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_BITMAP</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// C is bitmap, or is converted to bitmap.  M and A can have any</comment>
            <comment type="line">// sparsity (if present).</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method: bitmap_subassign "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_bitmap_assign</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>C_replace</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>,
                <argument><expr><name>GB_SUBASSIGN</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C = x where x is a scalar; C becomes full</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_21</name></expr> :</case> 
        <block>{<block_content>

            <comment type="line">//  =====================       ==============</comment>
            <comment type="line">//  M   cmp rpl acc A   S       method: action</comment>
            <comment type="line">//  =====================       ==============</comment>

            <comment type="line">//  -   -   x   -   -   -       21:  C = x, no S, C anything</comment>

            <comment type="line">// Method 21: C = x where x is a scalar; C becomes full</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 21: (C full) = scalar "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>iso</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_convert_any_to_full</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C = A</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_24</name></expr> :</case> 
        <block>{<block_content>

            <comment type="line">//  =====================       ==============</comment>
            <comment type="line">//  M   cmp rpl acc A   S       method: action</comment>
            <comment type="line">//  =====================       ==============</comment>

            <comment type="line">//  -   -   x   -   A   -       24:  C = A, no S, C and A anything</comment>

            <comment type="line">// Method 24: C = A</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 24: C = Z "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_24</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C += A or x where C is dense or full (and becomes full)</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   cmp rpl acc A   S       method: action</comment>
        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  -   -   -   +   -   -       22:  C += x, no S, C dense</comment>
        <comment type="line">//  -   -   -   +   A   -       23:  C += A, no S, C dense</comment>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_22</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 22: C(:,:) += x where C is dense or full</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 22: (C full) += scalar "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_dense_subassign_22</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_23</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 23: C(:,:) += A where C is dense or full</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 23: (C full) += Z "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_dense_subassign_23</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C(I,J)&lt;M&gt; = scalar or +=scalar</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   cmp rpl acc A   S       method: action</comment>
        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   -   -   -   -   -       05d: C(:,:)&lt;M&gt; = x, no S, C dense</comment>
        <comment type="line">//  M   -   -   -   -   -       05e: C(:,:)&lt;M,s&gt; = x, no S, C empty</comment>
        <comment type="line">//  M   -   -   -   -   -       05f: C(:,:)&lt;C,s&gt; = x, no S, C == M</comment>
        <comment type="line">//  M   -   -   -   -   -       05:  C(I,J)&lt;M&gt; = x, no S</comment>
        <comment type="line">//  M   -   -   +   -   -       07:  C(I,J)&lt;M&gt; += x, no S</comment>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_05f</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 05f: C(:,:)&lt;C,s&gt; = scalar ; no S; C == M, M structural</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 05f: C&lt;C,struct&gt; = scalar "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <comment type="line">// no more work to do; all work has been done by GB_assign_prep</comment>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_05e</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 05e: C(:,:)&lt;M&gt; = scalar ; no S; C empty, M structural</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 05e: (C empty)&lt;M,struct&gt; = scalar "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_05e</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_05d</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 05d: C(:,:)&lt;M&gt; = scalar ; no S; C is dense or full;</comment>
            <comment type="line">// C becomes full.</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 05d: (C full)&lt;M&gt; = scalar "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_dense_subassign_05d</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_05</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 05: C(I,J)&lt;M&gt; = scalar ; no S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 05: C(%s,%s)&lt;M&gt; = scalar ; no S "</literal></expr></argument>,
                <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_05</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_07</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 07: C(I,J)&lt;M&gt; += scalar ; no S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 07: C(%s,%s)&lt;M&gt; += scalar ; no S "</literal></expr></argument>,
                <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_07</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C(I,J)&lt;M&gt; = A or += A</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   cmp rpl acc A   S       method: action</comment>
        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   -   -   +   A   -       08n: C(I,J)&lt;M&gt; += A, no S</comment>
        <comment type="line">//  M   -   -   +   A   -       08s: C(I,J)&lt;M&gt; += A, with S</comment>
        <comment type="line">//  A   -   -   -   A   -       06d: C&lt;A&gt; = A, no S, C dense</comment>
        <comment type="line">//  M   -   x   -   A   -       25:  C&lt;M,s&gt; = A, A dense, C empty</comment>
        <comment type="line">//  M   -   -   -   A   -       06n: C(I,J)&lt;M&gt; = A, no S</comment>
        <comment type="line">//  M   -   -   -   A   S       06s: C(I,J)&lt;M&gt; = A, with S</comment>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_08n</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 08n: C(I,J)&lt;M&gt; += A ; no S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 08n: C(%s,%s)&lt;M&gt; += Z ; no S "</literal></expr></argument>, <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_08n</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_08s</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 08s: C(I,J)&lt;M&gt; += A ; with S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 08s: C(%s,%s)&lt;M&gt; += Z ; with S "</literal></expr></argument>,
                <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_08s_and_16</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_06d</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 06d: C(:,:)&lt;A&gt; = A ; no S, C dense or full;</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 06d: (C full)&lt;Z&gt; = Z "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_dense_subassign_06d</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_25</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 25:  C&lt;M,struct&gt; = A, A dense, C empty</comment>
            <comment type="line">// A is dense or full; remains unchanged</comment>
            <comment type="line">// C is iso if A is so</comment>
            <expr_stmt><expr><call><name>GB_BURBLE_DENSE</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"Method 25: (C empty)&lt;M&gt; = (Z %s) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_dense_subassign_25</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_06n</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 06n: C(I,J)&lt;M&gt; = A ; no S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 06n: C(%s,%s)&lt;M&gt; = Z ; no S "</literal></expr></argument>, <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_06n</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_06s</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 06s: C(I,J)&lt;M&gt; = A ; using S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 06s: C(%s,%s)&lt;M&gt; = Z ; using S "</literal></expr></argument>,
                <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_06s_and_14</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// assignment using S_Extraction method, no mask M</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   cmp rpl acc A   S       method: action</comment>
        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  -   -   -   -   -   S       01:  C(I,J) = x, with S</comment>
        <comment type="line">//  -   -   -   -   A   S       02:  C(I,J) = A, with S</comment>
        <comment type="line">//  -   -   -   +   -   S       03:  C(I,J) += x, with S</comment>
        <comment type="line">//  -   -   -   +   A   S       04:  C(I,J) += A, with S</comment>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_01</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 01: C(I,J) = scalar ; using S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 01: C(%s,%s) = scalar ; using S "</literal></expr></argument>,
                <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_01</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_03</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 03: C(I,J) += scalar ; using S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 03: C(%s,%s) += scalar ; using S "</literal></expr></argument>,
                <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_03</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_02</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 02: C(I,J) = A ; using S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 02: C(%s,%s) = Z ; using S "</literal></expr></argument>,
                <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_02</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_04</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 04: C(I,J) += A ; using S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 04: C(%s,%s) += Z ; using S "</literal></expr></argument>, <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_04</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <comment type="line">//----------------------------------------------------------------------</comment>
        <comment type="line">// C(I,J)&lt;#M&gt; = scalar or += scalar ; using S</comment>
        <comment type="line">//----------------------------------------------------------------------</comment>

        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   cmp rpl acc A   S       method: action</comment>
        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   -   r   -   -   S       09:  C(I,J)&lt;M,repl&gt; = x, with S</comment>
        <comment type="line">//  M   -   r   +   -   S       11:  C(I,J)&lt;M,repl&gt; += x, with S</comment>
        <comment type="line">//  M   c   -   -   -   S       13:  C(I,J)&lt;!M&gt; = x, with S</comment>
        <comment type="line">//  M   c   -   +   -   S       15:  C(I,J)&lt;!M&gt; += x, with S</comment>
        <comment type="line">//  M   c   r   -   -   S       17:  C(I,J)&lt;!M,repl&gt; = x, with S</comment>
        <comment type="line">//  M   c   r   +   -   S       19:  C(I,J)&lt;!M,repl&gt; += x, with S</comment>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_17</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 17: C(I,J)&lt;!M,repl&gt; = scalar ; using S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 17: C(%s,%s)&lt;!M,repl&gt; = scalar ; using S "</literal></expr></argument>,
                <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_17</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_13</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 13: C(I,J)&lt;!M&gt; = scalar ; using S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 13: C(%s,%s)&lt;!M&gt; = scalar ; using S "</literal></expr></argument>,
                <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_13</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_09</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 09: C(I,J)&lt;M,repl&gt; = scalar ; using S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 09: C(%s,%s)&lt;M,repl&gt; = scalar ; using S "</literal></expr></argument>,
                <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_09</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_19</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 19: C(I,J)&lt;!M,repl&gt; += scalar ; using S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 19: C(%s,%s)&lt;!M,repl&gt; += scalar ; using S "</literal></expr></argument>,
                <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_19</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_15</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 15: C(I,J)&lt;!M&gt; += scalar ; using S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 15: C(%s,%s)&lt;!M&gt; += scalar ; using S "</literal></expr></argument>,
                <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_15</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_11</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 11: C(I,J)&lt;M,repl&gt; += scalar ; using S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 11: C(%s,%s)&lt;M,repl&gt; += scalar ; using S "</literal></expr></argument>,
                <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_11</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <comment type="line">//------------------------------------------------------------------</comment>
        <comment type="line">// C(I,J)&lt;#M&gt; = A or += A ; using S</comment>
        <comment type="line">//------------------------------------------------------------------</comment>

        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   cmp rpl acc A   S       method: action</comment>
        <comment type="line">//  =====================       ==============</comment>
        <comment type="line">//  M   -   r   -   A   S       10:  C(I,J)&lt;M,repl&gt; = A, with S</comment>
        <comment type="line">//  M   -   r   +   A   S       12:  C(I,J)&lt;M,repl&gt; += A, with S</comment>
        <comment type="line">//  M   c   -   -   A   S       14:  C(I,J)&lt;!M&gt; = A, with S</comment>
        <comment type="line">//  M   c   -   +   A   S       16:  C(I,J)&lt;!M&gt; += A, with S</comment>
        <comment type="line">//  M   c   r   -   A   S       18:  C(I,J)&lt;!M,repl&gt; = A, with S</comment>
        <comment type="line">//  M   c   r   +   A   S       20:  C(I,J)&lt;!M,repl&gt; += A, with S</comment>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_18</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 18: C(I,J)&lt;!M,repl&gt; = A ; using S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 18: C(%s,%s)&lt;!M,repl&gt; = Z ; using S "</literal></expr></argument>,
                <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_10_and_18</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_14</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 14: C(I,J)&lt;!M&gt; = A ; using S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 14: C(%s,%s)&lt;!M&gt; = Z ; using S "</literal></expr></argument>,
                <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_06s_and_14</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_10</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 10: C(I,J)&lt;M,repl&gt; = A ; using S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 10: C(%s,%s)&lt;M,repl&gt; = Z ; using S "</literal></expr></argument>,
                <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_10_and_18</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_20</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 20: C(I,J)&lt;!M,repl&gt; += A ; using S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 20: C(%s,%s)&lt;!M,repl&gt; += Z ; using S "</literal></expr></argument>,
                <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_12_and_20</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_16</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 16: C(I,J)&lt;!M&gt; += A ; using S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 16: C(%s,%s)&lt;!M&gt; += Z ; using S "</literal></expr></argument>,
                <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_08s_and_16</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <case>case <expr><name>GB_SUBASSIGN_METHOD_12</name></expr> :</case> 
        <block>{<block_content>
            <comment type="line">// Method 12: C(I,J)&lt;M,repl&gt; += A ; using S</comment>
            <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"Method 12: C(%s,%s)&lt;M,repl&gt; += Z ; using S "</literal></expr></argument>,
                <argument><expr><name>Istring</name></expr></argument>, <argument><expr><name>Jstring</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_subassign_12_and_20</name> <argument_list>(<argument><expr><name>C</name></expr></argument>,
                <argument><expr><name>I</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>nI</name></expr></argument>, <argument><expr><name>Ikind</name></expr></argument>, <argument><expr><name>Icolon</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>nj</name></expr></argument>, <argument><expr><name>nJ</name></expr></argument>, <argument><expr><name>Jkind</name></expr></argument>, <argument><expr><name>Jcolon</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block>
        <break>break ;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>GB_DEAD_CODE</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></switch>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// finalize C and return result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C subassigner result"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <return>return <expr><operator>(</operator><call><name>GB_block</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
