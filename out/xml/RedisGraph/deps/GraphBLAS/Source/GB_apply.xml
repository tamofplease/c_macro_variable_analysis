<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_apply.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_apply: apply a unary operator; optionally transpose a matrix</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// C&lt;M&gt; = accum (C, op(A)) or accum (C, op(A)')</comment>

<comment type="line">// GB_apply does the work for GrB_*_apply, including the binary op variants.</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_ALL</name></cpp:macro> <cpp:value>;</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_apply.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_binop.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_transpose.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_accum_mask.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_scalar.h"</cpp:file></cpp:include>

<function><type><name>GrB_Info</name></type> <name>GB_apply</name>                   <comment type="line">// C&lt;M&gt; = accum (C, op(A)) or op(A')</comment>
<parameter_list>(
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,                   <comment type="line">// input/output matrix for results</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>C_replace</name></decl></parameter>,           <comment type="line">// C descriptor</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>M</name></decl></parameter>,             <comment type="line">// optional mask for C, unused if NULL</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_comp</name></decl></parameter>,           <comment type="line">// M descriptor</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_struct</name></decl></parameter>,         <comment type="line">// if true, use the only structure of M</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_BinaryOp</name></type> <name>accum</name></decl></parameter>,       <comment type="line">// optional accum for Z=accum(C,T)</comment>
        <parameter><decl><type><specifier>const</specifier> <name>GB_Operator</name></type> <name>op_in</name></decl></parameter>,        <comment type="line">// unary/idxunop/binop to apply</comment>
        <parameter><decl><type><specifier>const</specifier> <name>GrB_Scalar</name></type> <name>scalar_in</name></decl></parameter>,     <comment type="line">// scalar to bind to binop, or thunk</comment>
        <parameter><decl><type><name>bool</name></type> <name>binop_bind1st</name></decl></parameter>,             <comment type="line">// if true, binop(x,A) else binop(A,y)</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,             <comment type="line">// first or 2nd input:  matrix A</comment>
    <parameter><decl><type><name>bool</name></type> <name>A_transpose</name></decl></parameter>,               <comment type="line">// A matrix descriptor</comment>
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// C may be aliased with M and/or A</comment>

    <decl_stmt><decl><type><name><name>struct</name> <name>GB_Matrix_opaque</name></name></type> <name>T_header</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Matrix</name></type> <name>T</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>

    <expr_stmt><expr><call><name>GB_RETURN_IF_FAULTY_OR_POSITIONAL</name> <argument_list>(<argument><expr><name>accum</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_RETURN_IF_NULL_OR_FAULTY</name> <argument_list>(<argument><expr><name>op_in</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C input for GB_apply"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK_OR_NULL</name> <argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><literal type="string">"M for GB_apply"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_BINARYOP_OK_OR_NULL</name> <argument_list>(<argument><expr><name>accum</name></expr></argument>, <argument><expr><literal type="string">"accum for GB_apply"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"A input for GB_apply"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_OP_OK</name> <argument_list>(<argument><expr><name>op_in</name></expr></argument>, <argument><expr><literal type="string">"op for GB_apply"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <decl_stmt><decl><type><name>GB_Operator</name></type> <name>op</name> <init>= <expr><name>op_in</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GB_Opcode</name></type> <name>opcode</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>opcode</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Type</name></type> <name>T_type</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>ztype</name></name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>GrB_Scalar</name></type> <name>scalar</name> <init>= <expr><operator>(</operator><name>GrB_Scalar</name><operator>)</operator> <name>scalar_in</name></expr></init></decl> ;</decl_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>op_is_unop</name> <init>= <expr><call><name>GB_IS_UNARYOP_CODE</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>op_is_binop</name> <init>= <expr><call><name>GB_IS_BINARYOP_CODE</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>op_is_idxunop</name> <init>= <expr><call><name>GB_IS_INDEXUNARYOP_CODE</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>op_is_positional</name> <init>= <expr><call><name>GB_OPCODE_IS_POSITIONAL</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>GB_Scalar_opaque</name></name></type> <name>Thunk_header</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>ithunk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>op_is_unop</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// apply a unary operator: scalar is ignored</comment>
        <expr_stmt><expr><call><name>ASSERT_UNARYOP_OK</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"unop for GB_apply"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>op_is_positional</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// A must also be compatible with op-&gt;xtype</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>xtype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content> 
                <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DOMAIN_MISMATCH</name></expr></argument>,
                    <argument><expr><literal type="string">"Incompatible type for z=%s(x):\n"</literal>
                    <literal type="string">"input A of type [%s]\n"</literal>
                    <literal type="string">"cannot be typecast to x input of type [%s]"</literal></expr></argument>,
                    <argument><expr><name><name>op</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>xtype</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>op_is_binop</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// apply a binary operator, with one input bound to a scalar</comment>
        <expr_stmt><expr><call><name>ASSERT_BINARYOP_OK</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"binop for GB_apply"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT_SCALAR_OK</name> <argument_list>(<argument><expr><name>scalar</name></expr></argument>, <argument><expr><literal type="string">"scalar for GB_apply"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>op_is_positional</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type> <name>op_is_first</name>  <init>= <expr><name>opcode</name> <operator>==</operator> <name>GB_FIRST_binop_code</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>op_is_second</name> <init>= <expr><name>opcode</name> <operator>==</operator> <name>GB_SECOND_binop_code</name></expr></init></decl> ;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>op_is_pair</name>   <init>= <expr><name>opcode</name> <operator>==</operator> <name>GB_PAIR_binop_code</name></expr></init></decl> ;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>binop_bind1st</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// C = op (scalar,A)</comment>
                <comment type="line">// A must be compatible with op-&gt;ytype</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>op_is_first</name> <operator>||</operator> <name>op_is_pair</name> <operator>||</operator>
                      <call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>ytype</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DOMAIN_MISMATCH</name></expr></argument>,
                        <argument><expr><literal type="string">"Incompatible type for z=%s(x,y):\n"</literal>
                        <literal type="string">"input A of type [%s]\n"</literal>
                        <literal type="string">"cannot be typecast to y input of type [%s]"</literal></expr></argument>,
                        <argument><expr><name><name>op</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>ytype</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <comment type="line">// scalar must be compatible with op-&gt;xtype</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>op_is_second</name> <operator>||</operator> <name>op_is_pair</name> <operator>||</operator>
                      <call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name><name>scalar</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>xtype</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DOMAIN_MISMATCH</name></expr></argument>,
                        <argument><expr><literal type="string">"Incompatible type for z=%s(x,y):\n"</literal>
                        <literal type="string">"input scalar of type [%s]\n"</literal>
                        <literal type="string">"cannot be typecast to x input of type [%s]"</literal></expr></argument>,
                        <argument><expr><name><name>op</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>scalar</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>xtype</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="line">// C = op (A,scalar)</comment>
                <comment type="line">// A must be compatible with op-&gt;xtype</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>op_is_first</name> <operator>||</operator> <name>op_is_pair</name> <operator>||</operator>
                      <call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>xtype</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DOMAIN_MISMATCH</name></expr></argument>,
                        <argument><expr><literal type="string">"Incompatible type for z=%s(x,y):\n"</literal>
                        <literal type="string">"input A of type [%s]\n"</literal>
                        <literal type="string">"cannot be typecast to x input of type [%s]"</literal></expr></argument>,
                        <argument><expr><name><name>op</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>xtype</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <comment type="line">// scalar must be compatible with op-&gt;ytype</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>op_is_second</name> <operator>||</operator> <name>op_is_pair</name>
                      <operator>||</operator> <call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name><name>scalar</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>ytype</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
                <block>{<block_content> 
                    <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DOMAIN_MISMATCH</name></expr></argument>,
                        <argument><expr><literal type="string">"Incompatible type for z=%s(x,y):\n"</literal>
                        <literal type="string">"input scalar of type [%s]\n"</literal>
                        <literal type="string">"cannot be typecast to y input of type [%s]"</literal></expr></argument>,
                        <argument><expr><name><name>op</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>scalar</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>ytype</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else <comment type="line">// op_is_idxunop</comment>
    <block>{<block_content>
        <comment type="line">// apply an idxunop operator, with a thunk scalar</comment>
        <expr_stmt><expr><call><name>ASSERT_INDEXUNARYOP_OK</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"idxunop for GB_apply"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT_SCALAR_OK</name> <argument_list>(<argument><expr><name>scalar</name></expr></argument>, <argument><expr><literal type="string">"thunk for GB_apply"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <comment type="line">// A must be compatible with op-&gt;xtype</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>xtype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DOMAIN_MISMATCH</name></expr></argument>,
                <argument><expr><literal type="string">"Incompatible type for z=%s(x,i,j,thunk):\n"</literal>
                <literal type="string">"input A of type [%s]\n"</literal>
                <literal type="string">"cannot be typecast to x input of type [%s]"</literal></expr></argument>,
                <argument><expr><name><name>op</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>xtype</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="line">// scalar must be compatible with op-&gt;ytype</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GB_Type_compatible</name> <argument_list>(<argument><expr><name><name>scalar</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>ytype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DOMAIN_MISMATCH</name></expr></argument>,
                <argument><expr><literal type="string">"Incompatible type for z=%s(x,i,j,thunk):\n"</literal>
                <literal type="string">"input scalar of type [%s]\n"</literal>
                <literal type="string">"cannot be typecast to thunk input of type [%s]"</literal></expr></argument>,
                <argument><expr><name><name>op</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>scalar</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>ytype</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// check domains and dimensions for C&lt;M&gt; = accum (C,T)</comment>
    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_compatible</name> <argument_list>(<argument><expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>C</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>T_type</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// check the dimensions</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>tnrows</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>A_transpose</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>tncols</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>A_transpose</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>tnrows</name> <operator>||</operator> <call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>tncols</name></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_DIMENSION_MISMATCH</name></expr></argument>,
            <argument><expr><literal type="string">"Dimensions not compatible:\n"</literal>
            <literal type="string">"output is "</literal> <name>GBd</name> <literal type="string">"-by-"</literal> <name>GBd</name> <literal type="string">"\n"</literal>
            <literal type="string">"input is "</literal> <name>GBd</name> <literal type="string">"-by-"</literal> <name>GBd</name> <literal type="string">"%s"</literal></expr></argument>,
            <argument><expr><call><name>GB_NROWS</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GB_NCOLS</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>tnrows</name></expr></argument>, <argument><expr><name>tncols</name></expr></argument>, <argument><expr><ternary><condition><expr><name>A_transpose</name></expr> ?</condition><then> <expr><literal type="string">" (transposed)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// quick return if an empty mask is complemented</comment>
    <expr_stmt><expr><call><name>GB_RETURN_IF_QUICK_MASK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>C_replace</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// delete any lingering zombies and assemble any pending tuples</comment>
    <expr_stmt><expr><call><name>GB_MATRIX_WAIT_IF_PENDING_OR_ZOMBIES</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>      <comment type="line">// A can be jumbled</comment>
    <expr_stmt><expr><call><name>GB_MATRIX_WAIT</name> <argument_list>(<argument><expr><name>scalar</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>op_is_unop</name> <operator>&amp;&amp;</operator> <call><name>GB_nnz</name> <argument_list>(<argument><expr><operator>(</operator><name>GrB_Matrix</name><operator>)</operator> <name>scalar</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// the scalar entry must be present</comment>
        <expr_stmt><expr><call><name>GB_ERROR</name> <argument_list>(<argument><expr><name>GrB_EMPTY_OBJECT</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"Scalar must contain an entry"</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// rename binop and idxunop operators</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_binop_rename</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>binop_bind1st</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>opcode</name></name></expr> ;</expr_stmt>
    <expr_stmt><expr><name>op_is_unop</name> <operator>=</operator> <call><name>GB_IS_UNARYOP_CODE</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><name>op_is_binop</name> <operator>=</operator> <call><name>GB_IS_BINARYOP_CODE</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><name>op_is_idxunop</name> <operator>=</operator> <call><name>GB_IS_INDEXUNARYOP_CODE</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><name>op_is_positional</name> <operator>=</operator> <call><name>GB_OPCODE_IS_POSITIONAL</name> <argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// all VALUE* index_unary ops have been renamed to their corresponding</comment>
    <comment type="line">// binary ops.  Only positional and user-defined idxunops remain.</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><name>op_is_idxunop</name></expr></argument>,
        <argument><expr><name>op_is_positional</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>GB_USER_idxunop_code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// get the int64 value of the thunk for positional operators</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <if_stmt><if>if <condition>(<expr><name>op_is_idxunop</name> <operator>&amp;&amp;</operator> <name>op_is_positional</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// ithunk = (int64) scalar</comment>
        <expr_stmt><expr><call><name>GB_cast_scalar</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>ithunk</name></expr></argument>, <argument><expr><name>GB_INT64_code</name></expr></argument>, <argument><expr><name><name>scalar</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>scalar</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>code</name></name></expr></argument>,
            <argument><expr><name><name>scalar</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <comment type="line">// wrap ithunk in the new scalar</comment>
        <expr_stmt><expr><name>scalar</name> <operator>=</operator> <call><name>GB_Scalar_wrap</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>Thunk_header</name></expr></argument>, <argument><expr><name>GrB_INT64</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ithunk</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// T = op(A) or op(A')</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>T_is_csc</name> <init>= <expr><name><name>C</name><operator>-&gt;</operator><name>is_csc</name></name></expr></init></decl> ;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>T_is_csc</name> <operator>!=</operator> <name><name>A</name><operator>-&gt;</operator><name>is_csc</name></name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// Flip the sense of A_transpose</comment>
        <expr_stmt><expr><name>A_transpose</name> <operator>=</operator> <operator>!</operator><name>A_transpose</name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>T_is_csc</name> <operator>&amp;&amp;</operator> <name>op_is_positional</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// positional ops must be flipped, with i and j swapped</comment>
        <if_stmt><if>if <condition>(<expr><name>op_is_unop</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>op</name> <operator>=</operator> <operator>(</operator><name>GB_Operator</name><operator>)</operator> <call><name>GB_positional_unop_ijflip</name> <argument_list>(<argument><expr><operator>(</operator><name>GrB_UnaryOp</name><operator>)</operator> <name>op</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>op_is_binop</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>op</name> <operator>=</operator> <operator>(</operator><name>GB_Operator</name><operator>)</operator> <call><name>GB_positional_binop_ijflip</name> <argument_list>(<argument><expr><operator>(</operator><name>GrB_BinaryOp</name><operator>)</operator> <name>op</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></if>
        <else>else <comment type="line">// op_is_idxunop</comment>
        <block>{<block_content> 
            <comment type="line">// also revise ithunk as needed (TRIL, TRIU, DIAG, OFFDIAG only)</comment>
            <expr_stmt><expr><name>op</name> <operator>=</operator> <operator>(</operator><name>GB_Operator</name><operator>)</operator> <call><name>GB_positional_idxunop_ijflip</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>ithunk</name></expr></argument>,
                <argument><expr><operator>(</operator><name>GrB_IndexUnaryOp</name><operator>)</operator> <name>op</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>opcode</name></name></expr> ;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// user operator must have i,j flipped</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>flipij</name> <init>= <expr><operator>(</operator><operator>!</operator><name>T_is_csc</name> <operator>&amp;&amp;</operator> <name>opcode</name> <operator>==</operator> <name>GB_USER_idxunop_code</name><operator>)</operator></expr></init></decl> ;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>A_transpose</name></expr>)</condition>
    <block>{<block_content> 
        <comment type="line">// T = op (A'), typecasting to op-&gt;ztype</comment>
        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(transpose-op) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T_header</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>GB_transpose</name> <argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>T_type</name></expr></argument>, <argument><expr><name>T_is_csc</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>,
            <argument><expr><name>binop_bind1st</name></expr></argument>, <argument><expr><name>flipij</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_JUMBLED_OK</name> <argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <comment type="line">// A positional op is applied to C after the transpose is computed,</comment>
        <comment type="line">// using the T_is_csc format.  The ijflip is handled above.</comment>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>M</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>accum</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>C</name> <operator>==</operator> <name>A</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>C</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>T_type</name>
        <operator>&amp;&amp;</operator> <call><name>GB_nnz</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(in-place-op) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <comment type="line">// C = op (C), operating on the values in-place, with no typecasting</comment>
        <comment type="line">// of the output of the operator with the matrix C.</comment>
        <comment type="line">// No work to do if the op is identity.</comment>
        <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>!=</operator> <name>GB_IDENTITY_unop_code</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// the output Cx is aliased with C-&gt;x in GB_apply_op.</comment>
            <decl_stmt><decl><type><name>GB_iso_code</name></type> <name>C_code_iso</name> <init>= <expr><call><name>GB_iso_unop_code</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>binop_bind1st</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
            <expr_stmt><expr><name>info</name> <operator>=</operator> <name>GrB_SUCCESS</name></expr> ;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>C_code_iso</name> <operator>==</operator> <name>GB_NON_ISO</name> <operator>&amp;&amp;</operator> <name><name>C</name><operator>-&gt;</operator><name>iso</name></name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// expand C to non-iso; initialize C-&gt;x unless the op</comment>
                <comment type="line">// is positional</comment>
                <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>GB_convert_any_to_non_iso</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><operator>!</operator><name>op_is_positional</name></expr></argument>,
                    <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// C-&gt;x = op (C-&gt;x) in place</comment>
                <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>GB_apply_op</name> <argument_list>(<argument><expr><operator>(</operator><name>GB_void</name> <operator>*</operator><operator>)</operator> <name><name>C</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>C</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>C_code_iso</name></expr></argument>,
                    <argument><expr><name>op</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>binop_bind1st</name></expr></argument>, <argument><expr><name>flipij</name></expr></argument>, <argument><expr><name>C</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>info</name> <operator>==</operator> <name>GrB_SUCCESS</name> <operator>&amp;&amp;</operator> <name>C_code_iso</name> <operator>!=</operator> <name>GB_NON_ISO</name></expr>)</condition>
            <block>{<block_content> 
                <comment type="line">// compact the iso values of C</comment>
                <expr_stmt><expr><name><name>C</name><operator>-&gt;</operator><name>iso</name></name> <operator>=</operator> <name>true</name></expr> ;</expr_stmt> <comment type="line">// OK</comment>
                <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>GB_convert_any_to_iso</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><operator>(</operator><name>info</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content> 
        <comment type="line">// T = op (A), pattern is a shallow copy of A, type is op-&gt;ztype.</comment>
        <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"(shallow-op) "</literal></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><call><name>GB_CLEAR_STATIC_HEADER</name> <argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T_header</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>GB_shallow_op</name> <argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>T_is_csc</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>scalar</name></expr></argument>, <argument><expr><name>binop_bind1st</name></expr></argument>, <argument><expr><name>flipij</name></expr></argument>,
            <argument><expr><name>A</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>info</name> <operator>!=</operator> <name>GrB_SUCCESS</name></expr>)</condition>
    <block>{<block_content> 
        <expr_stmt><expr><call><name>GB_Matrix_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>T</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
        <return>return <expr><operator>(</operator><name>info</name><operator>)</operator></expr> ;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>T</name><operator>-&gt;</operator><name>is_csc</name></name> <operator>==</operator> <name><name>C</name><operator>-&gt;</operator><name>is_csc</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// C&lt;M&gt; = accum (C,T): accumulate the results into C via the M</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <return>return <expr><operator>(</operator><call><name>GB_accum_mask</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><name>C_replace</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>,
        <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
