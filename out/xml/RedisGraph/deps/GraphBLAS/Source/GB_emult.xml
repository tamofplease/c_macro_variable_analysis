<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/Source/GB_emult.c"><comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// GB_emult: C = A.*B, C&lt;M&gt;=A.*B, or C&lt;!M&gt;=A.*B</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2022, All Rights Reserved.</comment>
<comment type="line">// SPDX-License-Identifier: Apache-2.0</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>

<comment type="line">// GB_emult, does C=A.*B, C&lt;M&gt;=A.*B, C&lt;!M&gt;=A.*B, using the given operator</comment>
<comment type="line">// element-wise on the matrices A and B.  The result is typecasted as needed.</comment>
<comment type="line">// The pattern of C is the intersection of the pattern of A and B, intersection</comment>
<comment type="line">// with the mask M or !M, if present.</comment>

<comment type="line">// Let the op be z=f(x,y) where x, y, and z have type xtype, ytype, and ztype.</comment>
<comment type="line">// If both A(i,j) and B(i,j) are present, then:</comment>

<comment type="line">//      C(i,j) = (ctype) op ((xtype) A(i,j), (ytype) B(i,j))</comment>

<comment type="line">// If just A(i,j) is present but not B(i,j), or</comment>
<comment type="line">// if just B(i,j) is present but not A(i,j), then C(i,j) is not present.</comment>

<comment type="line">// ctype is the type of matrix C, and currently it is always op-&gt;ztype,</comment>
<comment type="line">// but this might change in the future.</comment>

<comment type="line">// The pattern of C is the intersection of A and B, and also intersection with</comment>
<comment type="line">// M if present and not complemented.</comment>

<comment type="line">// TODO: if C is bitmap on input and C_sparsity is GxB_BITMAP, then C=A.*B,</comment>
<comment type="line">// C&lt;M&gt;=A.*B and C&lt;M&gt;+=A.*B can all be done in-place.  Also, if C is bitmap</comment>
<comment type="line">// but T&lt;M&gt;=A.*B is sparse (M sparse, with A and B bitmap), then it too can</comment>
<comment type="line">// be done in place.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_emult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GB_add.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_WORKSPACE</name></cpp:macro>                       \
<cpp:value>{                                               \
    GB_FREE_WORK (&amp;TaskList, TaskList_size) ;   \
    GB_FREE_WORK (&amp;C_to_M, C_to_M_size) ;       \
    GB_FREE_WORK (&amp;C_to_A, C_to_A_size) ;       \
    GB_FREE_WORK (&amp;C_to_B, C_to_B_size) ;       \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GB_FREE_ALL</name></cpp:macro>             \
<cpp:value>{                               \
    GB_FREE_WORKSPACE ;         \
    GB_phybix_free (C) ;        \
}</cpp:value></cpp:define>

<function><type><name>GrB_Info</name></type> <name>GB_emult</name>           <comment type="line">// C=A.*B, C&lt;M&gt;=A.*B, or C&lt;!M&gt;=A.*B</comment>
<parameter_list>(
    <parameter><decl><type><name>GrB_Matrix</name></type> <name>C</name></decl></parameter>,           <comment type="line">// output matrix, static header</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Type</name></type> <name>ctype</name></decl></parameter>,   <comment type="line">// type of output matrix C</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>C_is_csc</name></decl></parameter>,    <comment type="line">// format of output matrix C</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>M</name></decl></parameter>,     <comment type="line">// optional mask, unused if NULL</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_struct</name></decl></parameter>, <comment type="line">// if true, use the only structure of M</comment>
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>Mask_comp</name></decl></parameter>,   <comment type="line">// if true, use !M</comment>
    <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>mask_applied</name></decl></parameter>,     <comment type="line">// if true, the mask was applied</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>A</name></decl></parameter>,     <comment type="line">// input A matrix</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_Matrix</name></type> <name>B</name></decl></parameter>,     <comment type="line">// input B matrix</comment>
    <parameter><decl><type><specifier>const</specifier> <name>GrB_BinaryOp</name></type> <name>op</name></decl></parameter>,  <comment type="line">// op to perform C = op (A,B)</comment>
    <parameter><decl><type><name>GB_Context</name></type> <name>Context</name></decl></parameter>
)</parameter_list>
<block>{<block_content>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// check inputs</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GrB_Info</name></type> <name>info</name></decl> ;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>C</name><operator>-&gt;</operator><name>static_header</name></name> <operator>||</operator> <name>GBNSTATIC</name><operator>)</operator></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"A for emult phased"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><literal type="string">"B for emult phased"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK_OR_NULL</name> <argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><literal type="string">"M for emult phased"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_BINARYOP_OK</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"op for emult phased"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>vdim</name></name> <operator>==</operator> <name><name>B</name><operator>-&gt;</operator><name>vdim</name></name> <operator>&amp;&amp;</operator> <name><name>A</name><operator>-&gt;</operator><name>vlen</name></name> <operator>==</operator> <name><name>B</name><operator>-&gt;</operator><name>vlen</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><call><name>GB_IMPLIES</name> <argument_list>(<argument><expr><name>M</name> <operator>!=</operator> <name>NULL</name></expr></argument>, <argument><expr><name><name>A</name><operator>-&gt;</operator><name>vdim</name></name> <operator>==</operator> <name><name>M</name><operator>-&gt;</operator><name>vdim</name></name> <operator>&amp;&amp;</operator> <name><name>A</name><operator>-&gt;</operator><name>vlen</name></name> <operator>==</operator> <name><name>M</name><operator>-&gt;</operator><name>vlen</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// declare workspace</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>GB_task_struct</name> <modifier>*</modifier></type><name>TaskList</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>TaskList_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>C_to_M</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>C_to_M_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>C_to_A</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>C_to_A_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>C_to_B</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>C_to_B_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// delete any lingering zombies and assemble any pending tuples</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// some cases can allow M, A, and/or B to be jumbled</comment>
    <expr_stmt><expr><call><name>GB_MATRIX_WAIT_IF_PENDING_OR_ZOMBIES</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_MATRIX_WAIT_IF_PENDING_OR_ZOMBIES</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_MATRIX_WAIT_IF_PENDING_OR_ZOMBIES</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// determine the sparsity of C and the method to use</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>apply_mask</name></decl> ;</decl_stmt>           <comment type="line">// if true, mask is applied during emult</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ewise_method</name></decl> ;</decl_stmt>          <comment type="line">// method to use</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>C_sparsity</name> <init>= <expr><call><name>GB_emult_sparsity</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>apply_mask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ewise_method</name></expr></argument>,
        <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// C&lt;M or !M&gt; = A.*B</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <switch>switch <condition>(<expr><name>ewise_method</name></expr>)</condition>
    <block>{<block_content>

        <case>case <expr><name>GB_EMULT_METHOD1_ADD</name></expr> :</case>  <comment type="line">// A and B both full (or as-if-full)</comment>

            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      C       =           A       .*      B</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      full    .           full            full    (GB_add)</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      C       &lt;M&gt; =       A       .*      B</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      sparse  sparse      full            full    (GB_add or 4)</comment>
            <comment type="line">//      bitmap  bitmap      full            full    (GB_add or 7)</comment>
            <comment type="line">//      bitmap  full        full            full    (GB_add or 7)</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      C       &lt;!M&gt;=       A       .*      B</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      bitmap  sparse      full            full    (GB_add or 6)</comment>
            <comment type="line">//      bitmap  bitmap      full            full    (GB_add or 7)</comment>
            <comment type="line">//      bitmap  full        full            full    (GB_add or 7)</comment>

            <comment type="line">// A and B are both full (or as-if-full).  The mask M may be</comment>
            <comment type="line">// anything.  GB_add computes the same thing in this case, so it is</comment>
            <comment type="line">// used instead, to reduce the code needed for GB_emult.</comment>

            <return>return <expr><operator>(</operator><call><name>GB_add</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>, <argument><expr><name>C_is_csc</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>,
                <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>mask_applied</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                <argument><expr><name>op</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>

        <case>case <expr><name>GB_EMULT_METHOD2</name></expr> :</case>  <comment type="line">// A sparse/hyper, B bitmap/full</comment>

            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      C       =           A       .*      B</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      sparse  .           sparse          bitmap  (method: 2)</comment>
            <comment type="line">//      sparse  .           sparse          full    (method: 2)</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      C       &lt;M&gt; =       A       .*      B</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      sparse  bitmap      sparse          bitmap  (method: 2)</comment>
            <comment type="line">//      sparse  bitmap      sparse          full    (method: 2)</comment>
            <comment type="line">//      sparse  full        sparse          bitmap  (method: 2)</comment>
            <comment type="line">//      sparse  full        sparse          full    (method: 2)</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      C       &lt;!M&gt;=       A       .*      B</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      sparse  sparse      sparse          bitmap  (2: M later)</comment>
            <comment type="line">//      sparse  sparse      sparse          full    (2: M later)</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      C       &lt;!M&gt; =       A       .*      B</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      sparse  bitmap      sparse          bitmap  (method: 2)</comment>
            <comment type="line">//      sparse  bitmap      sparse          full    (method: 2)</comment>
            <comment type="line">//      sparse  full        sparse          bitmap  (method: 2)</comment>
            <comment type="line">//      sparse  full        sparse          full    (method: 2)</comment>

            <comment type="line">// A is sparse/hyper and B is bitmap/full.  M is either not</comment>
            <comment type="line">// present, not applied (!M when sparse/hyper), or bitmap/full.</comment>
            <comment type="line">// This method does not handle the case when M is sparse/hyper,</comment>
            <comment type="line">// unless M is ignored and applied later.</comment>

            <return>return <expr><operator>(</operator><call><name>GB_emult_02</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>, <argument><expr><name>C_is_csc</name></expr></argument>,
                <argument><expr><ternary><condition><expr><operator>(</operator><name>apply_mask</name><operator>)</operator></expr> ?</condition><then> <expr><name>M</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>,
                <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>

        <case>case <expr><name>GB_EMULT_METHOD3</name></expr> :</case>  <comment type="line">// A bitmap/full, B sparse/hyper</comment>

            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      C       =           A       .*      B</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      sparse  .           bitmap          sparse  (method: 3)</comment>
            <comment type="line">//      sparse  .           full            sparse  (method: 3)</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      C       &lt;M&gt; =       A       .*      B</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      sparse  bitmap      bitmap          sparse  (method: 3)</comment>
            <comment type="line">//      sparse  bitmap      full            sparse  (method: 3)</comment>
            <comment type="line">//      sparse  full        bitmap          sparse  (method: 3)</comment>
            <comment type="line">//      sparse  full        full            sparse  (method: 3)</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      C       &lt;!M&gt;=       A       .*      B</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      sparse  sparse      bitmap          sparse  (3: M later)</comment>
            <comment type="line">//      sparse  sparse      full            sparse  (3: M later)</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      C       &lt;!M&gt; =      A       .*      B</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      sparse  bitmap      bitmap          sparse  (method: 3)</comment>
            <comment type="line">//      sparse  bitmap      full            sparse  (method: 3)</comment>
            <comment type="line">//      sparse  full        bitmap          sparse  (method: 3)</comment>
            <comment type="line">//      sparse  full        full            sparse  (method: 3)</comment>

            <comment type="line">// A is bitmap/full and B is sparse/hyper, with flipxy true.</comment>
            <comment type="line">// M is not present, not applied, or bitmap/full</comment>
            <comment type="line">// Note that A and B are flipped.</comment>

            <return>return <expr><operator>(</operator><call><name>GB_emult_02</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>, <argument><expr><name>C_is_csc</name></expr></argument>,
                <argument><expr><ternary><condition><expr><operator>(</operator><name>apply_mask</name><operator>)</operator></expr> ?</condition><then> <expr><name>M</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>,
                <argument><expr><name>B</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>

        <case>case <expr><name>GB_EMULT_METHOD8</name></expr> :</case> 

            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      C       =           A       .*      B</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      sparse  .           sparse          sparse  (method: 8)</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      C       &lt;M&gt; =       A       .*      B</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      sparse  sparse      sparse          sparse  (method: 8)</comment>
            <comment type="line">//      sparse  bitmap      sparse          sparse  (method: 8)</comment>
            <comment type="line">//      sparse  full        sparse          sparse  (method: 8)</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      C       &lt;!M&gt;=       A       .*      B</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      sparse  sparse      sparse          sparse  (8: M later)</comment>
            <comment type="line">//      sparse  bitmap      sparse          sparse  (method: 8)</comment>
            <comment type="line">//      sparse  full        sparse          sparse  (method: 8)</comment>

            <comment type="line">// TODO: break Method8 into different methods</comment>
            <break>break ;</break>

        <case>case <expr><name>GB_EMULT_METHOD5</name></expr> :</case>   <comment type="line">// C is bitmap, M is not present</comment>

            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      C       =           A       .*      B</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      bitmap  .           bitmap          bitmap  (method: 5)</comment>
            <comment type="line">//      bitmap  .           bitmap          full    (method: 5)</comment>
            <comment type="line">//      bitmap  .           full            bitmap  (method: 5)</comment>

        <case>case <expr><name>GB_EMULT_METHOD6</name></expr> :</case>   <comment type="line">// C is bitmap, !M is sparse/hyper</comment>

            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      C       &lt;!M&gt;=       A       .*      B</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      bitmap  sparse      bitmap          bitmap  (method: 6)</comment>
            <comment type="line">//      bitmap  sparse      bitmap          full    (method: 6)</comment>
            <comment type="line">//      bitmap  sparse      full            bitmap  (method: 6)</comment>
            <comment type="line">//      bitmap  sparse      full            full    (GB_add or 6)</comment>

        <case>case <expr><name>GB_EMULT_METHOD7</name></expr> :</case>   <comment type="line">// C is bitmap, M is bitmap/full</comment>

            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      C      &lt;M&gt; =        A       .*      B</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      bitmap  bitmap      bitmap          bitmap  (method: 7)</comment>
            <comment type="line">//      bitmap  bitmap      bitmap          full    (method: 7)</comment>
            <comment type="line">//      bitmap  bitmap      full            bitmap  (method: 7)</comment>
            <comment type="line">//      bitmap  bitmap      full            full    (GB_add or 7)</comment>
            <comment type="line">//      bitmap  full        bitmap          bitmap  (method: 7)</comment>
            <comment type="line">//      bitmap  full        bitmap          full    (method: 7)</comment>
            <comment type="line">//      bitmap  full        full            bitmap  (method: 7)</comment>
            <comment type="line">//      bitmap  full        full            full    (GB_add or 7)</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      C      &lt;!M&gt; =       A       .*      B</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      bitmap  bitmap      bitmap          bitmap  (method: 7)</comment>
            <comment type="line">//      bitmap  bitmap      bitmap          full    (method: 7)</comment>
            <comment type="line">//      bitmap  bitmap      full            bitmap  (method: 7)</comment>
            <comment type="line">//      bitmap  bitmap      full            full    (GB_add or 7)</comment>
            <comment type="line">//      bitmap  full        bitmap          bitmap  (method: 7)</comment>
            <comment type="line">//      bitmap  full        bitmap          full    (method: 7)</comment>
            <comment type="line">//      bitmap  full        full            bitmap  (method: 7)</comment>
            <comment type="line">//      bitmap  full        full            full    (GB_add or 7)</comment>

            <comment type="line">// For methods 5, 6, and 7, C is constructed as bitmap.</comment>
            <comment type="line">// Both A and B are bitmap/full.  M is either not present,</comment>
            <comment type="line">// complemented, or not complemented and bitmap/full.  The</comment>
            <comment type="line">// case when M is not complemented and sparse/hyper is handled</comment>
            <comment type="line">// by method 4, which constructs C as sparse/hyper (the same</comment>
            <comment type="line">// structure as M), not bitmap.</comment>

            <return>return <expr><operator>(</operator><call><name>GB_bitmap_emult</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>ewise_method</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>, <argument><expr><name>C_is_csc</name></expr></argument>,
                <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>mask_applied</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>,
                <argument><expr><name>op</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>

        <case>case <expr><name>GB_EMULT_METHOD4</name></expr> :</case> 

            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      C       &lt;M&gt;=        A       .*      B</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      sparse  sparse      bitmap          bitmap  (method: 4)</comment>
            <comment type="line">//      sparse  sparse      bitmap          full    (method: 4)</comment>
            <comment type="line">//      sparse  sparse      full            bitmap  (method: 4)</comment>
            <comment type="line">//      sparse  sparse      full            full    (GB_add or 4)</comment>

            <return>return <expr><operator>(</operator><call><name>GB_emult_04</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>, <argument><expr><name>C_is_csc</name></expr></argument>, <argument><expr><name>M</name></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>,
                <argument><expr><name>mask_applied</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ;</return>

        <case>case <expr><name>GB_EMULT_METHOD9</name></expr> :</case> <break>break ;</break> <comment type="line">// punt</comment>

            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      C       &lt;M&gt;=        A       .*      B</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      sparse  sparse      sparse          bitmap  (method: 9)</comment>
            <comment type="line">//      sparse  sparse      sparse          full    (method: 9)</comment>

            <comment type="line">// TODO: this will use Method9 (M,A,B, flipxy=false)</comment>

            <comment type="line">// The method will compute the 2-way intersection of M and A,</comment>
            <comment type="line">// using the same parallization as C=A.*B when both A and B are</comment>
            <comment type="line">// both sparse.  It will then lookup B in O(1) time.</comment>
            <comment type="line">// M and A must not be jumbled.</comment>

        <case>case <expr><name>GB_EMULT_METHOD10</name></expr> :</case> <break>break ;</break> <comment type="line">// punt</comment>

            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      C       &lt;M&gt;=        A       .*      B</comment>
            <comment type="line">//      ------------------------------------------</comment>
            <comment type="line">//      sparse  sparse      bitmap          sparse  (method: 10)</comment>
            <comment type="line">//      sparse  sparse      full            sparse  (method: 10)</comment>

            <comment type="line">// TODO: this will use Method10 (M,B,A, flipxy=true)</comment>
            <comment type="line">// M and B must not be jumbled.</comment>

        <default>default:</default><empty_stmt>;</empty_stmt>
    </block_content>}</block></switch>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// Method8 (and for now, Method9 and Method10)</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C_sparsity</name> <operator>==</operator> <name>GxB_SPARSE</name> <operator>||</operator> <name>C_sparsity</name> <operator>==</operator> <name>GxB_HYPERSPARSE</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GB_MATRIX_WAIT</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_MATRIX_WAIT</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>GB_MATRIX_WAIT</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>GBURBLE</name> <argument_list>(<argument><expr><literal type="string">"emult:(%s&lt;%s&gt;=%s.*%s) "</literal></expr></argument>,
        <argument><expr><call><name>GB_sparsity_char</name> <argument_list>(<argument><expr><name>C_sparsity</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>GB_sparsity_char_matrix</name> <argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>GB_sparsity_char_matrix</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>GB_sparsity_char_matrix</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// initializations</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>Cnvec</name></decl>, <decl><type ref="prev"/><name>Cnvec_nonempty</name></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>Cp</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Cp_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier></type><name>Ch</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt> <decl_stmt><decl><type><name>size_t</name></type> <name>Ch_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>C_ntasks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>C_nthreads</name></decl> ;</decl_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// phase0: finalize the sparsity C and find the vectors in C</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_emult_phase0</name> <argument_list>(
        <comment type="line">// computed by phase0:</comment>
        <argument><expr><operator>&amp;</operator><name>Cnvec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ch_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>C_to_M</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>C_to_M_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>C_to_A</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>C_to_A_size</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>C_to_B</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>C_to_B_size</name></expr></argument>,
        <comment type="line">// input/output to phase0:</comment>
        <argument><expr><operator>&amp;</operator><name>C_sparsity</name></expr></argument>,
        <comment type="line">// original input:</comment>
        <argument><expr><ternary><condition><expr><operator>(</operator><name>apply_mask</name><operator>)</operator></expr> ?</condition><then> <expr><name>M</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// C is still sparse or hypersparse, not bitmap or full</comment>
    <expr_stmt><expr><call><name>ASSERT</name> <argument_list>(<argument><expr><name>C_sparsity</name> <operator>==</operator> <name>GxB_SPARSE</name> <operator>||</operator> <name>C_sparsity</name> <operator>==</operator> <name>GxB_HYPERSPARSE</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// phase1: split C into tasks, and count entries in each vector of C</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// phase1a: split C into tasks</comment>
    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_ewise_slice</name> <argument_list>(
        <comment type="line">// computed by phase1a:</comment>
        <argument><expr><operator>&amp;</operator><name>TaskList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TaskList_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>C_ntasks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>C_nthreads</name></expr></argument>,
        <comment type="line">// computed by phase0:</comment>
        <argument><expr><name>Cnvec</name></expr></argument>, <argument><expr><name>Ch</name></expr></argument>, <argument><expr><name>C_to_M</name></expr></argument>, <argument><expr><name>C_to_A</name></expr></argument>, <argument><expr><name>C_to_B</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
        <comment type="line">// original input:</comment>
        <argument><expr><ternary><condition><expr><operator>(</operator><name>apply_mask</name><operator>)</operator></expr> ?</condition><then> <expr><name>M</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">// count the number of entries in each vector of C</comment>
    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_emult_phase1</name> <argument_list>(
        <comment type="line">// computed by phase1:</comment>
        <argument><expr><operator>&amp;</operator><name>Cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Cp_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Cnvec_nonempty</name></expr></argument>,
        <comment type="line">// from phase1a:</comment>
        <argument><expr><name>TaskList</name></expr></argument>, <argument><expr><name>C_ntasks</name></expr></argument>, <argument><expr><name>C_nthreads</name></expr></argument>,
        <comment type="line">// from phase0:</comment>
        <argument><expr><name>Cnvec</name></expr></argument>, <argument><expr><name>Ch</name></expr></argument>, <argument><expr><name>C_to_M</name></expr></argument>, <argument><expr><name>C_to_A</name></expr></argument>, <argument><expr><name>C_to_B</name></expr></argument>,
        <comment type="line">// original input:</comment>
        <argument><expr><ternary><condition><expr><operator>(</operator><name>apply_mask</name><operator>)</operator></expr> ?</condition><then> <expr><name>M</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// phase2: compute the entries (indices and values) in each vector of C</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <comment type="line">// Cp is either freed by phase2, or transplanted into C.</comment>
    <comment type="line">// Either way, it is not freed here.</comment>

    <expr_stmt><expr><call><name>GB_OK</name> <argument_list>(<argument><expr><call><name>GB_emult_phase2</name> <argument_list>(
        <comment type="line">// computed or used by phase2:</comment>
        <argument><expr><name>C</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>, <argument><expr><name>C_is_csc</name></expr></argument>, <argument><expr><name>op</name></expr></argument>,
        <comment type="line">// from phase1:</comment>
        <argument><expr><operator>&amp;</operator><name>Cp</name></expr></argument>, <argument><expr><name>Cp_size</name></expr></argument>, <argument><expr><name>Cnvec_nonempty</name></expr></argument>,
        <comment type="line">// from phase1a:</comment>
        <argument><expr><name>TaskList</name></expr></argument>, <argument><expr><name>C_ntasks</name></expr></argument>, <argument><expr><name>C_nthreads</name></expr></argument>,
        <comment type="line">// from phase0:</comment>
        <argument><expr><name>Cnvec</name></expr></argument>, <argument><expr><name>Ch</name></expr></argument>, <argument><expr><name>Ch_size</name></expr></argument>, <argument><expr><name>C_to_M</name></expr></argument>, <argument><expr><name>C_to_A</name></expr></argument>, <argument><expr><name>C_to_B</name></expr></argument>, <argument><expr><name>C_sparsity</name></expr></argument>,
        <comment type="line">// from GB_emult_sparsity:</comment>
        <argument><expr><name>ewise_method</name></expr></argument>,
        <comment type="line">// original input:</comment>
        <argument><expr><ternary><condition><expr><operator>(</operator><name>apply_mask</name><operator>)</operator></expr> ?</condition><then> <expr><name>M</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>, <argument><expr><name>Mask_struct</name></expr></argument>, <argument><expr><name>Mask_comp</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ;</expr_stmt>

    <comment type="line">//--------------------------------------------------------------------------</comment>
    <comment type="line">// free workspace and return result</comment>
    <comment type="line">//--------------------------------------------------------------------------</comment>

    <expr_stmt><expr><name>GB_FREE_WORKSPACE</name></expr> ;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_MATRIX_OK</name> <argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="string">"C output for emult phased"</literal></expr></argument>, <argument><expr><name>GB0</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>mask_applied</name><operator>)</operator> <operator>=</operator> <name>apply_mask</name></expr> ;</expr_stmt>
    <return>return <expr><operator>(</operator><name>GrB_SUCCESS</name><operator>)</operator></expr> ;</return>
</block_content>}</block></function>

</unit>
