<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/RedisGraph/deps/GraphBLAS/zstd/zstd_subset/decompress/zstd_decompress_block.c"><comment type="block">/*
 * Copyright (c) Yann Collet, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 */</comment>

<comment type="block">/* zstd_decompress_block :
 * this module takes care of decompressing _compressed_ block */</comment>

<comment type="block">/*-*******************************************************
*  Dependencies
*********************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/zstd_deps.h"</cpp:file></cpp:include>   <comment type="block">/* ZSTD_memcpy, ZSTD_memmove, ZSTD_memset */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/compiler.h"</cpp:file></cpp:include>    <comment type="block">/* prefetch */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/cpu.h"</cpp:file></cpp:include>         <comment type="block">/* bmi2 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/mem.h"</cpp:file></cpp:include>         <comment type="block">/* low level memory routines */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSE_STATIC_LINKING_ONLY</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/fse.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_STATIC_LINKING_ONLY</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/huf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/zstd_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_decompress_internal.h"</cpp:file></cpp:include>   <comment type="block">/* ZSTD_DCtx */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_ddict.h"</cpp:file></cpp:include>  <comment type="block">/* ZSTD_DDictDictContent */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_decompress_block.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/bits.h"</cpp:file></cpp:include>  <comment type="block">/* ZSTD_highbit32 */</comment>

<comment type="block">/*_*******************************************************
*  Macros
**********************************************************/</comment>

<comment type="block">/* These two optional macros force the use one way or another of the two
 * ZSTD_decompressSequences implementations. You can't force in both directions
 * at the same time.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> \
    <call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"Cannot force the use of the short and the long ZSTD_decompressSequences variants!"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*_*******************************************************
*  Memory operations
**********************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_copy4</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>


<comment type="block">/*-*************************************************************
 *   Block decoding
 ***************************************************************/</comment>

<comment type="block" format="doxygen">/*! ZSTD_getcBlockSize() :
 *  Provides the size of compressed block from block header `src` */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_getcBlockSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                          <parameter><decl><type><name>blockProperties_t</name><modifier>*</modifier></type> <name>bpPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>srcSize</name> <operator>&lt;</operator> <name>ZSTD_blockHeaderSize</name></expr></argument>, <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>cBlockHeader</name> <init>= <expr><call><name>MEM_readLE24</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>cSize</name> <init>= <expr><name>cBlockHeader</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>bpPtr</name><operator>-&gt;</operator><name>lastBlock</name></name> <operator>=</operator> <name>cBlockHeader</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bpPtr</name><operator>-&gt;</operator><name>blockType</name></name> <operator>=</operator> <operator>(</operator><name>blockType_e</name><operator>)</operator><operator>(</operator><operator>(</operator><name>cBlockHeader</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bpPtr</name><operator>-&gt;</operator><name>origSize</name></name> <operator>=</operator> <name>cSize</name></expr>;</expr_stmt>   <comment type="block">/* only useful for RLE */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>bpPtr</name><operator>-&gt;</operator><name>blockType</name></name> <operator>==</operator> <name>bt_rle</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>bpPtr</name><operator>-&gt;</operator><name>blockType</name></name> <operator>==</operator> <name>bt_reserved</name></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>cSize</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* Allocate buffer for literals, either overlapping current dst, or split between dst and litExtraBuffer, or stored entirely within litExtraBuffer */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_allocateLiteralsBuffer</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>dstCapacity</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>litSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>streaming_operation</name></type> <name>streaming</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>expectedWriteSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>splitImmediately</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>streaming</name> <operator>==</operator> <name>not_streaming</name> <operator>&amp;&amp;</operator> <name>dstCapacity</name> <operator>&gt;</operator> <name>ZSTD_BLOCKSIZE_MAX</name> <operator>+</operator> <name>WILDCOPY_OVERLENGTH</name> <operator>+</operator> <name>litSize</name> <operator>+</operator> <name>WILDCOPY_OVERLENGTH</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* room for litbuffer to fit without read faulting */</comment>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name> <operator>+</operator> <name>ZSTD_BLOCKSIZE_MAX</name> <operator>+</operator> <name>WILDCOPY_OVERLENGTH</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferEnd</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name> <operator>+</operator> <name>litSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferLocation</name></name> <operator>=</operator> <name>ZSTD_in_dst</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>litSize</name> <operator>&gt;</operator> <name>ZSTD_LITBUFFEREXTRASIZE</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* won't fit in litExtraBuffer, so it will be split between end of dst and extra buffer */</comment>
        <if_stmt><if>if <condition>(<expr><name>splitImmediately</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* won't fit in litExtraBuffer, so it will be split between end of dst and extra buffer */</comment>
            <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name> <operator>+</operator> <name>expectedWriteSize</name> <operator>-</operator> <name>litSize</name> <operator>+</operator> <name>ZSTD_LITBUFFEREXTRASIZE</name> <operator>-</operator> <name>WILDCOPY_OVERLENGTH</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferEnd</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name> <operator>+</operator> <name>litSize</name> <operator>-</operator> <name>ZSTD_LITBUFFEREXTRASIZE</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else <block>{<block_content>
            <comment type="block">/* initially this will be stored entirely in dst during huffman decoding, it will partially be shifted to litExtraBuffer after */</comment>
            <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name> <operator>+</operator> <name>expectedWriteSize</name> <operator>-</operator> <name>litSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferEnd</name></name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name> <operator>+</operator> <name>expectedWriteSize</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferLocation</name></name> <operator>=</operator> <name>ZSTD_split</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* fits entirely within litExtraBuffer, so no split is necessary */</comment>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litExtraBuffer</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferEnd</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name> <operator>+</operator> <name>litSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferLocation</name></name> <operator>=</operator> <name>ZSTD_not_in_dst</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Hidden declaration for fullbench */</comment>
<function_decl><type><name>size_t</name></type> <name>ZSTD_decodeLiteralsBlock</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                          <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>streaming_operation</name></type> <name>streaming</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block" format="doxygen">/*! ZSTD_decodeLiteralsBlock() :
 * Where it is possible to do so without being stomped by the output during decompression, the literals block will be stored
 * in the dstBuffer.  If there is room to do so, it will be stored in full in the excess dst space after where the current
 * block will be output.  Otherwise it will be stored at the end of the current dst blockspace, with a small portion being
 * stored in dctx-&gt;litExtraBuffer to help keep it "ahead" of the current output write.
 *
 * @return : nb of bytes read from src (&lt; srcSize )
 *  note : symbol not declared but exposed for fullbench */</comment>
<function><type><name>size_t</name></type> <name>ZSTD_decodeLiteralsBlock</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,   <comment type="block">/* note : srcSize &lt; BLOCKSIZE */</comment>
                          <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>streaming_operation</name></type> <name>streaming</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decodeLiteralsBlock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>srcSize</name> <operator>&lt;</operator> <name>MIN_CBLOCK_SIZE</name></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <name>src</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>symbolEncodingType_e</name> <specifier>const</specifier></type> <name>litEncType</name> <init>= <expr><operator>(</operator><name>symbolEncodingType_e</name><operator>)</operator><operator>(</operator><name><name>istart</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">3</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

        <switch>switch<condition>(<expr><name>litEncType</name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>set_repeat</name></expr>:</case>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"set_repeat flag : re-using stats from previous compressed literals block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>litEntropy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>dictionary_corrupted</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ZSTD_FALLTHROUGH</name></expr>;</expr_stmt>

        <case>case <expr><name>set_compressed</name></expr>:</case>
            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>srcSize</name> <operator>&lt;</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">"srcSize &gt;= MIN_CBLOCK_SIZE == 2; here we need up to 5 for case 3"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>lhSize</name></decl>, <decl><type ref="prev"/><name>litSize</name></decl>, <decl><type ref="prev"/><name>litCSize</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name></type> <name>singleStream</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>lhlCode</name> <init>= <expr><operator>(</operator><name><name>istart</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>lhc</name> <init>= <expr><call><name>MEM_readLE32</name><argument_list>(<argument><expr><name>istart</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name></type> <name>hufSuccess</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name></type> <name>expectedWriteSize</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>ZSTD_BLOCKSIZE_MAX</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <switch>switch<condition>(<expr><name>lhlCode</name></expr>)</condition>
                <block>{<block_content>
                <case>case <expr><literal type="number">0</literal></expr>:</case> <case>case <expr><literal type="number">1</literal></expr>:</case> <default>default:</default>   <comment type="block">/* note : default is impossible, since lhlCode into [0..3] */</comment>
                    <comment type="block">/* 2 - 2 - 10 - 10 */</comment>
                    <expr_stmt><expr><name>singleStream</name> <operator>=</operator> <operator>!</operator><name>lhlCode</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>lhSize</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>litSize</name>  <operator>=</operator> <operator>(</operator><name>lhc</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3FF</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>litCSize</name> <operator>=</operator> <operator>(</operator><name>lhc</name> <operator>&gt;&gt;</operator> <literal type="number">14</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3FF</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="number">2</literal></expr>:</case>
                    <comment type="block">/* 2 - 2 - 14 - 14 */</comment>
                    <expr_stmt><expr><name>lhSize</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>litSize</name>  <operator>=</operator> <operator>(</operator><name>lhc</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3FFF</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>litCSize</name> <operator>=</operator> <name>lhc</name> <operator>&gt;&gt;</operator> <literal type="number">18</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="number">3</literal></expr>:</case>
                    <comment type="block">/* 2 - 2 - 18 - 18 */</comment>
                    <expr_stmt><expr><name>lhSize</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>litSize</name>  <operator>=</operator> <operator>(</operator><name>lhc</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3FFFF</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>litCSize</name> <operator>=</operator> <operator>(</operator><name>lhc</name> <operator>&gt;&gt;</operator> <literal type="number">22</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><name><name>istart</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">10</literal><operator>)</operator></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></switch>
                <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>litSize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dst</name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"NULL not handled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>litSize</name> <operator>&gt;</operator> <name>ZSTD_BLOCKSIZE_MAX</name></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>litCSize</name> <operator>+</operator> <name>lhSize</name> <operator>&gt;</operator> <name>srcSize</name></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>expectedWriteSize</name> <operator>&lt;</operator> <name>litSize</name></expr></argument> , <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTD_allocateLiteralsBuffer</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>, <argument><expr><name>streaming</name></expr></argument>, <argument><expr><name>expectedWriteSize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* prefetch huffman table if cold */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictIsCold</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>litSize</name> <operator>&gt;</operator> <literal type="number">768</literal> <comment type="block">/* heuristic */</comment><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>PREFETCH_AREA</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>HUFptr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>hufTable</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>litEncType</name><operator>==</operator><name>set_repeat</name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>singleStream</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>hufSuccess</name> <operator>=</operator> <call><name>HUF_decompress1X_usingDTable_bmi2</name><argument_list>(
                            <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>, <argument><expr><name>istart</name><operator>+</operator><name>lhSize</name></expr></argument>, <argument><expr><name>litCSize</name></expr></argument>,
                            <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>HUFptr</name></name></expr></argument>, <argument><expr><call><name>ZSTD_DCtx_get_bmi2</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <expr_stmt><expr><name>hufSuccess</name> <operator>=</operator> <call><name>HUF_decompress4X_usingDTable_bmi2</name><argument_list>(
                            <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>, <argument><expr><name>istart</name><operator>+</operator><name>lhSize</name></expr></argument>, <argument><expr><name>litCSize</name></expr></argument>,
                            <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>HUFptr</name></name></expr></argument>, <argument><expr><call><name>ZSTD_DCtx_get_bmi2</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>singleStream</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HUF_FORCE_DECOMPRESS_X2</name></expr></argument>)</argument_list></call></expr></cpp:if>
                        <expr_stmt><expr><name>hufSuccess</name> <operator>=</operator> <call><name>HUF_decompress1X_DCtx_wksp</name><argument_list>(
                            <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>hufTable</name></name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>,
                            <argument><expr><name>istart</name><operator>+</operator><name>lhSize</name></expr></argument>, <argument><expr><name>litCSize</name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>,
                            <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <expr_stmt><expr><name>hufSuccess</name> <operator>=</operator> <call><name>HUF_decompress1X1_DCtx_wksp_bmi2</name><argument_list>(
                            <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>hufTable</name></name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>,
                            <argument><expr><name>istart</name><operator>+</operator><name>lhSize</name></expr></argument>, <argument><expr><name>litCSize</name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>,
                            <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><call><name>ZSTD_DCtx_get_bmi2</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <expr_stmt><expr><name>hufSuccess</name> <operator>=</operator> <call><name>HUF_decompress4X_hufOnly_wksp_bmi2</name><argument_list>(
                            <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>hufTable</name></name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>,
                            <argument><expr><name>istart</name><operator>+</operator><name>lhSize</name></expr></argument>, <argument><expr><name>litCSize</name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>,
                            <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><call><name>ZSTD_DCtx_get_bmi2</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></else></if_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferLocation</name></name> <operator>==</operator> <name>ZSTD_split</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>litExtraBuffer</name></name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferEnd</name></name> <operator>-</operator> <name>ZSTD_LITBUFFEREXTRASIZE</name></expr></argument>, <argument><expr><name>ZSTD_LITBUFFEREXTRASIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ZSTD_memmove</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name> <operator>+</operator> <name>ZSTD_LITBUFFEREXTRASIZE</name> <operator>-</operator> <name>WILDCOPY_OVERLENGTH</name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name></expr></argument>, <argument><expr><name>litSize</name> <operator>-</operator> <name>ZSTD_LITBUFFEREXTRASIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name> <operator>+=</operator> <name>ZSTD_LITBUFFEREXTRASIZE</name> <operator>-</operator> <name>WILDCOPY_OVERLENGTH</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferEnd</name></name> <operator>-=</operator> <name>WILDCOPY_OVERLENGTH</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>HUF_isError</name><argument_list>(<argument><expr><name>hufSuccess</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litPtr</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litSize</name></name> <operator>=</operator> <name>litSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litEntropy</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>litEncType</name><operator>==</operator><name>set_compressed</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>HUFptr</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>hufTable</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <return>return <expr><name>litCSize</name> <operator>+</operator> <name>lhSize</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>set_basic</name></expr>:</case>
            <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>litSize</name></decl>, <decl><type ref="prev"/><name>lhSize</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>lhlCode</name> <init>= <expr><operator>(</operator><operator>(</operator><name><name>istart</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name></type> <name>expectedWriteSize</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>ZSTD_BLOCKSIZE_MAX</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <switch>switch<condition>(<expr><name>lhlCode</name></expr>)</condition>
                <block>{<block_content>
                <case>case <expr><literal type="number">0</literal></expr>:</case> <case>case <expr><literal type="number">2</literal></expr>:</case> <default>default:</default>   <comment type="block">/* note : default is impossible, since lhlCode into [0..3] */</comment>
                    <expr_stmt><expr><name>lhSize</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>litSize</name> <operator>=</operator> <name><name>istart</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="number">1</literal></expr>:</case>
                    <expr_stmt><expr><name>lhSize</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>litSize</name> <operator>=</operator> <call><name>MEM_readLE16</name><argument_list>(<argument><expr><name>istart</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="number">3</literal></expr>:</case>
                    <expr_stmt><expr><name>lhSize</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>srcSize</name><operator>&lt;</operator><literal type="number">3</literal></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">"srcSize &gt;= MIN_CBLOCK_SIZE == 2; here we need lhSize = 3"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>litSize</name> <operator>=</operator> <call><name>MEM_readLE24</name><argument_list>(<argument><expr><name>istart</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></switch>

                <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>litSize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dst</name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"NULL not handled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>expectedWriteSize</name> <operator>&lt;</operator> <name>litSize</name></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTD_allocateLiteralsBuffer</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>, <argument><expr><name>streaming</name></expr></argument>, <argument><expr><name>expectedWriteSize</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>lhSize</name><operator>+</operator><name>litSize</name><operator>+</operator><name>WILDCOPY_OVERLENGTH</name> <operator>&gt;</operator> <name>srcSize</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* risk reading beyond src buffer with wildcopy */</comment>
                    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>litSize</name><operator>+</operator><name>lhSize</name> <operator>&gt;</operator> <name>srcSize</name></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferLocation</name></name> <operator>==</operator> <name>ZSTD_split</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name></expr></argument>, <argument><expr><name>istart</name> <operator>+</operator> <name>lhSize</name></expr></argument>, <argument><expr><name>litSize</name> <operator>-</operator> <name>ZSTD_LITBUFFEREXTRASIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>litExtraBuffer</name></name></expr></argument>, <argument><expr><name>istart</name> <operator>+</operator> <name>lhSize</name> <operator>+</operator> <name>litSize</name> <operator>-</operator> <name>ZSTD_LITBUFFEREXTRASIZE</name></expr></argument>, <argument><expr><name>ZSTD_LITBUFFEREXTRASIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name></expr></argument>, <argument><expr><name>istart</name> <operator>+</operator> <name>lhSize</name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litPtr</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litSize</name></name> <operator>=</operator> <name>litSize</name></expr>;</expr_stmt>
                    <return>return <expr><name>lhSize</name><operator>+</operator><name>litSize</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* direct reference into compressed stream */</comment>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litPtr</name></name> <operator>=</operator> <name>istart</name><operator>+</operator><name>lhSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litSize</name></name> <operator>=</operator> <name>litSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferEnd</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litPtr</name></name> <operator>+</operator> <name>litSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferLocation</name></name> <operator>=</operator> <name>ZSTD_not_in_dst</name></expr>;</expr_stmt>
                <return>return <expr><name>lhSize</name><operator>+</operator><name>litSize</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>set_rle</name></expr>:</case>
            <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>lhlCode</name> <init>= <expr><operator>(</operator><operator>(</operator><name><name>istart</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name></type> <name>litSize</name></decl>, <decl><type ref="prev"/><name>lhSize</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name></type> <name>expectedWriteSize</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>ZSTD_BLOCKSIZE_MAX</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <switch>switch<condition>(<expr><name>lhlCode</name></expr>)</condition>
                <block>{<block_content>
                <case>case <expr><literal type="number">0</literal></expr>:</case> <case>case <expr><literal type="number">2</literal></expr>:</case> <default>default:</default>   <comment type="block">/* note : default is impossible, since lhlCode into [0..3] */</comment>
                    <expr_stmt><expr><name>lhSize</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>litSize</name> <operator>=</operator> <name><name>istart</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="number">1</literal></expr>:</case>
                    <expr_stmt><expr><name>lhSize</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>srcSize</name><operator>&lt;</operator><literal type="number">3</literal></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">"srcSize &gt;= MIN_CBLOCK_SIZE == 2; here we need lhSize+1 = 3"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>litSize</name> <operator>=</operator> <call><name>MEM_readLE16</name><argument_list>(<argument><expr><name>istart</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="number">3</literal></expr>:</case>
                    <expr_stmt><expr><name>lhSize</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>srcSize</name><operator>&lt;</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">"srcSize &gt;= MIN_CBLOCK_SIZE == 2; here we need lhSize+1 = 4"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>litSize</name> <operator>=</operator> <call><name>MEM_readLE24</name><argument_list>(<argument><expr><name>istart</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></switch>
                <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>litSize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dst</name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"NULL not handled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>litSize</name> <operator>&gt;</operator> <name>ZSTD_BLOCKSIZE_MAX</name></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>expectedWriteSize</name> <operator>&lt;</operator> <name>litSize</name></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTD_allocateLiteralsBuffer</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>, <argument><expr><name>streaming</name></expr></argument>, <argument><expr><name>expectedWriteSize</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferLocation</name></name> <operator>==</operator> <name>ZSTD_split</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name></expr></argument>, <argument><expr><name><name>istart</name><index>[<expr><name>lhSize</name></expr>]</index></name></expr></argument>, <argument><expr><name>litSize</name> <operator>-</operator> <name>ZSTD_LITBUFFEREXTRASIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>litExtraBuffer</name></name></expr></argument>, <argument><expr><name><name>istart</name><index>[<expr><name>lhSize</name></expr>]</index></name></expr></argument>, <argument><expr><name>ZSTD_LITBUFFEREXTRASIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ZSTD_memset</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name></expr></argument>, <argument><expr><name><name>istart</name><index>[<expr><name>lhSize</name></expr>]</index></name></expr></argument>, <argument><expr><name>litSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litPtr</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litSize</name></name> <operator>=</operator> <name>litSize</name></expr>;</expr_stmt>
                <return>return <expr><name>lhSize</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
            </block_content>}</block>
        <default>default:</default>
            <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">"impossible"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* Default FSE distribution tables.
 * These are pre-calculated FSE decoding tables using default distributions as defined in specification :
 * https://github.com/facebook/zstd/blob/release/doc/zstd_compression_format.md#default-distributions
 * They were generated programmatically with following method :
 * - start from default distributions, present in /lib/common/zstd_internal.h
 * - generate tables normally, using ZSTD_buildFSETable()
 * - printout the content of tables
 * - pretify output, report below, test with fuzzer to ensure it's correct */</comment>

<comment type="block">/* Default FSE distribution table for Literal Lengths */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ZSTD_seqSymbol</name></type> <name><name>LL_defaultDTable</name><index>[<expr><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>LL_DEFAULTNORMLOG</name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
     <expr><block>{  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">1</literal></expr>, <expr><name>LL_DEFAULTNORMLOG</name></expr>}</block></expr>,  <comment type="block">/* header : fastMode, tableLog */</comment>
     <comment type="block">/* nextState, nbAddBits, nbBits, baseVal */</comment>
     <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">4</literal></expr>,    <expr><literal type="number">0</literal></expr>}</block></expr>,  <expr><block>{ <expr><literal type="number">16</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">4</literal></expr>,    <expr><literal type="number">0</literal></expr>}</block></expr>,
     <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">1</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">3</literal></expr>}</block></expr>,
     <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">4</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">6</literal></expr>}</block></expr>,
     <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">7</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">9</literal></expr>}</block></expr>,
     <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">10</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">12</literal></expr>}</block></expr>,
     <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">14</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">16</literal></expr>}</block></expr>,
     <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">20</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">22</literal></expr>}</block></expr>,
     <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">28</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">32</literal></expr>}</block></expr>,
     <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">48</literal></expr>}</block></expr>,  <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">64</literal></expr>}</block></expr>,
     <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">128</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">8</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">256</literal></expr>}</block></expr>,
     <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">10</literal></expr>,  <expr><literal type="number">6</literal></expr>, <expr><literal type="number">1024</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">12</literal></expr>,  <expr><literal type="number">6</literal></expr>, <expr><literal type="number">4096</literal></expr>}</block></expr>,
     <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">4</literal></expr>,    <expr><literal type="number">0</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">4</literal></expr>,    <expr><literal type="number">1</literal></expr>}</block></expr>,
     <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">2</literal></expr>}</block></expr>,  <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">4</literal></expr>}</block></expr>,
     <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">5</literal></expr>}</block></expr>,  <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">7</literal></expr>}</block></expr>,
     <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">8</literal></expr>}</block></expr>,  <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">10</literal></expr>}</block></expr>,
     <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">11</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">13</literal></expr>}</block></expr>,
     <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">16</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">18</literal></expr>}</block></expr>,
     <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">22</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">24</literal></expr>}</block></expr>,
     <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">32</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">40</literal></expr>}</block></expr>,
     <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">4</literal></expr>,   <expr><literal type="number">64</literal></expr>}</block></expr>,  <expr><block>{ <expr><literal type="number">16</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">4</literal></expr>,   <expr><literal type="number">64</literal></expr>}</block></expr>,
     <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">128</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">9</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">512</literal></expr>}</block></expr>,
     <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">11</literal></expr>,  <expr><literal type="number">6</literal></expr>, <expr><literal type="number">2048</literal></expr>}</block></expr>,  <expr><block>{ <expr><literal type="number">48</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">4</literal></expr>,    <expr><literal type="number">0</literal></expr>}</block></expr>,
     <expr><block>{ <expr><literal type="number">16</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">4</literal></expr>,    <expr><literal type="number">1</literal></expr>}</block></expr>,  <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">2</literal></expr>}</block></expr>,
     <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">3</literal></expr>}</block></expr>,  <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">5</literal></expr>}</block></expr>,
     <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">6</literal></expr>}</block></expr>,  <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">8</literal></expr>}</block></expr>,
     <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">9</literal></expr>}</block></expr>,  <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">11</literal></expr>}</block></expr>,
     <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">12</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">15</literal></expr>}</block></expr>,
     <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">18</literal></expr>}</block></expr>,  <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">20</literal></expr>}</block></expr>,
     <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">24</literal></expr>}</block></expr>,  <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">28</literal></expr>}</block></expr>,
     <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">40</literal></expr>}</block></expr>,  <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">48</literal></expr>}</block></expr>,
     <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">16</literal></expr>,  <expr><literal type="number">6</literal></expr>,<expr><literal type="number">65536</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">15</literal></expr>,  <expr><literal type="number">6</literal></expr>,<expr><literal type="number">32768</literal></expr>}</block></expr>,
     <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">14</literal></expr>,  <expr><literal type="number">6</literal></expr>,<expr><literal type="number">16384</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">13</literal></expr>,  <expr><literal type="number">6</literal></expr>, <expr><literal type="number">8192</literal></expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>   <comment type="block">/* LL_defaultDTable */</comment>

<comment type="block">/* Default FSE distribution table for Offset Codes */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ZSTD_seqSymbol</name></type> <name><name>OF_defaultDTable</name><index>[<expr><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>OF_DEFAULTNORMLOG</name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
    <expr><block>{  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">1</literal></expr>, <expr><name>OF_DEFAULTNORMLOG</name></expr>}</block></expr>,  <comment type="block">/* header : fastMode, tableLog */</comment>
    <comment type="block">/* nextState, nbAddBits, nbBits, baseVal */</comment>
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">0</literal></expr>}</block></expr>,     <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">4</literal></expr>,   <expr><literal type="number">61</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">9</literal></expr>,  <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">509</literal></expr>}</block></expr>,     <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">15</literal></expr>,  <expr><literal type="number">5</literal></expr>,<expr><literal type="number">32765</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">21</literal></expr>,  <expr><literal type="number">5</literal></expr>,<expr><literal type="number">2097149</literal></expr>}</block></expr>,   <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">5</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">125</literal></expr>}</block></expr>,     <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">12</literal></expr>,  <expr><literal type="number">5</literal></expr>, <expr><literal type="number">4093</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">18</literal></expr>,  <expr><literal type="number">5</literal></expr>,<expr><literal type="number">262141</literal></expr>}</block></expr>,    <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">23</literal></expr>,  <expr><literal type="number">5</literal></expr>,<expr><literal type="number">8388605</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">29</literal></expr>}</block></expr>,     <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">8</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">253</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">14</literal></expr>,  <expr><literal type="number">5</literal></expr>,<expr><literal type="number">16381</literal></expr>}</block></expr>,     <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">20</literal></expr>,  <expr><literal type="number">5</literal></expr>,<expr><literal type="number">1048573</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">1</literal></expr>}</block></expr>,     <expr><block>{ <expr><literal type="number">16</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">125</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">11</literal></expr>,  <expr><literal type="number">5</literal></expr>, <expr><literal type="number">2045</literal></expr>}</block></expr>,     <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">17</literal></expr>,  <expr><literal type="number">5</literal></expr>,<expr><literal type="number">131069</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">22</literal></expr>,  <expr><literal type="number">5</literal></expr>,<expr><literal type="number">4194301</literal></expr>}</block></expr>,   <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">13</literal></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="number">16</literal></expr>,  <expr><literal type="number">8</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">253</literal></expr>}</block></expr>,     <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">13</literal></expr>,  <expr><literal type="number">5</literal></expr>, <expr><literal type="number">8189</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">19</literal></expr>,  <expr><literal type="number">5</literal></expr>,<expr><literal type="number">524285</literal></expr>}</block></expr>,    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">1</literal></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="number">16</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">4</literal></expr>,   <expr><literal type="number">61</literal></expr>}</block></expr>,     <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">10</literal></expr>,  <expr><literal type="number">5</literal></expr>, <expr><literal type="number">1021</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">16</literal></expr>,  <expr><literal type="number">5</literal></expr>,<expr><literal type="number">65533</literal></expr>}</block></expr>,     <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">28</literal></expr>,  <expr><literal type="number">5</literal></expr>,<expr><literal type="number">268435453</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">27</literal></expr>,  <expr><literal type="number">5</literal></expr>,<expr><literal type="number">134217725</literal></expr>}</block></expr>, <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">26</literal></expr>,  <expr><literal type="number">5</literal></expr>,<expr><literal type="number">67108861</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">25</literal></expr>,  <expr><literal type="number">5</literal></expr>,<expr><literal type="number">33554429</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">24</literal></expr>,  <expr><literal type="number">5</literal></expr>,<expr><literal type="number">16777213</literal></expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>   <comment type="block">/* OF_defaultDTable */</comment>


<comment type="block">/* Default FSE distribution table for Match Lengths */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ZSTD_seqSymbol</name></type> <name><name>ML_defaultDTable</name><index>[<expr><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>ML_DEFAULTNORMLOG</name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
    <expr><block>{  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">1</literal></expr>, <expr><name>ML_DEFAULTNORMLOG</name></expr>}</block></expr>,  <comment type="block">/* header : fastMode, tableLog */</comment>
    <comment type="block">/* nextState, nbAddBits, nbBits, baseVal */</comment>
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,    <expr><literal type="number">3</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">4</literal></expr>,    <expr><literal type="number">4</literal></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">5</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">6</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">8</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">9</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">11</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">13</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">16</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">19</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">22</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">25</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">28</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">31</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">34</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">37</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">41</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">47</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">59</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">83</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">131</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">9</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">515</literal></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="number">16</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">4</literal></expr>,    <expr><literal type="number">4</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">4</literal></expr>,    <expr><literal type="number">5</literal></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">6</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">7</literal></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">9</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">10</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">12</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">15</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">18</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">21</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">24</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">27</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">30</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">33</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">35</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">39</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">43</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">51</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">67</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">99</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">8</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">259</literal></expr>}</block></expr>,  <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">4</literal></expr>,    <expr><literal type="number">4</literal></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="number">48</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">4</literal></expr>,    <expr><literal type="number">4</literal></expr>}</block></expr>,  <expr><block>{ <expr><literal type="number">16</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">4</literal></expr>,    <expr><literal type="number">5</literal></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">7</literal></expr>}</block></expr>,  <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,    <expr><literal type="number">8</literal></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">10</literal></expr>}</block></expr>,  <expr><block>{ <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">11</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">14</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">17</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">20</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">23</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">26</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">29</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">32</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">16</literal></expr>,  <expr><literal type="number">6</literal></expr>,<expr><literal type="number">65539</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">15</literal></expr>,  <expr><literal type="number">6</literal></expr>,<expr><literal type="number">32771</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">14</literal></expr>,  <expr><literal type="number">6</literal></expr>,<expr><literal type="number">16387</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">13</literal></expr>,  <expr><literal type="number">6</literal></expr>, <expr><literal type="number">8195</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">12</literal></expr>,  <expr><literal type="number">6</literal></expr>, <expr><literal type="number">4099</literal></expr>}</block></expr>,
    <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">11</literal></expr>,  <expr><literal type="number">6</literal></expr>, <expr><literal type="number">2051</literal></expr>}</block></expr>,  <expr><block>{  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">10</literal></expr>,  <expr><literal type="number">6</literal></expr>, <expr><literal type="number">1027</literal></expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>   <comment type="block">/* ML_defaultDTable */</comment>


<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_buildSeqTable_rle</name><parameter_list>(<parameter><decl><type><name>ZSTD_seqSymbol</name><modifier>*</modifier></type> <name>dt</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>baseValue</name></decl></parameter>, <parameter><decl><type><name>U8</name></type> <name>nbAddBits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>ptr</name> <init>= <expr><name>dt</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_seqSymbol_header</name><modifier>*</modifier> <specifier>const</specifier></type> <name>DTableH</name> <init>= <expr><operator>(</operator><name>ZSTD_seqSymbol_header</name><operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_seqSymbol</name><modifier>*</modifier> <specifier>const</specifier></type> <name>cell</name> <init>= <expr><name>dt</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>DTableH</name><operator>-&gt;</operator><name>tableLog</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>DTableH</name><operator>-&gt;</operator><name>fastMode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>cell</name><operator>-&gt;</operator><name>nbBits</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cell</name><operator>-&gt;</operator><name>nextState</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nbAddBits</name> <operator>&lt;</operator> <literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cell</name><operator>-&gt;</operator><name>nbAdditionalBits</name></name> <operator>=</operator> <name>nbAddBits</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cell</name><operator>-&gt;</operator><name>baseValue</name></name> <operator>=</operator> <name>baseValue</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ZSTD_buildFSETable() :
 * generate FSE decoding table for one symbol (ll, ml or off)
 * cannot fail if input is valid =&gt;
 * all inputs are presumed validated at this stage */</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name>
<name>void</name></type> <name>ZSTD_buildFSETable_body</name><parameter_list>(<parameter><decl><type><name>ZSTD_seqSymbol</name><modifier>*</modifier></type> <name>dt</name></decl></parameter>,
            <parameter><decl><type><specifier>const</specifier> <name>short</name><modifier>*</modifier></type> <name>normalizedCounter</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name></decl></parameter>,
            <parameter><decl><type><specifier>const</specifier> <name>U32</name><modifier>*</modifier></type> <name>baseValue</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U8</name><modifier>*</modifier></type> <name>nbAdditionalBits</name></decl></parameter>,
            <parameter><decl><type><name>unsigned</name></type> <name>tableLog</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>wksp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZSTD_seqSymbol</name><modifier>*</modifier> <specifier>const</specifier></type> <name>tableDecode</name> <init>= <expr><name>dt</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>maxSV1</name> <init>= <expr><name>maxSymbolValue</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>tableSize</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>tableLog</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>U16</name><modifier>*</modifier></type> <name>symbolNext</name> <init>= <expr><operator>(</operator><name>U16</name><operator>*</operator><operator>)</operator><name>wksp</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>spread</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><operator>(</operator><name>symbolNext</name> <operator>+</operator> <name>MaxSeq</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>highThreshold</name> <init>= <expr><name>tableSize</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>


    <comment type="block">/* Sanity Checks */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>maxSymbolValue</name> <operator>&lt;=</operator> <name>MaxSeq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tableLog</name> <operator>&lt;=</operator> <name>MaxFSELog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>wkspSize</name> <operator>&gt;=</operator> <name>ZSTD_BUILD_FSE_TABLE_WKSP_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>wkspSize</name></expr>;</expr_stmt>
    <comment type="block">/* Init, lay down lowprob symbols */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>ZSTD_seqSymbol_header</name></type> <name>DTableH</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>DTableH</name><operator>.</operator><name>tableLog</name></name> <operator>=</operator> <name>tableLog</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>DTableH</name><operator>.</operator><name>fastMode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <block>{<block_content>   <decl_stmt><decl><type><name>S16</name> <specifier>const</specifier></type> <name>largeLimit</name><init>= <expr><operator>(</operator><name>S16</name><operator>)</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>tableLog</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name></type> <name>s</name></decl>;</decl_stmt>
            <for>for <control>(<init><expr><name>s</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name><operator>&lt;</operator><name>maxSV1</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>normalizedCounter</name><index>[<expr><name>s</name></expr>]</index></name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>tableDecode</name><index>[<expr><name>highThreshold</name><operator>--</operator></expr>]</index></name><operator>.</operator><name>baseValue</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>symbolNext</name><index>[<expr><name>s</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>normalizedCounter</name><index>[<expr><name>s</name></expr>]</index></name> <operator>&gt;=</operator> <name>largeLimit</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>DTableH</name><operator>.</operator><name>fastMode</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>normalizedCounter</name><index>[<expr><name>s</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>symbolNext</name><index>[<expr><name>s</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U16</name><operator>)</operator><name><name>normalizedCounter</name><index>[<expr><name>s</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>   </block_content>}</block></for>   </block_content>}</block>
        <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>dt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>DTableH</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DTableH</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Spread symbols */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tableSize</name> <operator>&lt;=</operator> <literal type="number">512</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Specialized symbol spreading for the case when there are
     * no low probability (-1 count) symbols. When compressing
     * small blocks we avoid low probability symbols to hit this
     * case, since header decoding speed matters more.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>highThreshold</name> <operator>==</operator> <name>tableSize</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>tableMask</name> <init>= <expr><name>tableSize</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>step</name> <init>= <expr><call><name>FSE_TABLESTEP</name><argument_list>(<argument><expr><name>tableSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="block">/* First lay down the symbols in order.
         * We use a uint64_t to lay down 8 bytes at a time. This reduces branch
         * misses since small blocks generally have small table logs, so nearly
         * all symbols have counts &lt;= 8. We ensure we have 8 bytes at the end of
         * our buffer to handle the over-write.
         */</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><name>U64</name> <specifier>const</specifier></type> <name>add</name> <init>= <expr><literal type="number">0x0101010101010101ull</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U64</name></type> <name>sv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name></type> <name>s</name></decl>;</decl_stmt>
            <for>for <control>(<init><expr><name>s</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name><operator>&lt;</operator><name>maxSV1</name></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr><operator>,</operator> <expr><name>sv</name> <operator>+=</operator> <name>add</name></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>n</name> <init>= <expr><name><name>normalizedCounter</name><index>[<expr><name>s</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>MEM_write64</name><argument_list>(<argument><expr><name>spread</name> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">8</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">8</literal></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><call><name>MEM_write64</name><argument_list>(<argument><expr><name>spread</name> <operator>+</operator> <name>pos</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <comment type="block">/* Now we spread those positions across the table.
         * The benefit of doing it in two stages is that we avoid the
         * variable size inner loop, which caused lots of branch misses.
         * Now we can run through all the positions without any branch misses.
         * We unroll the loop twice, since that is what empirically worked best.
         */</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name></type> <name>position</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>s</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>unroll</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tableSize</name> <operator>%</operator> <name>unroll</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* FSE_MIN_TABLELOG is 5 */</comment>
            <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>tableSize</name></expr>;</condition> <incr><expr><name>s</name> <operator>+=</operator> <name>unroll</name></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name></type> <name>u</name></decl>;</decl_stmt>
                <for>for <control>(<init><expr><name>u</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name> <operator>&lt;</operator> <name>unroll</name></expr>;</condition> <incr><expr><operator>++</operator><name>u</name></expr></incr>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>uPosition</name> <init>= <expr><operator>(</operator><name>position</name> <operator>+</operator> <operator>(</operator><name>u</name> <operator>*</operator> <name>step</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <name>tableMask</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name><name>tableDecode</name><index>[<expr><name>uPosition</name></expr>]</index></name><operator>.</operator><name>baseValue</name> <operator>=</operator> <name><name>spread</name><index>[<expr><name>s</name> <operator>+</operator> <name>u</name></expr>]</index></name></expr>;</expr_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><name>position</name> <operator>=</operator> <operator>(</operator><name>position</name> <operator>+</operator> <operator>(</operator><name>unroll</name> <operator>*</operator> <name>step</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <name>tableMask</name></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>position</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>tableMask</name> <init>= <expr><name>tableSize</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>step</name> <init>= <expr><call><name>FSE_TABLESTEP</name><argument_list>(<argument><expr><name>tableSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>position</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>s</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name><operator>&lt;</operator><name>maxSV1</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>n</name> <init>= <expr><name><name>normalizedCounter</name><index>[<expr><name>s</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><name><name>tableDecode</name><index>[<expr><name>position</name></expr>]</index></name><operator>.</operator><name>baseValue</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>position</name> <operator>=</operator> <operator>(</operator><name>position</name> <operator>+</operator> <name>step</name><operator>)</operator> <operator>&amp;</operator> <name>tableMask</name></expr>;</expr_stmt>
                <while>while <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name>position</name> <operator>&gt;</operator> <name>highThreshold</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>position</name> <operator>=</operator> <operator>(</operator><name>position</name> <operator>+</operator> <name>step</name><operator>)</operator> <operator>&amp;</operator> <name>tableMask</name></expr>;</expr_stmt></block_content></block></while>   <comment type="block">/* lowprob area */</comment>
        </block_content>}</block></for>   </block_content>}</block></for>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>position</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* position must reach all cells once, otherwise normalizedCounter is incorrect */</comment>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Build Decoding table */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>U32</name></type> <name>u</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>u</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name><operator>&lt;</operator><name>tableSize</name></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>symbol</name> <init>= <expr><name><name>tableDecode</name><index>[<expr><name>u</name></expr>]</index></name><operator>.</operator><name>baseValue</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>nextState</name> <init>= <expr><name><name>symbolNext</name><index>[<expr><name>symbol</name></expr>]</index></name><operator>++</operator></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>tableDecode</name><index>[<expr><name>u</name></expr>]</index></name><operator>.</operator><name>nbBits</name> <operator>=</operator> <operator>(</operator><name>BYTE</name><operator>)</operator> <operator>(</operator><name>tableLog</name> <operator>-</operator> <call><name>ZSTD_highbit32</name><argument_list>(<argument><expr><name>nextState</name></expr></argument>)</argument_list></call> <operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tableDecode</name><index>[<expr><name>u</name></expr>]</index></name><operator>.</operator><name>nextState</name> <operator>=</operator> <operator>(</operator><name>U16</name><operator>)</operator> <operator>(</operator> <operator>(</operator><name>nextState</name> <operator>&lt;&lt;</operator> <name><name>tableDecode</name><index>[<expr><name>u</name></expr>]</index></name><operator>.</operator><name>nbBits</name><operator>)</operator> <operator>-</operator> <name>tableSize</name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>nbAdditionalBits</name><index>[<expr><name>symbol</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tableDecode</name><index>[<expr><name>u</name></expr>]</index></name><operator>.</operator><name>nbAdditionalBits</name> <operator>=</operator> <name><name>nbAdditionalBits</name><index>[<expr><name>symbol</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tableDecode</name><index>[<expr><name>u</name></expr>]</index></name><operator>.</operator><name>baseValue</name> <operator>=</operator> <name><name>baseValue</name><index>[<expr><name>symbol</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* Avoids the FORCE_INLINE of the _body() function. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_buildFSETable_body_default</name><parameter_list>(<parameter><decl><type><name>ZSTD_seqSymbol</name><modifier>*</modifier></type> <name>dt</name></decl></parameter>,
            <parameter><decl><type><specifier>const</specifier> <name>short</name><modifier>*</modifier></type> <name>normalizedCounter</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name></decl></parameter>,
            <parameter><decl><type><specifier>const</specifier> <name>U32</name><modifier>*</modifier></type> <name>baseValue</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U8</name><modifier>*</modifier></type> <name>nbAdditionalBits</name></decl></parameter>,
            <parameter><decl><type><name>unsigned</name></type> <name>tableLog</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>wksp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ZSTD_buildFSETable_body</name><argument_list>(<argument><expr><name>dt</name></expr></argument>, <argument><expr><name>normalizedCounter</name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>,
            <argument><expr><name>baseValue</name></expr></argument>, <argument><expr><name>nbAdditionalBits</name></expr></argument>, <argument><expr><name>tableLog</name></expr></argument>, <argument><expr><name>wksp</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DYNAMIC_BMI2</name></expr></cpp:if>
<function><type><name>BMI2_TARGET_ATTRIBUTE</name> <specifier>static</specifier> <name>void</name></type> <name>ZSTD_buildFSETable_body_bmi2</name><parameter_list>(<parameter><decl><type><name>ZSTD_seqSymbol</name><modifier>*</modifier></type> <name>dt</name></decl></parameter>,
            <parameter><decl><type><specifier>const</specifier> <name>short</name><modifier>*</modifier></type> <name>normalizedCounter</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name></decl></parameter>,
            <parameter><decl><type><specifier>const</specifier> <name>U32</name><modifier>*</modifier></type> <name>baseValue</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U8</name><modifier>*</modifier></type> <name>nbAdditionalBits</name></decl></parameter>,
            <parameter><decl><type><name>unsigned</name></type> <name>tableLog</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>wksp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ZSTD_buildFSETable_body</name><argument_list>(<argument><expr><name>dt</name></expr></argument>, <argument><expr><name>normalizedCounter</name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>,
            <argument><expr><name>baseValue</name></expr></argument>, <argument><expr><name>nbAdditionalBits</name></expr></argument>, <argument><expr><name>tableLog</name></expr></argument>, <argument><expr><name>wksp</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>ZSTD_buildFSETable</name><parameter_list>(<parameter><decl><type><name>ZSTD_seqSymbol</name><modifier>*</modifier></type> <name>dt</name></decl></parameter>,
            <parameter><decl><type><specifier>const</specifier> <name>short</name><modifier>*</modifier></type> <name>normalizedCounter</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>maxSymbolValue</name></decl></parameter>,
            <parameter><decl><type><specifier>const</specifier> <name>U32</name><modifier>*</modifier></type> <name>baseValue</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U8</name><modifier>*</modifier></type> <name>nbAdditionalBits</name></decl></parameter>,
            <parameter><decl><type><name>unsigned</name></type> <name>tableLog</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>wksp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bmi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DYNAMIC_BMI2</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>bmi2</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_buildFSETable_body_bmi2</name><argument_list>(<argument><expr><name>dt</name></expr></argument>, <argument><expr><name>normalizedCounter</name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>,
                <argument><expr><name>baseValue</name></expr></argument>, <argument><expr><name>nbAdditionalBits</name></expr></argument>, <argument><expr><name>tableLog</name></expr></argument>, <argument><expr><name>wksp</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>bmi2</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_buildFSETable_body_default</name><argument_list>(<argument><expr><name>dt</name></expr></argument>, <argument><expr><name>normalizedCounter</name></expr></argument>, <argument><expr><name>maxSymbolValue</name></expr></argument>,
            <argument><expr><name>baseValue</name></expr></argument>, <argument><expr><name>nbAdditionalBits</name></expr></argument>, <argument><expr><name>tableLog</name></expr></argument>, <argument><expr><name>wksp</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*! ZSTD_buildSeqTable() :
 * @return : nb bytes read from src,
 *           or an error code if it fails */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZSTD_buildSeqTable</name><parameter_list>(<parameter><decl><type><name>ZSTD_seqSymbol</name><modifier>*</modifier></type> <name>DTableSpace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_seqSymbol</name><modifier>*</modifier><modifier>*</modifier></type> <name>DTablePtr</name></decl></parameter>,
                                 <parameter><decl><type><name>symbolEncodingType_e</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>max</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>maxLog</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>U32</name><modifier>*</modifier></type> <name>baseValue</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U8</name><modifier>*</modifier></type> <name>nbAdditionalBits</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>ZSTD_seqSymbol</name><modifier>*</modifier></type> <name>defaultTable</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>flagRepeatTable</name></decl></parameter>,
                                 <parameter><decl><type><name>int</name></type> <name>ddictIsCold</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbSeq</name></decl></parameter>, <parameter><decl><type><name>U32</name><modifier>*</modifier></type> <name>wksp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wkspSize</name></decl></parameter>,
                                 <parameter><decl><type><name>int</name></type> <name>bmi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch<condition>(<expr><name>type</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>set_rle</name></expr> :</case>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><operator>!</operator><name>srcSize</name></expr></argument>, <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name><operator>)</operator> <operator>&gt;</operator> <name>max</name></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>symbol</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>baseline</name> <init>= <expr><name><name>baseValue</name><index>[<expr><name>symbol</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U8</name> <specifier>const</specifier></type> <name>nbBits</name> <init>= <expr><name><name>nbAdditionalBits</name><index>[<expr><name>symbol</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ZSTD_buildSeqTable_rle</name><argument_list>(<argument><expr><name>DTableSpace</name></expr></argument>, <argument><expr><name>baseline</name></expr></argument>, <argument><expr><name>nbBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><operator>*</operator><name>DTablePtr</name> <operator>=</operator> <name>DTableSpace</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    <case>case <expr><name>set_basic</name></expr> :</case>
        <expr_stmt><expr><operator>*</operator><name>DTablePtr</name> <operator>=</operator> <name>defaultTable</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><name>set_repeat</name></expr>:</case>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><operator>!</operator><name>flagRepeatTable</name></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* prefetch FSE table if used */</comment>
        <if_stmt><if>if <condition>(<expr><name>ddictIsCold</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>nbSeq</name> <operator>&gt;</operator> <literal type="number">24</literal> <comment type="block">/* heuristic */</comment><operator>)</operator></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>pStart</name> <init>= <expr><operator>*</operator><name>DTablePtr</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>pSize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_seqSymbol</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><call><name>SEQSYMBOL_TABLE_SIZE</name><argument_list>(<argument><expr><name>maxLog</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>PREFETCH_AREA</name><argument_list>(<argument><expr><name>pStart</name></expr></argument>, <argument><expr><name>pSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><name>set_compressed</name></expr> :</case>
        <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name></type> <name>tableLog</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>S16</name></type> <name><name>norm</name><index>[<expr><name>MaxSeq</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>headerSize</name> <init>= <expr><call><name>FSE_readNCount</name><argument_list>(<argument><expr><name>norm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tableLog</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>FSE_isError</name><argument_list>(<argument><expr><name>headerSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>tableLog</name> <operator>&gt;</operator> <name>maxLog</name></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZSTD_buildFSETable</name><argument_list>(<argument><expr><name>DTableSpace</name></expr></argument>, <argument><expr><name>norm</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>baseValue</name></expr></argument>, <argument><expr><name>nbAdditionalBits</name></expr></argument>, <argument><expr><name>tableLog</name></expr></argument>, <argument><expr><name>wksp</name></expr></argument>, <argument><expr><name>wkspSize</name></expr></argument>, <argument><expr><name>bmi2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>DTablePtr</name> <operator>=</operator> <name>DTableSpace</name></expr>;</expr_stmt>
            <return>return <expr><name>headerSize</name></expr>;</return>
        </block_content>}</block>
    <default>default :</default>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr><name>GENERIC</name></expr></argument>, <argument><expr><literal type="string">"impossible"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>ZSTD_decodeSeqHeaders</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>nbSeqPtr</name></decl></parameter>,
                             <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>istart</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>istart</name> <operator>+</operator> <name>srcSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><name>istart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nbSeq</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decodeSeqHeaders"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check */</comment>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>srcSize</name> <operator>&lt;</operator> <name>MIN_SEQUENCES_SIZE</name></expr></argument>, <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* SeqHead */</comment>
    <expr_stmt><expr><name>nbSeq</name> <operator>=</operator> <operator>*</operator><name>ip</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>nbSeq</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>nbSeqPtr</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>srcSize</name> <operator>!=</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>nbSeq</name> <operator>&gt;</operator> <literal type="number">0x7F</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>nbSeq</name> <operator>==</operator> <literal type="number">0xFF</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">2</literal> <operator>&gt;</operator> <name>iend</name></expr></argument>, <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nbSeq</name> <operator>=</operator> <call><name>MEM_readLE16</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>LONGNBSEQ</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ip</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>ip</name> <operator>&gt;=</operator> <name>iend</name></expr></argument>, <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nbSeq</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>nbSeq</name><operator>-</operator><literal type="number">0x80</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>*</operator><name>ip</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>nbSeqPtr</name> <operator>=</operator> <name>nbSeq</name></expr>;</expr_stmt>

    <comment type="block">/* FSE table descriptors */</comment>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">1</literal> <operator>&gt;</operator> <name>iend</name></expr></argument>, <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* minimum possible size: 1 byte for symbol encoding types */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>symbolEncodingType_e</name> <specifier>const</specifier></type> <name>LLtype</name> <init>= <expr><operator>(</operator><name>symbolEncodingType_e</name><operator>)</operator><operator>(</operator><operator>*</operator><name>ip</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>symbolEncodingType_e</name> <specifier>const</specifier></type> <name>OFtype</name> <init>= <expr><operator>(</operator><name>symbolEncodingType_e</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>ip</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">3</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>symbolEncodingType_e</name> <specifier>const</specifier></type> <name>MLtype</name> <init>= <expr><operator>(</operator><name>symbolEncodingType_e</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>ip</name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">3</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>ip</name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/* Build DTables */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>llhSize</name> <init>= <expr><call><name>ZSTD_buildSeqTable</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>LLTable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dctx</name><operator>-&gt;</operator><name>LLTptr</name></name></expr></argument>,
                                                      <argument><expr><name>LLtype</name></expr></argument>, <argument><expr><name>MaxLL</name></expr></argument>, <argument><expr><name>LLFSELog</name></expr></argument>,
                                                      <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name><operator>-</operator><name>ip</name></expr></argument>,
                                                      <argument><expr><name>LL_base</name></expr></argument>, <argument><expr><name>LL_bits</name></expr></argument>,
                                                      <argument><expr><name>LL_defaultDTable</name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>fseEntropy</name></name></expr></argument>,
                                                      <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictIsCold</name></name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>,
                                                      <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                                      <argument><expr><call><name>ZSTD_DCtx_get_bmi2</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>llhSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_buildSeqTable failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>llhSize</name></expr>;</expr_stmt>
        </block_content>}</block>

        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>ofhSize</name> <init>= <expr><call><name>ZSTD_buildSeqTable</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>OFTable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dctx</name><operator>-&gt;</operator><name>OFTptr</name></name></expr></argument>,
                                                      <argument><expr><name>OFtype</name></expr></argument>, <argument><expr><name>MaxOff</name></expr></argument>, <argument><expr><name>OffFSELog</name></expr></argument>,
                                                      <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name><operator>-</operator><name>ip</name></expr></argument>,
                                                      <argument><expr><name>OF_base</name></expr></argument>, <argument><expr><name>OF_bits</name></expr></argument>,
                                                      <argument><expr><name>OF_defaultDTable</name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>fseEntropy</name></name></expr></argument>,
                                                      <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictIsCold</name></name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>,
                                                      <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                                      <argument><expr><call><name>ZSTD_DCtx_get_bmi2</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>ofhSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_buildSeqTable failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>ofhSize</name></expr>;</expr_stmt>
        </block_content>}</block>

        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>mlhSize</name> <init>= <expr><call><name>ZSTD_buildSeqTable</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>MLTable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dctx</name><operator>-&gt;</operator><name>MLTptr</name></name></expr></argument>,
                                                      <argument><expr><name>MLtype</name></expr></argument>, <argument><expr><name>MaxML</name></expr></argument>, <argument><expr><name>MLFSELog</name></expr></argument>,
                                                      <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name><operator>-</operator><name>ip</name></expr></argument>,
                                                      <argument><expr><name>ML_base</name></expr></argument>, <argument><expr><name>ML_bits</name></expr></argument>,
                                                      <argument><expr><name>ML_defaultDTable</name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>fseEntropy</name></name></expr></argument>,
                                                      <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictIsCold</name></name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>,
                                                      <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>workspace</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                                      <argument><expr><call><name>ZSTD_DCtx_get_bmi2</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>mlhSize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">"ZSTD_buildSeqTable failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>mlhSize</name></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block>

    <return>return <expr><name>ip</name><operator>-</operator><name>istart</name></expr>;</return>
</block_content>}</block></function>


<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>litLength</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>matchLength</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>offset</name></decl>;</decl_stmt>
}</block></struct></type> <name>seq_t</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_seqSymbol</name><modifier>*</modifier></type> <name>table</name></decl>;</decl_stmt>
}</block></struct></type> <name>ZSTD_fseState</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>BIT_DStream_t</name></type> <name>DStream</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_fseState</name></type> <name>stateLL</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_fseState</name></type> <name>stateOffb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_fseState</name></type> <name>stateML</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name><name>prevOffset</name><index>[<expr><name>ZSTD_REP_NUM</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>seqState_t</name>;</typedef>

<comment type="block" format="doxygen">/*! ZSTD_overlapCopy8() :
 *  Copies 8 bytes from ip to op and updates op and ip where ip &lt;= op.
 *  If the offset is &lt; 8 then the offset is spread to at least 8 bytes.
 *
 *  Precondition: *ip &lt;= *op
 *  Postcondition: *op - *op &gt;= 8
 */</comment>
<function><type><name>HINT_INLINE</name> <name>void</name></type> <name>ZSTD_overlapCopy8</name><parameter_list>(<parameter><decl><type><name>BYTE</name><modifier>*</modifier><modifier>*</modifier></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier><modifier>*</modifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>ip</name> <operator>&lt;=</operator> <operator>*</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* close range match, overlap */</comment>
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>U32</name></type> <name><name>dec32table</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr> }</block></expr></init></decl>;</decl_stmt>   <comment type="block">/* added */</comment>
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>dec64table</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">8</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">9</literal></expr>,<expr><literal type="number">10</literal></expr>,<expr><literal type="number">11</literal></expr> }</block></expr></init></decl>;</decl_stmt>   <comment type="block">/* subtracted */</comment>
        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>sub2</name> <init>= <expr><name><name>dec64table</name><index>[<expr><name>offset</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>op</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>*</operator><name>ip</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>op</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>*</operator><name>ip</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>op</name><operator>)</operator><index>[<expr><literal type="number">2</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>*</operator><name>ip</name><operator>)</operator><index>[<expr><literal type="number">2</literal></expr>]</index></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>op</name><operator>)</operator><index>[<expr><literal type="number">3</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>*</operator><name>ip</name><operator>)</operator><index>[<expr><literal type="number">3</literal></expr>]</index></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>ip</name> <operator>+=</operator> <name><name>dec32table</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_copy4</name><argument_list>(<argument><expr><operator>*</operator><name>op</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><operator>*</operator><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>ip</name> <operator>-=</operator> <name>sub2</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_copy8</name><argument_list>(<argument><expr><operator>*</operator><name>op</name></expr></argument>, <argument><expr><operator>*</operator><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>ip</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>op</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>op</name> <operator>-</operator> <operator>*</operator><name>ip</name> <operator>&gt;=</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*! ZSTD_safecopy() :
 *  Specialized version of memcpy() that is allowed to READ up to WILDCOPY_OVERLENGTH past the input buffer
 *  and write up to 16 bytes past oend_w (op &gt;= oend_w is allowed).
 *  This function is only called in the uncommon case where the sequence is near the end of the block. It
 *  should be fast for a single long sequence, but can be slow for several short sequences.
 *
 *  @param ovtype controls the overlap detection
 *         - ZSTD_no_overlap: The source and destination are guaranteed to be at least WILDCOPY_VECLEN bytes apart.
 *         - ZSTD_overlap_src_before_dst: The src and dst may overlap and may be any distance apart.
 *           The src buffer must be before the dst buffer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_safecopy</name><parameter_list>(<parameter><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend_w</name></decl></parameter>, <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>ZSTD_overlap_e</name></type> <name>ovtype</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>ptrdiff_t</name> <specifier>const</specifier></type> <name>diff</name> <init>= <expr><name>op</name> <operator>-</operator> <name>ip</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><name>op</name> <operator>+</operator> <name>length</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>ovtype</name> <operator>==</operator> <name>ZSTD_no_overlap</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>diff</name> <operator>&lt;=</operator> <operator>-</operator><literal type="number">8</literal> <operator>||</operator> <name>diff</name> <operator>&gt;=</operator> <literal type="number">8</literal> <operator>||</operator> <name>op</name> <operator>&gt;=</operator> <name>oend_w</name><operator>)</operator><operator>)</operator> <operator>||</operator>
           <operator>(</operator><name>ovtype</name> <operator>==</operator> <name>ZSTD_overlap_src_before_dst</name> <operator>&amp;&amp;</operator> <name>diff</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>length</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Handle short lengths. */</comment>
        <while>while <condition>(<expr><name>op</name> <operator>&lt;</operator> <name>oend</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>ip</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>ovtype</name> <operator>==</operator> <name>ZSTD_overlap_src_before_dst</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Copy 8 bytes and ensure the offset &gt;= 8 when there can be overlap. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>length</name> <operator>&gt;=</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_overlapCopy8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>length</name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>-</operator> <name>ip</name> <operator>&gt;=</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;=</operator> <name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>oend</name> <operator>&lt;=</operator> <name>oend_w</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* No risk of overwrite. */</comment>
        <expr_stmt><expr><call><name>ZSTD_wildcopy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>ovtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>op</name> <operator>&lt;=</operator> <name>oend_w</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Wildcopy until we get close to the end. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oend</name> <operator>&gt;</operator> <name>oend_w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_wildcopy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>oend_w</name> <operator>-</operator> <name>op</name></expr></argument>, <argument><expr><name>ovtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>oend_w</name> <operator>-</operator> <name>op</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>oend_w</name> <operator>-</operator> <name>op</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Handle the leftovers. */</comment>
    <while>while <condition>(<expr><name>op</name> <operator>&lt;</operator> <name>oend</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>ip</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<comment type="block">/* ZSTD_safecopyDstBeforeSrc():
 * This version allows overlap with dst before src, or handles the non-overlap case with dst after src
 * Kept separate from more common ZSTD_safecopy case to avoid performance impact to the safecopy common case */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ZSTD_safecopyDstBeforeSrc</name><parameter_list>(<parameter><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>ip</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>ptrdiff_t</name> <specifier>const</specifier></type> <name>diff</name> <init>= <expr><name>op</name> <operator>-</operator> <name>ip</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><name>op</name> <operator>+</operator> <name>length</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>length</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">8</literal> <operator>||</operator> <name>diff</name></expr></argument> &gt;</argument_list></name> <operator>-</operator><literal type="number">8</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Handle short lengths, close overlaps, and dst not before src. */</comment>
        <while>while <condition>(<expr><name>op</name> <operator>&lt;</operator> <name>oend</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>ip</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>op</name> <operator>&lt;=</operator> <name>oend</name> <operator>-</operator> <name>WILDCOPY_OVERLENGTH</name> <operator>&amp;&amp;</operator> <name>diff</name> <operator>&lt;</operator> <operator>-</operator><name>WILDCOPY_VECLEN</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_wildcopy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>oend</name> <operator>-</operator> <name>WILDCOPY_OVERLENGTH</name> <operator>-</operator> <name>op</name></expr></argument>, <argument><expr><name>ZSTD_no_overlap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>oend</name> <operator>-</operator> <name>WILDCOPY_OVERLENGTH</name> <operator>-</operator> <name>op</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>oend</name> <operator>-</operator> <name>WILDCOPY_OVERLENGTH</name> <operator>-</operator> <name>op</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Handle the leftovers. */</comment>
    <while>while <condition>(<expr><name>op</name> <operator>&lt;</operator> <name>oend</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>op</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>ip</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<comment type="block">/* ZSTD_execSequenceEnd():
 * This version handles cases that are near the end of the output buffer. It requires
 * more careful checks to make sure there is no overflow. By separating out these hard
 * and unlikely cases, we can speed up the common cases.
 *
 * NOTE: This function needs to be fast for a single long sequence, but doesn't need
 * to be optimized for many small sequences, since those fall into ZSTD_execSequence().
 */</comment>
<function><type><name>FORCE_NOINLINE</name>
<name>size_t</name></type> <name>ZSTD_execSequenceEnd</name><parameter_list>(<parameter><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name></decl></parameter>,
    <parameter><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name></decl></parameter>, <parameter><decl><type><name>seq_t</name></type> <name>sequence</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier><modifier>*</modifier></type> <name>litPtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>litLimit</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>virtualStart</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oLitEnd</name> <init>= <expr><name>op</name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>litLength</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>sequenceLength</name> <init>= <expr><name><name>sequence</name><operator>.</operator><name>litLength</name></name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>matchLength</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iLitEnd</name> <init>= <expr><operator>*</operator><name>litPtr</name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>litLength</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match</name> <init>= <expr><name>oLitEnd</name> <operator>-</operator> <name><name>sequence</name><operator>.</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend_w</name> <init>= <expr><name>oend</name> <operator>-</operator> <name>WILDCOPY_OVERLENGTH</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* bounds checks : careful of address space overflow in 32-bit mode */</comment>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>sequenceLength</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"last match must fit within dstBuffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>sequence</name><operator>.</operator><name>litLength</name></name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>litLimit</name> <operator>-</operator> <operator>*</operator><name>litPtr</name><operator>)</operator></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">"try to read beyond literal buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;</operator> <name>op</name> <operator>+</operator> <name>sequenceLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oLitEnd</name> <operator>&lt;</operator> <name>op</name> <operator>+</operator> <name>sequenceLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* copy literals */</comment>
    <expr_stmt><expr><call><name>ZSTD_safecopy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend_w</name></expr></argument>, <argument><expr><operator>*</operator><name>litPtr</name></expr></argument>, <argument><expr><name><name>sequence</name><operator>.</operator><name>litLength</name></name></expr></argument>, <argument><expr><name>ZSTD_no_overlap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>oLitEnd</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>litPtr</name> <operator>=</operator> <name>iLitEnd</name></expr>;</expr_stmt>

    <comment type="block">/* copy Match */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sequence</name><operator>.</operator><name>offset</name></name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oLitEnd</name> <operator>-</operator> <name>prefixStart</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <comment type="block">/* offset beyond prefix */</comment>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>sequence</name><operator>.</operator><name>offset</name></name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oLitEnd</name> <operator>-</operator> <name>virtualStart</name><operator>)</operator></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>match</name> <operator>=</operator> <name>dictEnd</name> <operator>-</operator> <operator>(</operator><name>prefixStart</name> <operator>-</operator> <name>match</name><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>match</name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>matchLength</name></name> <operator>&lt;=</operator> <name>dictEnd</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ZSTD_memmove</name><argument_list>(<argument><expr><name>oLitEnd</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name><name>sequence</name><operator>.</operator><name>matchLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>sequenceLength</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* span extDict &amp; currentPrefixSegment */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>length1</name> <init>= <expr><name>dictEnd</name> <operator>-</operator> <name>match</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTD_memmove</name><argument_list>(<argument><expr><name>oLitEnd</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>length1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>=</operator> <name>oLitEnd</name> <operator>+</operator> <name>length1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sequence</name><operator>.</operator><name>matchLength</name></name> <operator>-=</operator> <name>length1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>match</name> <operator>=</operator> <name>prefixStart</name></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTD_safecopy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend_w</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name><name>sequence</name><operator>.</operator><name>matchLength</name></name></expr></argument>, <argument><expr><name>ZSTD_overlap_src_before_dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>sequenceLength</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ZSTD_execSequenceEndSplitLitBuffer():
 * This version is intended to be used during instances where the litBuffer is still split.  It is kept separate to avoid performance impact for the good case.
 */</comment>
<function><type><name>FORCE_NOINLINE</name>
<name>size_t</name></type> <name>ZSTD_execSequenceEndSplitLitBuffer</name><parameter_list>(<parameter><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name></decl></parameter>,
    <parameter><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend_w</name></decl></parameter>, <parameter><decl><type><name>seq_t</name></type> <name>sequence</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier><modifier>*</modifier></type> <name>litPtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>litLimit</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>virtualStart</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oLitEnd</name> <init>= <expr><name>op</name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>litLength</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>sequenceLength</name> <init>= <expr><name><name>sequence</name><operator>.</operator><name>litLength</name></name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>matchLength</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iLitEnd</name> <init>= <expr><operator>*</operator><name>litPtr</name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>litLength</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match</name> <init>= <expr><name>oLitEnd</name> <operator>-</operator> <name><name>sequence</name><operator>.</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>


    <comment type="block">/* bounds checks : careful of address space overflow in 32-bit mode */</comment>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>sequenceLength</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"last match must fit within dstBuffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>sequence</name><operator>.</operator><name>litLength</name></name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>litLimit</name> <operator>-</operator> <operator>*</operator><name>litPtr</name><operator>)</operator></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">"try to read beyond literal buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;</operator> <name>op</name> <operator>+</operator> <name>sequenceLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oLitEnd</name> <operator>&lt;</operator> <name>op</name> <operator>+</operator> <name>sequenceLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* copy literals */</comment>
    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>op</name> <operator>&gt;</operator> <operator>*</operator><name>litPtr</name> <operator>&amp;&amp;</operator> <name>op</name> <operator>&lt;</operator> <operator>*</operator><name>litPtr</name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>litLength</name></name></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"output should not catch up to and overwrite literal buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_safecopyDstBeforeSrc</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>*</operator><name>litPtr</name></expr></argument>, <argument><expr><name><name>sequence</name><operator>.</operator><name>litLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>oLitEnd</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>litPtr</name> <operator>=</operator> <name>iLitEnd</name></expr>;</expr_stmt>

    <comment type="block">/* copy Match */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sequence</name><operator>.</operator><name>offset</name></name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oLitEnd</name> <operator>-</operator> <name>prefixStart</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <comment type="block">/* offset beyond prefix */</comment>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name><name>sequence</name><operator>.</operator><name>offset</name></name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oLitEnd</name> <operator>-</operator> <name>virtualStart</name><operator>)</operator></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>match</name> <operator>=</operator> <name>dictEnd</name> <operator>-</operator> <operator>(</operator><name>prefixStart</name> <operator>-</operator> <name>match</name><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>match</name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>matchLength</name></name> <operator>&lt;=</operator> <name>dictEnd</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ZSTD_memmove</name><argument_list>(<argument><expr><name>oLitEnd</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name><name>sequence</name><operator>.</operator><name>matchLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>sequenceLength</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* span extDict &amp; currentPrefixSegment */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>length1</name> <init>= <expr><name>dictEnd</name> <operator>-</operator> <name>match</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTD_memmove</name><argument_list>(<argument><expr><name>oLitEnd</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>length1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>=</operator> <name>oLitEnd</name> <operator>+</operator> <name>length1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sequence</name><operator>.</operator><name>matchLength</name></name> <operator>-=</operator> <name>length1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>match</name> <operator>=</operator> <name>prefixStart</name></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ZSTD_safecopy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend_w</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name><name>sequence</name><operator>.</operator><name>matchLength</name></name></expr></argument>, <argument><expr><name>ZSTD_overlap_src_before_dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>sequenceLength</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>HINT_INLINE</name>
<name>size_t</name></type> <name>ZSTD_execSequence</name><parameter_list>(<parameter><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name></decl></parameter>,
    <parameter><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name></decl></parameter>, <parameter><decl><type><name>seq_t</name></type> <name>sequence</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier><modifier>*</modifier></type> <name>litPtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>litLimit</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>virtualStart</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oLitEnd</name> <init>= <expr><name>op</name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>litLength</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>sequenceLength</name> <init>= <expr><name><name>sequence</name><operator>.</operator><name>litLength</name></name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>matchLength</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oMatchEnd</name> <init>= <expr><name>op</name> <operator>+</operator> <name>sequenceLength</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* risk : address space overflow (32-bits) */</comment>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend_w</name> <init>= <expr><name>oend</name> <operator>-</operator> <name>WILDCOPY_OVERLENGTH</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* risk : address space underflow on oend=NULL */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iLitEnd</name> <init>= <expr><operator>*</operator><name>litPtr</name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>litLength</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match</name> <init>= <expr><name>oLitEnd</name> <operator>-</operator> <name><name>sequence</name><operator>.</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>!=</operator> <name>NULL</name></expr></argument> <comment type="block">/* Precondition */</comment>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oend_w</name> <operator>&lt;</operator> <name>oend</name></expr></argument> <comment type="block">/* No underflow */</comment>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__aarch64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* prefetch sequence starting from match that will be used for copy later */</comment>
    <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Handle edge cases in a slow path:
     *   - Read beyond end of literals
     *   - Match end is within WILDCOPY_OVERLIMIT of oend
     *   - 32-bit mode and the match length overflows
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(
        <argument><expr><name>iLitEnd</name> <operator>&gt;</operator> <name>litLimit</name> <operator>||</operator>
        <name>oMatchEnd</name> <operator>&gt;</operator> <name>oend_w</name> <operator>||</operator>
        <operator>(</operator><call><name>MEM_32bits</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator> <operator>&lt;</operator> <name>sequenceLength</name> <operator>+</operator> <name>WILDCOPY_OVERLENGTH</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>ZSTD_execSequenceEnd</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name>sequence</name></expr></argument>, <argument><expr><name>litPtr</name></expr></argument>, <argument><expr><name>litLimit</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>virtualStart</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Assumptions (everything else goes into ZSTD_execSequenceEnd()) */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;=</operator> <name>oLitEnd</name></expr></argument> <comment type="block">/* No overflow */</comment>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oLitEnd</name> <operator>&lt;</operator> <name>oMatchEnd</name></expr></argument> <comment type="block">/* Non-zero match &amp; no overflow */</comment>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oMatchEnd</name> <operator>&lt;=</operator> <name>oend</name></expr></argument> <comment type="block">/* No underflow */</comment>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>iLitEnd</name> <operator>&lt;=</operator> <name>litLimit</name></expr></argument> <comment type="block">/* Literal length is in bounds */</comment>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oLitEnd</name> <operator>&lt;=</operator> <name>oend_w</name></expr></argument> <comment type="block">/* Can wildcopy literals */</comment>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oMatchEnd</name> <operator>&lt;=</operator> <name>oend_w</name></expr></argument> <comment type="block">/* Can wildcopy matches */</comment>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Copy Literals:
     * Split out litLength &lt;= 16 since it is nearly always true. +1.6% on gcc-9.
     * We likely don't need the full 32-byte wildcopy.
     */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>WILDCOPY_OVERLENGTH</name> <operator>&gt;=</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_copy16</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>litPtr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name><name>sequence</name><operator>.</operator><name>litLength</name></name> <operator>&gt;</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_wildcopy</name><argument_list>(<argument><expr><name>op</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>litPtr</name><operator>)</operator> <operator>+</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><name><name>sequence</name><operator>.</operator><name>litLength</name></name> <operator>-</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><name>ZSTD_no_overlap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>oLitEnd</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>litPtr</name> <operator>=</operator> <name>iLitEnd</name></expr>;</expr_stmt>   <comment type="block">/* update for next sequence */</comment>

    <comment type="block">/* Copy Match */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sequence</name><operator>.</operator><name>offset</name></name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oLitEnd</name> <operator>-</operator> <name>prefixStart</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <comment type="block">/* offset beyond prefix -&gt; go into extDict */</comment>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name><name>sequence</name><operator>.</operator><name>offset</name></name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oLitEnd</name> <operator>-</operator> <name>virtualStart</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>match</name> <operator>=</operator> <name>dictEnd</name> <operator>+</operator> <operator>(</operator><name>match</name> <operator>-</operator> <name>prefixStart</name><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>match</name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>matchLength</name></name> <operator>&lt;=</operator> <name>dictEnd</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ZSTD_memmove</name><argument_list>(<argument><expr><name>oLitEnd</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name><name>sequence</name><operator>.</operator><name>matchLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>sequenceLength</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* span extDict &amp; currentPrefixSegment */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>length1</name> <init>= <expr><name>dictEnd</name> <operator>-</operator> <name>match</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ZSTD_memmove</name><argument_list>(<argument><expr><name>oLitEnd</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>length1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>=</operator> <name>oLitEnd</name> <operator>+</operator> <name>length1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sequence</name><operator>.</operator><name>matchLength</name></name> <operator>-=</operator> <name>length1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>match</name> <operator>=</operator> <name>prefixStart</name></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Match within prefix of 1 or more bytes */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;=</operator> <name>oMatchEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oMatchEnd</name> <operator>&lt;=</operator> <name>oend_w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>match</name> <operator>&gt;=</operator> <name>prefixStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>sequence</name><operator>.</operator><name>matchLength</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Nearly all offsets are &gt;= WILDCOPY_VECLEN bytes, which means we can use wildcopy
     * without overlap checking.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><name><name>sequence</name><operator>.</operator><name>offset</name></name> <operator>&gt;=</operator> <name>WILDCOPY_VECLEN</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* We bet on a full wildcopy for matches, since we expect matches to be
         * longer than literals (in general). In silesia, ~10% of matches are longer
         * than 16 bytes.
         */</comment>
        <expr_stmt><expr><call><name>ZSTD_wildcopy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name><name>sequence</name><operator>.</operator><name>matchLength</name></name></expr></argument>, <argument><expr><name>ZSTD_no_overlap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>sequenceLength</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>sequence</name><operator>.</operator><name>offset</name></name> <operator>&lt;</operator> <name>WILDCOPY_VECLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Copy 8 bytes and spread the offset to be &gt;= 8. */</comment>
    <expr_stmt><expr><call><name>ZSTD_overlapCopy8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>match</name></expr></argument>, <argument><expr><name><name>sequence</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the match length is &gt; 8 bytes, then continue with the wildcopy. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sequence</name><operator>.</operator><name>matchLength</name></name> <operator>&gt;</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;</operator> <name>oMatchEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_wildcopy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name><name>sequence</name><operator>.</operator><name>matchLength</name></name> <operator>-</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>ZSTD_overlap_src_before_dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>sequenceLength</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>HINT_INLINE</name>
<name>size_t</name></type> <name>ZSTD_execSequenceSplitLitBuffer</name><parameter_list>(<parameter><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name></decl></parameter>,
    <parameter><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend_w</name></decl></parameter>, <parameter><decl><type><name>seq_t</name></type> <name>sequence</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier><modifier>*</modifier></type> <name>litPtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>litLimit</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>virtualStart</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oLitEnd</name> <init>= <expr><name>op</name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>litLength</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>sequenceLength</name> <init>= <expr><name><name>sequence</name><operator>.</operator><name>litLength</name></name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>matchLength</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oMatchEnd</name> <init>= <expr><name>op</name> <operator>+</operator> <name>sequenceLength</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* risk : address space overflow (32-bits) */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iLitEnd</name> <init>= <expr><operator>*</operator><name>litPtr</name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>litLength</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>match</name> <init>= <expr><name>oLitEnd</name> <operator>-</operator> <name><name>sequence</name><operator>.</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>!=</operator> <name>NULL</name></expr></argument> <comment type="block">/* Precondition */</comment>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oend_w</name> <operator>&lt;</operator> <name>oend</name></expr></argument> <comment type="block">/* No underflow */</comment>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Handle edge cases in a slow path:
     *   - Read beyond end of literals
     *   - Match end is within WILDCOPY_OVERLIMIT of oend
     *   - 32-bit mode and the match length overflows
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(
            <argument><expr><name>iLitEnd</name> <operator>&gt;</operator> <name>litLimit</name> <operator>||</operator>
            <name>oMatchEnd</name> <operator>&gt;</operator> <name>oend_w</name> <operator>||</operator>
            <operator>(</operator><call><name>MEM_32bits</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator> <operator>&lt;</operator> <name>sequenceLength</name> <operator>+</operator> <name>WILDCOPY_OVERLENGTH</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>ZSTD_execSequenceEndSplitLitBuffer</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name>oend_w</name></expr></argument>, <argument><expr><name>sequence</name></expr></argument>, <argument><expr><name>litPtr</name></expr></argument>, <argument><expr><name>litLimit</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>virtualStart</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Assumptions (everything else goes into ZSTD_execSequenceEnd()) */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;=</operator> <name>oLitEnd</name></expr></argument> <comment type="block">/* No overflow */</comment>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oLitEnd</name> <operator>&lt;</operator> <name>oMatchEnd</name></expr></argument> <comment type="block">/* Non-zero match &amp; no overflow */</comment>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oMatchEnd</name> <operator>&lt;=</operator> <name>oend</name></expr></argument> <comment type="block">/* No underflow */</comment>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>iLitEnd</name> <operator>&lt;=</operator> <name>litLimit</name></expr></argument> <comment type="block">/* Literal length is in bounds */</comment>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oLitEnd</name> <operator>&lt;=</operator> <name>oend_w</name></expr></argument> <comment type="block">/* Can wildcopy literals */</comment>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oMatchEnd</name> <operator>&lt;=</operator> <name>oend_w</name></expr></argument> <comment type="block">/* Can wildcopy matches */</comment>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Copy Literals:
     * Split out litLength &lt;= 16 since it is nearly always true. +1.6% on gcc-9.
     * We likely don't need the full 32-byte wildcopy.
     */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>WILDCOPY_OVERLENGTH</name> <operator>&gt;=</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_copy16</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>litPtr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name><name>sequence</name><operator>.</operator><name>litLength</name></name> <operator>&gt;</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ZSTD_wildcopy</name><argument_list>(<argument><expr><name>op</name><operator>+</operator><literal type="number">16</literal></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>litPtr</name><operator>)</operator><operator>+</operator><literal type="number">16</literal></expr></argument>, <argument><expr><name><name>sequence</name><operator>.</operator><name>litLength</name></name><operator>-</operator><literal type="number">16</literal></expr></argument>, <argument><expr><name>ZSTD_no_overlap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>oLitEnd</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>litPtr</name> <operator>=</operator> <name>iLitEnd</name></expr>;</expr_stmt>   <comment type="block">/* update for next sequence */</comment>

    <comment type="block">/* Copy Match */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sequence</name><operator>.</operator><name>offset</name></name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oLitEnd</name> <operator>-</operator> <name>prefixStart</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <comment type="block">/* offset beyond prefix -&gt; go into extDict */</comment>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name><name>sequence</name><operator>.</operator><name>offset</name></name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oLitEnd</name> <operator>-</operator> <name>virtualStart</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>match</name> <operator>=</operator> <name>dictEnd</name> <operator>+</operator> <operator>(</operator><name>match</name> <operator>-</operator> <name>prefixStart</name><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>match</name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>matchLength</name></name> <operator>&lt;=</operator> <name>dictEnd</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ZSTD_memmove</name><argument_list>(<argument><expr><name>oLitEnd</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name><name>sequence</name><operator>.</operator><name>matchLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>sequenceLength</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* span extDict &amp; currentPrefixSegment */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>length1</name> <init>= <expr><name>dictEnd</name> <operator>-</operator> <name>match</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ZSTD_memmove</name><argument_list>(<argument><expr><name>oLitEnd</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>length1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> <operator>=</operator> <name>oLitEnd</name> <operator>+</operator> <name>length1</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sequence</name><operator>.</operator><name>matchLength</name></name> <operator>-=</operator> <name>length1</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>match</name> <operator>=</operator> <name>prefixStart</name></expr>;</expr_stmt>
    </block_content>}</block>   </block_content>}</block></if></if_stmt>
    <comment type="block">/* Match within prefix of 1 or more bytes */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;=</operator> <name>oMatchEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oMatchEnd</name> <operator>&lt;=</operator> <name>oend_w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>match</name> <operator>&gt;=</operator> <name>prefixStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>sequence</name><operator>.</operator><name>matchLength</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Nearly all offsets are &gt;= WILDCOPY_VECLEN bytes, which means we can use wildcopy
     * without overlap checking.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><name><name>sequence</name><operator>.</operator><name>offset</name></name> <operator>&gt;=</operator> <name>WILDCOPY_VECLEN</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* We bet on a full wildcopy for matches, since we expect matches to be
         * longer than literals (in general). In silesia, ~10% of matches are longer
         * than 16 bytes.
         */</comment>
        <expr_stmt><expr><call><name>ZSTD_wildcopy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name><name>sequence</name><operator>.</operator><name>matchLength</name></name></expr></argument>, <argument><expr><name>ZSTD_no_overlap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>sequenceLength</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>sequence</name><operator>.</operator><name>offset</name></name> <operator>&lt;</operator> <name>WILDCOPY_VECLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Copy 8 bytes and spread the offset to be &gt;= 8. */</comment>
    <expr_stmt><expr><call><name>ZSTD_overlapCopy8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>match</name></expr></argument>, <argument><expr><name><name>sequence</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the match length is &gt; 8 bytes, then continue with the wildcopy. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sequence</name><operator>.</operator><name>matchLength</name></name> <operator>&gt;</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;</operator> <name>oMatchEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_wildcopy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name><name>sequence</name><operator>.</operator><name>matchLength</name></name><operator>-</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>ZSTD_overlap_src_before_dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>sequenceLength</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>ZSTD_initFseState</name><parameter_list>(<parameter><decl><type><name>ZSTD_fseState</name><modifier>*</modifier></type> <name>DStatePtr</name></decl></parameter>, <parameter><decl><type><name>BIT_DStream_t</name><modifier>*</modifier></type> <name>bitD</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_seqSymbol</name><modifier>*</modifier></type> <name>dt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>ptr</name> <init>= <expr><name>dt</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_seqSymbol_header</name><modifier>*</modifier> <specifier>const</specifier></type> <name>DTableH</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ZSTD_seqSymbol_header</name><operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>DStatePtr</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <call><name>BIT_readBits</name><argument_list>(<argument><expr><name>bitD</name></expr></argument>, <argument><expr><name><name>DTableH</name><operator>-&gt;</operator><name>tableLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_initFseState : val=%u using %u bits"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>DStatePtr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name><name>DTableH</name><operator>-&gt;</operator><name>tableLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><name>bitD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>DStatePtr</name><operator>-&gt;</operator><name>table</name></name> <operator>=</operator> <name>dt</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>void</name></type>
<name>ZSTD_updateFseStateWithDInfo</name><parameter_list>(<parameter><decl><type><name>ZSTD_fseState</name><modifier>*</modifier></type> <name>DStatePtr</name></decl></parameter>, <parameter><decl><type><name>BIT_DStream_t</name><modifier>*</modifier></type> <name>bitD</name></decl></parameter>, <parameter><decl><type><name>U16</name></type> <name>nextState</name></decl></parameter>, <parameter><decl><type><name>U32</name></type> <name>nbBits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>lowBits</name> <init>= <expr><call><name>BIT_readBits</name><argument_list>(<argument><expr><name>bitD</name></expr></argument>, <argument><expr><name>nbBits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>DStatePtr</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>nextState</name> <operator>+</operator> <name>lowBits</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* We need to add at most (ZSTD_WINDOWLOG_MAX_32 - 1) bits to read the maximum
 * offset bits. But we can only read at most (STREAM_ACCUMULATOR_MIN_32 - 1)
 * bits before reloading. This value is the maximum number of bytes we read
 * after reloading when we are decoding long offsets.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LONG_OFFSETS_MAX_EXTRA_BITS_32</name></cpp:macro>                       \
    <cpp:value>(ZSTD_WINDOWLOG_MAX_32 &gt; STREAM_ACCUMULATOR_MIN_32       \
        ? ZSTD_WINDOWLOG_MAX_32 - STREAM_ACCUMULATOR_MIN_32  \
        : 0)</cpp:value></cpp:define>

<typedef>typedef <type><enum>enum <block>{ <decl><name>ZSTD_lo_isRegularOffset</name></decl>, <decl><name>ZSTD_lo_isLongOffset</name><init>=<expr><literal type="number">1</literal></expr></init></decl> }</block></enum></type> <name>ZSTD_longOffset_e</name>;</typedef>

<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>seq_t</name></type>
<name>ZSTD_decodeSequence</name><parameter_list>(<parameter><decl><type><name>seqState_t</name><modifier>*</modifier></type> <name>seqState</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ZSTD_longOffset_e</name></type> <name>longOffsets</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>seq_t</name></type> <name>seq</name></decl>;</decl_stmt>
    <comment type="block">/*
     * ZSTD_seqSymbol is a structure with a total of 64 bits wide. So it can be
     * loaded in one operation and extracted its fields by simply shifting or
     * bit-extracting on aarch64.
     * GCC doesn't recognize this and generates more unnecessary ldr/ldrb/ldrh
     * operations that cause performance drop. This can be avoided by using this
     * ZSTD_memcpy hack.
     */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__aarch64__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
    <decl_stmt><decl><type><name>ZSTD_seqSymbol</name></type> <name>llDInfoS</name></decl>, <decl><type ref="prev"/><name>mlDInfoS</name></decl>, <decl><type ref="prev"/><name>ofDInfoS</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_seqSymbol</name><modifier>*</modifier> <specifier>const</specifier></type> <name>llDInfo</name> <init>= <expr><operator>&amp;</operator><name>llDInfoS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_seqSymbol</name><modifier>*</modifier> <specifier>const</specifier></type> <name>mlDInfo</name> <init>= <expr><operator>&amp;</operator><name>mlDInfoS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_seqSymbol</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ofDInfo</name> <init>= <expr><operator>&amp;</operator><name>ofDInfoS</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>llDInfo</name></expr></argument>, <argument><expr><name><name>seqState</name><operator>-&gt;</operator><name>stateLL</name><operator>.</operator><name>table</name></name> <operator>+</operator> <name><name>seqState</name><operator>-&gt;</operator><name>stateLL</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_seqSymbol</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>mlDInfo</name></expr></argument>, <argument><expr><name><name>seqState</name><operator>-&gt;</operator><name>stateML</name><operator>.</operator><name>table</name></name> <operator>+</operator> <name><name>seqState</name><operator>-&gt;</operator><name>stateML</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_seqSymbol</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>ofDInfo</name></expr></argument>, <argument><expr><name><name>seqState</name><operator>-&gt;</operator><name>stateOffb</name><operator>.</operator><name>table</name></name> <operator>+</operator> <name><name>seqState</name><operator>-&gt;</operator><name>stateOffb</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZSTD_seqSymbol</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_seqSymbol</name><modifier>*</modifier> <specifier>const</specifier></type> <name>llDInfo</name> <init>= <expr><name><name>seqState</name><operator>-&gt;</operator><name>stateLL</name><operator>.</operator><name>table</name></name> <operator>+</operator> <name><name>seqState</name><operator>-&gt;</operator><name>stateLL</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_seqSymbol</name><modifier>*</modifier> <specifier>const</specifier></type> <name>mlDInfo</name> <init>= <expr><name><name>seqState</name><operator>-&gt;</operator><name>stateML</name><operator>.</operator><name>table</name></name> <operator>+</operator> <name><name>seqState</name><operator>-&gt;</operator><name>stateML</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_seqSymbol</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ofDInfo</name> <init>= <expr><name><name>seqState</name><operator>-&gt;</operator><name>stateOffb</name><operator>.</operator><name>table</name></name> <operator>+</operator> <name><name>seqState</name><operator>-&gt;</operator><name>stateOffb</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>seq</name><operator>.</operator><name>matchLength</name></name> <operator>=</operator> <name><name>mlDInfo</name><operator>-&gt;</operator><name>baseValue</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>seq</name><operator>.</operator><name>litLength</name></name> <operator>=</operator> <name><name>llDInfo</name><operator>-&gt;</operator><name>baseValue</name></name></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>ofBase</name> <init>= <expr><name><name>ofDInfo</name><operator>-&gt;</operator><name>baseValue</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier></type> <name>llBits</name> <init>= <expr><name><name>llDInfo</name><operator>-&gt;</operator><name>nbAdditionalBits</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier></type> <name>mlBits</name> <init>= <expr><name><name>mlDInfo</name><operator>-&gt;</operator><name>nbAdditionalBits</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier></type> <name>ofBits</name> <init>= <expr><name><name>ofDInfo</name><operator>-&gt;</operator><name>nbAdditionalBits</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier></type> <name>totalBits</name> <init>= <expr><name>llBits</name><operator>+</operator><name>mlBits</name><operator>+</operator><name>ofBits</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>U16</name> <specifier>const</specifier></type> <name>llNext</name> <init>= <expr><name><name>llDInfo</name><operator>-&gt;</operator><name>nextState</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U16</name> <specifier>const</specifier></type> <name>mlNext</name> <init>= <expr><name><name>mlDInfo</name><operator>-&gt;</operator><name>nextState</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U16</name> <specifier>const</specifier></type> <name>ofNext</name> <init>= <expr><name><name>ofDInfo</name><operator>-&gt;</operator><name>nextState</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>llnbBits</name> <init>= <expr><name><name>llDInfo</name><operator>-&gt;</operator><name>nbBits</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>mlnbBits</name> <init>= <expr><name><name>mlDInfo</name><operator>-&gt;</operator><name>nbBits</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>ofnbBits</name> <init>= <expr><name><name>ofDInfo</name><operator>-&gt;</operator><name>nbBits</name></name></expr></init></decl>;</decl_stmt>
        <comment type="block">/*
         * As gcc has better branch and block analyzers, sometimes it is only
         * valuable to mark likeliness for clang, it gives around 3-4% of
         * performance.
         */</comment>

        <comment type="block">/* sequence */</comment>
        <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>offset</name></decl>;</decl_stmt>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call></expr></cpp:if>
            <if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><name>ofBits</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <if_stmt><if>if <condition>(<expr><name>ofBits</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><name>ZSTD_lo_isLongOffset</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><name>LONG_OFFSETS_MAX_EXTRA_BITS_32</name> <operator>==</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ofBits</name> <operator>&lt;=</operator> <name>MaxOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>MEM_32bits</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>longOffsets</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ofBits</name> <operator>&gt;=</operator> <name>STREAM_ACCUMULATOR_MIN_32</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>extraBits</name> <init>= <expr><name>ofBits</name> <operator>-</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>ofBits</name></expr></argument>, <argument><expr><literal type="number">32</literal> <operator>-</operator> <name><name>seqState</name><operator>-&gt;</operator><name>DStream</name><operator>.</operator><name>bitsConsumed</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>ofBase</name> <operator>+</operator> <operator>(</operator><call><name>BIT_readBitsFast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>-&gt;</operator><name>DStream</name></name></expr></argument>, <argument><expr><name>ofBits</name> <operator>-</operator> <name>extraBits</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>extraBits</name><operator>)</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>-&gt;</operator><name>DStream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>extraBits</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>BIT_readBitsFast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>-&gt;</operator><name>DStream</name></name></expr></argument>, <argument><expr><name>extraBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>extraBits</name> <operator>&lt;=</operator> <name>LONG_OFFSETS_MAX_EXTRA_BITS_32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* to avoid another reload */</comment>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>ofBase</name> <operator>+</operator> <call><name>BIT_readBitsFast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>-&gt;</operator><name>DStream</name></name></expr></argument>, <argument><expr><name>ofBits</name></expr></argument><comment type="block">/*&gt;0*/</comment>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* &lt;=  (ZSTD_WINDOWLOG_MAX-1) bits */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>MEM_32bits</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>-&gt;</operator><name>DStream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name><name>seqState</name><operator>-&gt;</operator><name>prevOffset</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>seqState</name><operator>-&gt;</operator><name>prevOffset</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>seqState</name><operator>-&gt;</operator><name>prevOffset</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>seqState</name><operator>-&gt;</operator><name>prevOffset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>seqState</name><operator>-&gt;</operator><name>prevOffset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>ll0</name> <init>= <expr><operator>(</operator><name><name>llDInfo</name><operator>-&gt;</operator><name>baseValue</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><operator>(</operator><name>ofBits</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>seqState</name><operator>-&gt;</operator><name>prevOffset</name><index>[<expr><name>ll0</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>seqState</name><operator>-&gt;</operator><name>prevOffset</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>seqState</name><operator>-&gt;</operator><name>prevOffset</name><index>[<expr><operator>!</operator><name>ll0</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>seqState</name><operator>-&gt;</operator><name>prevOffset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>ofBase</name> <operator>+</operator> <name>ll0</name> <operator>+</operator> <call><name>BIT_readBitsFast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>-&gt;</operator><name>DStream</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>temp</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>offset</name><operator>==</operator><literal type="number">3</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>seqState</name><operator>-&gt;</operator><name>prevOffset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name><name>seqState</name><operator>-&gt;</operator><name>prevOffset</name><index>[<expr><name>offset</name></expr>]</index></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name>temp</name> <operator>+=</operator> <operator>!</operator><name>temp</name></expr>;</expr_stmt>   <comment type="block">/* 0 is not valid; input is corrupted; force offset to 1 */</comment>
                        <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>seqState</name><operator>-&gt;</operator><name>prevOffset</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>seqState</name><operator>-&gt;</operator><name>prevOffset</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <expr_stmt><expr><name><name>seqState</name><operator>-&gt;</operator><name>prevOffset</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>seqState</name><operator>-&gt;</operator><name>prevOffset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>seqState</name><operator>-&gt;</operator><name>prevOffset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>offset</name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
            </block_content>}</block>   </block_content>}</block></else></if_stmt>   </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name><name>seq</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name>mlBits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if_stmt><if>if <condition>(<expr><name>mlBits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name><name>seq</name><operator>.</operator><name>matchLength</name></name> <operator>+=</operator> <call><name>BIT_readBitsFast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>-&gt;</operator><name>DStream</name></name></expr></argument>, <argument><expr><name>mlBits</name></expr></argument><comment type="block">/*&gt;0*/</comment>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>MEM_32bits</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>mlBits</name><operator>+</operator><name>llBits</name> <operator>&gt;=</operator> <name>STREAM_ACCUMULATOR_MIN_32</name><operator>-</operator><name>LONG_OFFSETS_MAX_EXTRA_BITS_32</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>-&gt;</operator><name>DStream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>MEM_64bits</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>UNLIKELY</name><argument_list>(<argument><expr><name>totalBits</name> <operator>&gt;=</operator> <name>STREAM_ACCUMULATOR_MIN_64</name><operator>-</operator><operator>(</operator><name>LLFSELog</name><operator>+</operator><name>MLFSELog</name><operator>+</operator><name>OffFSELog</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>-&gt;</operator><name>DStream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* Ensure there are enough bits to read the rest of data in 64-bit mode. */</comment>
        <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(<argument><expr><literal type="number">16</literal><operator>+</operator><name>LLFSELog</name><operator>+</operator><name>MLFSELog</name><operator>+</operator><name>OffFSELog</name> <operator>&lt;</operator> <name>STREAM_ACCUMULATOR_MIN_64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name>llBits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if_stmt><if>if <condition>(<expr><name>llBits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name><name>seq</name><operator>.</operator><name>litLength</name></name> <operator>+=</operator> <call><name>BIT_readBitsFast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>-&gt;</operator><name>DStream</name></name></expr></argument>, <argument><expr><name>llBits</name></expr></argument><comment type="block">/*&gt;0*/</comment>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>MEM_32bits</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>-&gt;</operator><name>DStream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"seq: litL=%u, matchL=%u, offset=%u"</literal></expr></argument>,
                    <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>seq</name><operator>.</operator><name>litLength</name></name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>seq</name><operator>.</operator><name>matchLength</name></name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>seq</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ZSTD_updateFseStateWithDInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>-&gt;</operator><name>stateLL</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>-&gt;</operator><name>DStream</name></name></expr></argument>, <argument><expr><name>llNext</name></expr></argument>, <argument><expr><name>llnbBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* &lt;=  9 bits */</comment>
        <expr_stmt><expr><call><name>ZSTD_updateFseStateWithDInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>-&gt;</operator><name>stateML</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>-&gt;</operator><name>DStream</name></name></expr></argument>, <argument><expr><name>mlNext</name></expr></argument>, <argument><expr><name>mlnbBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* &lt;=  9 bits */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>MEM_32bits</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>-&gt;</operator><name>DStream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* &lt;= 18 bits */</comment>
        <expr_stmt><expr><call><name>ZSTD_updateFseStateWithDInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>-&gt;</operator><name>stateOffb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>-&gt;</operator><name>DStream</name></name></expr></argument>, <argument><expr><name>ofNext</name></expr></argument>, <argument><expr><name>ofnbBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* &lt;=  8 bits */</comment>
    </block_content>}</block>

    <return>return <expr><name>seq</name></expr>;</return>
</block_content>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION</name></cpp:ifdef>
<function><type><name>MEM_STATIC</name> <name>int</name></type> <name>ZSTD_dictionaryIsActive</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name> <specifier>const</specifier><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>prefixStart</name></decl></parameter>, <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>oLitEnd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>windowSize</name> <init>= <expr><name><name>dctx</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>windowSize</name></name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* No dictionary used. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>dictContentEndForFuzzing</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Dictionary is our prefix. */</comment>
    <if_stmt><if>if <condition>(<expr><name>prefixStart</name> <operator>==</operator> <name><name>dctx</name><operator>-&gt;</operator><name>dictContentBeginForFuzzing</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Dictionary is not our ext-dict. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>dictEnd</name></name> <operator>!=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>dictContentEndForFuzzing</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Dictionary is not within our window size. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oLitEnd</name> <operator>-</operator> <name>prefixStart</name><operator>)</operator> <operator>&gt;=</operator> <name>windowSize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Dictionary is active. */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>MEM_STATIC</name> <name>void</name></type> <name>ZSTD_assertValidSequence</name><parameter_list>(
        <parameter><decl><type><name>ZSTD_DCtx</name> <specifier>const</specifier><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
        <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>oend</name></decl></parameter>,
        <parameter><decl><type><name>seq_t</name> <specifier>const</specifier></type> <name>seq</name></decl></parameter>,
        <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>prefixStart</name></decl></parameter>, <parameter><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier></type> <name>virtualStart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEBUGLEVEL</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></cpp:if>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>windowSize</name> <init>= <expr><name><name>dctx</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>windowSize</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>sequenceSize</name> <init>= <expr><name><name>seq</name><operator>.</operator><name>litLength</name></name> <operator>+</operator> <name><name>seq</name><operator>.</operator><name>matchLength</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name> <specifier>const</specifier><modifier>*</modifier> <specifier>const</specifier></type> <name>oLitEnd</name> <init>= <expr><name>op</name> <operator>+</operator> <name><name>seq</name><operator>.</operator><name>litLength</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"Checking sequence: litL=%u matchL=%u offset=%u"</literal></expr></argument>,
            <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>seq</name><operator>.</operator><name>litLength</name></name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>seq</name><operator>.</operator><name>matchLength</name></name></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name><name>seq</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;=</operator> <name>oend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator> <operator>&gt;=</operator> <name>sequenceSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sequenceSize</name> <operator>&lt;=</operator> <name>ZSTD_BLOCKSIZE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_dictionaryIsActive</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>oLitEnd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dictSize</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name><name>dctx</name><operator>-&gt;</operator><name>dictContentEndForFuzzing</name></name> <operator>-</operator> <operator>(</operator><name>char</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name><name>dctx</name><operator>-&gt;</operator><name>dictContentBeginForFuzzing</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <comment type="block">/* Offset must be within the dictionary. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>seq</name><operator>.</operator><name>offset</name></name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oLitEnd</name> <operator>-</operator> <name>virtualStart</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>seq</name><operator>.</operator><name>offset</name></name> <operator>&lt;=</operator> <name>windowSize</name> <operator>+</operator> <name>dictSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* Offset must be within our window. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>seq</name><operator>.</operator><name>offset</name></name> <operator>&lt;=</operator> <name>windowSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>dctx</name></expr><operator>,</operator> <expr><operator>(</operator><name>void</name><operator>)</operator><name>op</name></expr><operator>,</operator> <expr><operator>(</operator><name>void</name><operator>)</operator><name>oend</name></expr><operator>,</operator> <expr><operator>(</operator><name>void</name><operator>)</operator><name>seq</name></expr><operator>,</operator> <expr><operator>(</operator><name>void</name><operator>)</operator><name>prefixStart</name></expr><operator>,</operator> <expr><operator>(</operator><name>void</name><operator>)</operator><name>virtualStart</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG</name></cpp:ifndef>


<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>size_t</name>
<name>DONT_VECTORIZE</name></type>
<name>ZSTD_decompressSequences_bodySplitLitBuffer</name><parameter_list>( <parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
                               <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxDstSize</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>seqStart</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>seqSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbSeq</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>ZSTD_longOffset_e</name></type> <name>isLongOffset</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>seqStart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>ip</name> <operator>+</operator> <name>seqSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><name>ostart</name> <operator>+</operator> <name>maxDstSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><name>ostart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>litPtr</name> <init>= <expr><name><name>dctx</name><operator>-&gt;</operator><name>litPtr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>litBufferEnd</name> <init>= <expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferEnd</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <operator>(</operator><name><name>dctx</name><operator>-&gt;</operator><name>prefixStart</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>vBase</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <operator>(</operator><name><name>dctx</name><operator>-&gt;</operator><name>virtualStart</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <operator>(</operator><name><name>dctx</name><operator>-&gt;</operator><name>dictEnd</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decompressSequences_bodySplitLitBuffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>frame</name></expr>;</expr_stmt>

    <comment type="block">/* Regen sequences */</comment>
    <if_stmt><if>if <condition>(<expr><name>nbSeq</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>seqState_t</name></type> <name>seqState</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>fseEntropy</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <block>{<block_content> <decl_stmt><decl><type><name>U32</name></type> <name>i</name></decl>;</decl_stmt> <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>ZSTD_REP_NUM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>seqState</name><operator>.</operator><name>prevOffset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>rep</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for> </block_content>}</block>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(
            <argument><expr><call><name>ERR_isError</name><argument_list>(<argument><expr><call><name>BIT_initDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>DStream</name></name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name><operator>-</operator><name>ip</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_initFseState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>stateLL</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>DStream</name></name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>LLTptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_initFseState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>stateOffb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>DStream</name></name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>OFTptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_initFseState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>stateML</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>DStream</name></name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>MLTptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dst</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(
                <argument><expr><name>BIT_DStream_unfinished</name> <operator>&lt;</operator> <name>BIT_DStream_completed</name> <operator>&amp;&amp;</operator>
                <name>BIT_DStream_endOfBuffer</name> <operator>&lt;</operator> <name>BIT_DStream_completed</name> <operator>&amp;&amp;</operator>
                <name>BIT_DStream_completed</name> <operator>&lt;</operator> <name>BIT_DStream_overflow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* decompress without overrunning litPtr begins */</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><name>seq_t</name></type> <name>sequence</name> <init>= <expr><call><name>ZSTD_decodeSequence</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqState</name></expr></argument>, <argument><expr><name>isLongOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="block">/* Align the decompression loop to 32 + 16 bytes.
                *
                * zstd compiled with gcc-9 on an Intel i9-9900k shows 10% decompression
                * speed swings based on the alignment of the decompression loop. This
                * performance swing is caused by parts of the decompression loop falling
                * out of the DSB. The entire decompression loop should fit in the DSB,
                * when it can't we get much worse performance. You can measure if you've
                * hit the good case or the bad case with this perf command for some
                * compressed file test.zst:
                *
                *   perf stat -e cycles -e instructions -e idq.all_dsb_cycles_any_uops \
                *             -e idq.all_mite_cycles_any_uops -- ./zstd -tq test.zst
                *
                * If you see most cycles served out of the MITE you've hit the bad case.
                * If you see most cycles served out of the DSB you've hit the good case.
                * If it is pretty even then you may be in an okay case.
                *
                * This issue has been reproduced on the following CPUs:
                *   - Kabylake: Macbook Pro (15-inch, 2019) 2.4 GHz Intel Core i9
                *               Use Instruments-&gt;Counters to get DSB/MITE cycles.
                *               I never got performance swings, but I was able to
                *               go from the good case of mostly DSB to half of the
                *               cycles served from MITE.
                *   - Coffeelake: Intel i9-9900k
                *   - Coffeelake: Intel i7-9700k
                *
                * I haven't been able to reproduce the instability or DSB misses on any
                * of the following CPUS:
                *   - Haswell
                *   - Broadwell: Intel(R) Xeon(R) CPU E5-2680 v4 @ 2.40GH
                *   - Skylake
                *
                * Alignment is done for each of the three major decompression loops:
                *   - ZSTD_decompressSequences_bodySplitLitBuffer - presplit section of the literal buffer
                *   - ZSTD_decompressSequences_bodySplitLitBuffer - postsplit section of the literal buffer
                *   - ZSTD_decompressSequences_body
                * Alignment choices are made to minimize large swings on bad cases and influence on performance
                * from changes external to this code, rather than to overoptimize on the current commit.
                *
                * If you are seeing performance stability this script can help test.
                * It tests on 4 commits in zstd where I saw performance change.
                *
                *   https://gist.github.com/terrelln/9889fc06a423fd5ca6e99351564473f4
                */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
            <asm>__asm__(".p2align 6");</asm>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><name>__GNUC__</name> <operator>&gt;=</operator> <literal type="number">7</literal></expr></cpp:if>
	    <comment type="block">/* good for gcc-7, gcc-9, and gcc-11 */</comment>
            <asm>__asm__("nop");</asm>
            <asm>__asm__(".p2align 5");</asm>
            <asm>__asm__("nop");</asm>
            <asm>__asm__(".p2align 4");</asm>
<cpp:if>#    <cpp:directive>if</cpp:directive> <expr><name>__GNUC__</name> <operator>==</operator> <literal type="number">8</literal> <operator>||</operator> <name>__GNUC__</name> <operator>==</operator> <literal type="number">10</literal></expr></cpp:if>
	    <comment type="block">/* good for gcc-8 and gcc-10 */</comment>
            <asm>__asm__("nop");</asm>
            <asm>__asm__(".p2align 3");</asm>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="block">/* Handle the initial state where litBuffer is currently split between dst and litExtraBuffer */</comment>
            <for>for <control>(<init>;</init> <condition><expr><name>litPtr</name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>litLength</name></name> <operator>&lt;=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litBufferEnd</name></name></expr>;</condition> <incr/>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>oneSeqSize</name> <init>= <expr><call><name>ZSTD_execSequenceSplitLitBuffer</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name>litPtr</name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>litLength</name></name> <operator>-</operator> <name>WILDCOPY_OVERLENGTH</name></expr></argument>, <argument><expr><name>sequence</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>litPtr</name></expr></argument>, <argument><expr><name>litBufferEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>vBase</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FUZZING_ASSERT_VALID_SEQUENCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>oneSeqSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>frame</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ZSTD_assertValidSequence</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name>sequence</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>vBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>oneSeqSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>oneSeqSize</name></expr>;</return></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"regenerated sequence size : %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>oneSeqSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>oneSeqSize</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><operator>!</operator><operator>--</operator><name>nbSeq</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>seqState</name><operator>.</operator><name>DStream</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>sequence</name> <operator>=</operator> <call><name>ZSTD_decodeSequence</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqState</name></expr></argument>, <argument><expr><name>isLongOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <comment type="block">/* If there are more sequences, they will need to read literals from litExtraBuffer; copy over the remainder from dst and update litPtr and litEnd */</comment>
            <if_stmt><if>if <condition>(<expr><name>nbSeq</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>leftoverLit</name> <init>= <expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferEnd</name></name> <operator>-</operator> <name>litPtr</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>leftoverLit</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>leftoverLit</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"remaining lit must fit within dstBuffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ZSTD_safecopyDstBeforeSrc</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>litPtr</name></expr></argument>, <argument><expr><name>leftoverLit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>sequence</name><operator>.</operator><name>litLength</name></name> <operator>-=</operator> <name>leftoverLit</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>leftoverLit</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>litPtr</name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litExtraBuffer</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>litBufferEnd</name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litExtraBuffer</name></name> <operator>+</operator> <name>ZSTD_LITBUFFEREXTRASIZE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferLocation</name></name> <operator>=</operator> <name>ZSTD_not_in_dst</name></expr>;</expr_stmt>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>oneSeqSize</name> <init>= <expr><call><name>ZSTD_execSequence</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name>sequence</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>litPtr</name></expr></argument>, <argument><expr><name>litBufferEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>vBase</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FUZZING_ASSERT_VALID_SEQUENCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>oneSeqSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>frame</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ZSTD_assertValidSequence</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name>sequence</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>vBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>oneSeqSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>oneSeqSize</name></expr>;</return></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"regenerated sequence size : %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>oneSeqSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>oneSeqSize</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>--</operator><name>nbSeq</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>seqState</name><operator>.</operator><name>DStream</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <if_stmt><if>if <condition>(<expr><name>nbSeq</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <comment type="block">/* there is remaining lit from extra buffer */</comment>
        <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
            <asm>__asm__(".p2align 6");</asm>
            <asm>__asm__("nop");</asm>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><name>__GNUC__</name> <operator>!=</operator> <literal type="number">7</literal></expr></cpp:if>
            <comment type="block">/* worse for gcc-7 better for gcc-8, gcc-9, and gcc-10 and clang */</comment>
            <asm>__asm__(".p2align 4");</asm>
            <asm>__asm__("nop");</asm>
            <asm>__asm__(".p2align 3");</asm>
<cpp:elif>#  <cpp:directive>elif</cpp:directive> <expr><name>__GNUC__</name> <operator>&gt;=</operator> <literal type="number">11</literal></expr></cpp:elif>
            <asm>__asm__(".p2align 3");</asm>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
            <asm>__asm__(".p2align 5");</asm>
            <asm>__asm__("nop");</asm>
            <asm>__asm__(".p2align 3");</asm>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <for>for <control>(<init>;</init> <condition>;</condition> <incr/>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>seq_t</name> <specifier>const</specifier></type> <name>sequence</name> <init>= <expr><call><name>ZSTD_decodeSequence</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqState</name></expr></argument>, <argument><expr><name>isLongOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>oneSeqSize</name> <init>= <expr><call><name>ZSTD_execSequence</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name>sequence</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>litPtr</name></expr></argument>, <argument><expr><name>litBufferEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>vBase</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FUZZING_ASSERT_VALID_SEQUENCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>oneSeqSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>frame</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ZSTD_assertValidSequence</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name>sequence</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>vBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>oneSeqSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>oneSeqSize</name></expr>;</return></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"regenerated sequence size : %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>oneSeqSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>oneSeqSize</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><operator>!</operator><operator>--</operator><name>nbSeq</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>seqState</name><operator>.</operator><name>DStream</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* check if reached exact end */</comment>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decompressSequences_bodySplitLitBuffer: after decode loop, remaining nbSeq : %i"</literal></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>DStream</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>BIT_DStream_completed</name></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* save reps for next block */</comment>
        <block>{<block_content> <decl_stmt><decl><type><name>U32</name></type> <name>i</name></decl>;</decl_stmt> <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>ZSTD_REP_NUM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>rep</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>seqState</name><operator>.</operator><name>prevOffset</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></for> </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* last literal segment */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferLocation</name></name> <operator>==</operator> <name>ZSTD_split</name></expr>)</condition>  <comment type="block">/* split hasn't been reached yet, first get dst then copy litExtraBuffer */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>lastLLSize</name> <init>= <expr><name>litBufferEnd</name> <operator>-</operator> <name>litPtr</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>lastLLSize</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>op</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ZSTD_memmove</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>litPtr</name></expr></argument>, <argument><expr><name>lastLLSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>lastLLSize</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>litPtr</name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litExtraBuffer</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>litBufferEnd</name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litExtraBuffer</name></name> <operator>+</operator> <name>ZSTD_LITBUFFEREXTRASIZE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferLocation</name></name> <operator>=</operator> <name>ZSTD_not_in_dst</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>lastLLSize</name> <init>= <expr><name>litBufferEnd</name> <operator>-</operator> <name>litPtr</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>lastLLSize</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>op</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>litPtr</name></expr></argument>, <argument><expr><name>lastLLSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>lastLLSize</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>op</name><operator>-</operator><name>ostart</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>size_t</name>
<name>DONT_VECTORIZE</name></type>
<name>ZSTD_decompressSequences_body</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
    <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxDstSize</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>seqStart</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>seqSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbSeq</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>ZSTD_longOffset_e</name></type> <name>isLongOffset</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>seqStart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>ip</name> <operator>+</operator> <name>seqSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><ternary><condition><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferLocation</name></name> <operator>==</operator> <name>ZSTD_not_in_dst</name></expr> ?</condition><then> <expr><name>ostart</name> <operator>+</operator> <name>maxDstSize</name></expr> </then><else>: <expr><name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><name>ostart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>litPtr</name> <init>= <expr><name><name>dctx</name><operator>-&gt;</operator><name>litPtr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>litEnd</name> <init>= <expr><name>litPtr</name> <operator>+</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litSize</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>dctx</name><operator>-&gt;</operator><name>prefixStart</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>vBase</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>dctx</name><operator>-&gt;</operator><name>virtualStart</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>dctx</name><operator>-&gt;</operator><name>dictEnd</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decompressSequences_body: nbSeq = %d"</literal></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>frame</name></expr>;</expr_stmt>

    <comment type="block">/* Regen sequences */</comment>
    <if_stmt><if>if <condition>(<expr><name>nbSeq</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>seqState_t</name></type> <name>seqState</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>fseEntropy</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <block>{<block_content> <decl_stmt><decl><type><name>U32</name></type> <name>i</name></decl>;</decl_stmt> <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ZSTD_REP_NUM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>seqState</name><operator>.</operator><name>prevOffset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>rep</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for> </block_content>}</block>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(
            <argument><expr><call><name>ERR_isError</name><argument_list>(<argument><expr><call><name>BIT_initDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>DStream</name></name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name> <operator>-</operator> <name>ip</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_initFseState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>stateLL</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>DStream</name></name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>LLTptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_initFseState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>stateOffb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>DStream</name></name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>OFTptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_initFseState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>stateML</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>DStream</name></name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>MLTptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dst</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ZSTD_STATIC_ASSERT</name><argument_list>(
            <argument><expr><name>BIT_DStream_unfinished</name> <operator>&lt;</operator> <name>BIT_DStream_completed</name> <operator>&amp;&amp;</operator>
            <name>BIT_DStream_endOfBuffer</name> <operator>&lt;</operator> <name>BIT_DStream_completed</name> <operator>&amp;&amp;</operator>
            <name>BIT_DStream_completed</name> <operator>&lt;</operator> <name>BIT_DStream_overflow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
            <asm>__asm__(".p2align 6");</asm>
            <asm>__asm__("nop");</asm>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><name>__GNUC__</name> <operator>&gt;=</operator> <literal type="number">7</literal></expr></cpp:if>
            <asm>__asm__(".p2align 5");</asm>
            <asm>__asm__("nop");</asm>
            <asm>__asm__(".p2align 3");</asm>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
            <asm>__asm__(".p2align 4");</asm>
            <asm>__asm__("nop");</asm>
            <asm>__asm__(".p2align 3");</asm>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <for>for <control>( <init>;</init> <condition>;</condition> <incr/>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>seq_t</name> <specifier>const</specifier></type> <name>sequence</name> <init>= <expr><call><name>ZSTD_decodeSequence</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqState</name></expr></argument>, <argument><expr><name>isLongOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>oneSeqSize</name> <init>= <expr><call><name>ZSTD_execSequence</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name>sequence</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>litPtr</name></expr></argument>, <argument><expr><name>litEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>vBase</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FUZZING_ASSERT_VALID_SEQUENCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>oneSeqSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>frame</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ZSTD_assertValidSequence</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name>sequence</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>vBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>oneSeqSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>oneSeqSize</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"regenerated sequence size : %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>oneSeqSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>oneSeqSize</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><operator>!</operator><operator>--</operator><name>nbSeq</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>seqState</name><operator>.</operator><name>DStream</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/* check if reached exact end */</comment>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decompressSequences_body: after decode loop, remaining nbSeq : %i"</literal></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>DStream</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>BIT_DStream_completed</name></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* save reps for next block */</comment>
        <block>{<block_content> <decl_stmt><decl><type><name>U32</name></type> <name>i</name></decl>;</decl_stmt> <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>ZSTD_REP_NUM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>rep</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>seqState</name><operator>.</operator><name>prevOffset</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></for> </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* last literal segment */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>lastLLSize</name> <init>= <expr><name>litEnd</name> <operator>-</operator> <name>litPtr</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>lastLLSize</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>op</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ZSTD_memcpy</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>litPtr</name></expr></argument>, <argument><expr><name>lastLLSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>lastLLSize</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>op</name><operator>-</operator><name>ostart</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_decompressSequences_default</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
                                 <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxDstSize</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>seqStart</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>seqSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbSeq</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>ZSTD_longOffset_e</name></type> <name>isLongOffset</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_decompressSequences_body</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>seqStart</name></expr></argument>, <argument><expr><name>seqSize</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>isLongOffset</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_decompressSequencesSplitLitBuffer_default</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
                                               <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxDstSize</name></decl></parameter>,
                                         <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>seqStart</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>seqSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbSeq</name></decl></parameter>,
                                         <parameter><decl><type><specifier>const</specifier> <name>ZSTD_longOffset_e</name></type> <name>isLongOffset</name></decl></parameter>,
                                         <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_decompressSequences_bodySplitLitBuffer</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>seqStart</name></expr></argument>, <argument><expr><name>seqSize</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>isLongOffset</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT</name></cpp:ifndef>

<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>size_t</name></type>
<name>ZSTD_prefetchMatch</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>prefetchPos</name></decl></parameter>, <parameter><decl><type><name>seq_t</name> <specifier>const</specifier></type> <name>sequence</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>prefetchPos</name> <operator>+=</operator> <name><name>sequence</name><operator>.</operator><name>litLength</name></name></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>matchBase</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>sequence</name><operator>.</operator><name>offset</name></name> <operator>&gt;</operator> <name>prefetchPos</name><operator>)</operator></expr> ?</condition><then> <expr><name>dictEnd</name></expr> </then><else>: <expr><name>prefixStart</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>match</name> <init>= <expr><name>matchBase</name> <operator>+</operator> <name>prefetchPos</name> <operator>-</operator> <name><name>sequence</name><operator>.</operator><name>offset</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* note : this operation can overflow when seq.offset is really too large, which can only happen when input is corrupted.
                                                                              * No consequence though : memory address is only used for prefetching, not for dereferencing */</comment>
        <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>PREFETCH_L1</name><argument_list>(<argument><expr><name>match</name><operator>+</operator><name>CACHELINE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* note : it's safe to invoke PREFETCH() on any memory address, including invalid ones */</comment>
    </block_content>}</block>
    <return>return <expr><name>prefetchPos</name> <operator>+</operator> <name><name>sequence</name><operator>.</operator><name>matchLength</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This decoding function employs prefetching
 * to reduce latency impact of cache misses.
 * It's generally employed when block contains a significant portion of long-distance matches
 * or when coupled with a "cold" dictionary */</comment>
<function><type><name>FORCE_INLINE_TEMPLATE</name> <name>size_t</name></type>
<name>ZSTD_decompressSequencesLong_body</name><parameter_list>(
                               <parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
                               <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxDstSize</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>seqStart</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>seqSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbSeq</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>ZSTD_longOffset_e</name></type> <name>isLongOffset</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>seqStart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>iend</name> <init>= <expr><name>ip</name> <operator>+</operator> <name>seqSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ostart</name> <init>= <expr><operator>(</operator><name>BYTE</name><operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>oend</name> <init>= <expr><ternary><condition><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferLocation</name></name> <operator>==</operator> <name>ZSTD_in_dst</name></expr> ?</condition><then> <expr><name><name>dctx</name><operator>-&gt;</operator><name>litBuffer</name></name></expr> </then><else>: <expr><name>ostart</name> <operator>+</operator> <name>maxDstSize</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BYTE</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><name>ostart</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>litPtr</name> <init>= <expr><name><name>dctx</name><operator>-&gt;</operator><name>litPtr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>litBufferEnd</name> <init>= <expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferEnd</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>prefixStart</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <operator>(</operator><name><name>dctx</name><operator>-&gt;</operator><name>prefixStart</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictStart</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <operator>(</operator><name><name>dctx</name><operator>-&gt;</operator><name>virtualStart</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier> <specifier>const</specifier></type> <name>dictEnd</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator> <operator>(</operator><name><name>dctx</name><operator>-&gt;</operator><name>dictEnd</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>frame</name></expr>;</expr_stmt>

    <comment type="block">/* Regen sequences */</comment>
    <if_stmt><if>if <condition>(<expr><name>nbSeq</name></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORED_SEQS</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORED_SEQS_MASK</name></cpp:macro> <cpp:value>(STORED_SEQS-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADVANCED_SEQS</name></cpp:macro> <cpp:value>STORED_SEQS</cpp:value></cpp:define>
        <decl_stmt><decl><type><name>seq_t</name></type> <name><name>sequences</name><index>[<expr><name>STORED_SEQS</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>seqAdvance</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>ADVANCED_SEQS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>seqState_t</name></type> <name>seqState</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>seqNb</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>prefetchPos</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>op</name><operator>-</operator><name>prefixStart</name><operator>)</operator></expr></init></decl>;</decl_stmt> <comment type="block">/* track position relative to prefixStart */</comment>

        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>fseEntropy</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <block>{<block_content> <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt> <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>ZSTD_REP_NUM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>seqState</name><operator>.</operator><name>prevOffset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>rep</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for> </block_content>}</block>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dst</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>iend</name> <operator>&gt;=</operator> <name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(
            <argument><expr><call><name>ERR_isError</name><argument_list>(<argument><expr><call><name>BIT_initDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>DStream</name></name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>iend</name><operator>-</operator><name>ip</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_initFseState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>stateLL</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>DStream</name></name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>LLTptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_initFseState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>stateOffb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>DStream</name></name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>OFTptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZSTD_initFseState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>stateML</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>DStream</name></name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>MLTptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* prepare in advance */</comment>
        <for>for <control>(<init><expr><name>seqNb</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seqState</name><operator>.</operator><name>DStream</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>BIT_DStream_completed</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>seqNb</name><operator>&lt;</operator><name>seqAdvance</name><operator>)</operator></expr>;</condition> <incr><expr><name>seqNb</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>seq_t</name> <specifier>const</specifier></type> <name>sequence</name> <init>= <expr><call><name>ZSTD_decodeSequence</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqState</name></expr></argument>, <argument><expr><name>isLongOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>prefetchPos</name> <operator>=</operator> <call><name>ZSTD_prefetchMatch</name><argument_list>(<argument><expr><name>prefetchPos</name></expr></argument>, <argument><expr><name>sequence</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sequences</name><index>[<expr><name>seqNb</name></expr>]</index></name> <operator>=</operator> <name>sequence</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>seqNb</name><operator>&lt;</operator><name>seqAdvance</name></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* decompress without stomping litBuffer */</comment>
        <for>for <control>(<init>;</init> <condition><expr><operator>(</operator><call><name>BIT_reloadDStream</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>seqState</name><operator>.</operator><name>DStream</name></name><operator>)</operator></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>BIT_DStream_completed</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>seqNb</name> <operator>&lt;</operator> <name>nbSeq</name><operator>)</operator></expr>;</condition> <incr><expr><name>seqNb</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>seq_t</name></type> <name>sequence</name> <init>= <expr><call><name>ZSTD_decodeSequence</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqState</name></expr></argument>, <argument><expr><name>isLongOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>oneSeqSize</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferLocation</name></name> <operator>==</operator> <name>ZSTD_split</name> <operator>&amp;&amp;</operator> <name>litPtr</name> <operator>+</operator> <name><name>sequences</name><index>[<expr><operator>(</operator><name>seqNb</name> <operator>-</operator> <name>ADVANCED_SEQS</name><operator>)</operator> <operator>&amp;</operator> <name>STORED_SEQS_MASK</name></expr>]</index></name><operator>.</operator><name>litLength</name> <operator>&gt;</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litBufferEnd</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* lit buffer is reaching split point, empty out the first buffer and transition to litExtraBuffer */</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>leftoverLit</name> <init>= <expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferEnd</name></name> <operator>-</operator> <name>litPtr</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>leftoverLit</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>leftoverLit</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"remaining lit must fit within dstBuffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ZSTD_safecopyDstBeforeSrc</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>litPtr</name></expr></argument>, <argument><expr><name>leftoverLit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>sequences</name><index>[<expr><operator>(</operator><name>seqNb</name> <operator>-</operator> <name>ADVANCED_SEQS</name><operator>)</operator> <operator>&amp;</operator> <name>STORED_SEQS_MASK</name></expr>]</index></name><operator>.</operator><name>litLength</name> <operator>-=</operator> <name>leftoverLit</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>leftoverLit</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>litPtr</name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litExtraBuffer</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>litBufferEnd</name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litExtraBuffer</name></name> <operator>+</operator> <name>ZSTD_LITBUFFEREXTRASIZE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferLocation</name></name> <operator>=</operator> <name>ZSTD_not_in_dst</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>oneSeqSize</name> <operator>=</operator> <call><name>ZSTD_execSequence</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name><name>sequences</name><index>[<expr><operator>(</operator><name>seqNb</name> <operator>-</operator> <name>ADVANCED_SEQS</name><operator>)</operator> <operator>&amp;</operator> <name>STORED_SEQS_MASK</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>litPtr</name></expr></argument>, <argument><expr><name>litBufferEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>dictStart</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FUZZING_ASSERT_VALID_SEQUENCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>oneSeqSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>frame</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ZSTD_assertValidSequence</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name><name>sequences</name><index>[<expr><operator>(</operator><name>seqNb</name> <operator>-</operator> <name>ADVANCED_SEQS</name><operator>)</operator> <operator>&amp;</operator> <name>STORED_SEQS_MASK</name></expr>]</index></name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>dictStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>oneSeqSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>oneSeqSize</name></expr>;</return></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>prefetchPos</name> <operator>=</operator> <call><name>ZSTD_prefetchMatch</name><argument_list>(<argument><expr><name>prefetchPos</name></expr></argument>, <argument><expr><name>sequence</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>sequences</name><index>[<expr><name>seqNb</name> <operator>&amp;</operator> <name>STORED_SEQS_MASK</name></expr>]</index></name> <operator>=</operator> <name>sequence</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>oneSeqSize</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* lit buffer is either wholly contained in first or second split, or not split at all*/</comment>
                <expr_stmt><expr><name>oneSeqSize</name> <operator>=</operator> <ternary><condition><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferLocation</name></name> <operator>==</operator> <name>ZSTD_split</name></expr> ?</condition><then>
                    <expr><call><name>ZSTD_execSequenceSplitLitBuffer</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name>litPtr</name> <operator>+</operator> <name><name>sequences</name><index>[<expr><operator>(</operator><name>seqNb</name> <operator>-</operator> <name>ADVANCED_SEQS</name><operator>)</operator> <operator>&amp;</operator> <name>STORED_SEQS_MASK</name></expr>]</index></name><operator>.</operator><name>litLength</name> <operator>-</operator> <name>WILDCOPY_OVERLENGTH</name></expr></argument>, <argument><expr><name><name>sequences</name><index>[<expr><operator>(</operator><name>seqNb</name> <operator>-</operator> <name>ADVANCED_SEQS</name><operator>)</operator> <operator>&amp;</operator> <name>STORED_SEQS_MASK</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>litPtr</name></expr></argument>, <argument><expr><name>litBufferEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>dictStart</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>)</argument_list></call></expr> </then><else>:
                    <expr><call><name>ZSTD_execSequence</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name><name>sequences</name><index>[<expr><operator>(</operator><name>seqNb</name> <operator>-</operator> <name>ADVANCED_SEQS</name><operator>)</operator> <operator>&amp;</operator> <name>STORED_SEQS_MASK</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>litPtr</name></expr></argument>, <argument><expr><name>litBufferEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>dictStart</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FUZZING_ASSERT_VALID_SEQUENCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>oneSeqSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>frame</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ZSTD_assertValidSequence</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name><name>sequences</name><index>[<expr><operator>(</operator><name>seqNb</name> <operator>-</operator> <name>ADVANCED_SEQS</name><operator>)</operator> <operator>&amp;</operator> <name>STORED_SEQS_MASK</name></expr>]</index></name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>dictStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>oneSeqSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>oneSeqSize</name></expr>;</return></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>prefetchPos</name> <operator>=</operator> <call><name>ZSTD_prefetchMatch</name><argument_list>(<argument><expr><name>prefetchPos</name></expr></argument>, <argument><expr><name>sequence</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>sequences</name><index>[<expr><name>seqNb</name> <operator>&amp;</operator> <name>STORED_SEQS_MASK</name></expr>]</index></name> <operator>=</operator> <name>sequence</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>oneSeqSize</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>seqNb</name><operator>&lt;</operator><name>nbSeq</name></expr></argument>, <argument><expr><name>corruption_detected</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* finish queue */</comment>
        <expr_stmt><expr><name>seqNb</name> <operator>-=</operator> <name>seqAdvance</name></expr>;</expr_stmt>
        <for>for <control>( <init>;</init> <condition><expr><name>seqNb</name><operator>&lt;</operator><name>nbSeq</name></expr> ;</condition> <incr><expr><name>seqNb</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>seq_t</name> <modifier>*</modifier></type><name>sequence</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>sequences</name><index>[<expr><name>seqNb</name><operator>&amp;</operator><name>STORED_SEQS_MASK</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferLocation</name></name> <operator>==</operator> <name>ZSTD_split</name> <operator>&amp;&amp;</operator> <name>litPtr</name> <operator>+</operator> <name><name>sequence</name><operator>-&gt;</operator><name>litLength</name></name> <operator>&gt;</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litBufferEnd</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>leftoverLit</name> <init>= <expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferEnd</name></name> <operator>-</operator> <name>litPtr</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>leftoverLit</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>leftoverLit</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"remaining lit must fit within dstBuffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ZSTD_safecopyDstBeforeSrc</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>litPtr</name></expr></argument>, <argument><expr><name>leftoverLit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>sequence</name><operator>-&gt;</operator><name>litLength</name></name> <operator>-=</operator> <name>leftoverLit</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>leftoverLit</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>litPtr</name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litExtraBuffer</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>litBufferEnd</name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litExtraBuffer</name></name> <operator>+</operator> <name>ZSTD_LITBUFFEREXTRASIZE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferLocation</name></name> <operator>=</operator> <name>ZSTD_not_in_dst</name></expr>;</expr_stmt>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>oneSeqSize</name> <init>= <expr><call><name>ZSTD_execSequence</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><operator>*</operator><name>sequence</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>litPtr</name></expr></argument>, <argument><expr><name>litBufferEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>dictStart</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FUZZING_ASSERT_VALID_SEQUENCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>oneSeqSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>frame</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ZSTD_assertValidSequence</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name><name>sequences</name><index>[<expr><name>seqNb</name><operator>&amp;</operator><name>STORED_SEQS_MASK</name></expr>]</index></name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>dictStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>oneSeqSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>oneSeqSize</name></expr>;</return></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>oneSeqSize</name></expr>;</expr_stmt>
                </block_content>}</block>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>oneSeqSize</name> <init>= <expr><ternary><condition><expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferLocation</name></name> <operator>==</operator> <name>ZSTD_split</name></expr> ?</condition><then>
                    <expr><call><name>ZSTD_execSequenceSplitLitBuffer</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name>litPtr</name> <operator>+</operator> <name><name>sequence</name><operator>-&gt;</operator><name>litLength</name></name> <operator>-</operator> <name>WILDCOPY_OVERLENGTH</name></expr></argument>, <argument><expr><operator>*</operator><name>sequence</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>litPtr</name></expr></argument>, <argument><expr><name>litBufferEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>dictStart</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>)</argument_list></call></expr> </then><else>:
                    <expr><call><name>ZSTD_execSequence</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><operator>*</operator><name>sequence</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>litPtr</name></expr></argument>, <argument><expr><name>litBufferEnd</name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>dictStart</name></expr></argument>, <argument><expr><name>dictEnd</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FUZZING_ASSERT_VALID_SEQUENCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>oneSeqSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>frame</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ZSTD_assertValidSequence</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oend</name></expr></argument>, <argument><expr><name><name>sequences</name><index>[<expr><name>seqNb</name><operator>&amp;</operator><name>STORED_SEQS_MASK</name></expr>]</index></name></expr></argument>, <argument><expr><name>prefixStart</name></expr></argument>, <argument><expr><name>dictStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>oneSeqSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>oneSeqSize</name></expr>;</return></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>oneSeqSize</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* save reps for next block */</comment>
        <block>{<block_content> <decl_stmt><decl><type><name>U32</name></type> <name>i</name></decl>;</decl_stmt> <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>ZSTD_REP_NUM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>entropy</name><operator>.</operator><name>rep</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>U32</name><operator>)</operator><operator>(</operator><name><name>seqState</name><operator>.</operator><name>prevOffset</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></for> </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* last literal segment */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferLocation</name></name> <operator>==</operator> <name>ZSTD_split</name></expr>)</condition>  <comment type="block">/* first deplete literal buffer in dst, then copy litExtraBuffer */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>lastLLSize</name> <init>= <expr><name>litBufferEnd</name> <operator>-</operator> <name>litPtr</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>lastLLSize</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name> <operator>-</operator> <name>op</name><operator>)</operator></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>op</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ZSTD_memmove</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>litPtr</name></expr></argument>, <argument><expr><name>lastLLSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>lastLLSize</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>litPtr</name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litExtraBuffer</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>litBufferEnd</name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>litExtraBuffer</name></name> <operator>+</operator> <name>ZSTD_LITBUFFEREXTRASIZE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>lastLLSize</name> <init>= <expr><name>litBufferEnd</name> <operator>-</operator> <name>litPtr</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>lastLLSize</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>oend</name><operator>-</operator><name>op</name><operator>)</operator></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>op</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ZSTD_memmove</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>litPtr</name></expr></argument>, <argument><expr><name>lastLLSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> <operator>+=</operator> <name>lastLLSize</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>op</name><operator>-</operator><name>ostart</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_decompressSequencesLong_default</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
                                 <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxDstSize</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>seqStart</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>seqSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbSeq</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>ZSTD_longOffset_e</name></type> <name>isLongOffset</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_decompressSequencesLong_body</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>seqStart</name></expr></argument>, <argument><expr><name>seqSize</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>isLongOffset</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT */</comment>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DYNAMIC_BMI2</name></expr></cpp:if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>BMI2_TARGET_ATTRIBUTE</name> <name>size_t</name>
<name>DONT_VECTORIZE</name></type>
<name>ZSTD_decompressSequences_bmi2</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
                                 <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxDstSize</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>seqStart</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>seqSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbSeq</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>ZSTD_longOffset_e</name></type> <name>isLongOffset</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_decompressSequences_body</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>seqStart</name></expr></argument>, <argument><expr><name>seqSize</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>isLongOffset</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>BMI2_TARGET_ATTRIBUTE</name> <name>size_t</name>
<name>DONT_VECTORIZE</name></type>
<name>ZSTD_decompressSequencesSplitLitBuffer_bmi2</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
                                 <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxDstSize</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>seqStart</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>seqSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbSeq</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>ZSTD_longOffset_e</name></type> <name>isLongOffset</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_decompressSequences_bodySplitLitBuffer</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>seqStart</name></expr></argument>, <argument><expr><name>seqSize</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>isLongOffset</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>BMI2_TARGET_ATTRIBUTE</name> <name>size_t</name></type>
<name>ZSTD_decompressSequencesLong_bmi2</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
                                 <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxDstSize</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>seqStart</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>seqSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbSeq</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>ZSTD_longOffset_e</name></type> <name>isLongOffset</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ZSTD_decompressSequencesLong_body</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>seqStart</name></expr></argument>, <argument><expr><name>seqSize</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>isLongOffset</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* DYNAMIC_BMI2 */</comment>

<typedef>typedef <function_decl><type><name>size_t</name></type> (<modifier>*</modifier><name>ZSTD_decompressSequences_t</name>)<parameter_list>(
                            <parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
                            <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxDstSize</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>seqStart</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>seqSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbSeq</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>ZSTD_longOffset_e</name></type> <name>isLongOffset</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>frame</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_decompressSequences</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxDstSize</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>seqStart</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>seqSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbSeq</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>ZSTD_longOffset_e</name></type> <name>isLongOffset</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decompressSequences"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DYNAMIC_BMI2</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_DCtx_get_bmi2</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>ZSTD_decompressSequences_bmi2</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>seqStart</name></expr></argument>, <argument><expr><name>seqSize</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>isLongOffset</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><call><name>ZSTD_decompressSequences_default</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>seqStart</name></expr></argument>, <argument><expr><name>seqSize</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>isLongOffset</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_decompressSequencesSplitLitBuffer</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxDstSize</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>seqStart</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>seqSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbSeq</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>ZSTD_longOffset_e</name></type> <name>isLongOffset</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decompressSequencesSplitLitBuffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DYNAMIC_BMI2</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_DCtx_get_bmi2</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>ZSTD_decompressSequencesSplitLitBuffer_bmi2</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>seqStart</name></expr></argument>, <argument><expr><name>seqSize</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>isLongOffset</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><call><name>ZSTD_decompressSequencesSplitLitBuffer_default</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>seqStart</name></expr></argument>, <argument><expr><name>seqSize</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>isLongOffset</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG */</comment>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT</name></cpp:ifndef>
<comment type="block">/* ZSTD_decompressSequencesLong() :
 * decompression function triggered when a minimum share of offsets is considered "long",
 * aka out of cache.
 * note : "long" definition seems overloaded here, sometimes meaning "wider than bitstream register", and sometimes meaning "farther than memory cache distance".
 * This function will try to mitigate main memory latency through the use of prefetching */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ZSTD_decompressSequencesLong</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
                             <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxDstSize</name></decl></parameter>,
                             <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>seqStart</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>seqSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbSeq</name></decl></parameter>,
                             <parameter><decl><type><specifier>const</specifier> <name>ZSTD_longOffset_e</name></type> <name>isLongOffset</name></decl></parameter>,
                             <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decompressSequencesLong"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DYNAMIC_BMI2</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><call><name>ZSTD_DCtx_get_bmi2</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>ZSTD_decompressSequencesLong_bmi2</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>seqStart</name></expr></argument>, <argument><expr><name>seqSize</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>isLongOffset</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><call><name>ZSTD_decompressSequencesLong_default</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>maxDstSize</name></expr></argument>, <argument><expr><name>seqStart</name></expr></argument>, <argument><expr><name>seqSize</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>isLongOffset</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT */</comment>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> \
    <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* ZSTD_getLongOffsetsShare() :
 * condition : offTable must be valid
 * @return : "share" of long offsets (arbitrarily defined as &gt; (1&lt;&lt;23))
 *           compared to maximum possible of (1&lt;&lt;OffFSELog) */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name></type>
<name>ZSTD_getLongOffsetsShare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ZSTD_seqSymbol</name><modifier>*</modifier></type> <name>offTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>ptr</name> <init>= <expr><name>offTable</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>tableLog</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ZSTD_seqSymbol_header</name><operator>*</operator><operator>)</operator><name>ptr</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index><operator>.</operator><name>tableLog</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ZSTD_seqSymbol</name><modifier>*</modifier></type> <name>table</name> <init>= <expr><name>offTable</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>max</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>tableLog</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>U32</name></type> <name>u</name></decl>, <decl><type ref="prev"/><name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_getLongOffsetsShare: (tableLog=%u)"</literal></expr></argument>, <argument><expr><name>tableLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>max</name> <operator>&lt;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>OffFSELog</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* max not too large */</comment>
    <for>for <control>(<init><expr><name>u</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name><operator>&lt;</operator><name>max</name></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>table</name><index>[<expr><name>u</name></expr>]</index></name><operator>.</operator><name>nbAdditionalBits</name> <operator>&gt;</operator> <literal type="number">22</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>total</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tableLog</name> <operator>&lt;=</operator> <name>OffFSELog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>total</name> <operator>&lt;&lt;=</operator> <operator>(</operator><name>OffFSELog</name> <operator>-</operator> <name>tableLog</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* scale to OffFSELog */</comment>

    <return>return <expr><name>total</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>size_t</name></type>
<name>ZSTD_decompressBlock_internal</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
                              <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>frame</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>streaming_operation</name></type> <name>streaming</name></decl></parameter>)</parameter_list>
<block>{<block_content>   <comment type="block">/* blockType == blockCompressed */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BYTE</name><modifier>*</modifier></type> <name>ip</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BYTE</name><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* isLongOffset must be true if there are long offsets.
     * Offsets are long if they are larger than 2^STREAM_ACCUMULATOR_MIN.
     * We don't expect that to be the case in 64-bit mode.
     * In block mode, window size is not known, so we have to be conservative.
     * (note: but it could be evaluated from current-lowLimit)
     */</comment>
    <decl_stmt><decl><type><name>ZSTD_longOffset_e</name> <specifier>const</specifier></type> <name>isLongOffset</name> <init>= <expr><operator>(</operator><name>ZSTD_longOffset_e</name><operator>)</operator><operator>(</operator><call><name>MEM_32bits</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>frame</name> <operator>||</operator> <operator>(</operator><name><name>dctx</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>windowSize</name></name> <operator>&gt;</operator> <operator>(</operator><literal type="number">1ULL</literal> <operator>&lt;&lt;</operator> <name>STREAM_ACCUMULATOR_MIN</name><operator>)</operator><operator>)</operator><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decompressBlock_internal (size : %u)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>srcSize</name> <operator>&gt;=</operator> <name>ZSTD_BLOCKSIZE_MAX</name></expr></argument>, <argument><expr><name>srcSize_wrong</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Decode literals section */</comment>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>litCSize</name> <init>= <expr><call><name>ZSTD_decodeLiteralsBlock</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>streaming</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>DEBUGLOG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ZSTD_decodeLiteralsBlock : cSize=%u, nbLiterals=%zu"</literal></expr></argument>, <argument><expr><operator>(</operator><name>U32</name><operator>)</operator><name>litCSize</name></expr></argument>, <argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>litSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>litCSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>litCSize</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>litCSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>srcSize</name> <operator>-=</operator> <name>litCSize</name></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Build Decoding Tables */</comment>
    <block>{<block_content>
        <comment type="block">/* These macros control at build-time which decompressor implementation
         * we use. If neither is defined, we do some inspection and dispatch at
         * runtime.
         */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> \
    <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <decl_stmt><decl><type><name>int</name></type> <name>usePrefetchDecoder</name> <init>= <expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictIsCold</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <decl_stmt><decl><type><name>int</name></type> <name>nbSeq</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>seqHSize</name> <init>= <expr><call><name>ZSTD_decodeSeqHeaders</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbSeq</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>seqHSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>seqHSize</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>seqHSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>srcSize</name> <operator>-=</operator> <name>seqHSize</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>RETURN_ERROR_IF</name><argument_list>(<argument><expr><name>dst</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>nbSeq</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>dstSize_tooSmall</name></expr></argument>, <argument><expr><literal type="string">"NULL not handled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> \
    <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <if_stmt><if>if <condition>( <expr><operator>!</operator><name>usePrefetchDecoder</name>
          <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>frame</name> <operator>||</operator> <operator>(</operator><name><name>dctx</name><operator>-&gt;</operator><name>fParams</name><operator>.</operator><name>windowSize</name></name> <operator>&gt;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator><operator>)</operator><operator>)</operator>
          <operator>&amp;&amp;</operator> <operator>(</operator><name>nbSeq</name><operator>&gt;</operator><name>ADVANCED_SEQS</name><operator>)</operator></expr> )</condition> <block>{<block_content>  <comment type="block">/* could probably use a larger nbSeq limit */</comment>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>shareLongOffsets</name> <init>= <expr><call><name>ZSTD_getLongOffsetsShare</name><argument_list>(<argument><expr><name><name>dctx</name><operator>-&gt;</operator><name>OFTptr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>U32</name> <specifier>const</specifier></type> <name>minShare</name> <init>= <expr><ternary><condition><expr><call><name>MEM_64bits</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">7</literal></expr> </then><else>: <expr><literal type="number">20</literal></expr></else></ternary></expr></init></decl>;</decl_stmt> <comment type="block">/* heuristic values, correspond to 2.73% and 7.81% */</comment>
            <expr_stmt><expr><name>usePrefetchDecoder</name> <operator>=</operator> <operator>(</operator><name>shareLongOffsets</name> <operator>&gt;=</operator> <name>minShare</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>ddictIsCold</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> \
    <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <if_stmt><if>if <condition>(<expr><name>usePrefetchDecoder</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT</name></cpp:ifndef>
            <return>return <expr><call><name>ZSTD_decompressSequencesLong</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>isLongOffset</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG</name></cpp:ifndef>
        <comment type="block">/* else */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>dctx</name><operator>-&gt;</operator><name>litBufferLocation</name></name> <operator>==</operator> <name>ZSTD_split</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>ZSTD_decompressSequencesSplitLitBuffer</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>isLongOffset</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><call><name>ZSTD_decompressSequences</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <argument><expr><name>nbSeq</name></expr></argument>, <argument><expr><name>isLongOffset</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>ZSTD_checkContinuity</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>dst</name> <operator>!=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>previousDstEnd</name></name> <operator>&amp;&amp;</operator> <name>dstSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>   <comment type="block">/* not contiguous */</comment>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>dictEnd</name></name> <operator>=</operator> <name><name>dctx</name><operator>-&gt;</operator><name>previousDstEnd</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>virtualStart</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>dst</name> <operator>-</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>dctx</name><operator>-&gt;</operator><name>previousDstEnd</name></name><operator>)</operator> <operator>-</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>dctx</name><operator>-&gt;</operator><name>prefixStart</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>prefixStart</name></name> <operator>=</operator> <name>dst</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>previousDstEnd</name></name> <operator>=</operator> <name>dst</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>ZSTD_decompressBlock</name><parameter_list>(<parameter><decl><type><name>ZSTD_DCtx</name><modifier>*</modifier></type> <name>dctx</name></decl></parameter>,
                            <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstCapacity</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>dSize</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ZSTD_checkContinuity</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dSize</name> <operator>=</operator> <call><name>ZSTD_decompressBlock_internal</name><argument_list>(<argument><expr><name>dctx</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>, <comment type="block">/* frame */</comment> <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>not_streaming</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dctx</name><operator>-&gt;</operator><name>previousDstEnd</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>dst</name> <operator>+</operator> <name>dSize</name></expr>;</expr_stmt>
    <return>return <expr><name>dSize</name></expr>;</return>
</block_content>}</block></function></block_content></block></function>
</unit>
